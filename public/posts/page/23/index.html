<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 王小红的笔记</title><meta name=keywords content><meta name=description content="Posts - 王小红的笔记"><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wangxiaohong123.github.io/posts/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wangxiaohong123.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span class=active>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ribbon</h2></header><div class=entry-content><p>Ribbon三剑客：ILoadbalancer、IRule、IPing。
ILoadBalancer就是RestClient底层的负载均衡器，基于BaseBalance实现，负载均衡的规则都是基于IRule。
@LoadBalanced，这个注解的意思就是把RestTemplate标志为底层采用LoadBalanceClient来执行http请求，支持负载均衡。目前这个类里啥都没有，可以去看看这个注解所在包下有什么。看看有没有LoadBalanceAutoConfiguration，真的有。但是有两个：AsyncLoadBalancerAutoConfiguration和LoadBalancerAutoConfiguration。能看出来他是支持异步负载均衡请求的。
LoadBalancerAutoConfiguration 1 2 3 4 5 6 7 8 9 10 /** * Auto configuration for Ribbon (client side load balancing). * 看这注释，专门为ribbon的Auto configuration * @author Spencer Gibb * @author Dave Syer * @author Will Tran * @author Gang Li */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 这块可能是我在controller或者service定义的RestTemplate，会被放到这个集合里 @LoadBalanced @Autowired(required = false) private List&lt;RestTemplate> restTemplates = Collections.emptyList(); // 这就是最后执行完来处理一些东西 @Bean public SmartInitializingSingleton loadBalancedRestTemplateInitializer( final List&lt;RestTemplateCustomizer> customizers) { return new SmartInitializingSingleton() { @Override public void afterSingletonsInstantiated() { // 然后遍历RestTemplate在定制化什么的，先猜成这样 for (RestTemplate restTemplate : LoadBalancerAutoConfiguration.this.restTemplates) { for (RestTemplateCustomizer customizer : customizers) { customizer.customize(restTemplate); } } } }; } // 下面有一个类restTemplateCustomizer // 能看出来就是给restTemplate设置了拦截器 // 拦截器就是上面的LoadBalancerInterceptor @Bean @ConditionalOnMissingBean public RestTemplateCustomizer restTemplateCustomizer( final LoadBalancerInterceptor loadBalancerInterceptor) { return new RestTemplateCustomizer() { @Override public void customize(RestTemplate restTemplate) { List&lt;ClientHttpRequestInterceptor> list = new ArrayList&lt;>( restTemplate.getInterceptors()); list.add(loadBalancerInterceptor); restTemplate.setInterceptors(list); } }; } // 下面就是retry相关的代码，先不看 LoadBalancerInterceptor LoadBalanceInterceptor继承了ClientHttpRequestInterceptor
...</p></div><footer class=entry-footer>3 min</footer><a class=entry-link aria-label="post link to ribbon" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud/ribbon/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RocketMQ配置</h2></header><div class=entry-content><p>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 # 这个是集群的名称，你整个broker集群都可以用这个名称 brokerClusterName = RaftCluster # 这是Broker的名称，比如你有一个Master和两个Slave，那么他们的Broker名称必须是一样的，因为他们三个是一个分组，如果你有另外一组Master和两个Slave，你可以给他们起个别的名字，比如说RaftNode01 brokerName=broker-a #0 表示 Master，>0 表示 Slave brokerId=0 # 这个就是你的Broker监听的端口号，如果每台机器上就部署一个Broker，可以考虑就用这个端口号，不用修改 listenPort=30911 # 这里是配置NameServer的地址，如果你有很多个NameServer的话，可以在这里写入多个NameServer的地址 namesrvAddr=192.168.0.3:9876 # 下面两个目录是存放Broker数据的地方，你可以换成别的目录，类似于是/usr/local/rocketmq/node00之类的 storePathRootDir=/usr/local/rocketmq/store/ # commitLog存储路径 storePathCommitLog=/usr/local/rocketmq/store/commitlog # 消费队列存储路径 storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue # 消息索引存储路径 storePathIndex=/usr/local/rocketmq/store/index # checkpoint 文件存储路径 storeCheckpoint=/usr/local/rocketmq/store/checkpoint # abort 文件存储路径 abortFile=/usr/local/rocketmq/store/abort # 这个是非常关键的一个配置，就是是否启用DLeger技术，这个必须是true enableDLegerCommitLog=true # 这个一般建议和Broker名字保持一致，一个Master加两个Slave会组成一个Group dLegerGroup=broker-a # 这个很关键，对于每一组Broker，你得保证他们的这个配置是一样的，在这里要写出来一个组里有哪几个Broker，比如在这里假设有三台机器部署了Broker，要让他们作为一个组，那么在这里就得写入他们三个的ip地址和监听的端口号 dLegerPeers=n0-192.168.0.3:40911;n1-192.168.0.5:40912;n2-192.168.0.6:40913 # 这个是代表了一个Broker在组里的id，一般就是n0、n1、n2之类的，这个你得跟上面的dLegerPeers中的n0、n1、n2相匹配 dLegerSelfId=n0 # 删除文件时间点，默认是凌晨4点 deleteWhen=04 # 文件保留时间，默认48小时 fileReservedTime=120 # 这个是发送消息的线程数量，一般建议你配置成跟你的CPU核数一样，比如我们的机器假设是24核的，那么这里就修改成24核 sendMessageThreadPoolNums=4 #在发送消息时，自动创建服务器不存在的topic，默认创建的队列数。由于是4个broker节点，所以设置为4 defaultTopicQueueNums=4 #是否允许 Broker 自动创建Topic，建议线下开启，线上关闭 autoCreateTopicEnable=true #是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭 autoCreateSubscriptionGroup=true # commitLog每个文件的大小，默认是1G mapedFileSizeCommitLog=1073741824 # ConsumeQueue每个文件默认存30W条，根据业务情况调整 mapedFileSizeConsumeQueue=300000 # destroyMapedFileIntervalForcibly=120000 # redeleteHangedFileInterval=120000 # 检测物理文件磁盘空间 diskMaxUsedSpaceRatio=88 # 限制的消息大小 maxMessageSize=65536 flushCommitLogLeastPages=4 flushConsumeQueueLeastPages=2 flushCommitLogThoroughInterval=10000 flushConsumeQueueThoroughInterval=60000 # Broker 的角色 # ASYNC_MASTER 异步复制Master # SYNC_MASTER 同步双写Master # SLAVE brokerRote=ASYNC_MASTER #刷盘方式 #- ASYNC_FLUSH 异步刷盘 #- SYNC_FLUSH 同步刷盘 flushDiskType=ASYNC_FLUSH # checkTransactionMessageEnable=false # 重试时间间隔 messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to RocketMQ配置" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/mq/rocketmq/rcoketmq%E9%85%8D%E7%BD%AE/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>saga事务</h2></header><div class=entry-content><p>saga和tcc很像，tcc是把接口拆成三个，try、confirm、cancel，saga就是两个，try和confirm合并为一个。
两种思想 编排模式：事件驱动模式，服务之间的调用时通过发布事件，监听时间来驱动，比如借助mq，回滚也是一样的，通过事件来驱动。编排模式很有去中心化的思想，而且是异步调用，缺点就是异步发生异常不好排查问题，而且需要依赖mq。 命令模式：类似tcc，有一个saga分布式事务管理器，同步调用。优点和缺点和编排模式相反。 AxonFramework AxonFramework是一个CQRS框架，在国内几乎没人用，不过它是基于DDD，现在国内DDD正火，而且这个框架自带saga事务的实现，
aggregate：聚合，就是类图中的聚合。
event sourcing：回溯，存储数据变化的历史版本，这样就可以找到历史的版本。
Actor模型：每个actor都是一个线程，都有个mailbox，各个actor都可以通过mailbox相互通信，这样的话就没有并发问题了，因为线程值直接修改数据的。
CQRS：命令和查询职责分离，c就是command，增删改的操作，q就是query，查询，大概意思就是增删改和查询时两个服务，写服务写到单独的存储里去，比如mysql，有一个单独的同步组件，把数据同步到读用到的存储中，比如es。
这些都是DDD中的概念。DDD中提到了一种事务模型，就是saga事务模型。
saga事务框架 Eventuate Tram Saga：gitbub才100多star，哈哈哈哈哈哈，作者还出了本书。
AxonFramework：1000多star，他不是事务框架，只是顺带包括了saga事务。
华为的ServiceComb：这是一套分布式的技术栈，包括了saga的支持。
这就能看出来，saga的运用还是比较少的，也没有单独的成熟的方案，都是包括在了框架中。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to saga事务" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/%E4%BA%8B%E5%8A%A1/4.saga%E9%9D%9E%E9%87%8D%E7%82%B9/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Set</h2></header><div class=entry-content><p>HashSet 因为HashMap的key是不会重复的，因为重复的key执行的是替换操作，HashSet就是基于HashMap实现的。value存成new Object()就完事了。源码里也能看到，就是声明了一个HashMap，所有操作就是去操作map。
LinkedHashSet 他继承了HashSet，初始化时调用了HashSet的构造方法，HashSet中会创建一个LinkedHashMap
1 2 3 HashSet(int initialCapacity, float loadFactor, boolean dummy) { map = new LinkedHashMap&lt;>(initialCapacity, loadFactor); } TreeSet 里面实现了一个TreeMap。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to Set" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/1.%E9%9B%86%E5%90%88/6.set/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>springboot+哨兵</h2></header><div class=entry-content><p>作用 集群监控，负责监控redis master和slave进程是否正常工作 消息通知，如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员 故障转移，如果master node挂掉了，会自动转移到slave node上，同时会修改redis的配置文件 配置中心，如果故障转移发生了，通知client客户端新的master地址 quorum = 1（配置）：当主节点挂掉时，需要至少多少个哨兵节点认为master宕机就会进行主备切换；majority（概念）：哨兵运行数的最小值，比如当两个哨兵集群时，majority就是2，三个哨兵集群时，majority还是2，如果是两个哨兵集群，redis所在的服务器宕机，哨兵也不可用，此时majority数变成1，无法完成主备切换，所以哨兵一般最少三个集群。
主观宕机和客观宕机 一个哨兵认为master宕机叫做主管宕机，quorum数量的哨兵都觉得master宕机了就是客观宕机，这时候会进行主备切换。
选举机制 (down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state，理解为一个salve跟master断开连接的时间太长不参加选举 按照slave优先级进行排序，slave priority越低，优先级就越高 如果slave priority相同，再看salve同步数据的偏移量，哪个slave复制了越多的数据，offset越靠后，优先级就越高 如果上面两个条件都相同，那么选择一个run id比较小的那个slave 搭建 一个哨兵集群可以监控多个redis主从，哨兵集群需要最少三台redis，这三个redis只要解压执行make、make test、make install即可。
三台机器分别执行如下操作：
创建两个目录
1 2 3 mkdir /etc/sentinel mkdir -p /var/sentinel/5000 mkdir -p /var/log/sentinel/5000 将redis目录下的sentinel.conf拷贝到本地修改名字为5000.conf并修改配置：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 后台启动 daemonize yes # 日志输出路径 logfile /var/log/sentinel/5000 # 哨兵所在虚拟机ip bind 192.168.0.6 port 5000 dir /var/sentinel/5000 # redismaster节点的ip # mymaster：redis主备集群名称 # 2：quorum值 sentinel monitor mymaster 192.168.0.3 6379 2 # 主备切换时，超过30s没切换成功由另一个哨兵进行切换 sentinel down-after-milliseconds mymaster 30000 # 主备切换之后，原来的salve需要重新绑定master并同步数据，1就是一次绑定1个salve sentinel parallel-syncs mymaster 1 # master的redis密码 sentinel auth-pass mymaster redis-pass 将5000.conf上传到/etc/sentinel目录下。
...</p></div><footer class=entry-footer>3 min</footer><a class=entry-link aria-label="post link to springboot+哨兵" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/6.%E5%93%A8%E5%85%B5/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>stable-diffusion</h2></header><div class=entry-content><p>stable-diffusion原理就是逆向降噪的过程，就好比秋天的时候地上都是树叶，这个时候地上的树叶就是噪点，把树叶一点一点收起来，地面越来越清晰就是降噪的过程，所以使用stable-diffusion生成图片的时候控制台中的图片时从模糊到越来越清晰的。
那么就有两个问题，初始的图片为什么要加噪点，以及如何实现降噪？
为什么要加噪点？ 加噪点是为了给图片降维，图片是由像素组成，像素是由红黄蓝三颜色混合组成，拿一个512*512的图片举例，这个图片就可以转换成$5125123=786432$个数字组成，如果是读取的话没有任何困难，但是如果把786432个数字放到神经网络里就会变成786432维，这种算力不是普通显卡可以承受的，所以把图片上不是关键的像素变成噪点可以减少计算维度，就像地上虽然堆满了树叶，但是我们还能看出来这是一片空地，。其实不需要关心怎么给图片加上噪点，模型库中的图片自带噪点，只需要计算怎么降燥。
怎么去除噪点？ 网上一搜这里会出现一大堆名次，VAE、UNet、CLIP巴拉巴拉看不懂，但是可以想象出来地上的树叶并不是一次全都落下来的，每次只落一点慢慢地上的树叶越来越多，清理这些树叶可能需要n次，n越大就越干净，这里就对应了stable-diffusion的采样步数，可以理解成清除噪点的次数。如何降噪对应的是采样器，比如有的采样器是用吸尘器吸树叶，有的采样器用手捡树叶。
stable-diffusion怎么识别prompt去画图？ 首先需要一个足够大的图片数据库，里面存放的是降维过的(也就是说有噪点的)图片，就是模型库，其次它需要有**语意识别(trnasformer，也是chat GPT里的T)**功能，识别语意之后去模型库中找到描述相关的图片中和prompt相符合的内容，最后把他们整合。
安装模型 我没有使用cola安装，很多扩展都没有，比如civitai，但是我手动装了civitai页面上页不显示，这样的话下载模型只能去c站[https://civitai.com/]手动下载，把下载完的模型放到stable-diffusion目录下的models/Stable-diffusion路径下，然后重启stable-diffusion。
1.lora模型 安装完lora模型之后点击附加网络是看不到我们刚刚下载的模型的：
但是他已经提示了需要把模型放到models/lora路径下，把刚刚下载的模型复制一份到这个路径，然后点击页面右边的刷新按钮就可以看到刚才安装的模型了。
然后我们去c站找一张lora的模型示例图，把prompt复制到文生图的提示词里：
然后点击刚刚下载的模型，在上面的输入框会出现一个lora标签，shuimobysimV3就是我们刚刚下载的模型在本地的名称，最后的1表示权重，这里能看到复制过来的提示词中的lora中的模型名和我们安装的不一样， 所以需要替换模型名最后删掉刚才生成的lora标签，点击生成：
严格来说lora不像是一个模型，下载的时候就可以看出来他的体积非常小，他的原理类似一个汉堡，一个人说不够甜，厨师就把上面的面包拿掉，挤了点糖，第二次说生菜少了，厨师就把上面的面包和牛肉拿掉，下面放了几片生菜，就这样一点一点加工。他的原理就是不影响原有扩散模型的层中的内容，而是在中间插入新层影响输出内容。
controlNet 安装 从网址安装扩展中输入controlnet[https://github.com/Mikubill/sd-webui-controlnet]的地址安装。本地自己安装的stable-diffusion在装完controlNet之后是没有模型的，需要自己去hugginface[https://huggingface.co/lllyasviel/ControlNet-v1-1/tree/main]或者[https://huggingface.co/TencentARC/T2I-Adapter/tree/main/models]上下载pth后缀的模型，下载完后放到stable-diffusion-webui/extensions/sd-webui-controlnet/models路径下，最后重启webUI。
新版生成预览按钮在这里，妈的找半天：
常用预处理器和模型 canny：线稿检测，就是上图的效果，把图片的信息提取出线条，这样可以让SD根据提供的线条作画； color：他会把图片变成马赛克，马赛克的颜色和图片对应，这样可以控制SD画图时的颜色； mlsd+seg开头的预处理器：mlsd是直线检测，他会把图片中的直线选中，曲线被忽略，seg开头的是分块检测，会把图片中的每个物体用不同颜色区分，他俩一起使用可以实现室内设计相关功能； 如果想要同时使用controlNet的多个模型时可以使用上面的control net unit选显卡，每个选项卡对应一个模型，每个选项卡都需要勾选enable：
简单使用 1.提示词 大部分情况的提示次其实就一个字，抄，去c站找到目标图片查看他的提示次和模型……
正向提示次：
普通关键词使用’,‘分割，不同顺序会导致不一样的出图结果； 小括号表示赋权，比如(blue hair:1.5)表示蓝色头发权重1.5； 中括号表示关键词参与采样步数占比，比如采样步数为20时，[blue hair:0.5]和[blue hair::10]都表示关键词参与前10步的采样； 2.局部重绘 图生图的一个选项卡，使用这个可以把图片中我们不想要的内容替换掉。
3.换脸 换脸和换其他部位的思路一样，使用局部重绘功能把想要更换的位置涂掉，然后利用canny模型锁定图片整体的线条，然后用open pose模型锁定任务的骨架，open pose的作用是换脸时因为脸部被我们涂掉了，所以DF在自由发挥的时候很有可能在脸上画一只手之类的，open pose可以限制DF不要话其他的四肢，在确定参数、模型都没问题后可能换出来的脸很丑，这个时候需要提示次做最后的补充，然后开始刷图，跟抽奖一样。
inpaint anything扩展也可以实现这个功能。
4.图片放大 不考虑插件的情况SD有3个地方可以实现图片的放大：
字生图时选择高清修复； 图生图时在脚本处选择SD upscale，或者安装Ultimate SD upscale[https://github.com/Coyote-A/ultimate-upscale-for-automatic1111]扩展; 额外功能中对图片进行缩放； 不管使用哪种方式都要选择放大算法，常见的放大的算法：Lanczos、Nearest、LDSR、ESRGAN_4x、R-ESRGAN 4x+、R-ESRGAN 4x+ Anime6B、SwinIR_4x、ScuNET、ScuNET PSNR。
Lanczos、Nearest不好用，LDSR动漫和真人都可以，ESRGAN_4x和SwinIR_4x更适合真人；R-ESRGAN 4x+、R-ESRGAN 4x+ Anime6B更适合动漫；SwinIR_4x、ScuNET、ScuNET PSNR更适合降噪；
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to stable-diffusion" href=https://wangxiaohong123.github.io/posts/%E5%85%B6%E4%BB%96/stable-diffusion/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Threadlocal</h2></header><div class=entry-content><p>线程变量的副本。每个Thread内部有一个ThreadLocalMap，这个map是一个Entry数组，只能是线程自己内部使用，因为他就是内部的变量嘛，Entry中有两个变量，一个是k（ThreadLocal类型），一个是value（自己定义类型）
set
1 2 3 4 5 6 7 8 9 10 11 public void set(T value) { Thread t = Thread.currentThread(); // 获取线程内部的ThreadLocalMap ThreadLocalMap map = getMap(t); // 如果map已经创建了就添加元素 if (map != null) map.set(this, value); // 不存在就创建 else createMap(t, value); } get
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to Threadlocal" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/6.threadlocal/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>TiDB-1.入门</h2></header><div class=entry-content><p>分布式数据库是由分库分表演化过来的，分库分表需要单独部署leaf，DDL维护，整合分布式事务，扩容缩容等，麻烦的很。他有点类似es集群，开发的时候不需要关注有几台机器，高可用的问题，只需要知道连接信息，就是把之前分库分表的工作都在内部完成了。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to TiDB-1.入门" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/tidb/1.%E5%85%A5%E9%97%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>transactional</h2></header><div class=entry-content><p>在Spring中如果想使用注解声明的事务需要添加@EnableTransactionManagement注解，从这个注解进去是个ImportSelector类，然后进入ProxyTransactionManagementConfiguration，这是个全配置类，里面创建了一个Bean：TransactionInterceptor，他是AOP事务的增强逻辑。
被transactional修饰的方法会被spring生成一个动态代理对象，controller注入的bean也是被代理过的，代理对象的方法中调用方法之前会使用transactional.start()启动一个MySQL的事务，如果执行法法的过程中有报错就会调用MySQL的事务回滚，方法执行完之后会调用MySQL的事务提交。
被transactional修饰的类就是一个切面。spring的事务的核心逻辑都在spring-tx的jar包下。
调用@transactional修饰的方法之前先会走TransactionInterceptor（org.springframework.transaction.interceptor包下），这个类下的invoke()方法是事务控制的核心，这个方法中调用了invokeWithinTransaction()。这个方法是父类（TransactionAspectSupport）的方法，核心就是这行代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 这段代码实在动态代理的类执行时候进行拦截的 // 创建事务，在点进去看到是用PlatformTransactionManager开启事务，这是jpa里的代码 TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification); Object retVal = null; try { // This is an around advice: Invoke the next interceptor in the chain. // This will normally result in a target object being invoked. // 执行代码逻辑 retVal = invocation.proceedWithInvocation(); } catch (Throwable ex) { // target invocation exception // 回滚事务，在抛出异常 completeTransactionAfterThrowing(txInfo, ex); throw ex; } finally { cleanupTransactionInfo(txInfo); } // 提交事务 commitTransactionAfterReturning(txInfo); 代码很好找，一直往下跟就行，看到底层可以看到是基于hibernate来实现的。最后的找到的最最最底层的代码在AbstractLogicalConnectionImplementor（org.hibernate.resource.jdbc.internal）里：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to transactional" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/%E4%BA%8B%E5%8A%A1/1.transactional/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Vector和stack</h2></header><div class=entry-content><p>Vector也是基于数组来实现的。Stack继承了Vector。
push操作就是往数组中添加元素
1 2 3 4 5 6 7 public synchronized void addElement(E obj) { modCount++; // 扩容相关，调用的是Vector的方法 ensureCapacityHelper(elementCount + 1); // 添加元素 elementData[elementCount++] = obj; } pop()
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public synchronized E pop() { E obj; // 获取数组长度 int len = size(); // peek就是获取最后一个元素 obj = peek(); // 删除最后一个元素 removeElementAt(len - 1); return obj; } public synchronized E peek() { int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); }</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to Vector和stack" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/1.%E9%9B%86%E5%90%88/3.vector%E5%92%8Cstack/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wangxiaohong123.github.io/posts/page/22/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://wangxiaohong123.github.io/posts/page/24/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>