<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 王小红的笔记</title><meta name=keywords content><meta name=description content="Posts - 王小红的笔记"><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wangxiaohong123.github.io/posts/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wangxiaohong123.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span class=active>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>4.扫描</h2></header><div class=entry-content><p>启动容器时会执行一堆BeanFactoryPostProcessor接口和子接口的方法，ConfigurationClassPostProcessor实现了BeanDefinitionRegistryPostProcessor，所以这个类有父接口和子接口的方法，扫描的代码入口就在子接口的方法实现里。
@inherited注解标记的类上的注解会被子类继承，接口无效。
半配置和全配置 全配置会被代理，为了确保@Bean对应的Bean的作用域的正确，在全被配置类里可以保证@Bean配置的Bean的作用域是单例的，而半配置类没法保证。
除了@Bean注解产生的类或者ImportBeanDefinitionRegistrar的实现类，其他的Bean都是配置类！
1.Spring中存在多个扫描器 容器启动的时候会创建一个ClassPathBeanDefinitionScanner，当ConfigurationClassPostProcessor扫描类的时候又会在方法里创建一个局部的ClassPathBeanDefinitionScanner，这两个有什么区别？
第一个scanner是负责处理我们手动设置的扫描路径context.scan(“包名”)，这里要注意如果我们手动设置扫描路径实例化容器的时候是不能传配置类的，因为传进去一个配置类，容器会自动调用refresh()方法，这个时候我们在调用context.scan(“包名”)就不生效，因为容器已经启动了，设置完之后需要手动调用refresh()方法。
第二个scanner是负责处理@ComponentScan注解的。
修改第一个名字生成器需要再调用applicationContext.setBeanNameGenerator()，修改第二个生成器需要再@ComponentScan注解里设置nameGenerator属性。注意修改scanner1的时候他会把生成器放到单例池中，这个时候scanner2也会被修改，也就是说通过applicationContext.setBeanNameGenerator()设置的名字生成器是全局的，所有名字生成器都会使用设置的这个。
2.为什么Spring在加载类的时候不是通过反射，而是使用了ASM技术？ 因为通过反射加载的类会进到元数据空间，如果累里面有静态代码块，此时也会执行，但是很有可能这个类不是一个Bean，我们也不需要提前把这个类加载到元数据空间里，ASM就会实现这个效果，最小限度的干扰我们。
3.@Configuration+@Bean怎么保证单例 添加了@Configuration注解，这个类就会被标记成全配置类，全配置类在BeanFactoryPostProcessor的回调里会被CGLib代理，代理的类里加了3个callbackFilter，分别是处理@Bean标记的方法，和setBeanFactory()方法。处理@Bean方法的callback在执行方法前会把方法信息存到threadlocal里判断是否是当前执行的方法避免单例Bean被重复创建：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 判断当前这个@Bean方法是不是正在执行 // 通过这个增强可以避免下面这种重复创建Bean的写法： // @Bean // public X createX() {return new X();} // // @Bean // public Y createY() { // createX(); // return new Y(); // } // 当调用createY()的时候，createX()不会通过下面的判断 if (isCurrentlyInvokedFactoryMethod(beanMethod)) { // 调用父类方法 return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs); } // 如果没通过上面的判断，会直接从容器中获取 return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName); }</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 4.扫描" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/framework/4.%E6%89%AB%E6%8F%8F/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>4.支付成功到履约相关问题</h2></header><div class=entry-content><p>支付成功之前进行的预支付和取消订单的延迟消息处理需要用到分布式锁，防止在处理订单超时时，用户支付，不同业务可能还要加上在支付回调中检测订单取消后发起退款
同时为了防止发送延时消息失败需要有一个定时任务，定时扫描超过30分钟没有支付的订单，执行超时操作
在支付成功后订单系统会受到一条回调，这个时候需要把订单状态更新成已支付，然后发送支付完成消息，发出去消息后再由订单系统自己来消费这个消息，为什么要发消息，第一履约执行很耗时间，通过mq解耦加快支付成功的响应时间，然后其他服务需要监听支付成功不需要通过api，直接消费消息就好了。
当收到支付成功事件后，先调用履约系统，调用履约系统成功后再把订单改成已履约，流程如下图，红线表示可能出现问题的步骤：
发送支付成功消息失败 收到回调并且修改完订单状态，此时如果发送mq消息失败，需要回滚数据，这里用到的是rocket的事务消息，他的事务消息使用的是TransactionMQProducer，使用**TransactionSendResult result = transactionMQProducer.sendMessageInTransaction(mq, orderInfoDO);**发送消息，每次发送消息之前producer都需要设置监听，用来处理发送消息成功和失败的情况，例如：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 transactionMQProducer.setTransactionListener(new TransactionListener() { @Override public LocalTransactionState executeLocalTransaction(Message message, Object o) { try { // 正常的业务逻辑代码 return LocalTransactionState.COMMIT_MESSAGE; } catch (BaseBizException e) { throw e; } catch (Exception e) { log.error("system error", e); return LocalTransactionState.ROLLBACK_MESSAGE; } } @Override public LocalTransactionState checkLocalTransaction(MessageExt messageExt) { // 这个回调只有mq检测到存在长时间没提交的half消息时调用 // 逻辑就是判断之前的的正常业务代码有没有执行完 // 执行完就返回COMMIT_MESSAGE，没执行完就返回ROLLBACK_MESSAGE if(true) { return LocalTransactionState.COMMIT_MESSAGE; } return LocalTransactionState.ROLLBACK_MESSAGE; } }); 消费支付成功消息 调用履约系统失败 调用履约失败只要消费者返回Action.RECONSUME_LATER就可以了，返回这个rocket就会把消息放到重试队列里，重试超过16次会把消息放到死信队列里，这个时候需要在起一个消费者负责消费私信队列。
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to 4.支付成功到履约相关问题" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/cloud-alibaba-demo%E4%B9%8B%E8%AE%A2%E5%8D%95/4.%E6%94%AF%E4%BB%98%E6%88%90%E5%8A%9F%E5%88%B0%E5%B1%A5%E7%BA%A6%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>4.消息消费</h2></header><div class=entry-content><p>读写分离主从漂移设计：RocketMQ默认是不倾向于读写分离的，默认的读写都是走主节点，从节点相当于热备份，当主节点检测出自己压力过大时，会返回一个从节点信息告诉消费者下次在从节点拉取，然后拉取一段时间之后，从节点检测出自己消息积压量小于物理内存的30%就会又返回主节点的信息，让消费者下次尝试从主节点拉取消息。这种有的时候访问主，有的时候访问从就叫ip漂移。
他为什么要采取这种惰性的读写分离呢？因为他要维护每个消费者对消息的消费进度，如果一直读写分离，并且有多个从节点，每次消费都可能从任意一个从节点读取，这样是没法维护消费进度的，在RocketMQ中，从节点每隔10s会和主节点进行offset同步，这样也不会支持频繁的读写分离，因为会有大量的重复消息。kafka连漂移都没有。
但是在4.5之后由于改成了raft协议选举，他有个特点就是过半写成功就算成功，当有一些节点没写成功发生了ip漂移就可能导致有些消息无法读取，这样就和kafka一样了。
绑定consume queue逻辑 想要拿到消息首先需要绑定consume Queue，一个消费者可以消费多个consumeQueue，但是多个消费者不能消费相同的consume Queue，具体绑定到那个consume Queue是有消费者自己计算的，从nameServer上获取topic信息之后就知道有几个consume queue了，然后就可以计算要绑定到那个queue上，queue在那台broker上，但是有个关键的地方就是他需要知道一个consumer group里有哪些消费者，当消费者启动的时候会去想broker注册，这样随便找一个broker就能找到消费者组的所有信息。
分配consumeQueue的算法：平均算法、轮询分配、一致性hash、配置化、机房分配，由consumer的RebalanceService组件实现。
拉取消息模式 拉取消息的组件命名上看有pull和push，但是底层实现都是pull模式，当没有开启long polling的时候也就是默认情况下就是short polling，他在拉取消息时如果没有消息会挂起1s，1s之后会在去检查有没有消息，没有就返回，如果开启了long polling会长时间挂起，然后broker上有一个后台线程每隔5s去检查有没有新的消息，这个时候就要分pull还是push，如果是push就会挂起等待后台线程检查有新消息或者超过15s返回，如果是pull模式最多挂起的时间应该是20s。
并发消费 消费者会在内存里维护多个processQueue，每个processQueue都和自己绑定的consumeQueue对应，当拉取消息的线程拉取到消息之后会把消息写到内存的processQueue里，然后会有一个线程池来消费这个processQueue的数据，这个线程池就是我们在初始化消费者的时候设置的线程池，然后线程池里的线程拿到消息之后就回去回调我们的自己的消费逻辑。
消费进度管理 当我们消费完之后如果返回的是成功就会把消息从processQueue中删掉并且更新自己内存里的消费进度，然后在通过后台向线程把消费进度异步通知broker，broker也是把消费进度更新到内存里，然后通过后台线程异步刷盘。
如果返回的是失败broker会把消息写到一个延迟消息的topic里去，等到时间后再把消息拿出来重新写到原来的topic中。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 4.消息消费" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/mq/rocketmq/4.%E6%B6%88%E6%81%AF%E8%8E%B7%E5%8F%96/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>5.Bean的实例化</h2></header><div class=entry-content><p>1.单例池 在BeanFactory中beanDefinitionMap存放的是bean的名字作为key，类对应的BeanDefinition作为value，还有一个singletonObjects用来存放已经实例化好的Bean，Spring中叫单例池。
2.实例化源码 在启动容器结束后就已经完成了Bean的扫描，ApplicationContext的refresh()方法中会调用下面的方法，就是Bean实例化的入口：
1 2 // 完成不是懒加载的单例Bean的实例化 finishBeanFactoryInitialization(beanFactory); 真正的入口在finishBeanFactoryInitialization(beanFactory);方法里的最后一行：
1 beanFactory.preInstantiateSingletons(); 这个类里先校验，然后把name前面拼上"&“去调用getBean()方法，这个方法中会判断如果单例池中没有这个Bean回去创建：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public void preInstantiateSingletons() throws BeansException { if (logger.isTraceEnabled()) { logger.trace("Pre-instantiating singletons in " + this); } // 这个beanDefinitionNames存的是beanDefinitionMap的key List&lt;String> beanNames = new ArrayList&lt;>(this.beanDefinitionNames); for (String beanName : beanNames) { // 先从mergedBeanDefinitions(map)中根据name拿到BeanDefinition // todo mergedBeanDefinitions和beanDefinitionMap有什么区别 // todo 为什么获取BeanDefinition要搞得真么复杂，直接遍历beanDefinitionMap不可以吗 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); // 抽象类或者非单例类或者懒加载的类不会实例化 if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) { // 验证是否是FactoryBean if (isFactoryBean(beanName)) { // 把name前面拼上"&"，然后获取Bean Object bean = getBean(FACTORY_BEAN_PREFIX + beanName); if (bean instanceof FactoryBean) { FactoryBean&lt;?> factory = (FactoryBean&lt;?>) bean; boolean isEagerInit; if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) { isEagerInit = AccessController.doPrivileged( (PrivilegedAction&lt;Boolean>) ((SmartFactoryBean&lt;?>) factory)::isEagerInit, getAccessControlContext()); } else { isEagerInit = (factory instanceof SmartFactoryBean && ((SmartFactoryBean&lt;?>) factory).isEagerInit()); } if (isEagerInit) { getBean(beanName); } } } else { // 非FactoryBean得话走这里 getBean(beanName); } } } // Trigger post-initialization callback for all applicable beans... for (String beanName : beanNames) { Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) { SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedAction&lt;Object>) () -> { smartSingleton.afterSingletonsInstantiated(); return null; }, getAccessControlContext()); } else { smartSingleton.afterSingletonsInstantiated(); } } } } getBean()方法里直接调用了doGetBean()方法：
...</p></div><footer class=entry-footer>13 min</footer><a class=entry-link aria-label="post link to 5.Bean的实例化" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/framework/5.bean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>5.shiro-session原理</h2></header><div class=entry-content><p>了解session原理需要先看Subject的源码，因为session由他管理，打开这个接口看到有个内部类叫Builder，它里面有两个变量：
1 2 private final SubjectContext subjectContext; private final SecurityManager securityManager; SubjectContext 负责管理Subject上下文接口，他继承了Map类，里面是一些get、set方法，他有1个实现类(DefaultSubjectContext)和一个子接口(WebSubjectContext)，WebSubjectContext就是把request、response等变量存起来，实现类和子接口有一个共同的实现类(DefaultWebSubjectContext)。
Builder在实例化的时候会创建一个DefaultSubjectContext然后把SecurityManager放进去，Builder中还有一个buildSubject()方法，调用SecurityManager的createSubject()根据创建的SubjectContext创建一个Subject。
Subject也有一个实现类(DelegatingSubject)和一个子接口(WebSubject)，他俩有一个共同的实现类(WebDelegatingSubject)，当项目启动时，通过MEATA-INF扫描到shiro的一堆bean，spring.factories的配置：
1 2 3 4 5 6 7 8 9 10 org.springframework.boot.autoconfigure.EnableAutoConfiguration = \ org.apache.shiro.spring.config.web.autoconfigure.ShiroWebAutoConfiguration,\ org.apache.shiro.spring.config.web.autoconfigure.ShiroWebFilterConfiguration,\ org.apache.shiro.spring.config.web.autoconfigure.ShiroWebMvcAutoConfiguration,\ org.apache.shiro.spring.boot.autoconfigure.ShiroBeanAutoConfiguration,\ org.apache.shiro.spring.boot.autoconfigure.ShiroAutoConfiguration,\ org.apache.shiro.spring.boot.autoconfigure.ShiroAnnotationProcessorAutoConfiguration org.springframework.boot.diagnostics.FailureAnalyzer = \ org.apache.shiro.spring.boot.autoconfigure.ShiroNoRealmConfiguredFailureAnalyzer 其中有个bean就叫ShiroWebFilterConfiguration，在这个filterConfiguration中创建了ShiroFilterFactoryBean，而这个bean继承了BeanPostProcessor，这个bean的getObject()方法里创建了AbstractShiroFilter，这个filter创建并且调用了Subject：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 5.shiro-session原理" href=https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/shiro/5.session%E5%8E%9F%E7%90%86/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>5.SPI实现源码</h2></header><div class=entry-content><p>SPI的全称就是Service Provider Interface，是一种动态替换的机制，用来动态替换接口的实现类，需要在工作目录下的META-INF/services目录中创建一个文件，这个文件名是要被动态替换实现类的接口的全限定名，文件的内容是接口实现类的全限定名。java中通过Service.providers(接口.class)或者ServiceLoader.load(接口.class)拿到所有实现类，之后就可以遍历调用了。
Dubbo自己实现了一套SPI机制，关键组件类都是通过自己的SPI动态实例化的，让我们只需要修改一些配置就可以替换默认的组件。
java的SPI会把所有的实现类都拿出来，而Dubbo的SPI会根据需要拿到实现类，而且Dubbo的SPI还提供了IOC、AOP的功能。
除了SPI这种扩展，还可以使用配置文件的方式，当发现配置了某个配置，就加载用户自己的实现类，但是这种方式只适合少量的组件扩展，dubbo使用SPI机制让大量的核心组件都是可以替换的。
SPI的实现在ExtensionLoader中，这个类主要有3种获取extension方式getExtension()根据name获取、getAdaptiveExtension()获取url中配置的extension、getActivateExtension()根据@Adaptive注解实现一个接口自动激活多个实现类。
getExtension() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public T getExtension(String name, boolean wrap) { // 检查的代码没看 checkDestroyed(); if (StringUtils.isEmpty(name)) { throw new IllegalArgumentException("Extension name == null"); } if ("true".equals(name)) { return getDefaultExtension(); } // 一个缓存key String cacheKey = name; if (!wrap) { cacheKey += "_origin"; } // 根据缓存key获取实例对应的holder // 如果没有就创建一个空的holder final Holder&lt;Object> holder = getOrCreateHolder(cacheKey); Object instance = holder.get(); // 双重检查 if (instance == null) { synchronized (holder) { instance = holder.get(); if (instance == null) { // 创建对象 instance = createExtension(name, wrap); holder.set(instance); } } } return (T) instance; } 创建对象方法就包括读取SPI配置文件、创建class和初始化实例：
...</p></div><footer class=entry-footer>5 min</footer><a class=entry-link aria-label="post link to 5.SPI实现源码" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/dubbo/5.spi%E5%AE%9E%E7%8E%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>5.买卖股票的最佳时机</h2></header><div class=entry-content><p>题目 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
示例 ：
输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
提示
1 &lt;= prices.length &lt;= 105 0 &lt;= prices[i] &lt;= 104 根据题目得到一下结论：
买入时间要小于卖出时间，也就是买入时的下标i小于卖出时的下标j； 利润不能是负数； 每天只能进行一次交易，就是说不能同时买多次；
算法思路 暴力解法肯定很容易，两个for循环，但是时间肯定过不了，盈利公式：
利润=$ price(sale)-price(buy)$
=>利润=$\sum(price(D_{x + 1})-price(D_x))$ for $x\in [i,j-1]$
归约算法 很多年前当人们发现化学、物理、计算机都涉及到了数学，那把数学单独拿出来当做一门学科还是否有必要，直到微积分的出现。计算机也一样，很多专业也涉及计算机比如金融，为什么还要把计算机单独拿出来当做一门专业，因为计算机有两个核心，规约和递归。
当人遇到未知问题的时候会倾向于把未知问题转化成已知问题的求解，再深点就是规约是把复杂问题简单化的一把尺子，他决定了把问题转换成多大粒度的子问题。举个例子：
一个数学家和物理学家坐在一起，突然饮水机着火，物理学家找到一个垃圾桶，把垃圾倒出来装上水然后去浇灭火，人们防止饮水机在着火就专门在饮水机旁边放一个装满水的垃圾桶，第二天数学家和物理学家又坐在了一起，饮水机又着火了，这个时候数学家把垃圾桶里的水倒掉，然后装满垃圾，把装满垃圾的垃圾桶递给了物理学家……。
根据上面的总盈利公式等于每天的盈利之和，比如股票价格[7,1,5,3,6,4]变成盈利的数组就是[-6,4,-2,3,-2]，求最高盈利就是连续的天数盈利最高，变成了求最大连续子数组和的问题：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public int maxProfit(int[] prices) { int[] deltaPrices = new int[prices.length-1]; for(int i=0; i&lt; deltaPrices.length; i++){ deltaPrices[i] = prices[i+1] - prices[i]; } int maxProfit = maxSubArray(deltaPrices); return Math.max(maxProfit, 0); } public int maxSubArray(int[] nums) { int maxSum = Integer.MIN_VALUE; int sum = 0; for (int num : nums) { sum += num; if (sum > maxSum) { maxSum = sum; } if (sum &lt; 0) { sum = 0; } } return maxSum; } 贪心算法 如果参考及时止损的思路，假设第一天买入，第二天如果赔了就卖出并且买入，如果遇到赔钱可以理解为遇见了股票的低价，只要遇到了低价我们就重新买入，声明一个变量存储当前最大利润，这样就可以根据局部最优推出全局最优：
...</p></div><footer class=entry-footer>3 min</footer><a class=entry-link aria-label="post link to 5.买卖股票的最佳时机" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/leecode/5.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>5.二叉查找树</h2></header><div class=entry-content><p>二叉查找树是一颗二叉树，每个节点都含有一个Comparable的键和关联的值，并且每个节点的键都大于左子树中任意节点的键，小于右子树中任意节点的键。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 5.二叉查找树" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/5.%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>5.压测</h2></header><div class=entry-content><p>首先去Apache官网下载最新版jMeter，Mac下载tgz，windows下载zip然后解压。
进入bin目录双击ApacheJMeter.jar运行。
解决中文乱码 编辑bin目录下的jmeter.properties文件，设置属性：
1 sampleresult.default.encoding=UTF-8 创建测试请求 在测试计划下创建线程组
在线程组下添加http请求
填写请求信息
![image-20220106163135849](/Users/xiaohong/Library/Application Support/typora-user-images/image-20220106163135849.png)
根据需要配置Content-Type属性，我们接口基本上都是application/json的：
在线程组下添加“查看结果树”，⽤于查看运⾏结果：
运行脚本，点击结果树可以查看到结果。
添加断言判断接口结果，这里添加json断言
创建多个请求 多个请求直接在线程组下添加多个http就可以，但是如果存在请求需要用到上一个接口的数据，需要添加json提取器，拿到接口的返回值
match no表示匹配第几个，-1表示全部匹配，0表示随机。
压测 在线程组下添加汇总报告和聚合报告：
然后配置线程数，启动：</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 5.压测" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/cloud-alibaba-demo%E4%B9%8B%E8%AE%A2%E5%8D%95/5.%E5%8E%8B%E6%B5%8B/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>5.常见问题</h2></header><div class=entry-content><p>消息丢失 0丢失方案：发送端发送事务消息：half消息加commit or rollback方式，broker同步刷盘加主从同步，消费端确保一条线程消费成功后提交偏移量；
消息重复消费问题 消费端重复消费的场景：首先我们拉取到的消息可能有很多条，这一批消息如果有一条失败就要全部返回RECONSUME_LATER，在拉取到这些消息后就可能导致之前成功消费的又处理一遍；然后提交偏移量在broker那里是先写到内存在异步刷盘，这也会导致偏移量不准，还有一种情况是broker主节点宕机，从节点的consumer group偏移量信息不是最新的，也会导致消息重复消费。
解决方案是使用redis或者zk的分布式锁，这个要基于业务逻辑来实现，或者基于redis/数据库的唯一索引的幂等检查，消费成功之后插入一条数据，消费之前判断是否有这条数据，这样也要根据msgId进行加锁；
消息乱序 由于rocketMQ将消息存储到多个messageQueue中，很有可能数据库中一条数据的操作被放在了不同的messageQueue里，消费时可能会发生乱序的问题，所以在发送消息的时候就要保证有序的数据发到同一个messageQueue中。如果想要保证消息有序在消费的时候如果失败了也不可以进重试队列了，重试过来的消息和乱序消费时没区别的，只能返回SUSPEND_CURRENT_QUEUE_A_MOMENT暂停或者成功状态然后记录，根据具体业务处理。
生产者代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 根据订单id，将同一个订单发送到同一个messageQueue中 // 异步send方法的四个参数：消息实体；messageQueue选择器；选择器参数o；回调函数； Long orderId = 0L; producer.send(message, (list, message1, o) -> { Long orderId1 = (Long) o; // 根据队列取余 Long index = orderId1 % list.size(); return list.get(index.intValue()); }, orderId, new SendCallback() { @Override public void onSuccess(SendResult sendResult) { log.info("发送消息结果:{}", sendResult); } @Override public void onException(Throwable throwable) { throwable.printStackTrace(); log.error("发送失败"); } }); 消费者代码：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 5.常见问题" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/mq/rocketmq/5.%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wangxiaohong123.github.io/posts/page/13/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://wangxiaohong123.github.io/posts/page/15/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>