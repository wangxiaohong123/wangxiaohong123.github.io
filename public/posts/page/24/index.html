<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Posts | 王小红的笔记</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - 王小红的笔记">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css" integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/posts/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="/katex/katex.min.css">
<script defer src="/katex/katex.min.js"></script>
<script defer src="/katex/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: "$$", right: "$$", display: true},
        {left: "$", right: "$", display: false},
        {left: "\\(", right: "\\)", display: false},
        {left: "\\[", right: "\\]", display: true}
      ]
    });
  });
</script>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="王小红的笔记 (Alt + H)">王小红的笔记</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="笔记">
                    <span class="active">笔记</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">volatile
    </h2>
  </header>
  <div class="entry-content">
    <p>volatile是为了解决修改数据后，其他线程可以立即感知到数据的变化。
因为CPU读写主内存的速度比较低，所以数据的处理都是在CPU缓存中。CPU会读写的自己缓存，缓存在刷新到主内存或者别的地方，提高性能。但是这样的话就会导致别的线程修改了数据，不会马上写回主内存，就算写回主内存，有些线程可能也不会去主内存读，还是读取自己的缓存中的数据。
被volatile修饰后就符合MESI协议，当数据被修改之后也就是assign步骤结束后，会强制执行store和write操作，同时所有CPU会嗅探到数据过期，在重新读取数据。
java内存模型 可以看出来和CPU的缓存模型很像，也存在同样的问题，线程1在修改数据后，线程2感知不到。
并发三大问题 可见性：上面说得都是可见性。
原子性：多个线程读，一个线程写，会发生可见性，如果多个线程写就会发生原子性了，可能两个线程都执行&#43;1操作，结果执行完了结果还是1。jvm规定变量的简单赋值都是原子性的，包括引用类型的赋值。复杂的赋值比如i = j &#43; 2;这种待计算的就不保证原子性。但是在32位虚拟机中，赋值long和double是不保证原子性的，加上volatile就可以了，但是仅仅在这种情况使用volatile可以保证原子性。
有序性：编译器和指令器会进行指令重排。在静态编译（javac）和动态编译（JIT）过程中，都可能会发生指令重排，尤其是JIT。处理器在收到JIT编译好之后的机器码指令后，可能对指令进行重排序，处理器执行完到写缓冲器、无效队列、高速缓存中执行指令可能又发生下指令重排。
处理器在执行的时候哪个指令先就绪，就执行哪个指令，执行完了以后把结果放到重排序处理器，重排序处理器根据CPU收到的指令顺序把结果写到高度缓存或者写缓冲器中。
volatile是无法保证保证原子性的，因为就算数据被强制加载到工作内存，但是线程可能正在修改或者正在执行write操作，这时候就算工作内存中的数据变化了，也没用。
MESI协议 tag是保存主内存中数据的地址，flag是数据的状态，cache line里可以包含多个变量，就是具体的值。
处理器根据index、tag、offect来定位到数据，index定位到缓存中的bucket，tag定位到tag entry，offect定位到cache line中的数据。
flag的状态：
invalid：无效的
shared：共享的
exclusive：独占的
modified：修改过的
读取数据的时候，CPU1向总线发送read消息，主内存把数据返回，这时，数据的flag是S（共享的），修改数据的时候向总线发送invalidate消息，其他CPU嗅探到这条消息会把数据的flag变成I，然后返回ack给总线，CPU收到所有CPU的ack消息之后把flag变成E，修改完了把flag改成M，有的处理器还会把主内存的数据刷新。其他CPU在读取数据的时候发现flag是I，就要在发送read消息。这样会有一个问题，操作数据变成串行了，效率非常低。
在发invalidate消息之前把数据写到写缓冲器里，就可以去干别的了，收到invalidate消息之后把消息写到无效队列中，就返回ack，CPU1收到所有处理器的ack之后从写缓冲器中取出写入的数据，把flag变成E，然后在修改数据，在变成M，其他处理器从无效队列中消费完消息就把flag变成I，然后返回ack。这种异步的就会导致消息不会马上更新到高速缓存或者主内存，产生了可见性问题。还可能发生StoreLoad、StoreStore。
从图中可以看出，可见性是因为处理器更新数据副本可能写到寄存器、高速缓存或者写缓冲器，写到这几个地方其他处理器都不能马上感知到数据的变化。
flush操作：在刷新数据到写缓冲器的同时，也要把数据刷新到高速缓存中，有的硬件还需要把数据刷到主内存中，刷新完了会发送消息到消息总线。
refresh操作：处理器接收到总线的消息后会把变量副本过期，然后从发消息的处理器的高速缓存或者主内存中加载数据（根据硬件决定）。
happens-before 只要是符合这个原则，就不能重排序。
内存屏障 Load屏障：执行refresh操作，收到invalidate消息之后马上修改flag为I；
Store屏障：执行flush操作，把数据写到写缓冲器中后必须等到所有ack之后写到高速缓存或者主内存中；
Acquire屏障（LoadLoad &#43; LoadStore）：禁止读操作和读写操作发生指令重排；
Release屏障（StoreLoad &#43; StoreStore）：禁止写操作和读写操作发生指令重排；
1 2 3 4 5 6 7 8 9 10 11 boolean volatile isRunning; // Release屏障 isRunning = false; // Store屏障 // Load屏障 while(isRunning) { // Acquire屏障 …… } </p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to volatile" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/2.volatile/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">为什么使用微服务
    </h2>
  </header>
  <div class="entry-content">
    <p>单块应用的缺点： 代码重复问题，如果十几个人或者更多人一起干一个单块项目，你要别的模块的接口，但是那个人很忙，没时间写，拖了很长时间你可能就自己写了，这样就操作别的表，别人的库，很有可能和那个人的摸个功能有重复代码，可能会出现大量的重复代码，使用cloud的feign可以避免，微服务中每个人都没有修改别人代码的权限；
协作问题：多人修改公共文件夹下的代码就会出现代码冲突，两个人的冲突还好解决，多个人的冲突超级麻烦；
扩容行问题：所有模块都在一个项目里，要扩容就一起扩容，但是根据28法则，只有那么几个模块流量很大，而且有的时候有的模块还有一些状态什么的，如果扩容就会计算出错，这种也很麻烦；
可用性问题，可能一个人负责的模块写了个死循环或者不小心oom，整个系统就瘫痪了，微服务里如果别的服务挂了可以使用histrix降级熔断；
耦合度太高：代码量上来的时候在后期想要修改代码都不敢动手；
spring cloud是一站式微服务架构解决方案。dubbo是RPC框架。
</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 为什么使用微服务" href="http://localhost:1313/posts/%E6%A1%86%E6%9E%B6/spring/cloud/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">事务-2.XA事务
    </h2>
  </header>
  <div class="entry-content">
    <p>一般项目刚上线不久，数据量稍微有点大的时候，但是还没到分库分表的数据量，会把不同的表放到不同的数据库中，但是这个时候@transactional注解垮裤不会生效了。这时候就要用到XA规范和2PC、3PC理论。
XA规范 TM和RM通信的规范就是XA，TM就相当于是引入的一个组件。
XA规范流程：connect -&gt; closed，start -&gt; end，prepare -&gt; commit/rollback。
一般的TM用的都是Atomikos
1 2 3 4 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jta-atomikos&lt;/artifactId&gt; &lt;/dependency&gt; 2PC（Tow Phase Commit） 2PC是一套基于XA的理论，两阶段提交，第一个阶段TM发送prepare消息，让RM先把操作数据库的语句跑完，但是不提交，操作完后给TM结果，如果TM收到的结果全是成功就在告诉RM进行提交，如果有失败的或者超时的就会通知RM回滚。
问题： 在第二阶段提交之前，资源会一直锁定，这样别人在对资源加独占锁的时候会同步阻塞住；
在第一阶段后单点的TM挂了，这时候资源就会被一直占用着；
在TM发送commit消息的时候，一台服务器挂了，TM也挂了，这时候在选举一个TM出来也不知道哪个消息commit成功了；
脑裂问题，所有主从都有脑裂问题；
3PC 第一阶段：TM发送CanCommit消息，各个库确认环境是否OK；
第二阶段：发送PreCommit消息，相当于2PC的第一阶段；
第三阶段：发送DoCommit消息，2PC的第二阶段；
每个库有一个超时机制，如果在PreCommit之后过一段时间没接收到DoCommit的消息，就会回滚，关键还有一个CanCommit阶段，因为能到PreCommit消息说明所有库都在CanCommit阶段返回成功了，那么这么长时间还没有DoCommit或者abort消息，应该就是TM挂了。
MySQL支持的是2PC协议。
JTA事务 J2EE中的概念，单库的的事务是基于jdbc的，多库的事务是JTA事务，也是基于DTP那一套玩的。
全局事务 x/Open组织定义了一套分布式事务的模型和规范，叫做DTP，就是图中的TM、RM等等。全局事务就是DTP模型中的一个概念，图里也写到了。
</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 事务-2.XA事务" href="http://localhost:1313/posts/%E6%A1%86%E6%9E%B6/%E4%BA%8B%E5%8A%A1/2.%E5%8D%95%E6%A8%A1%E5%9D%97%E5%A4%9A%E5%BA%93/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">事务-3.TCC事务
    </h2>
  </header>
  <div class="entry-content">
    <p>
主业务服务就是调用其他服务的接口，比如说下订单的接口，在这个接口中需要冻结用户钱包金额，主业务服务就是订单服务，从业务服务就是钱包服务，钱包服务需要提供三个接口：try接口、confirm接口、cancel接口。
业务活动管理器就是管理分布式事务状态的，他会去触发从业务服务的confirm和cancel接口。
try阶段：会锁定资源，没有资源锁定的操作，try接口就可以留空。
confirm：执行具体的逻辑；
cancel：对之前的变动回滚；
TCC的两个变种 异步型TCC方案：从业务服务之前加一层消息服务，从业务服务只有一个confirm接口，try操作就是在消息服务中写入一条confirm消息，confirm操作就是把这个消息发送到从业务服务，cancel操作就是把消息删掉，比如从业务服务已经写好了接口，如果现在要改成分布式事务，需要加两个接口，一个try，一个concel，加一个消息服务，从业务服务就不需要加接口了。 补偿性TCC方案：只有两个阶段，一个do接口，一个compensate接口，其实就是把try拿掉了。 国内的热门TCC框架 tcc-transaction：对spring cloud整合不太好，dubbo还行。 himly：他的整合都是用xml格式，现在都是注解了。 ByteTCC：支持TCC和saga事务，注解驱动，和spring cloud整合还行。 byteTCC可以实现tcc事务和saga事务，在tcc事务中，try和cancel是对应起来的，如果confirm失败会一直重试，cancel失败也会一直重试，而在saga事务中，没有confirm，try就是执行业务逻辑，cancel提供对应的反向数据操作。
byteTCC源码 首先使用byteTCC需要在dataSource组件加入注解：@Import(SpringCloudConfiguration.class)，SpringCloudConfiguration.class里面是对cloud的组件比如feign创建了自己的动态代理，实现自己的逻辑。
启动类上添加注解**@ImportResource({ &#34;classpath:bytetcc-supports-springcloud.xml&#34; }) **，这个xml配置了很多bean。
服务之间的事务上下文都是通过request的header传递。
bytejta表中如果只有一条记录，说明try执行完了，confirm或者cancel还没执行成功，正常来说一个事务会对应两条记录。
CompensableWork会定时（60s）重试失败的confirm或者cancel，也是调用CompensableCoordinatorController中的接口，同时在刚启动的时候他也会去恢复没执行的事务。
链式调用也是使用resourceList。
在bytetcc中，confirm和cancel失败会一直重试，直到成功，讲道理来说，confirm失败也应该调用对应的cancel，cancel失败不断重试就完美了。
</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 事务-3.TCC事务" href="http://localhost:1313/posts/%E6%A1%86%E6%9E%B6/%E4%BA%8B%E5%8A%A1/3.tcc%E5%8F%8A%E5%8F%98%E7%A7%8D%E6%96%B9%E6%A1%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">事务-6.seata
    </h2>
  </header>
  <div class="entry-content">
    <p>seata原理 AT模式原理 首先有一个Seata Server负责控制事务的提交和回滚，每个服务里需要引入seata client负责监听sql，并生成对应的undo_log，undo_log存储在表里，并且操作本地数据和插入undo_log在同一本地事务中，当服务完成本地事务后需要告诉Seata Server分支事务提交成功，所有分支事务都完成后(那个角色提交？)向Seata Server提交事务并释放全局锁，如果存在某个服务发生异常，此时Seata Server会向提交分支事务成功的服务发送执行回滚日志消息，再由seata client执行对应的undo_log。
![seataAT模式](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/seata AT模式.png)
读写隔离原理 seata的隔离级别是读未提交，未提交指的是分布式事务没有提交，并不是本地事务。
首先完整的流程如下图，在提交本地事务前必须要通过Seata Server获取全局锁，其他分布式事务在没有拿到全局锁前不能提交本地事务，如果没有全局锁会导致多个分布式事务同时操作一条数据，发生回滚时数据错乱的问题，但是引入的全局锁会让性能下降的严重，所以AT模式的分布式事务只用在跟钱相关的操作里，其他时候如果需要用到分布式事务可以使用mq的软事务。
![seataAT模式读写隔离原理](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/seata AT模式读写隔离原理.png)
死锁问题 比如上图两个事务操作同一条数据，事务1中服务A的操作执行完成并且提交了本地事务，此时事务2开始执行服务A的操作，此时全局锁在事务1上，所以事务2的服务A没法提交本地事务，他会等待拿到全局锁，但是这个时候他是持有11001的本地锁的，事务1在执行服务B操作的时候发生异常需要回滚，服务A收到回滚消息需要拿到11001的本地锁，出现了事务1持有事务2需要的全局锁，事务2持有事务1需要的本地锁，循环等待了，seata为了解决这个死锁问题在获取全局锁的时候加了个超时机制，如果超时会回滚数据并释放锁。
使用seata 前提：Seata Server启动好，每个服务对应的库创建好undo_log表。
pom中添加依赖：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 &lt;!-- 引入seata整合分布式事务 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- 跟安装的seata-server需要保持版本一致 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; 添加配置：
...</p>
  </div>
  <footer class="entry-footer">4 min</footer>
  <a class="entry-link" aria-label="post link to 事务-6.seata" href="http://localhost:1313/posts/%E6%A1%86%E6%9E%B6/%E4%BA%8B%E5%8A%A1/6.seata/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">事务-可靠消息最终一致性事务
    </h2>
  </header>
  <div class="entry-content">
    <p>一些耗时的操作可以使用这个。
步骤5.1失败了：
可靠消息服务更新状态为已发送：一直会有一条状态时待确认的消息； 可靠消息服务删除消息失败：一直会有一条状态是待确认的消息； 不管是那种情况操作失败了，都是比较尴尬的。
步骤7失败：可靠消息服务一直有一条状态是已发送的消息；
可以看出来出现尴尬问题的点都在可靠消息服务上。
解决步骤5.1失败：回调机制，可靠消息服务后台线程定时扫描超时的待确认消息，然后回调上游服务，上游服务返回这条消息对应的业务处理结果是成功还是失败，如果失败就删掉这条消息，如果是成功就执行步骤5.2。
解决步骤6、7失败：可靠消息服务后台线程定时扫描超时的已发送消息，重新投递到消息队列中，不过下游消息要做好幂等性。
一般做这种事务都不要太依赖mq，mq只是作为存储消息的中间件，这样mq的bug不会影响到我们系统，而且以后想换mq或者升级也不会受到影响。
这套方案的缺陷非常明显，可靠消息服务全部基于MySQL，扛不住高并发。数据量也很大，可以用redis或者zk来代替MySQL，定时清理数据。
</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 事务-可靠消息最终一致性事务" href="http://localhost:1313/posts/%E6%A1%86%E6%9E%B6/%E4%BA%8B%E5%8A%A1/5.%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">全文检索
    </h2>
  </header>
  <div class="entry-content">
    <p>一般match都是拆词，包含一个词就可以
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 查询title中包含java或者elasticsearch GET /forum/article/_search { &#34;query&#34;: { &#34;match&#34;: { &#34;title&#34;: &#34;java elasticsearch&#34; } } } // 这么写的时候，es把他转换成should语法，像下面这样 GET /forum/article/_search { &#34;query&#34;: { &#34;bool&#34;: { &#34;should&#34;: [ &#34;match&#34;: { &#34;title&#34;: &#34;java&#34; }, &#34;match&#34;: { &#34;title&#34;: &#34;elasticsearch&#34; } ] } } } 如果想要必须都包含，也就是并且关系
...</p>
  </div>
  <footer class="entry-footer">3 min</footer>
  <a class="entry-link" aria-label="post link to 全文检索" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/es/7.%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">分布式搜索引擎
    </h2>
  </header>
  <div class="entry-content">
    <p>1.es原理(es是如何实现分布式的) 首先每个节点都有primary shard和replica shard，写数据只能写到primary shard上，读数据可以从primary和replica shard上读。
写数据的时候会随便选择一个协调节点，协调节点通过hash值把请求路由到具体的primary shard所在机器，然后primary shard把数据写到内存的indexing buffer，同时在OS cache中记录trans log，然后同步数据给replica shard，这个时候就可以返回成功了，但是数据还不能被查到。 每秒会有一个refresh操作：再OS cache中新建一个segement file，把indexing buffer刷到segement file中并建立好倒排索引，然后清空indexing buffer，这个时候数据才能被查询到，所以es是准实时的；OS cache中的trans log每5秒会被刷到硬盘中，所以默认情况下es可能会最多丢失5s的数据；当trans log太大或者每半个小时会执行一次flush操作，记录一个commit point然后把trans log清空。 删除的时候会把删除的数据写进del文件，当segement文件太多之后会进行merge操作，把segement文件合成一个大文件，这个时候会把del文件中的数据物理删除。
查询的时候也是根据id计算出数据在那个shard上，然后找对应shard查找，搜索的时候会查找所有shard把符合条件的document的id都返回到协调节点上，然后协调节点在根据doc id去查找对应document再进行筛选，最后返回结果。
2.在大数据量的情况下如何提高查询效率 es的查询优化是没有银弹的！
首先在查询数据的时候，会先去cache中找，如果没有再把磁盘的数据读到filesystem cache中，然后把结果返回，下次再来查找的时候会直接把cache中的数据返回，所以filesystem cache的大小对查询的速度影响是最大的。如果走磁盘的话基本就上秒了。所以要把更多的内存给cache，并且尽可能减少es的document的field大小，就把要用来检索的字段存到es中。检索出来的数据的id再去MySQL或者hbase中查完整的数据。
如果数据量还是很大，可以统计热数据，每隔一段时间主动查询一下热数据，让热数据一直在OS cache中。
在模型设计的时候要避免多次查询，一些join操作把涉及到的数据存到一个document中。
他的分页性能非常差，需要把数据都拿到协调节点上，然后排序，在分页操作，比如查询10000~10010的数据，他会从每个shard中都查询出来10010条数据进行排序然后找到10000~10010的数据，所以翻页越深，性能越差。如果是上拉加载更多那样的可以用scroll api。
3.生产环境的es部署架构？每个索引有多大？每个数据多少个分片？ 我们生产环境部署了3台16g机器，48g的总内存，es进程每个不到8g，OS cache差不多有20多个g。日增数据量差不多八十万条，日增的数据大约120多兆，每个月增量数据大概两千多万，2g左右，两个索引，每个索引6个shard。
4.分词器的二次开发 下载ik分词器源码，然后添加MySQL依赖，然后编写MySQL连接代码，还有查询分词、停用词代码，最后在Dictionary类中添加一个addStopWord()方法，不断查询MySQL调用Dictionary的addStopWord()和addWords()方法就可以了。
</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 分布式搜索引擎" href="http://localhost:1313/posts/%E9%9D%A2%E8%AF%95/9.%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">创建型-单例模式
    </h2>
  </header>
  <div class="entry-content">
    <p>什么时候用单例？
比如配置文件这种，存在一份就够了，每次使用都创建实例的话就会浪费资源；
或者一个操作文件的类，每次都创建一个实例去写文件在高并发的场景很可能会相互覆盖；
第二种情况使用分布式锁或者将写操作放到队列中排队消费，但是都很复杂，这些情况都可以使用单例很容易的解决。
我们实现的单例都是类加载器级别的单例，他的作用域介于线程和进程之间，因为java中确定类的唯一是通过类全名&#43;类加载器实例。
饿汉单例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 饿汉是第二简单的实现方法，由于Singleton实例在类加载的时候就已经创建好了，所以是线程安全的 * 缺点就是不支持延迟加载 * 如果类的初始化耗时长还是应该使用这种方法，在用到的时候再去创建反倒会影响系统性能 * @author xiaohong */ public class Singleton { private Singleton() {} private static final Singleton instance = new Singleton(); public static Singleton getInstance() { return instance; } } 懒汉单例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * 懒汉单例也比较简单，并且可以支持延迟加载 * 但是getInstance()方法上有一把锁，这让这个函数的操作都会变成串行，在高并发的时候非常影响性能 * @author xiaohong */ public class Singleton { private Singleton(){} private static Singleton instance; public static synchronized Singleton getInstance() { if(instance == null){ instance = new Singleton(); } return instance; } } 双重检查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * 双重检查就是更细粒度的锁，提升了一点性能 * 网上有人说这种写法会发生指令重排，然后在创建完实例还没初始化（调用构造函数）的时候就会被别的线程使用了，需要加上volatile关键字禁止指令重排 * 其实在高版本java中已经解决了这个问题，在java中把new的操作和初始化的操作设计成立原子操作，不存在编译优化问题 * @author xiaohong */ public class Singleton { private Singleton(){} private static Singleton instance; public static Singleton getInstance() { if(instance == null){ synchronized(Singleton.class){ if(instance == null){ instance = new Singleton(); } } } return instance; } } 静态内部类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 主流的单例模式创建方法 * 由内部类实现，instance的唯一和线程安全都有jvm保证，还支持延迟加载 * @author xiaohong */ public class Singleton { private Singleton(){} private static class SingletonHolder { private static Singleton instance = new Singleton(); } public static Singleton getInstance() { return SingletonHolder.instance; } } 枚举类 查看JAD反编译之后的文件感觉枚举的单例和饿汉模式很像
...</p>
  </div>
  <footer class="entry-footer">2 min</footer>
  <a class="entry-link" aria-label="post link to 创建型-单例模式" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">创建型-原型模式
    </h2>
  </header>
  <div class="entry-content">
    <p>原型模式就是从一个对象创建另一个可定制的对象，而且不需要知道创建的细节。
如果只是申请内存然后再给变量赋值，使用clone的方法提升的性能是可以忽略不计的，但是我觉得如果这种操作很多，比如循环一万次，每次都要创建一个新的实例，这时候可以使用原型模式； 当创建对象的操作比较复杂的时候，比如需要操作数据库、文件、计算hash值等等，这时候使用拷贝的对象就比较快了； 实现原型模式的类要继承Cloneable接口，并重写clone方法，因为继承这个接口也不具备复制对象的能力，需要在重写的clone中调用super.clone()：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Student implements Cloneable { private String name; private Date birth; public String getName(){ return name; } public void setName(String name){ this.name= name; } public Date getBirth() { return birth; } public void setBirth(Date birth) { this.birth = birth; } /** * 重写clone方法 * @return */ @Override public Student clone(){ Student student = null; try{ // 调用Object的clone方法 student = (Student) super.clone(); student.birth = (Date) student.birth.clone(); }catch(CloneNotSupportedException e){ e.printStackTrace(); } return student; } } 使用时直接调用Student的clone方法：
...</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 创建型-原型模式" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/posts/page/23/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:1313/posts/page/25/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">王小红的笔记</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
