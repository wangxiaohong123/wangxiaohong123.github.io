<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Posts | 王小红的笔记</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - 王小红的笔记">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css" integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/posts/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="/katex/katex.min.css">
<script defer src="/katex/katex.min.js"></script>
<script defer src="/katex/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: "$$", right: "$$", display: true},
        {left: "$", right: "$", display: false},
        {left: "\\(", right: "\\)", display: false},
        {left: "\\[", right: "\\]", display: true}
      ]
    });
  });
</script>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="王小红的笔记 (Alt + H)">王小红的笔记</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="笔记">
                    <span class="active">笔记</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">线上问题排查
    </h2>
  </header>
  <div class="entry-content">
    <p>服务器 端口号被占用
启动服务发现端口号被占用可以使用netstat或者lsof查看占用端口号进程，没有用就杀掉
1 2 3 netstat -tunlp | grep 80 lsof -i:80 kill -9 [pid] 磁盘
当磁盘不足的时候可能会收到类似java.io.IOException: 磁盘空间不足这种信息，可以先使用以下指令查看磁盘状态
1 df -h 比如显示下面的信息就表示/目录下的磁盘占用很大
就要去/下面查看文件夹大小，一层一层一直找到大文件
1 2 3 4 5 6 du -sh * # 然后可以使用ls查看文件大小 ls -lh # 或者直接找到大文件，max-depth就是查找文件夹的深度 du -h --max-depth=1 | sort -n 或者直接使用find命令把大文件筛选出来
...</p>
  </div>
  <footer class="entry-footer">3 min</footer>
  <a class="entry-link" aria-label="post link to 线上问题排查" href="http://localhost:1313/posts/linux/1.%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">线程
    </h2>
  </header>
  <div class="entry-content">
    <p> 工作线程：main方法就是一个线程，在main线程中在启动一个线程，线程中是一个死循环，比如定时发送心跳，这时候就算main执行完成，jvm也不会退出，因为有一个非后台的工作线程在一直运行。 daemon线程：非工作线程就是daemon线程，如果说所有的工作线程都停止了，daemon线程会跟着jvm一起退出了。使用**setDaemon(true)**将工作线程设置成daemon线程，什么时候需要设置成daemon线程呢？比如说有一个后台的监控线程，在工作线程都结束之后，后台的监控也没用了，jvm就可以退出了，不让监控线程影响jvm的退出就要把监控线程设置成daemon线程。 ThreadGroup：线程是有父子概念的，比如在main中创建一个线程，那main就是创建线程的父线程，如果没指明线程组，会被分配到父线程所在的线程组中。main线程的名字就是main，平时创建的线程可以使用**setName(&#34;ServiceAliveMonitor&#34;)**设置线程名。手动创建线程组 1 2 3 4 // 创建一个线程组 ThreadGroup daemonThreadGroup = new ThreadGroup(&#34;daemon&#34;); // daemon是我自己创建的线程，在线程中的构造方法中调用super(ThreadGroup, ThreadName)就可以分配线程组了 this.daemon = new Daemon(daemonThreadGroup, &#34;ServiceAliveMonitor&#34;); 线程优先级:setPriority(8)，理论上来说数越大越会CPU更多的执行，默认是5。 Thread.yield()：告诉CPU说不执行这个线程了，暂停。 join()就是要等待这个线程执行完才能往下走。 Interrupt：打断一个线程，就是修改线程里的interrupt标志位，线程中可以通过isInterrupted()来感知到被打断，在决定是否继续运行，还可以打断一个线程的休眠。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 Thread thread = new Thread() { @Override public void run() { while (!isInterrupted()) { System.out.println(&#34;线程1执行在工作&#34;); } } }; thread.start(); TimeUnit.MILLISECONDS.sleep(200); // interrupt并不会停止线程，只是修改一下标志位 // 要在线程中判断被打断了以后怎么操作 thread.interrupt(); /** * 唤醒睡眠的线程 */ public static void main(String[] args) throws Exception { MyThread thread = new MyThread(); thread.start(); // 让线程执行一会 Thread.sleep(1000); // 修改线程的while条件 thread.setShouldRun(false); // 然后在唤醒，这样的话线程被唤醒就退出了 thread.interrupt(); } private static class MyThread extends Thread { private boolean shouldRun = true; @Override public void run() { while (shouldRun) { try { System.out.println(&#34;线程1执行在工作&#34;); Thread.sleep(30 * 1000L); } catch (InterruptedException e) { e.printStackTrace(); } } } public void setShouldRun(boolean shouldRun) { this.shouldRun = shouldRun; } } </p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 线程" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/1.%E7%BA%BF%E7%A8%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">线程
    </h2>
  </header>
  <div class="entry-content">
    <p>Synchronized原理
Mark Word结构
Synchronized修饰普通方法，锁的是实例对象，修饰的是静态方法的时候锁的是类，class对象。
每个对象都有monitor对象，monitor中有一个计数器，编译的时候碰到了Synchronized时候会生成MonitorEnter和对应的MonitorExit，线程执行到Synchronized修饰的代码块或者方法的时候，先看看monitor对象中的计数器是不是0，如果不是0就根据owner判断持有锁的对象是不是自己，如果不是就等待，如果是就把计数器在加1，调用wait方法的时候会把计数器清0，owner变成null，然后waitset中添加当前线程，调用notify的时候就唤醒waitset中的线程。
双重检查的单例需要使用volatile并不是因为volatile的可见性，因为Synchronized本身就可以保证可见性，而是因为双重检查的写法可能会导致指令重排，打乱了创建对象实例的时候的顺序，比如单例的构造函数中实例化了其他的对象，可能会重排成对象没实例化，但是指针有了，这时候线程2走if判断，发现是true直接返回实例，但是实例的对象还没全部初始化，只是有了一个指针，用这个实例就会有问题。加上volatile根据happens-before原则不会进行重排序。
synchornized使用锁来保证原子性，通过在释放锁的时候执行flush操作，在进入代码块的时候执行refresh操作，通过内存屏障来解决有序性，和可见性。
在执行完monitorenter之后会执行Load内存屏障，执行monitorexit之后会执行Store内存屏障。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // synchronized通过Acquire和Release屏障可以保证代码块内部和外部不发生指令重排 // 代码块里面还是可能会发生指令重排 int b = 0; int c = 0; synchronized(this) { // -&gt; monitorenter // Load内存屏障 // Acquire内存屏障 int a = b; c = 1; // Release内存屏障 } // -&gt; monitorexit // Store内存屏障 锁升级 偏向锁 偏向锁就是在Mark Word中存储线程ID，为了提升同一个线程多次加锁释放锁的性能，比如循环调用Synchronized代码块，如果高并发而且并不存在同一个线程多次调用同一个Synchronized代码块时，会频繁的发生stop the world和CAS，影响性能，这时候应该关闭偏向锁：
...</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 线程" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/3.synchronized/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">线程池
    </h2>
  </header>
  <div class="entry-content">
    <p>四种线程池：
fixed：固定数量 cached：数量不固定，有新任务就创建线程，空闲的线程会回收 single：只有一个线程池 scheduled：在指定时间后执行提交的线程 fixed，fixed中并不会触发reject策略，和maximumPoolSize，因为他用的是无界队列。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 /** * Executors类的newFixedThreadPool方法 * 虽然LinkedBlockingQueue是有界队列，但是声明线程池的时候没有设置capacity，相当于一个无界队列，容易OOM * 核心线程数和最大线程数是相同的，如果nThreads都在处理任务就会把任务压进队列中 * 如果线程报错挂掉，会在创建一个新的线程来顶替 * 线程空闲的时候不会被销毁，因为核心线程数就是最大线程数 */ public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); } /** * ThreadPoolExecutor类的构造方法 * 他的父类实现了ExecutorService * 所以创建普通线程池一般都用ExecutorService来接收： * ExecutorService threadPool = Executors.newFixedThreadPool(10); */ public ThreadPoolExecutor(int corePoolSize, // 核心线程数 // 最大线程数 int maximumPoolSize, // 多余线程的空闲存活时间 long keepAliveTime, TimeUnit unit, // 任务队列 BlockingQueue&lt;Runnable&gt; workQueue, // 创建线程的工厂 ThreadFactory threadFactory, // 线程数达到最大并且队列也满了之后在收到任务的拒绝策略 RejectedExecutionHandler handler) { if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } // ThreadPoolExecutor中除了构造函数的参数，还有一些关键的参数 // 通过一个32位的二进制数，来表示线程状态和数量， // 前3位是线程池的状态，后29为是数量，通过一些二进制计算来查询和修改 private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); // 获取状态 private static int runStateOf(int c) { return c &amp; ~CAPACITY; } // 获取线程数量 private static int workerCountOf(int c) { return c &amp; CAPACITY; } // 设置线程数量和线程池状态 private static int ctlOf(int rs, int wc) { return rs | wc; } /** * 提交线程的方法 */ public void execute(Runnable command) { if (command == null) throw new NullPointerException(); // 获取上面说得那个32位数字 int c = ctl.get(); // 如果线程数小于核心线程数就创建一个线程 if (workerCountOf(c) &lt; corePoolSize) { // addWorker传的true表示是核心线程 // 使用cas增加核心线程数 if (addWorker(command, true)) return; c = ctl.get(); } // 任务入队成功，使用的是offer，这个是非阻塞的，如果队列满了就返回false if (isRunning(c) &amp;&amp; workQueue.offer(command)) { int recheck = ctl.get(); // 下面的操作是双重检查 // 如果线程池关闭了，删除任务，然后拒绝 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); // 如果线程数是0就创建线程 else if (workerCountOf(recheck) == 0) addWorker(null, false); } // 任务入队失败，说明核心线程数达到最大并且队列已经满了 // 尝试创建新线程，直到线程达到最大线程数 // 如果这个时候创建线程失败就走拒绝策略 else if (!addWorker(command, false)) // 拒绝策略 reject(command); } 关闭，关闭不会马上关闭有任务的线程，而是先关闭线程池，线程池状态是关闭时，不接受新任务，在线程把队列和自己的任务执行完之后while循环中的take（不是阻塞队列的take）就会返回null，线程就结束了。
...</p>
  </div>
  <footer class="entry-footer">4 min</footer>
  <a class="entry-link" aria-label="post link to 线程池" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/12.%E7%BA%BF%E7%A8%8B%E6%B1%A0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">结构型-享元模式
    </h2>
  </header>
  <div class="entry-content">
    <p>
就是缓存，把对象都存起来，以后用到的时候都是一个实例，需要注意一下并发安全。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public abstract class FlyWeight { public abstract void operation(int extrinsicstate); } public class ConcreteFlyWeight extends FlyWeight { @Override public void operation(int extrinsicstate) { System.out.printLn(&#34;具体FlyWeight:&#34; &#43; extrinsicstate); } } public class UnsharedConcreteFlyWeight extends FlyWeight { @Override public void operation(int extrinsicstate) { System.out.printLn(&#34;不共享的具体FlyWeight:&#34; &#43; extrinsicstate); } } public class FlyWeightFactory { private HashTable flyWeights = new HashTable(); public FlyWeightFactory() { // 什么时候初始化看情况， flyWeights.add(&#34;x&#34;, new ConcreteFlyWeight()); flyWeights.add(&#34;y&#34;, new ConcreteFlyWeight()); flyWeights.add(&#34;z&#34;, new ConcreteFlyWeight()); } public FlyWeight getFlyWeight(String key) { return (FlyWeight) flyWeights.get(key); } } public static void main(String[] args) { int extrinsicstate = 22; FlyWeightFactory f = new FlyWeightFactory(); FlyWeight fx = f.getFlyWeight(&#34;x&#34;); fx.operation(--extrinsicstate); FlyWeight fy = f.getFlyWeight(&#34;y&#34;); fx.operation(--extrinsicstate); FlyWeight uf = new UnsharedConcreteFlyWeight(); uf.operation(--extrinsicstate); } </p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 结构型-享元模式" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">结构型-代理模式
    </h2>
  </header>
  <div class="entry-content">
    <p>类图：
场景：
代理模式就是在访问对象时引入的间接性，因为这种间接性，可以附加很多用途。
增强方法，比如日志； mybatis或者hibernate的一对多关系实体中get关联的实体集合时会使用代理模式去数据库中查； http接口和rpc接口是被代理类代理的，我们直接调用接口就可以了； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public abstract class Subject { public abstract void request(); } public class RealSubject extends Subject { @Override public void request() { System.out.println(&#34;真实的请求&#34;); } } public class Proxy extends Subject { private Subject subject; public Proxy(Subject subject) { this.subject = subject; } @Override public void request() { System.out.println(&#34;代理的请求&#34;); subject.request(); } } public statis void main(string[] args) { Proxy proxy = new Proxy(new RealSubject()); proxy.request(); } </p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 结构型-代理模式" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">结构型-桥接模式
    </h2>
  </header>
  <div class="entry-content">
    <p>在面向对象的设计中有一个非常重要的原则，合成/聚合复用原则，就是优先使用对象合成或者聚合，尽量不要使用继承。因为继承关系在编译时就确定好了，子类和父类有非常紧密的联系，以至于父类实现中有任何改变必然会导致子类发生变化，这种依赖关系限制了灵活性和复用性。
合成(组合)和聚合都是一种特殊的关联关系，组合是强拥有，聚合时弱拥有。桥接模式就是将抽象部分和他的实现分离，使他们可以独立的变化。这里的抽象实现不是说抽象类的子类，而是用来实现抽象类的对象。在通俗点就是系统可能有多个角度的分类，每一种分类都可能有变化，就把多个角度抽离，让他们各自独立，比如手机品牌是抽象，手机软件是手机的实现，手机和软件就是聚合的关系。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /** * 实现 */ public abstract class Implementor { public abstract void operationImpl(); } public class ConcreteImplementorA extends Implementor { @Override public void operationImpl() { System.out.println(&#34;具体实现A的方法执行&#34;); } } public class ConcreteImplementorB extends Implementor { @Override public void operationImpl() { System.out.println(&#34;具体实现B的方法执行&#34;); } } public class Abstraction { protected Implementor implementor; public void setImplementor(Implementor implementor) { this.implementor = implementor; } public void operation() { implementor.operationImpl(); } } public class RefinedAbstraction extends Abstraction { @Override public void operation() { implementor.operationImpl(); } } public static void main(String[] args) { Abstraction ab = new RefinedAbstraction(); ab.setImplementor(new ConcreteImplementorA()); ab.operation(); ab.setImplementor(new ConcreteImplementorB()); ab.operation(); } </p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 结构型-桥接模式" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">结构型-组合模式
    </h2>
  </header>
  <div class="entry-content">
    <p>组合模式就是将对象组合成属性结构展示，让客户端对单个对象和组合对象的使用具有一致性。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 public abstract class Component { protected String name; public Component(String name) { this.name = name; } public abstract void add(Component c); public abstract void remove(Component c); public abstract void display(int depth); } /** * 组合中没有子节点的分支 */ public class Leaf extends Component { public Leaf(String name) { super(name); } @Override public void add(Component c) { System.out.println(&#34;当前节点不支持添加&#34;); } @Override public void remove(Component c) { System.out.println(&#34;当前节点不支持删除&#34;); } @Override public void display(int depth) { // 叶节点的具体方法 System.out.println(this.name &#43; &#34;-&#34; &#43; depth); } } /** * 组合中有子节点的分支 */ public class Composite extends Component { private List&lt;Component&gt; children; public Leaf(String name) { super(name); children = new LinkedList&lt;&gt;(); } @Override public void add(Component c) { children.add(c); } @Override public void remove(Component c) { children.remove(c); } @Override public void display(int depth) { // 叶节点的具体方法 System.out.println(this.name &#43; &#34;-&#34; &#43; depth); for (Component child : children) { child.display(depth &#43; 1); } } } /** * 客户端 */ public static void main(String[] args) { Composite root = new Composite(&#34;root&#34;); root.add(new Leaf(&#34;leaf a&#34;)); root.add(new Leaf(&#34;leaf b&#34;)); Composite compX = new Composite(&#34;compX&#34;); compX.add(new Leaf(&#34;compX a&#34;)); compX.add(new Leaf(&#34;compX b&#34;)); root.add(compX); Composite compY = new Composite(&#34;compY&#34;); compY.add(new Leaf(&#34;compY a&#34;)); compY.add(new Leaf(&#34;compY b&#34;)); root.add(compY); root.display(1); } 数可以有无数分支，只需要反复使用Composite就可以实现，上面的Component把所有管理子节点的方法全部声明成抽象的，让子类必须实现，这样叶节点和枝节点堆外没有区别，具有一致的行为，叫做透明方式，这样有个缺点就是叶节点实现了没有意义的接口。
...</p>
  </div>
  <footer class="entry-footer">2 min</footer>
  <a class="entry-link" aria-label="post link to 结构型-组合模式" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">结构型-装饰器模式
    </h2>
  </header>
  <div class="entry-content">
    <p>类图： 当系统需要新功能的时候如果还像主类中添加代码会增加主类的复杂度并且容易出问题，装饰器模式是说把每个需要装饰的功能放到一个单独的类中，让这个类包装他所装饰的对象，当需要执行这个装饰的功能的时候，调用方可以有选择的、自定义顺序的执行装饰功能。他和代理模式差不多他也可以对已有功能进行增强。java的好多IO类或者spring的aop都是这个模式。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 public class Demo { public abstract class Component { public abstract void operation(); } public class ConcreteComponent extends Component { @Override public void operation() { System.out.println(&#34;具体的对象操作&#34;); } } public abstract class Decorator extends Component { protected Component component; public void setComponent(Component component) { this.component = component; } @Override public void operation() { component.operation(); } } public class ConcreteDecoratorA extends Decorator { // 装饰对象A独有的属性 private String addedState; @Override public void operation() { // 先执行Component的operation()，在执行装饰对象A的增强操作 super.operation(); this.addedState = &#34;1111&#34;; System.out.println(&#34;具体装饰对象A的操作&#34;); } } public class ConcreteDecoratorB extends Decorator { @Override public void operation() { // 先执行Component的operation()，在执行装饰对象B的增强操作 super.operation(); this.addBehavior(); System.out.println(&#34;具体装饰对象B的操作&#34;); } // 装饰对象B独有的增强操作 private void addBehavior() {} } public static void main(string[] args) { Component c = new ConcreteComponent(); ConcreteDecoratorA da = new ConcreteDecoratorA(); ConcreteDecoratorB db = new ConcreteDecoratorB(); da.setComponent(c); db.setComponent(da); db.operation(); } } 通过具体的装饰类之间的注入决定了装饰类的执行顺序。
</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 结构型-装饰器模式" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">结构型-适配器模式
    </h2>
  </header>
  <div class="entry-content">
    <p>adapter模式是将一个接口转换成客户端希望的另外一个接口，使原来由于接口不兼容而不能一起工作的哪那些类可以一起工作。比如项目版本升级之后还想继续使用部分老本的接口，这两个接口可能规范和风格不一样。adapter概念源于电工学，最开始各个国家的民用电压不同，有的110v，有的220v，但是一些电器不是什么电压都能用的，比如笔记本，所以电源适配器就出来了。
adapter模式分为类适配器和对象适配器，类适配器主要是通过多继承，但是java不支持多继承，所以平时用的都是对象适配器模式：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * 客户端期待的接口 */ public class Target { public void request() { // 普通请求 } } /** * 需要被适配的接口 */ public class Adaptee { public void specificRequest() { // 特殊请求 } } /** * 新版本接口 */ public class Adapter extends Target { private Adaptee adaptee; public void request() { // 把调用request的方法改成实际调用specificRequest adaptee.specificRequest(); } } /** * 客户端代码 */ public static void main(String[] args) { Target target = new Adapter(); target.request(); } 一般就是controller层分为面向app、面向h5、面向web的，通过适配调用同一个应用服务。其他情况最好是优先考虑重构接口，统一风格，避免问题扩大，不到万不得已不用adapter。
</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 结构型-适配器模式" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/posts/page/26/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:1313/posts/page/28/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">王小红的笔记</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
