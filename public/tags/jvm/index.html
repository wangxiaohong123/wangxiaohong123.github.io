<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JVM | 王小红的笔记</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/tags/jvm/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/tags/jvm/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/tags/jvm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wangxiaohong123.github.io/tags/jvm/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="JVM"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="JVM"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>JVM</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>jvm-5.常用工具</h2></header><div class=entry-content><p>这些工具都在java_home/bin目录下，主要分成3类：
商业授权工具：主要是JMC以及他要用到的JFR，用这个需要付费。 正式支持工具：长期支持，可能会因为版本、平台稍微不同，但是不会突然消失。 实验性工具：这些工具在说明中被声明成不支持并且是实验性质的，可能会转正也可能会消失。 jstat jstat是用来监视虚拟机各种运行状态信息的命令。命令格式是jstat [option] PID [interval[s|ms]] [count]。比如 jstat -gc 20420 1000 10 ：每过1s打印一次PID是20420的系统的gc信息，打印十次。
S0C： From Survivor区大小
S1C：To Survivor区大小
S0U：From Survivor区使用的内存大小
S1U：To Survivor区使用的内存大小
EC：Eden区大小
EU：Eden区使用的内存大小
OC：老年代大小
OU：老年代使用的内存大小
MC：元数据空间大小
MU：元数据空间使用大小
CCSC：压缩类空间大小
CCSU：压缩类空间使用内存大小
YGC：系统运行到现在yongGC的次数
YGCT：YGC的总耗时（秒）
FGC：系统运行到现在OldGC的次数
FGCT：FGC的总耗时（秒）
GCT：所有GC的总耗时（秒）
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 查看类加载、卸载、总空间以及装在消耗时间 jstat -class PID # 堆内存分析 jstat -gccapacity PID # 年轻代GC分析，这里的TT和MTT可以看到对象在年轻代存活的年龄和存活的最大年龄 jstat -gcnew PID # 年轻代内存分析 jstat -gcnewcapacity PID # 老年代GC分析 jstat -gcold PID # 老年代内存分析 jstat -gcoldcapacity PID # 元数据区内存分析 jstat -gcmetacapacity PID # 即时编译过的方法、耗时 jstat -compiler PID jmap 主要就是用来生成堆的快照。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to jvm-5.常用工具" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/jvm/5.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>jvm-6.类文件结构</h2></header><div class=entry-content><p>编译的结果是字节码而不是机器码实现了“一次编写，到处运行”，而且语言无关性也越来越被重视，设计java的时候就是这么考虑的，所以把Java的规范拆分成《Java语言规范》和《Java虚拟机规范》，2018年graalVM公开之后基本上实现了语言无关性，目前运行在java虚拟机上的语言有Kotlin、Groovy、JRuby、JPython、Scala等等。
实现平台、语言无关的关键就是虚拟机和编译之后的字节码(就是class文件)，比如javac把java程序编译成class文件、jrubyc把jruby程序编译成class文件。
class文件结构 class文件中只有两种数据格式，无符号数和表：
无符号数是基本数据类型，u1、u2、u4、u8分别代表1个字节、2个字节、4个字节和8个字节，无符号数用来描述数字、引用或者字符串； 表：表就是多个无符号数或者其他表组成的复合数据类型，一般表都以_info结尾，整个class其实就是一张表。 class中的数据项严格按顺序紧凑的排列，没有任何分隔符，如果一个变量需要占用1个字节以上的空间时，按照高位在前的方式分割成多个字节，比如u2类型正常的顺序是11100111 00000001，在class文件中就应该是00000001 11100111。不管是表还是符号，在描述同一个类型但是数量不确定的时候都在前面定义一个变量标记这个同类型的若干个变量的数量，class表中各个数据项：
名称 类型 数量 magic(魔数) u4 1 minor_version(次版本) u2 1 major_version(主版本) u2 1 constant_pool_count u2 1 constant_pool(常量池) cp_info constant_pool_count - 1 access_flags(访问标志) u2 1 this_class(类索引) u2 1 super_class(父类索引) u2 1 interfaces_count u2 1 interfaces(接口索引集合) u2 interfaces_count fields_count u2 1 fields(字段表集合) field_info fields_count methods_count u2 1 methods(方法表集合) method_info methods_count attributes_count u2 1 attributes(属性表集合) attribute_info attributes_count 1.魔数 每个class的头4个字节是魔数，他的作用是确定这个文件能不能被虚拟机接受，class的文件魔数的16进制是0xCAFEBABE(咖啡宝贝)，大部分文件都有魔数，比如图片。
2.版本 魔数后4个字节是版本，第5、6个字节是次版本，次版本号是65535时表示技术预览版功能特性，这样虚拟机在加载类文件的时候能够区分出来。
主版本从45开始，之后每个大版本号递增，比如JDK13的主版本号就是57。《Java虚拟机规范》要求虚拟机必须拒绝执行超过其主版本号的class文件，就是说JDK7不能执行JDK8编译之后的class。
3.常量池 主版本号后面紧跟着常量池，由于常量池中元素个数不确定所以在入口放了一个u2的数据表示常量池容量，class中只有这个集合类型的索引是从1开始的，比如constant_pool_count是22，那么常量池的数量就是21，设计的时候考虑到常量池的0有特殊意义。
常量池中的常量分成两类，一类是字面量，类似于Java里的常量，比如字符串、final修饰的变量等，另一类是符号引用，符号引用包括下面几类：
...</p></div><footer class=entry-footer>3 min</footer><a class=entry-link aria-label="post link to jvm-6.类文件结构" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/jvm/6.%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>jvm-7.类加载机制</h2></header><div class=entry-content><p>生命周期： 加载：通过虚拟机内置的类加载器或者自定义的类加载器(重写一个类加载器的findClass或者loadClass方法)把字节流加载到内存中。这个阶段干3件事：
1.通过类的全限定名获取定义这个类的二进制字节流，这个阶段是扩展性最强的阶段，很多技术都建立在这个阶段，比如从jar包或者war包读取二进制、从网络中读取、动态代理的运行时计算生成、其他文件生成，比如jsp、从加密文件中获取，反编译的保护措施； 把字节流转换成方法区需要的存储结构； 在堆中生成一个代表这个类的对象(Class对象)，作为这个类的数据访问入口； 验证：java本身是相对C更安全的语言，如果访问数组边界外的数据、类型转换错误这种编译的时候就会报错，但是class文件不一定只能由源码编译而来，比如直接篡改class文件，所以在加载到内存中之后还需要在校验一下，大概就是验证文件格式、元数据、语法、符号引用这些。文件格式验证和加载是交叉进行的，就是说加载的时候会把一部分已经加载的二进制先拿去验证文件格式；
准备：这个阶段会把类中定义的静态变量分配内存并设置初始值，这写变量在JDK7之后会随着class对象一起放在堆中，因为hotspot没有方法区的物理分区，这个阶段不会给实例变量分配内存，实例对象会在实例化的时候分配，基础数据类型除了boolean的初始值都是0，boolean的初始值是false，reference是null。如果静态变量被final修饰，不会赋值初始值，直接赋真实值，因为final修饰的变量编译的时候属性表会生成ConstantValue属性，而没有final修饰的静态变量编译时把赋值操作放到了编译器生成的构造方法中；
解析：把符号引用替换为直接引用，符号引用就是描述目标的一个字符串，直接引用才是指向内存地址的指针或者句柄，针对的是类或者接口、字段、方法。什么时候解析并没有明确的规定，虚拟机可以在准备之后就解析，也可以在遇见getfield、instanceof这些指令时在解析；
初始化：验证、准备、解析都是虚拟机主导的，没有扩展的空间，初始化才会执行类中的程序代码。说白了这步就是执行类的clinit方法，他和构造方法不一样，他不需要显示调用父类clinit方法，虚拟机会保证父类clinit方法先执行，也就是说第一个被执行的clinit方法一定是Object，clinit方法是由编译器根据变量的赋值、静态代码块操作合并生成的；
使用；
卸载；
验证、准备解析合到一起叫做链接(Linking)，其中加载、验证、准备、初始化的顺序是确定的，也就是初始化完毕，一定是加载、验证、准备好了的，但是不一定会解析，某些情况下解析会出现在初始化阶段之后，这么做是为了动态绑定。前5个步骤叫做类加载过程。
《Java虚拟机规范》没有约束什么时候需要加载，但是他规定了有6中情况必须要初始化(那么加载、验证、准备自然需要再次之前开始)：
遇到new、getstatic、putstatic、invokestatic四条字节码指令时如果类没有初始化，需要初始化，比如使用new关键字实例化对象、读取或者设置非final修饰的字段、调用静态方法； 使用reflect包的方法进行反射调用的时候，如果类没有初始化； 初始化类时，如果父类没有初始化，需要先初始化父类。但是接口不需要，接口是在用到父类的时候才会进行初始化； 虚拟机启动的时候虚拟机会初始化用户指定的主类； 使用jdk7新加入的动态语言支持时，如果MethodHandle实例最后的解析结果是RES_getStatic、RES_putstatic、RES_invokestatic、RES_newinvokespecial四种类型的方法句柄、并且这个方法句柄对应的类没有初始化； 使用了jdk8新加入的default修饰的接口，如果实现类发生了初始化，那么接口需要在实现类之前被初始化； 只有这6中情况会导致类的初始化，叫做主动引用。其余情况不会类的初始化叫被动引用，被动引用举例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class SuperClass { static { System.out.println("SuperClass init"); } public staic int value = 123; } public class SubClass extends SuperClass { static { System.out.println("SubClass init"); } public static final String HELLOWORLD = "hello world"; } public static void main(String[] args) { // 被动引用：通过子类引用父类的静态字段 System.out.println(SubClass.value); // 被动引用：通过数组定义引用类 SuperClass[] sca = new SuperClass[10]; // 被动引用：通过类引用类的常量，因为常量在类的常量池中，可以直接拿出来 // 这里有个概念叫常量传播优化，编译的时候会把SubClass.HELLOWORLD的值存储到引用这个变量的常量池中 System.out.println(SubClass.HELLOWORLD); } 类加载器： 根据全限定名获取描述该类的二进制字节流的代码叫做类加载器。对于任何一个类，必须要由加载他的类加载器和类本身才能确定唯一性，也就是说equals、isAssignableFrom、instanceof这些方法比较的结果。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to jvm-7.类加载机制" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/jvm/7.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>jvm-8.即时编译器</h2></header><div class=entry-content><p>Java程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或者代码块运行的特别频繁，就会把这些代码认定为热点代码，为了提高热点代码的执行效率，虚拟机会把热点代码编译为本地机器码，并且尽可能的进行优化，完成这个任务的编译器被称为即时编译器。
HotSpot虚拟机内置了2、3个即时编译器，时间最久的两个是客户端编译器(Client Complier)和服务端编译器(Server Complier)，也被简称为C1、C2，第三个是Java10出现的为了代替C2的Graal编译器，目前还在实验阶段。
分层编译 在分层编译模式出现之前，HotSpot虚拟机采用解释器和即时编译搭配的工作方式，使用哪个即时编译器取决于虚拟机运行的模式，HotSpot会根据宿主机器硬件性能和自身版本选择合适的运行模式，也可以使用**-server或者-client参数强制指定虚拟机运行在客户端模式还是服务端模式。默认情况下虚拟机采用混合模式(Mixed Mode)，可以使用-Xint强制虚拟机运行于解释模式，这个时候即时编译器完全不介入，或者使用-Xcomp**强制虚拟机运行于编译模式，这个时候就优先使用编译器方式运行，编译器无法运行的时候解释器才介入。
因为即时编译编译代码需要占用程序运行时间，尤其是优化部分，优化的成都越高，花的时间就越长，而且解释器还要替编译器收集监控信息，为了平衡运行效率和启动响应速度，JDK7之后出现了分层编译策略，并且作为默认的编译策略：
0层：纯解释执行，并且不需要开启监控。 1层：使用客户端将字节码编译成本地机器码，不需要开启监控。 2层：使用客户端编译器，仅开启方法、回边(从方法边界往回跳转)次数统计等监控。 3层：使用客户端编译器，开启全部统计，比如分支跳转。 4层：使用服务端编译器。 具体使用多少层也是虚拟机自己决定的。
编译触发条件 热点代码主要分成两类，这两类编译的对象都是整个方法体：
被多次调用的方法 被多次执行的循环体 1.栈上替换 统计循环体的调用次数时，由于统计的是方法内的代码块，所以要在方法的执行过程中进行统计，如果发现调用次数达到热点的阈值就会进行及时编译，但是编译的对象是整个方法，所以这种情况可能会导致方法的栈针还在栈上就被替换了。
2.热点探测判定方式 热点探测就是判定代码是不是需要触发即时编译，进行热点探测有两种方式：
采样热点探测：虚拟机周期性的检查所有线程的调用栈顶，如果发现某个方法经常出现在这个栈顶，那这个方法就是热点方法，这样做就是效率高，但是不准，比如线程阻塞就会影响判断。 计数器的热点探测：虚拟机为每个方法甚至是代码块建立计数器，统计代码执行次数，这种方式更准但是实现麻烦。 J9使用的是采样，HotSpot使用的是计数器。使用参数**-XX:CompileThreshold**设置方法计数器的阈值，默认客户端是1500次，服务端10000次，当方法被调用的时候虚拟机先检查这个方法有没有被即时编译过，如果没有，方法的计数器+1，如果方法的调用+回边次数达到阈值就交给即时编译器编译，即时编译是异步的，这个时候还是会解释执行，当即时编译结束后会把方法的入口地址替换。
统计的方法被调用次数并不是绝对的，统计的是某个时间段内的，如果超过了时间限度，调用次数会减半，这个过程成为计数器的热度衰减，这段时间成为半衰周期，热度衰减的动作是在垃圾回收时顺便进行的。使用**-XX:UseCounterDecay关闭热度衰减，还可以使用-XX:CounterHalfLifeTime**设置半衰周期，单位是s。
回边的热点探测和方法的差不多，他计算阈值的方式更复杂，而且当回边计数器达到阈值时，会把方法计数器的统计数量也改成移出状态，其他的都差不多。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to jvm-8.即时编译器" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/jvm/8.%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>jvm-9.arthas</h2></header><div class=entry-content><p>1.定位 他的定位是监控、排查故障以及性能优化。
2.用法 a.启动 启动方式有两种，第一种下载jar包[https://arthas.aliyun.com/arthas-boot.jar]，下载完直接使用jar包的方式启动：
1 2 3 4 # telnet-port 指定arthas监听的telnet端口，用来和arthas shell通信 # -1表示不监听，0表示随机 # 相关配置在arthas.properties里 java -jar arthas-boot.jar --telnet-port 4659 &lt;pid> 启动之后可以看到监听端口
第二种下载arthas远程客户端(启动远程客户端需要先安装telnet)
1 2 3 4 curl -L https://arthas.aliyun.com/install.sh | sh # 启动并指定监听进程的ip和端口，这里设置的是Web Console页面的ip和端口 ./as.sh --target-ip 127.0.0.1 --target-port 8888 &lt;pid> 不管哪种方式启动，如果启动时没有指定进程id，会列出所有java进程：
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to jvm-9.arthas" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/jvm/9.arthas/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>jvm-java历史</h2></header><div class=entry-content><p>从业务领域划分java，可以分成4部分：
java card：支持在小内存设备上运行的小程序； java ME：支持在手机、PDA等终端上运行的移动程序，之前叫J2ME，提供部分java API； java SE：在桌面运行的程序，之前叫J2SE，提供完整的java API； java EE：支持多层架构的企业应用(比如ERP)，之前叫J2EE，他是在java SE的基础上做了大量的补充和一些部署支持； java SE的核心api都是以java.*开头，java EE的扩展之前以javax.*开头，后来一些扩展也进入了核心包，所以核心包也有部分api是以javax开头的。
JDK发展史 1991年4月James Gosling启动了绿色计划，这个计划最开始是要开发一个在电子产品(机顶盒、冰箱等)上通用的架构，产品叫Oak，就是Java的前身，但是在市场上并没有普及，1995年Oak改名叫Java，在SunWorld大会上发布Java1.0，并且提出Write One，Run Anywhere的口号，1996年1月的时候JDK1.0发布，这个时候Java才有了第一个正式版本的运行环境，这个时候JDK里面只有一个纯解释执行的虚拟机(Sun Classic VM)。
到1996年4月就有8万多网站使用java实现，在同年5月底Sun在旧金山举行第一次JavaOne大会，从此javaOne成为全世界数百万的Java工程师每年一度的技术盛会。
97年2月JDK1.1发布，增加JDBC、RMI、JavaBeans，还有一些语法比如内部类、反射等。
98年12月JDK1.2发布，这是个里程碑的版本，在这个版本中Java体系分成3个方向，J2ME、J2SE和J2EE。也是在这个版本中第一次内置了JIT编译器，这个版本里并存了3个虚拟机，classic VM、HotSpot VM和Exact VM，后两个虚拟机内置JIT，classic VM需要外挂。Collections集合类也是在这个版本发布的。
HotSpot是一家Longview Technologies的小公司开发，97年被Sun收购，HotSpot是从1.3之后版本的默认虚拟机。
2000年JDK1.3发布，这个版本更新的较少，都是一些类库比如Timer API，更多的的是改进Java 2D，但是从1.3开始Sun保持每2年更新一个JDK主版本，以动物命名，小的修复版本用昆虫命名。
2002年JDK1.4版本发布，这个是java真正走向成熟的版本，新增了很多特性，比如正则、异常链、NIO、日之类、XML解析器等。很多公司都有参与或者自己实现的独立的JDK1.4版本，比如IBM。现在也有很多的应用框架比如Spring、status可以运行在1.4上。2002年.Net发布了。
2004年JDK1.5版本发布，这个版本在语法的易用性上有了很大的改进，比如泛型、动态注解、可变长参数等。这个版本还改进了内存模型，提供了并发包。
2006年JDK1.6版本发布，这个版本取消了J2EE这种命名，改成Java EE6。这个版本对虚拟机做了大量改进，比如锁与同步、垃圾回收、类加载等方面的算法。也是在06年11月的JavaOne大会上，Sun宣布将java开源，并建立Open JDK组织对源码进行独立管理。
JDK1.6发布后没有保持2年一个大版本的速度，直到09年才发布了JDK1.7，而且也不是完整的1.7，在1.7中一个规划了10个里程碑，计划在2010年9月结束，2009年2月只是第一个里程碑，但是Sun那两年过的贼差，导致1.7一直跳票，09年4月Oracle收购Sun，在Oracle收购Sun之后，大量裁剪1.7的预定目标，比如lambda、Jigsaw(虚拟机模块化支持)和Coin(语言细节进化)放到了1.8中，最后1.7就加了个G1(发布后一直是Experimental状态，直到2012年4月才转正)，又升级了下类加载架构。
现在只是Java的商标贵Oracle，java语言不属于任何公司，由JCP组织管理，但是JCP主要就是Sun公司领导的。也是从1.7开始JDK的发布一直在跳票。
虚拟机发展史 Classic VM是历史上第一个商用的java虚拟机，这个时候只能用纯解释器执行代码，如果要用JIT，需要外挂，但是编译器和解释器不能相互配合，意思是尽管使用了JIT，JIT需要对每行代码都进行编译，不管执行的频率是否有编译的价值，在加上需要考虑程序的响应时间，这写编译器不敢使用耗时过高的优化技术，所以这个时候使用了JIT但是效率也比C/C++慢很多，所以那时候都说Java慢。
在JDK1.2的时候发部过Exact VM，他提供了更准确的内存管理，比如内存地址是指针还是真正的变量，这样有利于GC，哪怕对象被移动也不应判断。但是他马上就被HotSpot取代了，在1.3的时候HotSpot变成了JDK的默认虚拟机，1.4的时候classic VM变成历史。
HotSpot VM通过执行计数器找出最具有编译价值的代码，通过JIT以方法为单位进行编译，如果一个方法被频繁调用或者方法中有效循环次数很多，就会触发标准编译和OSR(栈上替换)操作，通过编译器和解释器配合工作。
Oracle收购Sun和BEA公司之后打算把两家的虚拟机合并，既有JRockit的垃圾回收器又有HotSpot的JIT和混合时的运行系统。
Sun公司的其他虚拟机：
KVM：强调轻量、简单、高度可移植，之前在手机平台上使用。 CDC/CLDC HotSpot Implementation：他是运行Java ME的。 Squawk VM：之前用在Java Card上。 JavaInJava：这是个实验的虚拟机。 MaxIne VM：不了解。 和HotSpot类似的虚拟机还有BEA的JRockit VM和IBM的J9 VM。
Apache的Harmony不能叫java虚拟机，因为他没通过TCK认证(如果一个公司要求自己的运行平台兼容java语言就必须通过TCK认证)，但是Sun不给Apache认证，后来Apache一生气就退出JCP了，在加上Open JDK的诞生，导致IBM也抛弃Apache加入OpenJDK的开发，虽然Harmony没有被商业使用，但是他的很多代码被引到了INM的JDK7和Google的Android SDK中，Android燃Java真正走进了移动设备领域，只是不是Sun计划的Java ME那条路。Android用的是Dalvik VM，他不是一个Java虚拟机，没有遵守java虚拟机规范，所以他不能执行class文件，而且是基于寄存器而不是栈架构，但是class文件可以转成dex文件被Dalvik执行，也兼容大部分的Java API，后来Android自己也出了个即时编译器。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to jvm-java历史" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/jvm/1.java%E5%8E%86%E5%8F%B2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>jvm-内存区域</h2></header><div class=entry-content><p>Java虚拟机规范规定jvm运行时数据区应该包括方法区、堆、虚拟机栈、本地方法栈、程序计数器。其中程序计数器、虚拟机栈和本地方法栈是线程私有的，堆和方法区是所有线程共享的。
内存区域 1 程序计数器 他是当前线程执行的字节码行号指示器，占用内存较小，字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令，比如分支、循环、跳转、异常都需要这个计数器来完成。在单核CPU进行多线程切换时，在切换后需要恢复到正确的执行位置也要依赖这个计数器。
如果执行的是java方法，计数器记录的是正在执行的虚拟机字节码指令的地址，如果是本地方法(Native)，计数器的值就是空，所以我猜执行本地方法的时候不能进行线程切换。程序计数器是唯一一个没有OOM情况的区域。
2 虚拟机栈 虚拟机栈是描述java方法执行的线程内存模型，每个方法执行的时候会创建一个栈针，栈针用来存储局部变量表、操作数栈、动态连接、方法出口等信息，每个方法从被调用到执行完毕的过程对应着一个栈针的入栈到出栈的过程。大部分情况下说得jvm中的栈指的是虚拟机栈中的栈针的局部变量表。
局部变量表里放的是编译期间可知的各种基础数据类型、对象引用(对象引用并不是对象本身，可能是一个指向对象起始地址的指针，也可能是指向一个代表对象句柄或者其他和这个对象相关的位置)和returnAddress类型(指向一条字节码指令的地址)。
这些对象在局部变量表中以局部变量槽(slot)来表示，64位长度的long和double占用两个槽，其他的占用1个槽。所以当进去方法时，需要创建多大的局部变量表是确定的了。
如果线程请求的栈深度超过虚拟机允许的深度会抛出StackOverflowError；当虚拟机栈容量可以扩展时，只会出现扩展到无法申请内存，然后抛出OutOfMemoryError异常，HotSpot虚拟机是不能扩展虚拟机栈的，所以不会因为虚拟机栈无法扩展导致OOM。
3 本地方法栈 本地方法栈和虚拟栈的作用非常相似，虚拟机栈执行的是java方法，也就是字节码服务，本地方法栈执行的是本地Native方法，而且在《java虚拟机规范》中没有强制规定本地方法栈的语言、使用方式、数据结构等，所以每个虚拟机实现的方式都不一样，比如Hot Spot中把虚拟机栈和本地方法栈合二为一了。
4 堆 堆是所有线程共享的空间，堆里面也有一些线程私有的分配缓冲区(Thread Local Allocation Buffer，TLAB)，这个区域是为了对象分配的效率，在高并发的情况下分配堆内存可能会出现两个对象被分配到了同一块内存，解决这个问题有两种方案：一种是CAS不断重试，另外一种就是TLAB，具体那种方案通过**-XX:+/-UseTLAB**参数决定。
堆内存的年轻代、老年代、Eden区……这种分代设计时为了让新生代、老年代收集器搭配工作设计的，但是随着G1的出现之后，这种对于堆的说法仅限分代收集器了。
堆中存放了几乎所有的对象实例，为什么是几乎？不管以后有没有值类型，就现在来说栈上分配、标量替换让对象都在堆中分配变得不是那么绝对了。主流的虚拟机的栈内存都是可扩展的，就是设置-Xmx和-Xms参数，并且堆可以在不连续的内存空间中，但是对于大对象，为了存储高效可能要求连续的内存空间。
5 方法区 方法区也是线程共享的内存区域，它存储的是被虚拟机加载的类型信息、常量、静态常量、即时编译器编译后的代码缓存，《Java虚拟机规范》中把方法区描述成堆的一个逻辑部分，但是他又有个别名叫“非堆(Non-Heap)”，目的是和堆区分开。
永久代和方法区并不是等价的，在Java8之前，HotSpot的设计团队把收集器的分代设计扩展到了方法区，从而出现了永久代这个概念，新生代、老年代、永久代听起来是不是很顺耳，可以说在Java8之前，HotSpot虚拟机使用永久代来实现方法区，目的就是方便管理方法区的内存。
因为永久代的内存是有上限(-XX:MaxPermSize)的，这就导致了HotSpot要比JRockit更容易内存溢出，当时Oracle收购BEA之后想把JRockit和HotSpot合二为一但是因为他俩对方法区的实现差太多了，所以合并失败。
在JDK7的时候，HotSpot把原来永久代中的常量池、静态变量等放到了堆中，到了JDK8，HotSpot彻底放弃永久代，采用在本地内存中实现的元数据空间(Meta-space)来代替，把JDK7剩下的类型信息放到元空间中。方法区也会抛出OOM。
6 运行时常量池 他其实是方法区的一部分，因为它存在于class文件中以常量池表的方式，class文件除了常量池表还有版本、字段、方法、接口描述等信息。常量池表存储的是编译时期生成的字面量和符号引用，在类加载后放到方法区的运行时常量池中，运行时常量池中是具有动态性的，就是说运行期间可以加入新的常量，比如String的intern()方法。会抛出OOM。
7 直接内存 直接内存并不是jvm运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，在JDK1.4的时候加入了NIO，他是基于通道(channel)和缓冲区(buffer)的I/O方式，直接调用Native函数分配堆外内存，然后在堆内存中有一个DirectByteBuffer对象引用这个堆外内存，这样可以避免Native内存和Java堆之间来回复制对象。它主要是收到本机总内存(物理内存、SWAP分区等)的影响也会抛出OOM。
OOM 元数据空间OOM 正常生产环境的元数据空间配置128m或者256m就够用了，如果运行一段时间后元数据空间导致的OOM，原因就是不断的创建类，导致fullGC也无法回收掉动态创建的类，所以使用动态代理模拟元数据空间OOM：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class OomMat { public static void main(String[] args){ long counter = 0; while(true){ Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(Car.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() { public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { if(method.getName().equals("run")){ System.out.println("汽车启动前检查"); return methodProxy.invokeSuper(o, objects); }else{ return methodProxy.invokeSuper(o, objects); } } }); Car car = (Car)enhancer.create(); car.run(); System.out.println("目前创建了" + (++counter) + "个Car的子类"); } } static class Car { public void run(){ System.out.println("汽车启动，开始行使……"); } } static class SafeCar extends Car { @Override public void run(){ System.out.println("汽车启动，开始行使……"); super.run(); } } } 代码中使用无线循环创建Car的子类，jvm进程分配10m应该很快就会发生OOM，jvm参数：
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to jvm-内存区域" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/jvm/2.%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>jvm-垃圾回收器和内存分配</h2></header><div class=entry-content><p>本地方法栈、虚拟机栈和程序计数器会随着线程结束被回收，因为栈针需要多大的内存是确定的，而方法区和堆就有非常多的不确定性，比如一个接口的多个实现类需要的内存是不一样的，同一个方法进入不同分支需要的内存也不一样，所以这两个区域的内存分配和回收时动态的，也是垃圾回收负责的地方。
对象存活判断 很多人说Java虚拟机里使用引用计数算法判断对象是否存活，比如对象中有一个引用计数器，被引用的时候就+1，引用失效的时候就-1，引用计数算法虽然需要花费额外的内存，但是他简单且高效，Python好像用的是这个，不过主流的Java虚拟机没有使用这个算法而是使用可达性分析来确定对象是否存活，因为引用计数看起来很简单，却需要考虑很多情况，必须要做大量的额外处理，比如两个对象的循环引用，其实两个对象都是死去的对象，但是他们的引用计数都不是0，所以不会被回收，一直占着内存。
可达性分析就是先选出一堆GC Root，从这些节点开始根据引用关系向下搜索，搜索过程中走过的路径叫引用链，那么如果一个对象和GC Root之间没有引用链，这个对象就是死去的对象，可以被回收。下面是可以当做GC Root的变量：
虚拟机栈针中本地变量表的引用对象，可以理解成当前运行方法中的入参、局部变量和临时变量 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI(就是Native中的方法)引用的对象 虚拟机内部引用，比如基本数据类型对应的Class对象、一些常驻异常对象(NullPointException)等 被同步锁持有的对象 JMXBean、JVMTI、本地代码缓存等 根据垃圾收集器和当前回收区域的不同还有其他对象临时加入GC Roots 标记为不可达对象后并不会马上进行回收，如果不可达的对象没有重写finalize方法或者这个对象的finalize方法已经被执行过了，就等着被回收，相反就把他放进一个F-Queue队列中，然后会有一个低优先级的Finalizer线程去遍历F-Queue中的对象并执行里面的finalize方法，想要不被回收可以在finalize方法中引用GC Root对象，注意每个对象的finalize方法在生命周期中只会被调用1次。官方已经不推荐重写finalize方法了，因为它运行代价高，而且不能保证对象的调用顺序。
经典回收器： 经典说的是JDK7 update4以前出现的回收器，而在这之后的回收器有着高性能低延迟的革命性改进。分代回收器都是遵循分带理论的：
绝大多数的对象都是朝生夕灭的 熬过越多次数的垃圾收集的对象就越难以消亡 因为这个理论出现了年轻代、老年代的划分，以及发展出了标记-复制算法、标记-清除算法、标记-整理算法。这种分代回收是有问题的，比如说对象之间会存在跨代引用的关系，这就让我们在回收年轻代的时候不得不去遍历老年代的对象，看看是否存在和老年代中的GCRoot有引用链关系的对象，为了解决扫描对象太多的问题在年轻代中维护了一个记忆集的东西，记录老年代中那些内存存在跨代引用，这样是减少了扫描，但是增加了运行时的开销。
1.Serial serial的单线程不仅是使用1个处理器或者1个线程执行垃圾回收工作，最重要的是强调他在回收的时候需要Stop The Word，他的优点就是简单且高效，大部分的系统已经不用这个收集器了，但是目前他还是HotSpot的默认回收器，他在小内存比如桌面应用上回收效率极高，因为没有线程切换的花销。
2.ParNew ParNew是Serial的多线程版本，他俩的区别也只有线程数，像控制参数(-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等)、回收策略、算法、对象分配规则都完全一样。单核服务器下他是没有Serial好用的，可以使用-XX:ParallelGCThreads调整垃圾收集的线程数，默认是处理器核心数。目前只有ParNew和Serial能和CMS配合使用，因为其他收集器没有分代框架。在JDK9之后去掉了-XX:+UseParNewGC参数，可以理解成ParNew合并到了CMS中。
3.Parallel Scavenge（吞吐量优先收集器） 他也是使用标记-复制算法，也是年轻代的垃圾收集器，和ParNew不同的是他可以控制运行业务代码的吞吐量，吞吐量的公式：
$吞吐量=\frac{运行业务代码时间}{运行业务代码时间 + 运行垃圾收集时间}$
-XX:MaxGCPauseMillis参数要求是大于0的毫秒数，收集器会尽量保证收集的时间小于这个设定值，这个值直接影响回收频率。
-XX:GCTimeRatio参数要求正整数，表示期望虚拟机在GC上消耗的时间不超过程序运行时间的1/(1+n)，默认是99，意思就是垃圾收集器运行的时间不超过总运行时间的1%，也就是程序执行时间是垃圾回收执行之间的99倍以上。
-XX:+UseAdaptiveSizePolicy，他是个开关，如果打开就不需要手动设置-Xmn、E区和S区的比例、晋升老年代对象大小等等，虚拟机会根据当前运行情况的性能监控信息动态调整。
4.Serial Old 使用标记-整理算法，JDK5之前和Parallel Scavenge配合使用，目前应该是CMS失败的降级方案。
5.Parallel Old 他是Parallel Scavenge的老年代版本，因为在JDK6之前Parallel Scavenge只能搭配Serial Old，这个非常慢，所以JDK6出了Parallel Old，他也使用的标记-整理算法。
6.CMS CMS是获取最短回收停顿时间的回收器，他默认基于标记-整理算法，如果指定了CMS收集器(-XX:+UseConcMarkSweepGC)新生代收集器会默认选择ParNew。整个过程分成4步：
初始标记：标记被gc root直接关联的对象，这步会有stw，但是很快； 并发标记：和系统并行，从上一步标记的对象中开始遍历进行标记所有垃圾对象，因为系统也在运行，所以可能有新对象进来，或者标记过的对象变化了，CMS都会记录，这步是最慢的，而且会占用CPU，使用线程数计算公式：(核数 + 3)/4； 重新标记：把第二阶段变化的对象通过可达性分析标记成垃圾对象，会有stw，但是也很快； 并发清除：和系统并行，清除垃圾对象； CMS的缺点非常多，由于并发时使用的线程数是(核数 + 3)/4，所以核数越少，占用的资源就越多，比如4核就要占用25%的资源；而且他没有办法处理浮动垃圾，浮动垃圾就是在回收时产生的垃圾，虽然在并发清除前还要在标记一次，但是并发清除时产生的垃圾没有办法回收，所以使用CMS的堆不能等到内存满了在回收，可以通过**-XX:CMSInitiatingOccupancyFraction=92**参数调整使用内存达到某个百分比时进行GC，这个参数如果设置的越大就越容易导致并发失败。如果在垃圾回收时内存满了会导致并发失败，系统会自动切换成Serial Old回收器，这个时候就要stw了；
最后一个缺点就是他的算法，默认是标记-整理，因为有个参数**-XX:CMSFullGCsBeforeCompaction=5(JDK9之后废弃)来控制回收几次后进行整理，默认是0，如果设置的参数大于0那就是标记-清除算法了，标记-清除会有大量内存碎片，标记-整理又会增加停顿时间，还有个参数是-XX:+UseCMSCompactAtFullCollection(JDK9之后废弃)**，这个参数的意思是在FullGC时开启内存碎片的整理，因为需要移动存活对象，所以不能并发，他也会增加停顿时间。
7.G1回收器 G1最早在JDK6update14的时候开始进入实验阶段，JDK7update4的时候进行商用直到JDK8的update40G1完成了并发的类卸载的最后一块功能拼图，在JDK9之后被当做默认的垃圾回收器。
G1虽然也是遵循分代理论，但是没有年轻代和老年代的界限，所有对象都放到一起，还多了一个大对象(Humongous)区域(只要超过了region的一半就算大对象)。region的大小通过**-XX:G1HeapRegionSize**参数决定，范围是1M~32M，且要是2的n次幂。
他只有两个回收情况，年轻代RegionGC和mixedGC，G1的垃圾回收算法都是使用复制清除算法，同样在年轻代中还是有两个survivor区的概念，只不过所有的区域都没有明显的划分。G1将堆内存划分为2048个region，默认初始会给年轻代5%个region，老年代0个，大数据也是0个，当年轻代的region数超过60%（默认）时进行一次regionGC，当老年代的region数超过45%（默认）时进行一次mixedGC，mixedGC包括老年代、年轻代和大数据区，G1的回收时的四个阶段：
初始标记：标记直接被gc root关联的对象，并且修改TAMS指针的值，这个也需要停顿，但是他是在MinorGC的时候同步完成的，不会有额外的停顿。 并发标记：遍历上一步标记出来的对象，找到满足回收条件的对象，扫描完成后还要处理SATB记录下的在并发时有引用变化的对象。 最终标记：std并且标记上一步遗留的SATB(原始快照)记录。 筛选回收：更新region的统计数据，对每个region的回收价值进行排序(能够回收多少空间和回收的时间)，根据用户期望的停顿时间制定回收计划，然后把选中要回收的region中存活对象复制到空region中，最后清空region。 G1是收集器技术的里程碑，从G1开始，收集器开始放弃每次回收整个堆，而是每次回收一小部分，只要保证回收的速度大于分配的速度就能让系统稳定运行。但是G1的记忆集、卡表这些指针会花费更多的内存。G1和CMS都是通过写屏障来维护卡表，但是CMS的卡表里只有和新生代有关联的对象，而G1维护的东西就多了，所以G1会更消耗资源。通常在小内存的时候CMS的性能要比G1好，6G或者8G以后使用G1要好。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to jvm-垃圾回收器和内存分配" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/jvm/4.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>jvm-对象的创建和布局</h2></header><div class=entry-content><p>对象的创建包括new关键字、复制、反序列化等等。
new关键字对象的创建 第1步 类加载 这里的new关键字不包括数组和Class对象，当虚拟机遇到一条字节码new指令时，首先会根据关键字的参数去常量池中找这个类的符号引用，然后在检查这个符号引用的类是否已经被加载、解析和初始化过，如果没有就先进行类加载。
第2步 分配内存 类加载完之后需要多大的内存就可以确定了，这个时候就要为对象分配内存，如果堆中的内存是规整的，所有用过的内存放到一边，没用过的在另一边，那么分配内存就是把指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式叫做指针碰撞(Bump The Pointer)；如果堆中的内存是不规整的，就必须要维护一个列表记录那些内存块是可用的，这种方式叫空闲列表(Free List)。
至于堆是否规整由垃圾回收器决定，比如ParNew使用的就是指针碰撞，因为他在GC的时候有收集整理的能力，而CMS这种基于清除算法的收集器使用的就是空闲列表。
第3步 设置对象 分配完内存之后把分配到的内存空间都设置成0，如果使用了TLAB的话会在分配TLAB时设置，设置成0是为了保证对象中的变量不需要赋初始值就能直接使用。然后还有一堆设置，比如对象属于哪个类、类的元数据信息、GC的分带年龄等。
第4步 调用构造方法 这个时候一个对象就已经生成了，但是对于java程序来说，对象的创建才刚开始，还需要在调用对象的构造方法，也就是class文件中的init()方法，是否调用构造方法由字节码中的new指令后面是否有invokespecial指令决定，编译器在编译时遇到new关键字会自动生成这个指令，如果通过其他方式产生的对象不一定会有这个指令，调用完构造方法之后对象才算被完整的构造出来。
对象的内存布局 在HotSpot虚拟机里，对象的内存布局可以分成3部分：对象头、实例数据和对齐填充。
对象头 对象头分成两类：一类是存储运行时的数据，另一类是指向类型元数据的指针，运行时的元数据在32位和64位的虚拟机中分别占32和64比特，官方称他为Mark Word：
存储内容 标志位 状态 对象hash码、对象分代年龄 01 未锁定 指向锁记录的指针 00 轻量级锁定 指向重量级锁的指针 10 重量级锁定 空 11 GC标记 偏向线程ID、偏向时间戳、对象分代年龄 01 可偏向 对象运行时的数据有的已经超过了32或者64bit能记录的最大限度，所以Mark Word被设计成了一个动态定义的数据结构，比如32位的HotSpot虚拟机中，如果对象没有被同步锁锁定，32个bit中25个bit存储hash码，4个bit存储分代年龄，2bit存储锁标志位，还有1bit固定是0。
指向类型元数据的指针是为了判断对象是哪个类的实例，单并不是只能通过这个指针查找元数据信息，通过元数据信息还可以计算出对象的大小，因为数组的长度是不确定的，所以数组的对象头中需要记录数组的长度。
实例数据部分 这部分存储的是代码中定义的各种类型的字段内容，包括从父类继承下来的，longs/doubles->ints->shorts/chars->bytes/booleans->oops(Ordinary Object Pointers)，同时父类的long会出现在子类的long之前。可以通过**-XX:FieldsAllocationStyle调整顺序策略，如果配置了-XX:CompactFields=true**那么子类比较窄的变量会插到父类变量的空隙中来节约内存。
对齐填充 由于HotSpot要求对象的大小必须是8的整数倍，对象头已经是8的整数倍了，如果实例数据不是8的整数倍就需要通过对齐填充来补全。
对象的定位 对象主要通过栈上的reference数据来操作堆上的具体对象，但是reference指向有两种：
句柄池：在堆内存中需要一块单独的区域来当句柄池，句柄中包含的对象的类型数据和实例数据，reference如果存储的是对象的句柄地址，在定位对象的时候会先找到句柄，然后在去查找对象，这个样有个好处就是对象地址改变的时候只需要修改句柄中的实例数据指针，不需要修改所有对象的引用指针，坏处就是不好的地方就是多一次指针定位。 直接指针：reference中存储的就是对象地址，减少一次指针定位的开销，HotSpot主要是用的就是这种方式。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to jvm-对象的创建和布局" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/jvm/3.%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%B8%83%E5%B1%80/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JVM参数</h2></header><div class=entry-content><p>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 # 初始堆内存 -Xms512M # 最大堆内存 -Xmx512M # 初始年轻代内存 1.8:-XX:NewSize -Xmn256M # 1.8最大年轻代内存 -XX:MaxNewSize=256M # 虚拟机栈内存 -Xss1M # 初始元空间内存 -XX:MetaspaceSize=128M # 最大元空间内存 -XX:MaxMetaspaceSize=128M # 设置Eden区和两个survivor区比例，当前意思是7:1:1默认8:1:1 -XX:SurvivorRatio=7 # 配置年轻代对象躲过多少次minorGC后进入老年代，默认15次 -XX:MaxTenuringThreshold=10 # 超过多少字节的对象直接进入老年代 -XX:PretenureSizeThreshold=1048576 # 当年轻代所有对象大于老年代剩余空间时，判断之前每次进入老年代的对象大小如果都比老年代剩余内存小，就不进行老年代垃圾回收（fullGC），否则进行老年代垃圾回收 JDk1.6之后默认开启 -XX:-HandlePromotionFailure=true # 设置jvm对新生代GC的垃圾回收器为ParNew -XX:+UseParNewGC # 设置jvm对老年代GC的垃圾回收期为CMS -XX:+UseConcMarkSweepGC # cms初始标记阶段开启多线程执行 -XX:+CMSParallelInitialMarkEnabled # 在cms重新标记阶段之前执行一个yongGC -XX:+CMSScavengeBeforeRemark # 调节ParNew回收时使用的线程数（默认与CPU核数相同） -XX:ParallelGCThreads=4 # 当老年代剩余可用空间不足92%时，进行fullGC -XX:CMSInitiatingOccupancyFraction=92 # fullGC之后停止系统所有线程，进行老年代空间整理 -XX:+UseCMSCompactAtFullCollection # 每多少次fullGC之后进行一次空间整理 -XX:CMSFullGCsBeforeCompaction=5 ##################################G1相关################################## # 使用G1回收器 -XX:+UseG1GC # 设置为G1回收器时，新生代默认初始堆内存占比 -XX:G1NewSizePercent # -XX:G1HeapRegionSize # 新生代占比最多为 -XX:G1MaxNewSizePercent # G1回收时最多消耗时间 -XX:MaxGCPauseMills # 默认是45%，当老年代的region数超过总region数的45%，进行年轻代和老年代和大对象的混合垃圾回收 -XX:InitiatingHeapOccupancyPercent # 配置混合回收次数，默认8次 -XX:G1MixedGCCountTarget=8 # -XX:G1HeapWastePercent # region中的存活对象低于多少时才可以回收，默认是85% -XX:G1MixedGCLiveThresholdPercent ######################################################################## # 打印详细的gc日志 -XX:+PrintGCDetils # 打印出来每次GC发生的时间 -XX:+PrintGCTimeStamps # 设置将gc日志写入一个磁盘文件 -Xloggc:gc.log # 禁止显示执行GC System.gc() -XX:+DisableExplicitGC # 在OOM时生成快照文件 -XX:+HeapDumpOnOutOfMemoryError # 生成的OOM快照位置 -XX:HeapDumpPath=/usr/local/app/oom # 关闭锁粗化 -XX:-EliminateLocks # 堆外内存大小 -XX:MaxDirectMemorySize 查看服务启动参数：jps -lv
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to JVM参数" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/jvm/jvm%E5%8F%82%E6%95%B0/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>