<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>设计模式 | 王小红的笔记</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wangxiaohong123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="设计模式"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="设计模式"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>设计模式</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>创建型-单例模式</h2></header><div class=entry-content><p>什么时候用单例？
比如配置文件这种，存在一份就够了，每次使用都创建实例的话就会浪费资源；
或者一个操作文件的类，每次都创建一个实例去写文件在高并发的场景很可能会相互覆盖；
第二种情况使用分布式锁或者将写操作放到队列中排队消费，但是都很复杂，这些情况都可以使用单例很容易的解决。
我们实现的单例都是类加载器级别的单例，他的作用域介于线程和进程之间，因为java中确定类的唯一是通过类全名+类加载器实例。
饿汉单例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 饿汉是第二简单的实现方法，由于Singleton实例在类加载的时候就已经创建好了，所以是线程安全的 * 缺点就是不支持延迟加载 * 如果类的初始化耗时长还是应该使用这种方法，在用到的时候再去创建反倒会影响系统性能 * @author xiaohong */ public class Singleton { private Singleton() {} private static final Singleton instance = new Singleton(); public static Singleton getInstance() { return instance; } } 懒汉单例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * 懒汉单例也比较简单，并且可以支持延迟加载 * 但是getInstance()方法上有一把锁，这让这个函数的操作都会变成串行，在高并发的时候非常影响性能 * @author xiaohong */ public class Singleton { private Singleton(){} private static Singleton instance; public static synchronized Singleton getInstance() { if(instance == null){ instance = new Singleton(); } return instance; } } 双重检查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * 双重检查就是更细粒度的锁，提升了一点性能 * 网上有人说这种写法会发生指令重排，然后在创建完实例还没初始化（调用构造函数）的时候就会被别的线程使用了，需要加上volatile关键字禁止指令重排 * 其实在高版本java中已经解决了这个问题，在java中把new的操作和初始化的操作设计成立原子操作，不存在编译优化问题 * @author xiaohong */ public class Singleton { private Singleton(){} private static Singleton instance; public static Singleton getInstance() { if(instance == null){ synchronized(Singleton.class){ if(instance == null){ instance = new Singleton(); } } } return instance; } } 静态内部类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 主流的单例模式创建方法 * 由内部类实现，instance的唯一和线程安全都有jvm保证，还支持延迟加载 * @author xiaohong */ public class Singleton { private Singleton(){} private static class SingletonHolder { private static Singleton instance = new Singleton(); } public static Singleton getInstance() { return SingletonHolder.instance; } } 枚举类 查看JAD反编译之后的文件感觉枚举的单例和饿汉模式很像
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 创建型-单例模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>创建型-原型模式</h2></header><div class=entry-content><p>原型模式就是从一个对象创建另一个可定制的对象，而且不需要知道创建的细节。
如果只是申请内存然后再给变量赋值，使用clone的方法提升的性能是可以忽略不计的，但是我觉得如果这种操作很多，比如循环一万次，每次都要创建一个新的实例，这时候可以使用原型模式； 当创建对象的操作比较复杂的时候，比如需要操作数据库、文件、计算hash值等等，这时候使用拷贝的对象就比较快了； 实现原型模式的类要继承Cloneable接口，并重写clone方法，因为继承这个接口也不具备复制对象的能力，需要在重写的clone中调用super.clone()：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Student implements Cloneable { private String name; private Date birth; public String getName(){ return name; } public void setName(String name){ this.name= name; } public Date getBirth() { return birth; } public void setBirth(Date birth) { this.birth = birth; } /** * 重写clone方法 * @return */ @Override public Student clone(){ Student student = null; try{ // 调用Object的clone方法 student = (Student) super.clone(); student.birth = (Date) student.birth.clone(); }catch(CloneNotSupportedException e){ e.printStackTrace(); } return student; } } 使用时直接调用Student的clone方法：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 创建型-原型模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>创建型-工厂方法</h2></header><div class=entry-content><p>简单工厂的优点是工厂类中包含了必要的逻辑判断，根据条件动态实例化相关的类，对于客户端来说没有具体类的依赖。工厂方法和简单工厂的区别是工厂方法将类的实例化操作放在子类或者实现类中，而且对于简单工厂来说，说过添加子类需要增加工厂方法中的分支，这也违背了对扩展开放，对修改关闭原则，而且当一个类的创建过程有点复杂，创建这个类会产生大量的重复代码的时候可以提取到工厂方法中创建：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * 工厂方法抽象类 * 当创建类有公用的代码段时可以使用抽象类实现 * * @author xiaohong */ public abstract class FactoryMethod { /** * 创建类实例 * @return */ public abstract MainTestClass getMainTestClass(); } 1 2 3 4 5 6 7 8 9 10 /** * 工厂方法的一个子类 * @author xiaohong */ public class TestClass01FactoryMethod extends FactoryMethod { @Override public MainTestClass getMainTestClass() { return new TestClass01(); } } 测试：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 创建型-工厂方法" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>创建型-建造者模式</h2></header><div class=entry-content><p>建造者模式也叫生成器模式
建造者模式 当构造函数需要很多参数，直接调用很容易产生顺序问题； 构造函数参数多的问题可以使用set方法代替，但是如果很多参数需要联合校验，比如判断大小、多个内部属性需要计算赋值等，这时候使用set实现就很麻烦； 如果希望这个对象创建完之后属性不可变，使用set也无法实现； 这时就需要使用建造者模式，并且将构造函数私有化，这时候就只能使用内部的构建类创建对象。JDK中的StringBuilder和StringBuffer就是使用的建造者。
和工厂方法的区别 工厂模式是为了创建相关类型的对象（继承同一父类或者接口），建造者模式是定制化（根据参数的不同和顺序的不同）一个类。在建造者模式中创建的类的属性会在建造类中有一份一模一样的，这部分算是重复代码但是还不能去掉。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 /** * 建造者模式测试实体 * @author xiaohong */ public class Course { private Course(CourseBuilder courseBuilder) { this.courseName = courseBuilder.courseName; this.courseVideo = courseBuilder.courseVideo; this.courseArticle = courseBuilder.courseArticle; } private String courseName; private String courseVideo; private String courseArticle; public String getCourseName() { return courseName; } public void setCourseName(String courseName) { this.courseName = courseName; } public String getCourseVideo() { return courseVideo; } public void setCourseVideo(String courseVideo) { this.courseVideo = courseVideo; } public String getCourseArticle() { return courseArticle; } public void setCourseArticle(String courseArticle) { this.courseArticle = courseArticle; } @Override public String toString() { return "Course{" + "courseName='" + courseName + '\'' + ", courseVideo='" + courseVideo + '\'' + ", courseArticle='" + courseArticle + '\'' + '}'; } /* * 通过静态内部类实现链式调用 */ public static class CourseBuilder { private String courseName; private String courseVideo; private String courseArticle; public CourseBuilder buildCourseName(String courseName) { this.courseName = courseName; return this; } public CourseBuilder buildCourseVideo(String courseVideo) { this.courseVideo = courseVideo; return this; } public CourseBuilder buildCourseArticle(String courseArticle) { this.courseArticle = courseArticle; return this; } public Course build() { // 集中校验 if(StringUtils.isEmpty(courseName)){ throw new IllegalArgumentException("..."); } return new Course(this); } } } 把实体和构建类写到一起在以后维护时很方便，而且链式调用合一选择构建哪些属性和顺序，调用也很简单：
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 创建型-建造者模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>创建型-抽象工厂</h2></header><div class=entry-content><p>工厂方法针对的是产品的等级结构，而抽象工厂针对的是产品族，用来创建多个相关或相互依赖的对象。
产品等级：不同厂商的相同产品，比如鞋子，所有的厂商的鞋都属于同一等级，比如Nike的鞋，阿迪的鞋； 产品族：相同厂商的不同产品，比如Nike的鞋、Nike的书包属于同一产品族； 通过抽象工厂创建对象需要指定厂商和产品，因为这种情况使用工厂方法模式需要创建跟多的子类或者实现类：
代码就比工厂方法的子类或者实现类多了几个获取实例的方法。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 创建型-抽象工厂" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>创建型-简单工厂</h2></header><div class=entry-content><p>简单工厂并不是23种设计模式中的，在23中设计模式中，工厂只有两种模式：工厂方法模式和抽象工厂模式。
首先要有一个总的抽象类或者接口MainTestClass，然后利用简单工厂模式创建她的实现类，简单工厂代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * 简单工厂方法 * @author xiaohong */ public class SimpleFactory { /** * 静态方法，当没有继承的需求时比较好用 * @param c * @return */ public static MainTestClass getMainTestClass(Class c) { MainTestClass mainTestClass = null; try { // 根据传入方法的值使用if判断并创建不符合开闭原则，所以这里使用反射创建 mainTestClass = (MainTestClass) Class.forName(c.getName()).newInstance(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } return mainTestClass; } } 测试：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 创建型-简单工厂" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>结构型-享元模式</h2></header><div class=entry-content><p>就是缓存，把对象都存起来，以后用到的时候都是一个实例，需要注意一下并发安全。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public abstract class FlyWeight { public abstract void operation(int extrinsicstate); } public class ConcreteFlyWeight extends FlyWeight { @Override public void operation(int extrinsicstate) { System.out.printLn("具体FlyWeight:" + extrinsicstate); } } public class UnsharedConcreteFlyWeight extends FlyWeight { @Override public void operation(int extrinsicstate) { System.out.printLn("不共享的具体FlyWeight:" + extrinsicstate); } } public class FlyWeightFactory { private HashTable flyWeights = new HashTable(); public FlyWeightFactory() { // 什么时候初始化看情况， flyWeights.add("x", new ConcreteFlyWeight()); flyWeights.add("y", new ConcreteFlyWeight()); flyWeights.add("z", new ConcreteFlyWeight()); } public FlyWeight getFlyWeight(String key) { return (FlyWeight) flyWeights.get(key); } } public static void main(String[] args) { int extrinsicstate = 22; FlyWeightFactory f = new FlyWeightFactory(); FlyWeight fx = f.getFlyWeight("x"); fx.operation(--extrinsicstate); FlyWeight fy = f.getFlyWeight("y"); fx.operation(--extrinsicstate); FlyWeight uf = new UnsharedConcreteFlyWeight(); uf.operation(--extrinsicstate); }</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 结构型-享元模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>结构型-代理模式</h2></header><div class=entry-content><p>类图：
场景：
代理模式就是在访问对象时引入的间接性，因为这种间接性，可以附加很多用途。
增强方法，比如日志； mybatis或者hibernate的一对多关系实体中get关联的实体集合时会使用代理模式去数据库中查； http接口和rpc接口是被代理类代理的，我们直接调用接口就可以了； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public abstract class Subject { public abstract void request(); } public class RealSubject extends Subject { @Override public void request() { System.out.println("真实的请求"); } } public class Proxy extends Subject { private Subject subject; public Proxy(Subject subject) { this.subject = subject; } @Override public void request() { System.out.println("代理的请求"); subject.request(); } } public statis void main(string[] args) { Proxy proxy = new Proxy(new RealSubject()); proxy.request(); }</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 结构型-代理模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>结构型-桥接模式</h2></header><div class=entry-content><p>在面向对象的设计中有一个非常重要的原则，合成/聚合复用原则，就是优先使用对象合成或者聚合，尽量不要使用继承。因为继承关系在编译时就确定好了，子类和父类有非常紧密的联系，以至于父类实现中有任何改变必然会导致子类发生变化，这种依赖关系限制了灵活性和复用性。
合成(组合)和聚合都是一种特殊的关联关系，组合是强拥有，聚合时弱拥有。桥接模式就是将抽象部分和他的实现分离，使他们可以独立的变化。这里的抽象实现不是说抽象类的子类，而是用来实现抽象类的对象。在通俗点就是系统可能有多个角度的分类，每一种分类都可能有变化，就把多个角度抽离，让他们各自独立，比如手机品牌是抽象，手机软件是手机的实现，手机和软件就是聚合的关系。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /** * 实现 */ public abstract class Implementor { public abstract void operationImpl(); } public class ConcreteImplementorA extends Implementor { @Override public void operationImpl() { System.out.println("具体实现A的方法执行"); } } public class ConcreteImplementorB extends Implementor { @Override public void operationImpl() { System.out.println("具体实现B的方法执行"); } } public class Abstraction { protected Implementor implementor; public void setImplementor(Implementor implementor) { this.implementor = implementor; } public void operation() { implementor.operationImpl(); } } public class RefinedAbstraction extends Abstraction { @Override public void operation() { implementor.operationImpl(); } } public static void main(String[] args) { Abstraction ab = new RefinedAbstraction(); ab.setImplementor(new ConcreteImplementorA()); ab.operation(); ab.setImplementor(new ConcreteImplementorB()); ab.operation(); }</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 结构型-桥接模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>结构型-组合模式</h2></header><div class=entry-content><p>组合模式就是将对象组合成属性结构展示，让客户端对单个对象和组合对象的使用具有一致性。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 public abstract class Component { protected String name; public Component(String name) { this.name = name; } public abstract void add(Component c); public abstract void remove(Component c); public abstract void display(int depth); } /** * 组合中没有子节点的分支 */ public class Leaf extends Component { public Leaf(String name) { super(name); } @Override public void add(Component c) { System.out.println("当前节点不支持添加"); } @Override public void remove(Component c) { System.out.println("当前节点不支持删除"); } @Override public void display(int depth) { // 叶节点的具体方法 System.out.println(this.name + "-" + depth); } } /** * 组合中有子节点的分支 */ public class Composite extends Component { private List&lt;Component> children; public Leaf(String name) { super(name); children = new LinkedList&lt;>(); } @Override public void add(Component c) { children.add(c); } @Override public void remove(Component c) { children.remove(c); } @Override public void display(int depth) { // 叶节点的具体方法 System.out.println(this.name + "-" + depth); for (Component child : children) { child.display(depth + 1); } } } /** * 客户端 */ public static void main(String[] args) { Composite root = new Composite("root"); root.add(new Leaf("leaf a")); root.add(new Leaf("leaf b")); Composite compX = new Composite("compX"); compX.add(new Leaf("compX a")); compX.add(new Leaf("compX b")); root.add(compX); Composite compY = new Composite("compY"); compY.add(new Leaf("compY a")); compY.add(new Leaf("compY b")); root.add(compY); root.display(1); } 数可以有无数分支，只需要反复使用Composite就可以实现，上面的Component把所有管理子节点的方法全部声明成抽象的，让子类必须实现，这样叶节点和枝节点堆外没有区别，具有一致的行为，叫做透明方式，这样有个缺点就是叶节点实现了没有意义的接口。
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 结构型-组合模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://wangxiaohong123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>