<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>数据库 | 王小红的笔记</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css" integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="/katex/katex.min.css">
<script defer src="/katex/katex.min.js"></script>
<script defer src="/katex/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: "$$", right: "$$", display: true},
        {left: "$", right: "$", display: false},
        {left: "\\(", right: "\\)", display: false},
        {left: "\\[", right: "\\]", display: true}
      ]
    });
  });
</script>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="王小红的笔记 (Alt + H)">王小红的笔记</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="笔记">
                    <span>笔记</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    数据库
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">redis-3.跳表
    </h2>
  </header>
  <div class="entry-content">
    <p>1.结构 跳表的结构体：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 跳表节点 typedef struct zskiplistNode { // 跳表的value sds ele; // 跳表的score double score; // 指向最底层的前一个节点的指针 struct zskiplistNode *backward; // 有几层就会有几个元素 struct zskiplistLevel { // 同一层的下一个元素 struct zskiplistNode *forward; // 到下一个节点跳过了多少个节点 unsigned long span; } level[]; } zskiplistNode; // 跳跃表节点链表 typedef struct zskiplist { // 头尾指针 // 头节点的level长度是64，ele是空，score等于0， struct zskiplistNode *header, *tail; // 跳表长度(不包括头节点) unsigned long length; // 跳表高度 int level; } zskiplist; 2.创建跳表 创建跳表比较简单，主要在申请内存，初始化header信息，在创建跳表的时候会直接创建64层的header，代码对应t_zset.c的zslCreate()函数：
...</p>
  </div>
  <footer class="entry-footer">4 min</footer>
  <a class="entry-link" aria-label="post link to redis-3.跳表" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/3.%E8%B7%B3%E8%A1%A8/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">redis-4.字典
    </h2>
  </header>
  <div class="entry-content">
    <p>字典的底层由两个hash table实现，一个table用来正常存储数据，另一个在rehash时使用，具体的结构体：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 typedef struct dict { // 字典类型，指向dictType dictType *type; // dictEntry中函数的参数 void *privdata; // 两个hash表 // ht[0]原始hash表 // ht[1]扩容的时候使用 dictht ht[2]; // rehash标识，-1表示没有rehash，其他表示当前rehash进度的数组索引 long rehashidx; /* rehashing not in progress if rehashidx == -1 */ // 迭代器 unsigned long iterators; /* number of iterators currently running */ } dict; dictht就是真正存储数据的hash table，dictType里面封装了一些方法，比如计算hash值、比较等等，dictType的结构体：
...</p>
  </div>
  <footer class="entry-footer">4 min</footer>
  <a class="entry-link" aria-label="post link to redis-4.字典" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/4.%E5%AD%97%E5%85%B8/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">redis-5.整数集合
    </h2>
  </header>
  <div class="entry-content">
    <p>一 intset redis中如果set类型存储的元素都是有符号整数并且size小于512会使用整数集合来存储元素。intset是一个有序不可重复的整形数组。
1.查找元素 查找元素在inset.c的intsetFind()函数：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 uint8_t intsetFind(intset *is, int64_t value) { // 获取value的encoding uint8_t valenc = _intsetValueEncoding(value); // 如果value的encoding小于等于intset的encoding就开始查找 // 如果是大于的话intset里肯定没有，不需要查找 return valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,NULL); } static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) { int min = 0, max = intrev32ifbe(is-&gt;length)-1, mid = -1; int64_t cur = -1; // intset是空字节返回0 if (intrev32ifbe(is-&gt;length) == 0) { if (pos) *pos = 0; return 0; } else { // 如果value大于intset的最大值返回0 if (value &gt; _intsetGet(is,intrev32ifbe(is-&gt;length)-1)) { if (pos) *pos = intrev32ifbe(is-&gt;length); return 0; } else if (value &lt; _intsetGet(is,0)) { // value小于intset的最小值返回0 if (pos) *pos = 0; return 0; } } // 二分查找 while(max &gt;= min) { mid = ((unsigned int)min &#43; (unsigned int)max) &gt;&gt; 1; cur = _intsetGet(is,mid); if (value &gt; cur) { min = mid&#43;1; } else if (value &lt; cur) { max = mid-1; } else { break; } } if (value == cur) { if (pos) *pos = mid; return 1; } else { if (pos) *pos = min; return 0; } } 2.添加元素 添加和删除都差不多，找到要修改的位置&#43;挪动其他元素&#43;插入元素：
...</p>
  </div>
  <footer class="entry-footer">3 min</footer>
  <a class="entry-link" aria-label="post link to redis-5.整数集合" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/5.%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">redis-调优
    </h2>
  </header>
  <div class="entry-content">
    <p>同步操作：
读写客户端数据； 过期机制是在主线程中执行的； 淘汰策略也是在主线程中执行； 异步操作：
主从同步生成全量的RDB； lazy-free机制，把bigkey的释放内存的耗时操作放在了异步线程中执行； AOF放入rewrite，重写采用的是写时复制机制，最开始只会fork一个子进程，子进程会先复制父进程中的内存页表信息，父子进程指向同一个地址的数据，这时候子进程就可以开始写日志了，但是会有两种情况引起阻塞：1）内存页表很大，也就是数据量很多，在fork完成之前都会阻塞住；2）当有新的数据写入时，父进程会创建新的数据，新申请数据如果很大，因为内存的分配是以页为单位的，默认4k，如果申请了bigkey的内存，会产生耗时，如果操作系统开启的内存大页机制，阻塞的概率会提高很多。 4.0特性：
提出了一个混合使用AOF和RDB的的方法，就是说RDB按照正常频率执行，在这期间的数据变更使用AOF来记录； 异步删除和异步清空，unlink命令或者flushall async，lazy-free机制，会尝试异步释放空间操作（比如过期key、淘汰、主从）； 耗时操作：
读写bigkey时，分配内存和释放内存会产生耗时； 使用复杂度是O(n)的指令； 大量key过期； 内存不够，这时候每次写入前都会淘汰一些key； AOF设置成always，每次都要刷盘； 主从同步时生成全量RDB的一瞬间会阻塞住； 生产调优 repl_backlog_size一般要配置成（主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小） * 2。因为主从之间的缓冲区是环形的，防止缓冲区写满主库还继续写入，导致数据被覆盖。
绑核：每个CPU有多个运行核心，叫做物理核，每个物理核都有私有的L1和L2，每个CPU的所有物理核共享一个L3，L1和L2一般都是几k左右，三级缓存会有百兆左右，这也叫NUMA架构，跨核后操作延迟不相等。每个物理核一般会有两个逻辑核，因为如果是多核的情况，一个redis程序运行在了多个CPU socket上，这样数据要通过缓存传递，说白了就是减少上下文的切换。首先使用lscpu查看所有逻辑核，以及每个核的编号和对应的cpu socket，使用taskset -c 0,3 ./redis-server把redis和0核和3核绑定绑定，一般都是绑两个逻辑核，一个用来异步处理，但是这两个逻辑核要在同一个物理核下。
使用**./redis-cli --intrinsic-latency 120**查看redis120s内的延迟。
什么时候横向扩容？
先找到进程号**$ redis-cli info | grep process_id** cd /proc/[进程号] cat smaps | egrep &#39;^(Swap|Size)&#39;，检查swap数值，如果很大就需要扩容了 关闭huge page，在/et/rc.local里加入配置echo never &gt;/sys/kernel/mm/transparent_hugepage/enabled，默认是开启，如果开启会导致fork的速度变慢。
vm.overcommit_memory，找linux申请内存，但是不马上使用，默认是0，意思就是有内存就可以申请，没有内存就申请失败，redis的生产一般设置成1，允许redis超量使用内存，一直到服务器的内存都用完。
降低redis被系统killer概率，这是swappiness，这个是物理内存不够的时候会swap刷到磁盘，防止linux的oom killer机制，在/etc/sysctl.conf里配置vm.swappiness=1，如果linux的版本&lt;=3.5就配置成0，这样可以让redis在内存不够时不被系统杀死；找到redis的pid，然后echo -17 &gt; /proc/redis的pid/oom_adj
修改文件句柄数，默认的进程可以打开文件句柄是4096，使用ulimit -Sn xx设置可以打开的文件句柄数。
结合慢查询日志优化 slowlog-log-slower-than配置默认是10000us，设置请求时间超过多少算慢查询。然后把慢查询日志存到双向链表里。
slowlog-max-len设置存放慢查询日志的链表大小，超过最大值会移除最早的。一般最少要配置1000。
然后通过slowlog len获取慢查询日志长度，slowlog get n获取n条慢查询日志。
...</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to redis-调优" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/7.%E8%B0%83%E4%BC%98/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">springboot&#43;哨兵
    </h2>
  </header>
  <div class="entry-content">
    <p>作用 集群监控，负责监控redis master和slave进程是否正常工作 消息通知，如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员 故障转移，如果master node挂掉了，会自动转移到slave node上，同时会修改redis的配置文件 配置中心，如果故障转移发生了，通知client客户端新的master地址 quorum = 1（配置）：当主节点挂掉时，需要至少多少个哨兵节点认为master宕机就会进行主备切换；majority（概念）：哨兵运行数的最小值，比如当两个哨兵集群时，majority就是2，三个哨兵集群时，majority还是2，如果是两个哨兵集群，redis所在的服务器宕机，哨兵也不可用，此时majority数变成1，无法完成主备切换，所以哨兵一般最少三个集群。
主观宕机和客观宕机 一个哨兵认为master宕机叫做主管宕机，quorum数量的哨兵都觉得master宕机了就是客观宕机，这时候会进行主备切换。
选举机制 (down-after-milliseconds * 10) &#43; milliseconds_since_master_is_in_SDOWN_state，理解为一个salve跟master断开连接的时间太长不参加选举 按照slave优先级进行排序，slave priority越低，优先级就越高 如果slave priority相同，再看salve同步数据的偏移量，哪个slave复制了越多的数据，offset越靠后，优先级就越高 如果上面两个条件都相同，那么选择一个run id比较小的那个slave 搭建 一个哨兵集群可以监控多个redis主从，哨兵集群需要最少三台redis，这三个redis只要解压执行make、make test、make install即可。
三台机器分别执行如下操作：
创建两个目录
1 2 3 mkdir /etc/sentinel mkdir -p /var/sentinel/5000 mkdir -p /var/log/sentinel/5000 将redis目录下的sentinel.conf拷贝到本地修改名字为5000.conf并修改配置：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 后台启动 daemonize yes # 日志输出路径 logfile /var/log/sentinel/5000 # 哨兵所在虚拟机ip bind 192.168.0.6 port 5000 dir /var/sentinel/5000 # redismaster节点的ip # mymaster：redis主备集群名称 # 2：quorum值 sentinel monitor mymaster 192.168.0.3 6379 2 # 主备切换时，超过30s没切换成功由另一个哨兵进行切换 sentinel down-after-milliseconds mymaster 30000 # 主备切换之后，原来的salve需要重新绑定master并同步数据，1就是一次绑定1个salve sentinel parallel-syncs mymaster 1 # master的redis密码 sentinel auth-pass mymaster redis-pass 将5000.conf上传到/etc/sentinel目录下。
...</p>
  </div>
  <footer class="entry-footer">3 min</footer>
  <a class="entry-link" aria-label="post link to springboot&#43;哨兵" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/6.%E5%93%A8%E5%85%B5/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">TiDB-1.入门
    </h2>
  </header>
  <div class="entry-content">
    <p>分布式数据库是由分库分表演化过来的，分库分表需要单独部署leaf，DDL维护，整合分布式事务，扩容缩容等，麻烦的很。他有点类似es集群，开发的时候不需要关注有几台机器，高可用的问题，只需要知道连接信息，就是把之前分库分表的工作都在内部完成了。
</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to TiDB-1.入门" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/tidb/1.%E5%85%A5%E9%97%A8/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">全文检索
    </h2>
  </header>
  <div class="entry-content">
    <p>一般match都是拆词，包含一个词就可以
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 查询title中包含java或者elasticsearch GET /forum/article/_search { &#34;query&#34;: { &#34;match&#34;: { &#34;title&#34;: &#34;java elasticsearch&#34; } } } // 这么写的时候，es把他转换成should语法，像下面这样 GET /forum/article/_search { &#34;query&#34;: { &#34;bool&#34;: { &#34;should&#34;: [ &#34;match&#34;: { &#34;title&#34;: &#34;java&#34; }, &#34;match&#34;: { &#34;title&#34;: &#34;elasticsearch&#34; } ] } } } 如果想要必须都包含，也就是并且关系
...</p>
  </div>
  <footer class="entry-footer">3 min</footer>
  <a class="entry-link" aria-label="post link to 全文检索" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/es/7.%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">参数
    </h2>
  </header>
  <div class="entry-content">
    <p>如果是单台机器上启动多个es，他们会把自己绑定在127.0.0.1（回环地址）上，然后去扫描9300~9305端口，自己就可以维护集群了，生产环境不能这么玩，要想和其他服务器的几点通信需要绑定在非回环地址上，es是peer2peer的分布式系统架构，master负责维护集群信息和其他元数据，把变更的信息推送到其他node（data node）。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 # 集群名称，node的这个属性一样才是集群的基本条件，线上一定要修改，否则其他测试node可能会不小心加入这个集群 cluster.name: elasticsearch-prod # 节点名称 node.name: node-elasticsearch-01 # 绑定地址，多机器一定要配这个 network.host: 192.168.0.10 # 这个配置的是master eligible node，在master宕机的时候从eligible node中选出来一个master，默认就是true node.master: true # 这个是是不是存储数据的节点，如果集群很大的时候可以设置3个节点为专门的eligible node，不存存储数据，这个就设成false node.data: true # unicast的中间节点host列表，其他node会和这几个节点通信然后加入集群，一般写三个就够了，有eligible node优先把eligible node写进去 discovery.zen.ping.unicast.hosts: [&#34;host1&#34;, &#34;host2&#34;] # ping的超时时间，可以防止网络问题导致的master选举过慢 discovery.zen.ping_timeout: 3s # 选举之后其他data节点发送一个join加入集群，配置超时时间，超时会重试 discovery.zen.join_timeout: 60s # 强制区分候选节点，避免node.master: false的节点发来请求参与master选举 discovery.zen.master_election.ignore_non_master_pings: true # 这些路径不嫩放在es目录下，方便以后升级 # 存放日志文件 path.logs: /var/log/elasticsearch # 存放数据文件 path.data: /var/data/elasticsearch # 选举的时候最少要求多少候选节点通过，设置为候选节点的quorum（num / 2 &#43; 1）数量 # 三个节点的集群quorum就是2，如果只有两个节点，quorum还是2，有一台机器宕机的时候就不能完成选举 # 如果两个节点，参数设置成1，那么就会随便发生脑裂，因为一个机器一下就把自己变成master了 discovery.zen.minimum_master_nodes: 2 # shard recover操作：当有一些几点无法启动或者还没启动的时候，es检测到已经启动的节点上的shard不正常，比如没有primary， # 就会复制出primary shard，当剩下节点启动之后，发现自己的shard过期就会把shard删除， # 集群发现shard分配不均匀，因为有些机器上一个shard没有，这时候又会把别的节点上的shard转到新启动的节点上，这样是很坑的 # 这三个参数是一起的，意思是在2个node上线之后开始计时，如果1分钟内节点数达到3个就OK，没达到就执行shard recover操作 gateway.recover_after_nodes: 2 gateway.expected_nodes: 3 gateway.recover_after_time: 1m # 锁定jvm内存，防止swaping bootstrap.memory_lock: true # 慢查询日志 index.search.slowlog.threshold.query.warn: 10s index.search.slowlog.threshold.query.info: 5s index.search.slowlog.threshold.query.debug: 2s index.search.slowlog.threshold.query.trace: 500ms index.search.slowlog.threshold.fetch.warn: 1s index.search.slowlog.threshold.fetch.info: 800ms index.search.slowlog.threshold.fetch.debug: 500ms index.search.slowlog.threshold.fetch.trace: 200ms index.indexing.slowlog.threshold.index.warn: 10s index.indexing.slowlog.threshold.index.info: 5s index.indexing.slowlog.threshold.index.debug: 2s index.indexing.slowlog.threshold.index.trace: 500ms index.indexing.slowlog.level: info index.indexing.slowlog.source: 1000 在启动的时候指定配置文件地址，-d后台启动：
...</p>
  </div>
  <footer class="entry-footer">2 min</footer>
  <a class="entry-link" aria-label="post link to 参数" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/es/9.%E5%8F%82%E6%95%B0/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">建模
    </h2>
  </header>
  <div class="entry-content">
    <p>建模有普通建模，就是逻辑外键、冗余建模，一对多的关系放在一个document下，父子关系建模（要求父子在一个shard中）。
父子关系建模 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 PUT /company { &#34;mappings&#34;: { &#34;rd_center&#34;: {}, // 研发中心type &#34;employee&#34;: { // 员工type &#34;_parent&#34;: { // 指定parent是研发中心 &#34;type&#34;: &#34;rd_center&#34; } } } } // 添加员工时指定parent就OK，指定了parent之后会使用parentid路由，这样就会保证父子数据在同一shard中 PUT /company/employee/1?parent=1 { &#34;name&#34;: &#34;张三&#34;, &#34;birthday&#34;: &#34;1970-10-24&#34;, &#34;hobby&#34;: &#34;爬山&#34; } 父子关系查询 根据child查询parent 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 查询有员工在1980-01-01以后出生的研发中心 GET /company/rd_center/_search { &#34;query&#34;: { &#34;has_child&#34;: { &#34;type&#34;: &#34;employee&#34;, &#34;query&#34;: { &#34;range&#34;: { &#34;birthday&#34;: { &#34;gte&#34;: &#34;1980-01-01&#34; } } } } } } // 查询至少有两个员工的研发中心 GET /company/rd_center/_search { &#34;query&#34;: { &#34;has_child&#34;: { &#34;type&#34;: &#34;employee&#34;, &#34;min_children&#34;: 2, &#34;query&#34;: { &#34;match_all&#34;: {} } } } } 根据parent查询child 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 查询研发中心在中国的员工信息 GET /company/employee/_search { &#34;query&#34;: { &#34;has_parent&#34;: { &#34;parent_type&#34;: &#34;rd_center&#34;, &#34;query&#34;: { &#34;term&#34;: { &#34;country.keyword&#34;: &#34;中国&#34; } } } } } 聚合统计 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 统计每个国家的员工爱好，及爱好人数 GET /company/rd_center/_search { &#34;size&#34;: 0, &#34;aggs&#34;: { &#34;group_by_country&#34;: { &#34;terms&#34;: { &#34;field&#34;: &#34;country.keyword&#34; }, &#34;aggs&#34;: { &#34;group_by_children_employee&#34;: { &#34;children&#34;: { &#34;type&#34;: &#34;employee&#34; }, &#34;aggs&#34;: { &#34;group_by_hobby&#34;: { &#34;terms&#34;: { &#34;field&#34;: &#34;hobby.keyword&#34; } } } } } } } } 如果是三代，在添加数据的时候只指定parent，那么就不能保证祖孙三代都路由到同一shard上，需要使用routing，指定祖先id。
</p>
  </div>
  <footer class="entry-footer">2 min</footer>
  <a class="entry-link" aria-label="post link to 建模" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/es/8.%E5%BB%BA%E6%A8%A1/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">持久化
    </h2>
  </header>
  <div class="entry-content">
    <p>RDB和AOF的区别 rdb是每达到一定条件就生成一个新的文件快照，快照内容是redis中当前内容的全量数据，文件名是dump.rdb，配置文件中的属性如下：
1 2 3 save 900 1 save 300 10 save 60 10000 意思是达到60s并且数据变化超过10000条或者300s数据变化超过10条或者900s数据变化超过1条就生成一个新的dump.rdb文件，生成完成后覆盖老的快照文件。
aof存储的向redis中写入数据的指令，以append-only的模式追加，默认关闭，aof备份文件名是appendonly.aof，redis先将指令写入os cache中，然后根据配置将os cache中的指令写入aof文件，当aof文件很大时会执行rewrite操作，此时会新生成一个新的aof文件，基于当前redis中的数据向新aof文件中写入指令，如果redis中数据发生变化，会追加到老aof文件中，当新aof文件追加结束再把新增的指令追加到新aof中，追加结束后删除老aof文件，aof相关配置如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 是否开启aof appendonly no # aof备份名称 appendfilename &#34;appendonly.aof&#34; # aof备份模式 # 每次redis中写入数据就同步写入到磁盘 # appendfsync always # 每秒执行一次写入 appendfsync everysec # 将写入指令放到os cache中不管，由操作系统控制 # appendfsync no #rewirte条件，当下面两个条件都满足时进行rewrite操作 # aof文件大小超过上次rewrite之后大小的100% auto-aof-rewrite-percentage 100 # aof文件最小64m auto-aof-rewrite-min-size 64mb RDB优缺点 rdb中数据可能不是最全的，但是恢复是最快的，因为存储的是数据，直接放到redis中就可以了； 如果redis中数据很多每次生成快照文件时可能导致redis服务暂停一段时间，类似jvm的stop the world； 很适合配合脚本做冷备份，比如传到oss上容灾； AOF优缺点 最多只有1s的数据丢失； 每次都要写入os cache，但比写磁盘快很多； 回复数据慢； 使用 一般都是同时开启RDB和AOF，这样，aof可以保证数据不丢，aof损坏时可以使用rdb的冷备快速恢复，防止雪崩；
...</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 持久化" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/5.rdb%E5%92%8Caof/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/page/3/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:1313/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/page/5/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">王小红的笔记</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
