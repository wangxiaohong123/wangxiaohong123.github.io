<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DDD on 王小红的笔记</title>
    <link>http://localhost:1313/categories/ddd/</link>
    <description>Recent content in DDD on 王小红的笔记</description>
    <generator>Hugo -- 0.150.0</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 24 Jun 2021 06:27:35 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/ddd/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>3.DDD框架之cola</title>
      <link>http://localhost:1313/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/ddd/4.cola/</link>
      <pubDate>Thu, 24 Jun 2021 06:27:35 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/ddd/4.cola/</guid>
      <description>&lt;p&gt;COLA是一个应用架构，作者对应用架构的解释是处理模块（Module）、组件（Component）、包（Package）和类（Class）之间的关系，让系统有章法，有结构。提倡以业务为核心，解耦外部依赖，分离业务复杂度和技术复杂度。&lt;/p&gt;
&lt;h5 id=&#34;cola架构&#34;&gt;COLA架构&lt;/h5&gt;
&lt;p&gt;&lt;img alt=&#34;68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f36353439323330633637323334343866623361623531636137343832396538302e706e67&#34; loading=&#34;lazy&#34; src=&#34;https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f36353439323330633637323334343866623361623531636137343832396538302e706e67.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适配层（Adapter Layer）：负责对前端展示（web，wireless，wap）的路由和适配，相当于MVC中的controller，主要用来解释用户指令；&lt;/li&gt;
&lt;li&gt;应用层（Application Layer）：主要负责获取输入，组装上下文，参数校验，调用领域层做业务处理，如果需要的话，发送消息通知等，其实就是&lt;strong&gt;对业务编排&lt;/strong&gt;。层次是开放的，应用层也可以绕过领域层，直接访问基础实施层；&lt;/li&gt;
&lt;li&gt;领域层（Domain Layer）：主要是封装了核心业务逻辑，并通过领域服务（Domain Service）和领域对象（Domain Entity）的方法对App层提供业务实体和业务逻辑计算。领域是应用的核心，&lt;strong&gt;不依赖任何其他层次&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;基础实施层（Infrastructrue Layer）：主要负责技术细节问题的处理，比如数据库的CRUD、搜索引擎、文件系统、分布式服务的RPC等。此外，领域防腐的重任也落在这里，外部依赖需要通过gateway的转义处理，才能被上面的App层和Domain层使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出来COLA和DDD的分层是一模一样的，只不过对于一些组件比如防腐层什么的所在的层级做了一些改动，这三种架构的普适性都是针对前端需求的变和领域模型的不变。&lt;/p&gt;
&lt;h4 id=&#34;cola的包结构&#34;&gt;COLA的包结构&lt;/h4&gt;
&lt;h5 id=&#34;adapter层&#34;&gt;Adapter层&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;mobile：文档上写的是wireless，但是生成的代码里叫mobile，就是app端对应的controller接口；&lt;/li&gt;
&lt;li&gt;web：电脑端页面对应的controller；&lt;/li&gt;
&lt;li&gt;wap：移动端页面对应的controller；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;app层&#34;&gt;App层&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;executor：处理request，包括command和query；&lt;/li&gt;
&lt;li&gt;consumer：处理外部message，就是对应的事件消费者；&lt;/li&gt;
&lt;li&gt;scheduler：处理定时任务；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;domain层&#34;&gt;Domain层&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;model：领域模型，就是实体、聚合这些东西；&lt;/li&gt;
&lt;li&gt;ability：领域能力，就是领域服务；&lt;/li&gt;
&lt;li&gt;gateway：领域网关，&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;infra层&#34;&gt;Infra层&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;gatewayimpl：网关实现；&lt;/li&gt;
&lt;li&gt;mapper：ibatis数据库映射；&lt;/li&gt;
&lt;li&gt;config：配置信息；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;client层&#34;&gt;Client层&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;api：服务对外暴露的api接口；&lt;/li&gt;
&lt;li&gt;dto：服务对外的DTO；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;start层&#34;&gt;Start层&lt;/h5&gt;
&lt;p&gt;里面只有服务的配置和启动类；&lt;/p&gt;
&lt;p&gt;其实不管我们用不用DDD的模型设计都可以用这一套包架构，只不过就是model里有没有东西的事儿。&lt;/p&gt;
&lt;h5 id=&#34;对于领域层和基础层的gateway包说明&#34;&gt;对于领域层和基础层的gateway包说明：&lt;/h5&gt;
&lt;p&gt;这里的gateway并不是微服务的网关，而是代表DDD中的防腐层或者仓储，操作数据库时，通过仓储+po和实体的转换实现解耦，rpc调用其他服务或者三方的时候通过防腐层进行实体转换，给我的感觉都是一样的，只要有依赖就有耦合，这几个做法都是为了降低耦合的可接受成都，主要的思想也都是一样的。cola中的gatewayImpl就是他的防腐层，他把数据库、es这些也定义成了外部依赖，这样做不管是应用层还是领域层都可以调用三方服务了。&lt;/p&gt;
&lt;h3 id=&#34;基于dddcola改造开发&#34;&gt;基于DDD+cola改造开发&lt;/h3&gt;
&lt;h5 id=&#34;分析方法&#34;&gt;分析方法&lt;/h5&gt;
&lt;p&gt;DDD的分析方法有三种，事件风暴、领域故事陈述和4色建模：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件风暴：类似于大家在一起的头脑风暴，每个人针对业务都想说什么说什么，然后有一个人专门根据大家的发言提炼出业务流、事件和命令，然后在根据事件的语义划分出实体、聚合、子域以及限界上下文。&lt;/li&gt;
&lt;li&gt;领域故事陈述：梳理出每个业务的流程图&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cola相关修改&#34;&gt;COLA相关修改&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;COLA中每一层就是一个模块，每一个子域对应一个工程，这样对人少的团队会增加维护成本，我们还是一个项目对应一个工程对应多个子域，每个子域只有两个服务，业务服务和api服务，api专门堆外暴露接口，其他层使用包的方式存在业务服务中。&lt;/li&gt;
&lt;li&gt;在COLA中client层除了对外的接口和dto还有命令和事件，我们把client层去掉后，把命令放到了app层，事件放到了领域层，事件的处理(publisher、subscriber)也在app层，还有一种方式是对于事件的publisher组件放到了gateway中，这么做是考虑下层不应该调用上层，publisher组件放到了gateway中方便在domain层调用。&lt;/li&gt;
&lt;li&gt;COLA的应用服务接口也放到了Client层，我觉得没必要，也没必要设计成依赖倒置的，所以我们直接在app层创建一个应用服务用来编排命令，app的executor包下有cmd和qry的包对应查询和命令的处理逻辑。&lt;/li&gt;
&lt;li&gt;COLA中并没有出现工厂的概念，我们需要，也放在app层，同时infra层需要convertor实现实体和其他dto或者do转换。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title>DDD-2.入门</title>
      <link>http://localhost:1313/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/ddd/2.ddd/</link>
      <pubDate>Thu, 24 Jun 2021 06:27:35 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/ddd/2.ddd/</guid>
      <description>&lt;p&gt;DDD是一套软件/系统的设计思想，目前没有一套完整的方法论。他建议用现实的场景映射我们的代码设计，传统的MVC主要是快，但是代码会全部堆积在service层，在拿到需求后，开始建库表，然后所有的代码都是面向数据库的，这样service的代码会越来越多，并且在面对复杂业务会很无力，DDD就是为了解决复杂场景下的代码设计。但是目前使用DDD做代码设计的非常少，因为资料少，实践困难，如果是一个微型团队，每个人负责几个子系统，每个人都需要定义自己子系统的通用语言，这样沟通很容易产生误会，最好是一个二三十人的团队，负责十几个系统，每个小团队负责一个系统（一个系统里可能包含很多服务），这样小团队之间用自己的自定语言，项目leader先划分好领域，然后建模，每个团队的leader在把自己的系统建模，这样才可以。&lt;/p&gt;
&lt;h5 id=&#34;为什么要用ddd&#34;&gt;为什么要用DDD？&lt;/h5&gt;
&lt;p&gt;首先DDD的思想是面向对象的，更接近真实场景，其次在复杂系统的设计上DDD更优于传统三层架构，但如果三层架构把服务拆的足够微，我不觉得他比DDD弱，其实现在的DDD和十几年前的三层架构一样，当时三层架构刚刚开始流行，大部分公司没有接触过，就感觉很厉害，很难，几年之后，三层架构变成标配，在这种分层的思想已经固化的时候，出来了一个DDD，思想和三层架构有些差别，使用的少或者没使用就会感觉DDD很深奥，可能再过几年DDD普及之后就和现在的MVC一样了。DDD的价值是让开发和产品对业务有相同的理解，DDD的流程差不多是这样：&lt;/p&gt;
&lt;p&gt;需求评审-&amp;gt;和产品、运营、用户定义通用语言-&amp;gt;业务建模-&amp;gt;架构设计(业务架构+技术架构)-&amp;gt;团队成员开始建模(实体、值对象、互动的流程)-&amp;gt;搭建工程、定义接口、代码落地(根据通用语言)&lt;/p&gt;
&lt;p&gt;可以看到和产品的沟通变多了，和产品一起定义的名词和业务挂钩，沟通无障碍，新人在看完需求文档，在看代码也很轻松。&lt;/p&gt;
&lt;p&gt;其实传统的service+controller+dao+domain除了开发快，还有一个优点，就是门槛低，随便一个培训出来的人都能开发。但是DDD更适合大型的复杂的业务系统，而且他更贴合显示，业务模型和业务代码特别清晰，代码非常好看，如果一直维护面向数据库的代码肯定会越来乱。&lt;/p&gt;
&lt;p&gt;如果一个大团队没搞DDD，小团队自己能不能搞？能，只要把只要把团队负责的几个系统定义一套通用语言就可以，小团队不搞，自己负责的几个服务能不能搞？能，自己负责的每个服务都是一个子域，使用一个通用语言也可以。&lt;/p&gt;
&lt;h5 id=&#34;基础概念&#34;&gt;基础概念&lt;/h5&gt;
&lt;h6 id=&#34;1限界上下文&#34;&gt;1.限界上下文&lt;/h6&gt;
&lt;p&gt;他是一个独立的业务领域，可以是一个或多个子域，一般就是一个子域，也建议这么划分，建议每个限界上下文最好是一个独立的子系统，拥有独立的git仓库，独立的数据仓库，独立的测试环境，独立的团队。&lt;/p&gt;
&lt;h6 id=&#34;2通用语言&#34;&gt;2.通用语言&lt;/h6&gt;
&lt;p&gt;针对同一限界上下文需要定义一套自己的名词，比如同样的orderNumber，在订单域里是充值、消费的订单号，在匹配域里，是发起一次群聊请求的订单号/房间号。&lt;/p&gt;
&lt;h6 id=&#34;3子域domain&#34;&gt;3.子域（domain）&lt;/h6&gt;
&lt;p&gt;其实说的就是限界上下文，主要有3种子域，一般一个子域最好对应唯一一个限界上下文。&lt;/p&gt;
&lt;p&gt;核心域：核心业务系统，比如订单、钱包、动态。&lt;/p&gt;
&lt;p&gt;支撑子域：非核心系统，但是有了锦上添花或者是辅助性的系统，比如BI系统、爬虫系统、社会化治理系统。&lt;/p&gt;
&lt;p&gt;通用子域：一般具有普适性，全公司都可以用的类似OA系统、权限系统这种。&lt;/p&gt;
&lt;p&gt;一个子域可以拆分成多个module，一般一个子域也是一个独立运行的大系统。&lt;/p&gt;
&lt;h6 id=&#34;4module&#34;&gt;4.module&lt;/h6&gt;
&lt;p&gt;一般一个module就是一个服务。&lt;/p&gt;
&lt;h6 id=&#34;5上下文映射&#34;&gt;5.上下文映射&lt;/h6&gt;
&lt;p&gt;就是子域进行集成，就是不同系统之间的接口调用，因为不同的系统可能会有通用语言的冲突，就需要在接口调用的时候把冲突的单词映射成另一个。&lt;/p&gt;
&lt;p&gt;上下文映射的种类，U-D就是调用链的上下游，下游调用，上游提供，箭头是由上游指向下游，表示数据的流向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合作关系（Partnership）：两个上下文强耦合在一起，多个服务完成一整个业务，一般都是一起需求评审，一起开发，一起上线。这种关系需求变更对应的服务也要改动。&lt;/li&gt;
&lt;li&gt;共享内核（Shared Kernel）：两个系统共同维护一些模型，比如A系统的API里的一些类是B系统认可的，或者一个单独的公共的模块，他们共用并且共同维护这些实体，很少见。&lt;/li&gt;
&lt;li&gt;客户方-供应方（Customer-Supplier Development）：就是系统B根据系统A的需求定制接口，返回值还是系统A（客户方说的算），一般都是和合作关系配合用，你需要接口，人家没有就一起商量一下。&lt;/li&gt;
&lt;li&gt;发布订阅（Publish-Subscribe）：比如那种发mq消息的。&lt;/li&gt;
&lt;li&gt;尊奉着/没商量（Conformist）：系统A调用系统B，但是A说得不算，B只暴露一些接口，你要是用就调一下，你想要修改人家也不配合你，一般就是中间件部门写的接口，或者其他独立的系统。&lt;/li&gt;
&lt;li&gt;开放主机服务OHS（Open Host Service）和发布语言PL（Published Language）：相当于是开放的API了，一般指三方或者公司自己的平台，比如云片短信，定义一种协议，一般都是http。基于消息机制也是发布语言的实现方式。&lt;/li&gt;
&lt;li&gt;防腐层ACL（Anticorruption Layer）：为了防止系统B接口改动频繁，把调用系统B的代码抽离出来，以后系统B再次改动，这需要改防腐层的代码即可，一般和尊奉着/开放主机服务一起使用。&lt;/li&gt;
&lt;li&gt;大泥球（Big Ball of Mud）：上下文没有关系，各行其道，混乱的组织在一起，一般说得就是本该拆成几个子域，结果混在了一个服务里。&lt;/li&gt;
&lt;li&gt;独立路线/隔离模式（SeparateWay）：没关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;6实体和值对象&#34;&gt;6.实体和值对象&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;实体：先理解成传统MVC的domain下的实体，但其实远不止，实体是有状态和行为的，也就是说实体的变量是可变的。&lt;/li&gt;
&lt;li&gt;值对象：就是实体中包含的数据，比如订单中的值对象可以有订单详情，代表的是封装了一份数据，最经典的例子，前端返回的实体一般起名都以VO结尾，VO就是value object的缩写，翻译过来就是值对象，比如返回给前端的订单信息中有OrderInfo、OrderItem、Product、PurchaseCart。其实实体和值对象的区别可以理解成实体有id，值对象没有id。标准的DDD中规定值对象只能替换，不能修改。&lt;/li&gt;
&lt;li&gt;聚合（Aggregate）：多个实体或者值对象的组合关系，一个订单实体中有多个订单明细实体，他们就是聚合关系，他可以看成是特殊的实体。&lt;/li&gt;
&lt;li&gt;根实体：每个聚合关系里都有一个根实体，在订单里，大订单就是跟实体，也叫聚合根。&lt;/li&gt;
&lt;li&gt;事务：说的是聚合实体的事务关系，比如说一起更新，要保证事务更新了这个聚合实体的整体或者部分的时候，实体内的数据是一致的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;聚合关系应尽量通过实体id引用，不要通过面向对象的引用，尽可能保证小型，主要就是通过事务规则，符合事务原则的实体，可以设计成聚合关系。&lt;/p&gt;
&lt;h6 id=&#34;7资源库repository&#34;&gt;7.资源库(repository)&lt;/h6&gt;
&lt;p&gt;负责对实体对象进行持久化。&lt;/p&gt;
&lt;h6 id=&#34;8应用服务&#34;&gt;8.应用服务&lt;/h6&gt;
&lt;p&gt;负责对业务流程的编排，对应service接口。&lt;/p&gt;
&lt;h6 id=&#34;9领域服务&#34;&gt;9.领域服务&lt;/h6&gt;
&lt;p&gt;实体/值对象/资源库/工厂/聚合不适合放在里面的复杂性为的补充。里面的行为就是指挥多个实体/值对象完成业务逻辑。&lt;/p&gt;
&lt;h6 id=&#34;10领域事件&#34;&gt;10.领域事件&lt;/h6&gt;
&lt;p&gt;系统交互的核心事件，比如支付订单事件，一般用过去式命名。&lt;/p&gt;
&lt;h6 id=&#34;11业务组件&#34;&gt;11.业务组件&lt;/h6&gt;
&lt;p&gt;对领域事件的发布和处理。&lt;/p&gt;
&lt;h6 id=&#34;12用户界面&#34;&gt;12.用户界面&lt;/h6&gt;
&lt;p&gt;对应controller接口。&lt;/p&gt;
&lt;h6 id=&#34;13基础设施&#34;&gt;13.基础设施&lt;/h6&gt;
&lt;p&gt;MySQL、es、redis什么的，业务组件、领域服务、实体、资源库都可以用，根据业务决定。&lt;/p&gt;
&lt;h6 id=&#34;14命令-command和查询query&#34;&gt;14.命令 command和查询query&lt;/h6&gt;
&lt;p&gt;用来驱动领域服务的业务逻辑核方法的执行，一般就是人通过web或者app这种UI界面发起的指令，是从CQRS架构里延伸出来的，牵扯到了下面的类DDD和泛DDD。&lt;/p&gt;
&lt;h6 id=&#34;15战略设计战略建模领域对象建模&#34;&gt;15.战略设计/战略建模/领域对象建模&lt;/h6&gt;
&lt;p&gt;对子域划分、上下文映射、子域集成、实体、值对象和领域服务建模，完全没必要说得这么高大上，其实就是业务建模。一般一块业务就对应一个领域，一个领域又可以拆成多个子域，拆分域还是很容易的。&lt;/p&gt;
&lt;p&gt;业务领域 -&amp;gt; 各个子域（module） -&amp;gt; 自己子域的通用语言（你应该跟子域里的其他人一起合作） -&amp;gt; 上下文映射（上下游关系）&lt;/p&gt;</description>
    </item>
    <item>
      <title>DDD-3.DDD的分层架构</title>
      <link>http://localhost:1313/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/ddd/3.ddd%E7%9A%84%E5%88%86%E5%B1%82/</link>
      <pubDate>Thu, 24 Jun 2021 06:27:35 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/ddd/3.ddd%E7%9A%84%E5%88%86%E5%B1%82/</guid>
      <description>&lt;p&gt;目前没有一套完整的DDD方法论，他仅仅提供了一些思想，所以每个公司可能都有自己的DDD目录结构，一般都是用到他的概念和分层，有的简单业务甚至只用到他的分层。&lt;/p&gt;
&lt;p&gt;推进DDD是很难的，第1花时间还没有产出，第2就是没有完整的方法论，包结构数据怎么流转等等都没有统一的规定。而且完全按照DDD的规范来开发不适合互联网，DDD讲究的是把聚合、值对象这些东西分的很细还有对以后扩展的预留，完全用这个会把开发周期拖长，对业务不熟或者赶工的时候非常容易走样。&lt;/p&gt;
&lt;h3 id=&#34;一些普适性架构&#34;&gt;一些普适性架构&lt;/h3&gt;
&lt;h5 id=&#34;清洁架构&#34;&gt;清洁架构&lt;/h5&gt;
&lt;p&gt;也叫洋葱架构，因为分层的图画出来很像洋葱：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;fc8208d9f4cfadb7949d6e98a8c18442&#34; loading=&#34;lazy&#34; src=&#34;https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/fc8208d9f4cfadb7949d6e98a8c18442.webp&#34;&gt;&lt;/p&gt;
&lt;p&gt;越里层，越是核心能力，并且外圆只能依赖内圆，基础资源除外，或者说最外层除外。在DDD中4层架构的功能边界如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;006_图解四层架构功能边界&#34; loading=&#34;lazy&#34; src=&#34;https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/006_%E5%9B%BE%E8%A7%A3%E5%9B%9B%E5%B1%82%E6%9E%B6%E6%9E%84%E5%8A%9F%E8%83%BD%E8%BE%B9%E7%95%8C.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;传统4层架构的调用方式看起来像下面这样：&lt;/p&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/Xnip2023-05-08_08-24-36.png&#34; alt=&#34;Xnip2023-05-08_08-24-36&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;就很怪，为什么接口可以直接调用基础层，数据库什么的都在这里？？？&lt;/p&gt;
&lt;h5 id=&#34;六边形架构&#34;&gt;六边形架构&lt;/h5&gt;
&lt;p&gt;也叫端口适配器架构，红框内是核心逻辑，核心逻辑不变采用适配器适配不同端，同理和基础架构的交互也是使用了依赖倒置，置于为什么叫6边型，是为了形容一套逻辑可以适配多个端口。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;6&#34; loading=&#34;lazy&#34; src=&#34;https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/6.webp&#34;&gt;&lt;/p&gt;
&lt;p&gt;四层架构里的接口层虽然有web界面这些东西，但是他定义的不是传统3层架构的controller，6变形架构就是为了解决这个问题，并且他把基础设施也定义成了api的方式提供其他层调用。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
