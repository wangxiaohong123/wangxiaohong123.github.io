<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>框架 | 王小红的笔记</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/categories/%E6%A1%86%E6%9E%B6/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/categories/%E6%A1%86%E6%9E%B6/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/categories/%E6%A1%86%E6%9E%B6/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wangxiaohong123.github.io/categories/%E6%A1%86%E6%9E%B6/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="框架"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="框架"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>框架</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>为什么使用微服务</h2></header><div class=entry-content><p>单块应用的缺点： 代码重复问题，如果十几个人或者更多人一起干一个单块项目，你要别的模块的接口，但是那个人很忙，没时间写，拖了很长时间你可能就自己写了，这样就操作别的表，别人的库，很有可能和那个人的摸个功能有重复代码，可能会出现大量的重复代码，使用cloud的feign可以避免，微服务中每个人都没有修改别人代码的权限；
协作问题：多人修改公共文件夹下的代码就会出现代码冲突，两个人的冲突还好解决，多个人的冲突超级麻烦；
扩容行问题：所有模块都在一个项目里，要扩容就一起扩容，但是根据28法则，只有那么几个模块流量很大，而且有的时候有的模块还有一些状态什么的，如果扩容就会计算出错，这种也很麻烦；
可用性问题，可能一个人负责的模块写了个死循环或者不小心oom，整个系统就瘫痪了，微服务里如果别的服务挂了可以使用histrix降级熔断；
耦合度太高：代码量上来的时候在后期想要修改代码都不敢动手；
spring cloud是一站式微服务架构解决方案。dubbo是RPC框架。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 为什么使用微服务" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>事务-2.XA事务</h2></header><div class=entry-content><p>一般项目刚上线不久，数据量稍微有点大的时候，但是还没到分库分表的数据量，会把不同的表放到不同的数据库中，但是这个时候@transactional注解垮裤不会生效了。这时候就要用到XA规范和2PC、3PC理论。
XA规范 TM和RM通信的规范就是XA，TM就相当于是引入的一个组件。
XA规范流程：connect -> closed，start -> end，prepare -> commit/rollback。
一般的TM用的都是Atomikos
1 2 3 4 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-jta-atomikos&lt;/artifactId> &lt;/dependency> 2PC（Tow Phase Commit） 2PC是一套基于XA的理论，两阶段提交，第一个阶段TM发送prepare消息，让RM先把操作数据库的语句跑完，但是不提交，操作完后给TM结果，如果TM收到的结果全是成功就在告诉RM进行提交，如果有失败的或者超时的就会通知RM回滚。
问题： 在第二阶段提交之前，资源会一直锁定，这样别人在对资源加独占锁的时候会同步阻塞住；
在第一阶段后单点的TM挂了，这时候资源就会被一直占用着；
在TM发送commit消息的时候，一台服务器挂了，TM也挂了，这时候在选举一个TM出来也不知道哪个消息commit成功了；
脑裂问题，所有主从都有脑裂问题；
3PC 第一阶段：TM发送CanCommit消息，各个库确认环境是否OK；
第二阶段：发送PreCommit消息，相当于2PC的第一阶段；
第三阶段：发送DoCommit消息，2PC的第二阶段；
每个库有一个超时机制，如果在PreCommit之后过一段时间没接收到DoCommit的消息，就会回滚，关键还有一个CanCommit阶段，因为能到PreCommit消息说明所有库都在CanCommit阶段返回成功了，那么这么长时间还没有DoCommit或者abort消息，应该就是TM挂了。
MySQL支持的是2PC协议。
JTA事务 J2EE中的概念，单库的的事务是基于jdbc的，多库的事务是JTA事务，也是基于DTP那一套玩的。
全局事务 x/Open组织定义了一套分布式事务的模型和规范，叫做DTP，就是图中的TM、RM等等。全局事务就是DTP模型中的一个概念，图里也写到了。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 事务-2.XA事务" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/%E4%BA%8B%E5%8A%A1/2.%E5%8D%95%E6%A8%A1%E5%9D%97%E5%A4%9A%E5%BA%93/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>事务-3.TCC事务</h2></header><div class=entry-content><p>主业务服务就是调用其他服务的接口，比如说下订单的接口，在这个接口中需要冻结用户钱包金额，主业务服务就是订单服务，从业务服务就是钱包服务，钱包服务需要提供三个接口：try接口、confirm接口、cancel接口。
业务活动管理器就是管理分布式事务状态的，他会去触发从业务服务的confirm和cancel接口。
try阶段：会锁定资源，没有资源锁定的操作，try接口就可以留空。
confirm：执行具体的逻辑；
cancel：对之前的变动回滚；
TCC的两个变种 异步型TCC方案：从业务服务之前加一层消息服务，从业务服务只有一个confirm接口，try操作就是在消息服务中写入一条confirm消息，confirm操作就是把这个消息发送到从业务服务，cancel操作就是把消息删掉，比如从业务服务已经写好了接口，如果现在要改成分布式事务，需要加两个接口，一个try，一个concel，加一个消息服务，从业务服务就不需要加接口了。 补偿性TCC方案：只有两个阶段，一个do接口，一个compensate接口，其实就是把try拿掉了。 国内的热门TCC框架 tcc-transaction：对spring cloud整合不太好，dubbo还行。 himly：他的整合都是用xml格式，现在都是注解了。 ByteTCC：支持TCC和saga事务，注解驱动，和spring cloud整合还行。 byteTCC可以实现tcc事务和saga事务，在tcc事务中，try和cancel是对应起来的，如果confirm失败会一直重试，cancel失败也会一直重试，而在saga事务中，没有confirm，try就是执行业务逻辑，cancel提供对应的反向数据操作。
byteTCC源码 首先使用byteTCC需要在dataSource组件加入注解：@Import(SpringCloudConfiguration.class)，SpringCloudConfiguration.class里面是对cloud的组件比如feign创建了自己的动态代理，实现自己的逻辑。
启动类上添加注解**@ImportResource({ “classpath:bytetcc-supports-springcloud.xml” }) **，这个xml配置了很多bean。
服务之间的事务上下文都是通过request的header传递。
bytejta表中如果只有一条记录，说明try执行完了，confirm或者cancel还没执行成功，正常来说一个事务会对应两条记录。
CompensableWork会定时（60s）重试失败的confirm或者cancel，也是调用CompensableCoordinatorController中的接口，同时在刚启动的时候他也会去恢复没执行的事务。
链式调用也是使用resourceList。
在bytetcc中，confirm和cancel失败会一直重试，直到成功，讲道理来说，confirm失败也应该调用对应的cancel，cancel失败不断重试就完美了。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 事务-3.TCC事务" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/%E4%BA%8B%E5%8A%A1/3.tcc%E5%8F%8A%E5%8F%98%E7%A7%8D%E6%96%B9%E6%A1%88/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>事务-6.seata</h2></header><div class=entry-content><p>seata原理 AT模式原理 首先有一个Seata Server负责控制事务的提交和回滚，每个服务里需要引入seata client负责监听sql，并生成对应的undo_log，undo_log存储在表里，并且操作本地数据和插入undo_log在同一本地事务中，当服务完成本地事务后需要告诉Seata Server分支事务提交成功，所有分支事务都完成后(那个角色提交？)向Seata Server提交事务并释放全局锁，如果存在某个服务发生异常，此时Seata Server会向提交分支事务成功的服务发送执行回滚日志消息，再由seata client执行对应的undo_log。
![seataAT模式](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/seata AT模式.png)
读写隔离原理 seata的隔离级别是读未提交，未提交指的是分布式事务没有提交，并不是本地事务。
首先完整的流程如下图，在提交本地事务前必须要通过Seata Server获取全局锁，其他分布式事务在没有拿到全局锁前不能提交本地事务，如果没有全局锁会导致多个分布式事务同时操作一条数据，发生回滚时数据错乱的问题，但是引入的全局锁会让性能下降的严重，所以AT模式的分布式事务只用在跟钱相关的操作里，其他时候如果需要用到分布式事务可以使用mq的软事务。
![seataAT模式读写隔离原理](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/seata AT模式读写隔离原理.png)
死锁问题 比如上图两个事务操作同一条数据，事务1中服务A的操作执行完成并且提交了本地事务，此时事务2开始执行服务A的操作，此时全局锁在事务1上，所以事务2的服务A没法提交本地事务，他会等待拿到全局锁，但是这个时候他是持有11001的本地锁的，事务1在执行服务B操作的时候发生异常需要回滚，服务A收到回滚消息需要拿到11001的本地锁，出现了事务1持有事务2需要的全局锁，事务2持有事务1需要的本地锁，循环等待了，seata为了解决这个死锁问题在获取全局锁的时候加了个超时机制，如果超时会回滚数据并释放锁。
使用seata 前提：Seata Server启动好，每个服务对应的库创建好undo_log表。
pom中添加依赖：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 &lt;!-- 引入seata整合分布式事务 --> &lt;dependency> &lt;groupId>com.alibaba.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-alibaba-seata&lt;/artifactId> &lt;exclusions> &lt;exclusion> &lt;groupId>io.seata&lt;/groupId> &lt;artifactId>seata-spring-boot-starter&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;!-- 跟安装的seata-server需要保持版本一致 --> &lt;dependency> &lt;groupId>io.seata&lt;/groupId> &lt;artifactId>seata-spring-boot-starter&lt;/artifactId> &lt;version>1.3.0&lt;/version> &lt;/dependency> 添加配置：
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to 事务-6.seata" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/%E4%BA%8B%E5%8A%A1/6.seata/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>事务-可靠消息最终一致性事务</h2></header><div class=entry-content><p>一些耗时的操作可以使用这个。
步骤5.1失败了：
可靠消息服务更新状态为已发送：一直会有一条状态时待确认的消息； 可靠消息服务删除消息失败：一直会有一条状态是待确认的消息； 不管是那种情况操作失败了，都是比较尴尬的。
步骤7失败：可靠消息服务一直有一条状态是已发送的消息；
可以看出来出现尴尬问题的点都在可靠消息服务上。
解决步骤5.1失败：回调机制，可靠消息服务后台线程定时扫描超时的待确认消息，然后回调上游服务，上游服务返回这条消息对应的业务处理结果是成功还是失败，如果失败就删掉这条消息，如果是成功就执行步骤5.2。
解决步骤6、7失败：可靠消息服务后台线程定时扫描超时的已发送消息，重新投递到消息队列中，不过下游消息要做好幂等性。
一般做这种事务都不要太依赖mq，mq只是作为存储消息的中间件，这样mq的bug不会影响到我们系统，而且以后想换mq或者升级也不会受到影响。
这套方案的缺陷非常明显，可靠消息服务全部基于MySQL，扛不住高并发。数据量也很大，可以用redis或者zk来代替MySQL，定时清理数据。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 事务-可靠消息最终一致性事务" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/%E4%BA%8B%E5%8A%A1/5.%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>最终一致性框架</h2></header><div class=entry-content><p>RocketMQ事务消息缺点 首先使用RocketMQ的事务消息会增加额外的代码，比如提交half失败，要实现mq定时回查的接口，最关键的是如果mq短时间故障，在业务开始之前创建half消息失败的时候就要返回系统异常，但是业务明明没问题，不应该让mq拖垮业务。
因为mq问题导致数据库或者分布式事务全部回滚的强一致方案是没有容错性的，可以使用本地消息表代替事务消息，将发送失败的消息暂存，定时重试。
框架的功能 有了软事务的框架后只要是非核心的动作(比如写redis、写MySQL、第三方接口调用等等)，如果不想让他们的失败拖垮核心链路都可以用本地消息表的方案解决，异常的非核心action操作一直重试就可以了。
但是一些操作比如调三方可能需要延迟或者降级的操作，比如发送短信一个三方发送失败就去调另一个三方执行降级逻辑，所以框架还要有延迟、降级功能。
如果重试到了最大次数还是失败怎么办？此时可能需要一个报警通知的功能。
整体流程如下： 数据库结构： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 CREATE TABLE `orderorigin_tend_consistency_task` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键自增', `task_id` varchar(300) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户自定义的任务名称，如果没有则使用方法签名', `task_status` tinyint NOT NULL DEFAULT '0' COMMENT '执行状态', `execute_times` int NOT NULL COMMENT '执行次数', `execute_time` bigint NOT NULL COMMENT '预计执行时间', `parameter_types` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '参数的类路径名', `method_name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '方法名', `method_sign_name` varchar(300) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '方法签名', `execute_interval_sec` int NOT NULL DEFAULT '60' COMMENT '执行间隔', `delay_time_sec` int NOT NULL DEFAULT '60' COMMENT '延迟时间', `task_parameter` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '方法参数', `performance_way` tinyint NOT NULL COMMENT '执行模式：1、立即执行 2、调度执行', `thread_way` tinyint NOT NULL COMMENT '线程模型 1、异步 2、同步', `ensure_idem` bit NOT NULL COMMENT '幂等性保证', `error_msg` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '执行的error信息', `alert_expression` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '告警表达式', `alert_action_bean_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '告警逻辑的的执行beanName', `fallback_class_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '降级逻辑的的类路径', `fallback_error_msg` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '降级失败时的错误信息', `created_time` datetime NOT NULL COMMENT '创建时间', `modified_time` datetime NOT NULL COMMENT '修改时间', PRIMARY KEY (`id`), INDEX `nk_status_execute_time_key` (`task_status`,`execute_time`) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci; 执行任务逻辑 任务状态：0 初始化；1 执行失败；2 执行中；3 执行成功；
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 最终一致性框架" href=https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6/1.%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E6%A1%86%E6%9E%B6/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wangxiaohong123.github.io/categories/%E6%A1%86%E6%9E%B6/page/2/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>