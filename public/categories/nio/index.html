<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>NIO | 王小红的笔记</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/categories/nio/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css" integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/categories/nio/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/categories/nio/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="/katex/katex.min.css">
<script defer src="/katex/katex.min.js"></script>
<script defer src="/katex/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: "$$", right: "$$", display: true},
        {left: "$", right: "$", display: false},
        {left: "\\(", right: "\\)", display: false},
        {left: "\\[", right: "\\]", display: true}
      ]
    });
  });
</script>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="王小红的笔记 (Alt + H)">王小红的笔记</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="笔记">
                    <span>笔记</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    NIO
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">1.NIO-buffer
    </h2>
  </header>
  <div class="entry-content">
    <p>一 创建缓冲区 创建缓冲区有3种方式：
1.创建空缓冲区 创建空缓冲区适合用在从磁盘文件读取数据或者从网络里读取数据
1 ByteBuffer buffer = ByteBuffer.allocate(10); 2.创建有数据的缓冲区 把现有数据写入磁盘或者网络
1 2 byte[] data = new byte[] {1, 2, 3}; ByteBuffer buffer = ByteBuffer.wrap(data); 3.direct缓冲区 正常的缓冲区前面还有一个jvm的缓冲区(堆外内存)，读取和写入都是要经过jvm的缓冲区，使用direct模式创建缓冲区，就没有jvm的缓冲区，性能会高一点
1 ByteBuffer buffer = ByteBuffer.allocateDirect(10); 不管是把jvm内存中的数据刷到磁盘、socket或者从磁盘读取数据到jvm，都是要先经过一个buffer。
二 buffer demo capacity：缓冲区的大小； limit：limit是用来卡死一个界限，比如buffer中有5个数据（1到5），limit指向3，就只能操作第3位之前的数据1、2、3这三个个数，默认limit和capacity是一样的； position：下一个读取数据的位置； mark：就是一个标记，调用reset()方法时，position会回到mark的位置； remaining：当前position距离limit还有多少位； 一般常用的byteBuffer、charBuffer，像什么longBuffer之类的没用过；
1 2 3 4 5 6 7 8 9 10 11 12 // 操作缓冲区 byte[] data = new byte[] {1, 2, 3}; ByteBuffer buffer = ByteBuffer.wrap(data); System.out.println(buffer.capacity()); System.out.println(buffer.position()); // 设置position的位置 buffer.position(1); System.out.println(buffer.limit()); // 从buffer中读取一位 System.out.println(buffer.get()); // 设置mark buffer.mark(); 三 常见方法 clear()：把position变成0，limit变成capacity，废弃mark，并不是删除数据了，这样再写的时候可以覆盖旧的数据； flip()：把limit变成position，然后position变成0，这样的话在读取数据就只能从0读取到之前的position了； rewind()：limit不变，position变成0，比如说刚读完一遍数据，还想在读一遍，用这个方法就可以了； reset()：让position回到mark位置，但是需要先调用mark()方法，否则会报错； get()：读取数据，可以直接把数据读到数组中； put()：插入或覆盖数据，可以直接写入数组； </p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 1.NIO-buffer" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/nio/1.buffer/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">2.NIO-channel
    </h2>
  </header>
  <div class="entry-content">
    <p>在buffer读取或者写入数据到磁盘或者socket的时候是要先写入channel的，数据管道的角色。
写数据 1.使用buffer加channel往磁盘顺序写数据demo 顺序写就是一直往后追加：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 构造一个传统的文件输出流 FileOutputStream out = new FileOutputStream(&#34;/Users/xiaohong/IdeaProjects/io_temp/hello.txt&#34;); // 通过文件输出流获取fileChannel，以nio的方式写文件 // getChannel的时候使用的Synchronized加锁，可以保证多线程操作的时候是同一个FileChannel时是线程安全的 // 新创建的channel的position是0，多个线程操作同一个channel时需要注意position的变化 FileChannel channel = out.getChannel(); ByteBuffer buffer = ByteBuffer.wrap(&#34;hello word&#34;.getBytes()); // 顺序写 channel.write(buffer); // position变成0，在写一遍buffer中的内容 buffer.rewind(); channel.write(buffer); // 强迫这个fileChannel对文件的更新强制刷到磁盘，都则会在OS cache里停留一段时间 // true就是文件元数据的修改也强制刷到磁盘上 channel.force(true); channel.close(); out.close(); // 写完后文件里的内容：hello worldhello world 2.使用buffer加channel往磁盘随机写数据demo 随机写就是从指定位置开始写，会覆盖原有内容：
...</p>
  </div>
  <footer class="entry-footer">2 min</footer>
  <a class="entry-link" aria-label="post link to 2.NIO-channel" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/nio/2.channel/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">3.NIO-selector
    </h2>
  </header>
  <div class="entry-content">
    <p>selector是专门在网络通信中使用的，多路复用思想。基于操作系统底层的select机制，监听所有客户端的连接，收到请求不会处理，一般都是交给一个队列，这样selector就专门干监听，我们只要创建一个线程池，每个线程绑定一个队列，消费这个队列就可以了。
NIO网络demo-服务端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 public class NIOServer { private static final CharsetEncoder encoder = Charset.forName(&#34;UTF-8&#34;).newEncoder(); private static final CharsetDecoder decoder = Charset.forName(&#34;UTF-8&#34;).newDecoder(); private static ByteBuffer readBuffer; private static Selector selector; public static void main(String[] args) { init(); listen(); } private static void init(){ // 读取请求数据的缓冲区 readBuffer = ByteBuffer.allocate(1024); // 监听客户端连接的channel ServerSocketChannel servSocketChannel; try { servSocketChannel = ServerSocketChannel.open(); // 设置为非阻塞 // 否则SocketChannel没有事件时，selector会一直阻塞住，不去监听其他channel servSocketChannel.configureBlocking(false); // 9000是服务端监听的端口号 // backlog是请求的队列长度是100，意思就是最多支持100个客户端保持连接 servSocketChannel.socket().bind(new InetSocketAddress(9000), 100); selector = Selector.open(); // 把servSocketChannel注册到selector上，并且配置监听的事件是OP_ACCEPT // OP_ACCEPT的意思是tcp连接请求 servSocketChannel.register(selector, SelectionKey.OP_ACCEPT); } catch (IOException e) { e.printStackTrace(); } } private static void listen() { while(true){ try{ // 这里会阻塞住，等待有事件产生 // 所以nio是同步非阻塞的 selector.select(); // 一个SelectionKey约等于1个请求 Iterator&lt;SelectionKey&gt; keysIterator = selector.selectedKeys().iterator(); while(keysIterator.hasNext()){ SelectionKey key = keysIterator.next(); keysIterator.remove(); // 处理事件 // 正常来说应该把这个事件放到队列中，交给线程池处理 handleKey(key); } } catch(Throwable t){ t.printStackTrace(); } } } private static void handleKey(SelectionKey key) throws IOException { SocketChannel channel = null; try{ // 处理连接请求 if(key.isAcceptable()) { ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel(); // 进行tcp3次握手后会生成一个socketChannel // 通过socketChannel就可以实现和客户端收发数据 channel = serverChannel.accept(); channel.configureBlocking(false); // 把SocketChannel注册到selector上，并设置监听的请求是OP_READ channel.register(selector, SelectionKey.OP_READ); } else if(key.isReadable()) { // 处理客户端发送过来的数据 channel = (SocketChannel) key.channel(); // 缓冲区复位 readBuffer.clear(); // 把数据写入到缓冲区 int count = channel.read(readBuffer); if(count &gt; 0) { // 让position变成0，limit变成接收到的字符长度 // 这样就可以只读取这次收到的数据了 readBuffer.flip(); CharBuffer charBuffer = decoder.decode(readBuffer); System.out.println(&#34;收到请求：&#34; &#43; charBuffer.toString()); // 返回响应 channel.write(encoder.encode(CharBuffer.wrap(&#34;收到&#34;))); } else { channel.close(); } } } catch(Throwable t) { t.printStackTrace(); if(channel != null){ channel.close(); } } } } NIO网络demo-客户端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 public class NIOClient { private static final CharsetEncoder encoder = Charset.forName(&#34;UTF-8&#34;).newEncoder(); private static final CharsetDecoder decoder = Charset.forName(&#34;UTF-8&#34;).newDecoder(); public static void main(String[] args) { for(int i = 0; i &lt; 10; i&#43;&#43;) { new Worker().start(); } } static class Worker extends Thread { @Override public void run() { SocketChannel channel = null; Selector selector = null; try { // 创建SocketChannel注册到selector上，并且设置关注的事件是OP_CONNECT channel = SocketChannel.open(); channel.configureBlocking(false); channel.connect(new InetSocketAddress(&#34;localhost&#34;, 9000)); selector = Selector.open(); channel.register(selector, SelectionKey.OP_CONNECT); while(true) { selector.select(); Iterator&lt;SelectionKey&gt; keysIterator = selector.selectedKeys().iterator(); while(keysIterator.hasNext()) { SelectionKey key = keysIterator.next(); keysIterator.remove(); // 处理建完连接 if(key.isConnectable()) { if(channel.isConnectionPending()) { if(channel.finishConnect()) { key.interestOps(SelectionKey.OP_READ); channel.write(encoder.encode(CharBuffer.wrap(&#34;你好&#34;))); } else { key.cancel(); } } } else if(key.isReadable()) { // 处理服务端发送过来的数据 ByteBuffer byteBuffer = ByteBuffer.allocate(128); channel.read(byteBuffer); byteBuffer.flip(); CharBuffer charBuffer = decoder.decode(byteBuffer); System.out.println(&#34;收到响应：&#34; &#43; charBuffer.toString()); channel.write(encoder.encode(CharBuffer.wrap(&#34;你好&#34;))); } } } } catch (Exception e) { e.printStackTrace(); } finally { if(channel != null) { try { channel.close(); } catch (IOException e) { e.printStackTrace(); } } if(selector != null) { try { selector.close(); } catch (IOException e) { e.printStackTrace(); } } } } } } SelectionKey，就相当于一个SocketChannel，主要有4个方法 key.isAcceptable()：当有客户端连接时触发，这个时候需要获取ServerSocketChannel调用accept方法，然后注册监听事件； key.isConnectable()：表示建立连接成功或者失败或者还没完成，需要在内部继续判断是否完成连接； key.isWritable()：可以写数据； key.isReadable()：读取数据； ...</p>
  </div>
  <footer class="entry-footer">3 min</footer>
  <a class="entry-link" aria-label="post link to 3.NIO-selector" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/nio/3.selector/"></a>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">王小红的笔记</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
