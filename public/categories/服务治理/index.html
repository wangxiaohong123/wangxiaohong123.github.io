<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>服务治理 | 王小红的笔记</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css" integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="/katex/katex.min.css">
<script defer src="/katex/katex.min.js"></script>
<script defer src="/katex/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: "$$", right: "$$", display: true},
        {left: "$", right: "$", display: false},
        {left: "\\(", right: "\\)", display: false},
        {left: "\\[", right: "\\]", display: true}
      ]
    });
  });
</script>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="王小红的笔记 (Alt + H)">王小红的笔记</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="笔记">
                    <span>笔记</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    服务治理
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">服务治理-1.异常治理
    </h2>
  </header>
  <div class="entry-content">
    <p>治理就是说捕获和上抛异常、处理异常、封装和定义异常(规范化异常)。线上的而系统出现异常一般都是堆外提供的接口处，大概有4个地方：http接口：对应前端的一个功能。rpc接口：给其他系统调用的一个功能。mq消费。调度线程。
错误码规范 code总长度为6位：
前两位是微服务或者通用异常，比如客户端异常异常(缺少参数、请求类型错误)10，探索服务是11，动态服务是12。 中间两位是每个服务对应的模块或者域。 后两位递增表示具体异常。 通常来说每个系统要有自己的异常类，这样看日志就知道出现问题的系统是哪个。
统一异常拦截 异常都会在出口处理，把异常封装成统一的实体返回，mq消费和调度线程可以包在try catch中，但是htto和rpc的接口太多，需要统一处理。
controller层 controller层的同一异常只需要在处理类上添加@RestControllerAdvice注解，然后定义多个方法处理不同异常，每个方法上添加@ExceptionHandler(value=异常类)就可以了：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Slf4j @RestControllerAdvice @Order public class GlobalExceptionHandler { // =========== 系统级别未知异常 ========= @ExceptionHandler(value = Exception.class) public JsonResponse&lt;Object&gt; handle(Exception e) { log.error(&#34;[ 系统未知错误 ]&#34;, e); return JsonResponse.createByError(SYSTEM_DEFAULT_ERROR); } // =========== 客户端异常 ========= /** * 1001 HTTP请求方法类型错误 */ @ExceptionHandler(value = HttpRequestMethodNotSupportedException.class) public JsonResponse&lt;Object&gt; handle(HttpServletRequest request, HttpRequestMethodNotSupportedException e) { log.error(&#34;[客户端HTTP请求方法错误]uri-&gt;{}&#34;, request.getRequestURI(), e); return JsonResponse.createByError(CLIENT_HTTP_METHOD_ERROR); } ………… /** * 系统自定义业务异常 */ @ExceptionHandler(value = BaseBizException.class) public JsonResponse&lt;Object&gt; handle(BaseBizException e) { log.error(&#34;[业务异常:{},{}]&#34;, e.getErrorCode(), e.getErrorMsg()); return JsonResponse.createByError(e.getErrorCode(), e.getErrorMsg(), e.getData()); } } rpc层 rpc通过dubbo的SPI扩展机制自定义过滤器实现，创建两个过滤器，第一个过滤器负责处理自定义异常，不让dubbo封装成RuntimeException，第二个过滤器负责把自定义异常封装成JsonRponse。
...</p>
  </div>
  <footer class="entry-footer">3 min</footer>
  <a class="entry-link" aria-label="post link to 服务治理-1.异常治理" href="http://localhost:1313/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/1.%E5%BC%82%E5%B8%B8%E6%B2%BB%E7%90%86/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">服务治理-3.监控系统
    </h2>
  </header>
  <div class="entry-content">
    <p>监控系统选型 prometheus、zabbis、nagios、open-falcon进行选型
监控系统 语言 成熟度 扩展性 性能 社区活跃 容器支持 企业使用 zabbix c &#43; php 高 高 低 中 低 高 nagios c 高 中 中 低 低 低 open-falcon go 中 高 高 中 中 中 prometheus go 中 高 高 高 高 高 zabbis和nagios的成熟度、企业使用高是因为他俩诞生的造，已经超过20年了。但是zabbix存储使用MySQL是硬伤，他不适合大规模的集群监控，nagios使用的是一个环形数据库，性能会稍微高一点，open-falcon底层是opensTSDB和基于graph分片存储的RRD环形数据库，prometheus是自研的时序数据库，也可以指定其他数据库。prometheus的社区活跃、国内外企业使用都非常高，open-falcon一般是小米(他就是小米开源的)、美团、滴滴这些大厂在用。
prometheus环境搭建 安装prometheus 到官网下载最新版本的prometheus，上传到服务器并解压：
1 tar -zxvf prometheus-2.35.0.linux-amd64.tar.gz 修改包名：
1 mv prometheus-2.35.0.linux-amd64 prometheus 进入prometheus目录验证版本：
1 ./prometheus --version prometheus默认的配置在prometheus.yml中：
...</p>
  </div>
  <footer class="entry-footer">2 min</footer>
  <a class="entry-link" aria-label="post link to 服务治理-3.监控系统" href="http://localhost:1313/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/3.%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">服务治理-4.单测
    </h2>
  </header>
  <div class="entry-content">
    <p>合格的单元测试 一个优秀的单元测试应该满足5个条件：
可验证：当单侧代码运行完就可以验证业务代码是否有问题，而不是通过肉眼去看log，即使用assert来判断结果。 可重复：当单测写好后是可以不分环境不分时间的运行的，比如依赖MySQL，想MySQL中插入数据区测试，如果数据被删或者在测试环境都没有这个数据了，这个单测没法进行，就是说要避免对基础环境(redis、es、MySQL、mq等)和外部接口(rpc接口)的依赖。执行完单测后应该恢复现场， 把之前准备的数据和单测过程中产生的数据全部释放或者删掉。 独立性：单测方法之间独立，单测的方法不能依赖其他单测方法的结果。并且每个单测方法只测试一种情况。 彻底的：核心逻辑的所有分支都要覆盖，整体覆盖率不低于70%。 专业的：测试代码也要有可维护性，因为业务变更频繁，所以单测也会频繁修改和扩展，所以要保证单测的类的职责单一，方法命名清晰，降低方法的复杂度，保证可扩展性。 PowerMock框架使用 常见的框架一般就是Mockito 2.x：官网(https://mockito.org)及(https://github.com/mockito/mockito )和PowerMock 2.x：官网(https://github.com/powermock/powermock)。PowerMock 2.x扩展了了EasyMock和Mockito。Mockito基于Cglib模拟public访问权限类型的方法，PowerMock基于javassist和objenesis来修改类的字节码 &#43; ⾃定义类加载器模拟public、private、static、final等访问权限修饰的⽅法。
使用PowerMock之前需要初始化：
1 2 3 4 @Before public void init() { MockitoAnnotations.initMocks(this); } 然后使用@MockBean标注需要被mock的bean，这个注解会将⼀个spring bean的所有⽅法变成⼀个空⽅法，然后配合**PowerMockito.when().thenReturn()或者PowerMockito.doNothing().when()**来mock数据。
有一个和@MockBean类似的注解是@SpyBean，他的意思是说spring bean保持原样，只有调用了比如PowerMockito.doReturn().when()这种代码后这个方法才会被mock。当我们不想所有方法都mock的时候可以使用这个注解。
@Rule注解是配合JUnit4使用的，他用来断言抛出的异常是否是期望的异常，JUnit5使用过**Assert.assertThrows()**来验证异常。
这么写单测需要花费大量的时间，特别是造数据和清理数据。很有可能单测的代码要比业务逻辑的代码要多。所以一些外部系统，比如redis、es可以使用测试环境，这样会大幅度降低造数据和清理数据消耗的时间。
</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 服务治理-4.单测" href="http://localhost:1313/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/5.%E5%8D%95%E6%B5%8B/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">服务治理-4.日志
    </h2>
  </header>
  <div class="entry-content">
    <p>日志规范 接口的入口和出口需要有日志，包括controller和service，级别是info。 关键步骤也需要有日志。 抛出异常前也需要打印日志，级别视情况而定，可以是info，也可以是error。 catch中也要打印日志，并且要输出异常信息，级别是error。 遇到if else分支时尽量打印日志。 核心功能模块建议打印完整日志。 统一系统、操作日志组件 参考美团文档[如何优雅地记录操作日志？]
系统日志和操作日志是不一样的，系统日志是各个功能运行流转过程中，打印出来的各种日志，能够根据日志还原出来运行的完整过程；操作日志是某个用户执行某些重要操作的时候，把操作日志记录持久化，后续可以随时查询操作。
ELK搭建 es和kibana安装参考之前笔记。
Logstash部署 需要采集的日志服务器都需要安装。
到官网下载安装包，创建目录：
1 mkdir -p /app/logstash 上传到目录下解压，进入解压后的bin目录，安装logstash json插件：
1 ./logstash-plugin install logstash-codec-json_lines 创建用户，修改/app/logstash的属组和属主：
1 2 3 useradd logstash passwd logstash chown -R logstash:logstash /app/logstash 在config目录下创建logstash.conf：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 input { # 输⼊ file { # ⽇志路径 path =&gt; &#34;/app/logstash/logs/test.log&#34; # 从头开始 start_position =&gt; &#34;beginning&#34; # 设置多⻓时间扫描⽬录发现新⽂件 discover_interval =&gt; 600 # 设置多⻓时间检测⽂件是否修改,默认是 1 秒 stat_interval =&gt; 1 } } filter{ # 对数据进⾏各种处理，如过滤，切割等 # grok和date是解决Kibana显示时间与应⽤⽇志时间不⼀致问题，还需要在kibana中选择Stack Management--&gt;高级设置--&gt;时区选择UTC grok { # 提取⽇志中的时间并设置为临时变量 match =&gt; { &#34;message&#34; =&gt; &#34;%{TIMESTAMP_ISO8601:logdate}&#34; } } date { # 设置变量的时间格式 match =&gt; [ &#34;logdate&#34;, &#34;YYYY-MM-dd HH:mm:ss.SSS&#34; ] # 需要替换的⽬标字段 target =&gt; &#34;@timestamp&#34; timezone =&gt;&#34;&#43;00:00&#34; } multiline { # 时间正则表达式，合并多⾏⽇志 pattern =&gt; &#34;^\d{4}-\d{1,2}-\d{1,2}\s\d{1,2}:\d{1,2}:\d{1,2}&#34; negate =&gt; true # 向前合并 what =&gt; &#34;previous&#34; } } output { # 输出 elasticsearch { hosts =&gt; [&#34;http://172.19.17.29:9200&#34;,&#34;http://172.19.17.28:9200&#34;,&#34;http://172.19.17.2 7:9200&#34;] # 指定索引名称 index =&gt; &#34;stars-log-%{&#43;YYYY.MM.dd}&#34; } logstash：
...</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 服务治理-4.日志" href="http://localhost:1313/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/4.%E6%97%A5%E5%BF%97/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">服务治理-5.DevOps
    </h2>
  </header>
  <div class="entry-content">
    <p>持续集成和持续交付 持续集成就是说每天或者说每次有人提交代码到gitlab，gitlab会通知jenkins服务器，然后jenkins把代码拉下来，使用mvn编译，打包，运行所有单元测试，如果单测没问题就说明本次提交到总代码里成功。
持续交付的意思是每隔一段时间比如一周让jenkins拉取最新的代码然后自动化的通过设置的脚本和命令部署到测试，持续性的交付可以运行、测试的完整版本的代码出来，测试完之后就可以让jenkins自动化部署到生产了，持续交付版本。
devOps持续集成和持续交付软件体系： gitlab -&gt; 公司代码私有仓库，jenkins -&gt; 持续集成 &#43; 自动化测试 &#43; 测试代码覆盖率 -&gt; 代码质量检测(SonarQube) &#43; 持续自动化部署，docker &#43; k8s，加上前面的监控。
软件安装 gitlab SonarQube Jenkins</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 服务治理-5.DevOps" href="http://localhost:1313/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/6.devops/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">链路追踪-1.原理
    </h2>
  </header>
  <div class="entry-content">
    <p>APM(Application Performance Monitor) 应用性能监控系统，他要监控到每个请求链路调用了那些环节，那些节点，每个节点的耗时，是否有异常，整个请求链路的TPS、性能延迟，出了问题能够快速便捷的看到某一次请求的日志。
SkyWalking模块 探针：在要监控的节点上通过注解的方式加上探针，这种无侵入的加探针的方式叫做插桩。 OAP平台：observability analysis platform，观察分析平台，需要独立部署。他会接收探针上报数据的请求。 存储模块：支持多种存储，es、mysql、hbase等等。 UI模块：统计数据查询和展现。 增强原理 主要是依靠java agent技术实现class字节码增强，当jvm加载class的时候会触发ClassFileLoadHool事件，然后遍历所有的instrumentation并执行里面的ClassFileTransformer的transform()方法，instrumentation就相当于类信息，transform()方法的入参有ClassLoader、ClassName、byte[]等等类信息，在SkyWalking的java agent中，就是在他的premain()方法中把所有的ClassFileTransformer添加到instrumentation里。
链路追踪模型 在sky walking中一次方法的调用成为span，span中有spanId和parent spanId，第一个span的parent id是null，第一个parent id为null的span会开启一个trace id，一个trace id对应一条链路。span有3中类型，entry、local、exit。
entry是一般是http server收到的请求。 local是相同进程内的方法的调用。 exit表示trace segment出来，比如发起rpc请求或者调用数据库。 sky walking的trace segment是进程内所有span的集合，上报时会以segment为单位组装上报，提升效率，entry span就是trace segment的第一个span。
内核轻量级队列模型 oap server收到上报数据之后会把数据放到内存队列中，在去进行消费、聚合、计算、持久化，oap server使用的内存队列是一个循环队列。
首先有个概念叫DataCarrier，他负责管理Channel，Channel负责管理buffer，每个Buffer表示一个数组，这个数组才是一个真正的队列。DataCarrier有两个参数，channel_size和buffer_size，channel_size表示Channel中有多少个buffer，buffer_size表示buffer中的数组长度。DataCarrier中还有一个组件IDataPartitoner，他负责处理数据应该路由到那个buffer。
buffer中持有一个index(此次数据应该写入的索引)和BufferStrategy strategy(队列策略)，因为buffer的数据是个循环数组，所以当往index上写入数据的时候发现这个数据没有被消费，需要对应的策略，他有三种实现，blocking阻塞等待&#43;callbacks回调，override覆盖以及if_possible往后找空闲位置。
当buffer注册到DataCarrier上时会指定n个线程去消费，1个线程消费1个或者多个buffer，也有可能多个线程消费一个buffer，每个线程内部有一个consumeList，大小为1500，间隔consumCycle秒时开始扫描buffer，当发现存在不为null的数据后就放入自己的consumeList，扫描完后如果有数据就交给处理器中的处理函数。
</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 链路追踪-1.原理" href="http://localhost:1313/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2.%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/1.%E5%8E%9F%E7%90%86/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">链路追踪-2.环境搭建
    </h2>
  </header>
  <div class="entry-content">
    <p>首先去官网[https://archive.apache.org/dist/skywalking/]点击8.5.0/，下载apache-skywalking-apm-es7-8.5.0.tar.gz，因为这个版本的和我们的es版本一致。下载之后解压，解压后的主要目录：
agent⽬录将来要拷⻉到各服务所在机器上⽤作探针 bin⽬录是服务启动脚本 config⽬录是配置⽂件 oap-libs⽬录是oap服务运⾏所需的jar包 webapp⽬录是web服务运⾏所需的jar包 确保es7.8.5可用
单机版 进入解压后的目录中。
修改config/application.yml配置文件：
1 vim config/application.yml 修改存储方式是es7，并修改elasticsearch7的配置：
1 2 3 4 5 6 7 storage: selector: ${SW_STORAGE:elasticsearch7} elasticsearch7: # 这个感觉是es集群名称 nameSpace: ${SW_NAMESPACE:&#34;escluster&#34;} # 默认是9200，改成我们自己的es的端口，es集群的多个地址用逗号分割 clusterNodes: ${SW_STORAGE_ES_CLUSTER_NODES:127.0.0.1:9300} 修改jvm配置：
1 vim bin/oapService.sh 调整堆内存大小：
1 JAVA_OPTS=&#34;${JAVA_OPTS:- -Xms512M -Xmx512M}&#34; 启动oap服务：
...</p>
  </div>
  <footer class="entry-footer">2 min</footer>
  <a class="entry-link" aria-label="post link to 链路追踪-2.环境搭建" href="http://localhost:1313/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2.%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/2.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">链路追踪-3.使用
    </h2>
  </header>
  <div class="entry-content">
    <p>agent配置信息大全
启动脚本配置 intellij启动 进入edit configurations配置界面，配置vm options：
1 -javaagent:[agent目录]/agent/skywalking-agent.jar Environment variables添加配置：
1 SW_AGENT_COLLECTOR_BACKEND_SERVICES=ip:11800;SW_AGENT_NAME=[服务名] 生产环境启动 启动脚本中添加如下配置：
1 2 3 4 5 # skywalking-agent.jar所在位置 -javaagent:${AGENT_ADDR} # oap服务的ip:端口 -Dskywalking.collector.backend_service=${OAP_SERVER} -Dskywalking.agent.service_name=${APP_NAME} 为接口添加注解 项目中添加依赖：
1 2 3 4 5 6 7 8 9 10 11 &lt;dependency&gt; &lt;groupId&gt;org.apache.skywalking&lt;/groupId&gt; &lt;artifactId&gt;apm-toolkit-trace&lt;/artifactId&gt; &lt;version&gt;${skywalking.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.skywalking&lt;/groupId&gt; &lt;artifactId&gt;apm-toolkit-opentracing&lt;/artifactId&gt; &lt;version&gt;${skywalking.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 然后在service接口上添加@Trace和@Tags注解，@Tags里面传@Tag数组，入下图，arg[0]表示方法第一个参数，returnedObj表示方法的返回值，这两个注解可以帮助我们在查看链路时的方法中标记入参和返回值： ...</p>
  </div>
  <footer class="entry-footer">4 min</footer>
  <a class="entry-link" aria-label="post link to 链路追踪-3.使用" href="http://localhost:1313/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2.%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/3.%E4%BD%BF%E7%94%A8/"></a>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">王小红的笔记</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
