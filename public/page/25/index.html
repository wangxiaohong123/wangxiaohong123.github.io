<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.150.0"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>王小红的笔记</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css" integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="/katex/katex.min.css">
<script defer src="/katex/katex.min.js"></script>
<script defer src="/katex/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: "$$", right: "$$", display: true},
        {left: "$", right: "$", display: false},
        {left: "\\(", right: "\\)", display: false},
        {left: "\\[", right: "\\]", display: true}
      ]
    });
  });
</script>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="王小红的笔记 (Alt + H)">王小红的笔记</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="笔记">
                    <span>笔记</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">创建型-工厂方法
    </h2>
  </header>
  <div class="entry-content">
    <p>简单工厂的优点是工厂类中包含了必要的逻辑判断，根据条件动态实例化相关的类，对于客户端来说没有具体类的依赖。工厂方法和简单工厂的区别是工厂方法将类的实例化操作放在子类或者实现类中，而且对于简单工厂来说，说过添加子类需要增加工厂方法中的分支，这也违背了对扩展开放，对修改关闭原则，而且当一个类的创建过程有点复杂，创建这个类会产生大量的重复代码的时候可以提取到工厂方法中创建：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * 工厂方法抽象类 * 当创建类有公用的代码段时可以使用抽象类实现 * * @author xiaohong */ public abstract class FactoryMethod { /** * 创建类实例 * @return */ public abstract MainTestClass getMainTestClass(); } 1 2 3 4 5 6 7 8 9 10 /** * 工厂方法的一个子类 * @author xiaohong */ public class TestClass01FactoryMethod extends FactoryMethod { @Override public MainTestClass getMainTestClass() { return new TestClass01(); } } 测试：
...</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 创建型-工厂方法" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">创建型-建造者模式
    </h2>
  </header>
  <div class="entry-content">
    <p>建造者模式也叫生成器模式
建造者模式 当构造函数需要很多参数，直接调用很容易产生顺序问题； 构造函数参数多的问题可以使用set方法代替，但是如果很多参数需要联合校验，比如判断大小、多个内部属性需要计算赋值等，这时候使用set实现就很麻烦； 如果希望这个对象创建完之后属性不可变，使用set也无法实现； 这时就需要使用建造者模式，并且将构造函数私有化，这时候就只能使用内部的构建类创建对象。JDK中的StringBuilder和StringBuffer就是使用的建造者。
和工厂方法的区别 工厂模式是为了创建相关类型的对象（继承同一父类或者接口），建造者模式是定制化（根据参数的不同和顺序的不同）一个类。在建造者模式中创建的类的属性会在建造类中有一份一模一样的，这部分算是重复代码但是还不能去掉。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 /** * 建造者模式测试实体 * @author xiaohong */ public class Course { private Course(CourseBuilder courseBuilder) { this.courseName = courseBuilder.courseName; this.courseVideo = courseBuilder.courseVideo; this.courseArticle = courseBuilder.courseArticle; } private String courseName; private String courseVideo; private String courseArticle; public String getCourseName() { return courseName; } public void setCourseName(String courseName) { this.courseName = courseName; } public String getCourseVideo() { return courseVideo; } public void setCourseVideo(String courseVideo) { this.courseVideo = courseVideo; } public String getCourseArticle() { return courseArticle; } public void setCourseArticle(String courseArticle) { this.courseArticle = courseArticle; } @Override public String toString() { return &#34;Course{&#34; &#43; &#34;courseName=&#39;&#34; &#43; courseName &#43; &#39;\&#39;&#39; &#43; &#34;, courseVideo=&#39;&#34; &#43; courseVideo &#43; &#39;\&#39;&#39; &#43; &#34;, courseArticle=&#39;&#34; &#43; courseArticle &#43; &#39;\&#39;&#39; &#43; &#39;}&#39;; } /* * 通过静态内部类实现链式调用 */ public static class CourseBuilder { private String courseName; private String courseVideo; private String courseArticle; public CourseBuilder buildCourseName(String courseName) { this.courseName = courseName; return this; } public CourseBuilder buildCourseVideo(String courseVideo) { this.courseVideo = courseVideo; return this; } public CourseBuilder buildCourseArticle(String courseArticle) { this.courseArticle = courseArticle; return this; } public Course build() { // 集中校验 if(StringUtils.isEmpty(courseName)){ throw new IllegalArgumentException(&#34;...&#34;); } return new Course(this); } } } 把实体和构建类写到一起在以后维护时很方便，而且链式调用合一选择构建哪些属性和顺序，调用也很简单：
...</p>
  </div>
  <footer class="entry-footer">2 min</footer>
  <a class="entry-link" aria-label="post link to 创建型-建造者模式" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">创建型-抽象工厂
    </h2>
  </header>
  <div class="entry-content">
    <p>工厂方法针对的是产品的等级结构，而抽象工厂针对的是产品族，用来创建多个相关或相互依赖的对象。
产品等级：不同厂商的相同产品，比如鞋子，所有的厂商的鞋都属于同一等级，比如Nike的鞋，阿迪的鞋； 产品族：相同厂商的不同产品，比如Nike的鞋、Nike的书包属于同一产品族； 通过抽象工厂创建对象需要指定厂商和产品，因为这种情况使用工厂方法模式需要创建跟多的子类或者实现类：
代码就比工厂方法的子类或者实现类多了几个获取实例的方法。
</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 创建型-抽象工厂" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">创建型-简单工厂
    </h2>
  </header>
  <div class="entry-content">
    <p>简单工厂并不是23种设计模式中的，在23中设计模式中，工厂只有两种模式：工厂方法模式和抽象工厂模式。
首先要有一个总的抽象类或者接口MainTestClass，然后利用简单工厂模式创建她的实现类，简单工厂代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * 简单工厂方法 * @author xiaohong */ public class SimpleFactory { /** * 静态方法，当没有继承的需求时比较好用 * @param c * @return */ public static MainTestClass getMainTestClass(Class c) { MainTestClass mainTestClass = null; try { // 根据传入方法的值使用if判断并创建不符合开闭原则，所以这里使用反射创建 mainTestClass = (MainTestClass) Class.forName(c.getName()).newInstance(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } return mainTestClass; } } 测试：
...</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 创建型-简单工厂" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">参数
    </h2>
  </header>
  <div class="entry-content">
    <p>如果是单台机器上启动多个es，他们会把自己绑定在127.0.0.1（回环地址）上，然后去扫描9300~9305端口，自己就可以维护集群了，生产环境不能这么玩，要想和其他服务器的几点通信需要绑定在非回环地址上，es是peer2peer的分布式系统架构，master负责维护集群信息和其他元数据，把变更的信息推送到其他node（data node）。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 # 集群名称，node的这个属性一样才是集群的基本条件，线上一定要修改，否则其他测试node可能会不小心加入这个集群 cluster.name: elasticsearch-prod # 节点名称 node.name: node-elasticsearch-01 # 绑定地址，多机器一定要配这个 network.host: 192.168.0.10 # 这个配置的是master eligible node，在master宕机的时候从eligible node中选出来一个master，默认就是true node.master: true # 这个是是不是存储数据的节点，如果集群很大的时候可以设置3个节点为专门的eligible node，不存存储数据，这个就设成false node.data: true # unicast的中间节点host列表，其他node会和这几个节点通信然后加入集群，一般写三个就够了，有eligible node优先把eligible node写进去 discovery.zen.ping.unicast.hosts: [&#34;host1&#34;, &#34;host2&#34;] # ping的超时时间，可以防止网络问题导致的master选举过慢 discovery.zen.ping_timeout: 3s # 选举之后其他data节点发送一个join加入集群，配置超时时间，超时会重试 discovery.zen.join_timeout: 60s # 强制区分候选节点，避免node.master: false的节点发来请求参与master选举 discovery.zen.master_election.ignore_non_master_pings: true # 这些路径不嫩放在es目录下，方便以后升级 # 存放日志文件 path.logs: /var/log/elasticsearch # 存放数据文件 path.data: /var/data/elasticsearch # 选举的时候最少要求多少候选节点通过，设置为候选节点的quorum（num / 2 &#43; 1）数量 # 三个节点的集群quorum就是2，如果只有两个节点，quorum还是2，有一台机器宕机的时候就不能完成选举 # 如果两个节点，参数设置成1，那么就会随便发生脑裂，因为一个机器一下就把自己变成master了 discovery.zen.minimum_master_nodes: 2 # shard recover操作：当有一些几点无法启动或者还没启动的时候，es检测到已经启动的节点上的shard不正常，比如没有primary， # 就会复制出primary shard，当剩下节点启动之后，发现自己的shard过期就会把shard删除， # 集群发现shard分配不均匀，因为有些机器上一个shard没有，这时候又会把别的节点上的shard转到新启动的节点上，这样是很坑的 # 这三个参数是一起的，意思是在2个node上线之后开始计时，如果1分钟内节点数达到3个就OK，没达到就执行shard recover操作 gateway.recover_after_nodes: 2 gateway.expected_nodes: 3 gateway.recover_after_time: 1m # 锁定jvm内存，防止swaping bootstrap.memory_lock: true # 慢查询日志 index.search.slowlog.threshold.query.warn: 10s index.search.slowlog.threshold.query.info: 5s index.search.slowlog.threshold.query.debug: 2s index.search.slowlog.threshold.query.trace: 500ms index.search.slowlog.threshold.fetch.warn: 1s index.search.slowlog.threshold.fetch.info: 800ms index.search.slowlog.threshold.fetch.debug: 500ms index.search.slowlog.threshold.fetch.trace: 200ms index.indexing.slowlog.threshold.index.warn: 10s index.indexing.slowlog.threshold.index.info: 5s index.indexing.slowlog.threshold.index.debug: 2s index.indexing.slowlog.threshold.index.trace: 500ms index.indexing.slowlog.level: info index.indexing.slowlog.source: 1000 在启动的时候指定配置文件地址，-d后台启动：
...</p>
  </div>
  <footer class="entry-footer">2 min</footer>
  <a class="entry-link" aria-label="post link to 参数" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/es/9.%E5%8F%82%E6%95%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">基本概念
    </h2>
  </header>
  <div class="entry-content">
    <p>最开始linux的作者都是手动把社区的人贡献的代码合并的内核源码中，然后代码越来越多，版本、冲突不好解决就把源码放在bitkeeper，bitkeeper是商用的，但是给了作者免费的授权，过了一段时间社区有个人想破解这个gitkeeper被发现了，然后就收回了免费使用权，于是linux作者就自己写了一个版本控制系统，Git。
Git是把仓库的版本快照都放在本地，和SVN不一样，如果仓库服务器卡了，SVN是提不了代码的，Git可以生成新的版本快照存在本地，然后在推到服务器，如果仓库服务坏了，代码丢了，SVN就废了，Git就不一样了，他把快照放在本地，服务器用不了还可以把本地的快照推到新服务器就好了。
创建项目 执行init就可以把一个项目交给Git管理，会创建一个.git的隐藏目录，需要提交代码的时候先add在commit就好了，不过这样commit会把所有改变都提交上去，有些文件比如intellij的.idea文件我们不想提上去就要创建一个.gitignore文件，把不想提的代码写进去，commit之后只是在本地的Git更新了版本。
windows在git init之前需要先执行git config --global core.autocrlf false，Mac不需要。
存放代码的地方叫做工作区，.git文件中分为暂存区和仓库，当执行add命令的时候会把工作区的代码放到暂存区，commit的时候会把缓存区的代码变更放到仓库中。
术语 tracked：提交到暂存区或者仓库中的文件；
untracked：从来没有被git追踪过版本的，比如新建的文件，或者在.gitignore文件中排除的文件；
三种状态：modified：修改未提交；staged：在暂存区；commited：提交到本地仓库；
工作流 集中式工作流： 需求的更新频率很低，开发人两个人一下的小工程，不需要分支，直接在master上开发。
功能分支工作流： 适合少人数开发或者公司内部系统，没有什么版本概念，每个人都从一个主分支上拉到自己的featrue分支进行开发，开发完了在合并到主分支上，合并之后有bug就要从分支新建一个bugfix分支进行修改在合并到主分支，合并之后就可以把bug分支删除了；
GitFlow工作流： 他适合项目的版本稳定迭代那种，稳定并且缓慢，如果业务发展很快，迭代很快，还可能设计多个版本并行开发，那么GitFlow并不合适。首先刚创建安完git项目会有一个muster分支，muster是用来发布上线的，然后还有一个develop分支，develop也不是用来开发的，它是用来把成员开发的代码合并起来；还要再有一个release分支，这个分支是用来测试的；还要有一个bugfix分支，用来修改线上的bug。流程差不多是这样：
首先创建git项目，这时候只有muster分支； 以muster分支为基础创建develop分支； 以develop分支为基础创建一堆featrue/XX分支，对应每个开发人； 开发人在自己的featrue分支上开发； 开发完事儿了提交代码然后提交merge request，让leader进行code review然后合并到develop分支，删除这个开发人的分支； 全部合并到develop分支之后，以develop分支为基础创建release分支； 在release分支上QA，然后改bug； 最后把release分支合并到develop分支和master分支，删除release分支然后把master打一个tag，在上线； 上线之后发现bug需要新建bugfix分支，修改在合并到master和develop分支，然后在master分支上打tag，在上线； 升级版GitFlow： 在快速迭代并且多版本并行开发的项目中，使用工作流式非常麻烦，如果都以develop分支为基准，那么不同版本的代码还有很多bug就开始合并，想想都让人头大，解决的办法可以是develop分支把不同版本区分开来，然后在master和release之间多出来一个staging分支，用来合并不同版本的代码打tag上线，因为在QA测试之后代码基本稳定，这时候合并不会有后续频繁的改bug在合并导致的代码冲突问题。
Git服务器 企业自己的git服务器免费的就是gitlab
rebease（变基） 主要是解决分支太多，比如集中式工作流，两个人频繁的解决冲突，这样提交历史看着就很乱
高阶 git生成的40位hash值是为了判断提交之后是否有被修改过，使用前7位的短hash值就可以定位到那次commit，使用git show 【7位短hash值】可以查看那次提交的具体，和reset类似也可以使用git show HEAD^查看head指向的commit明细，git show HEAD~5等等。
查看有多少个分支没有合并到主分支：git log --abbrev-commit --oneline master..featrue/xiaohong这个就是查看featrue/xiaohong分支有多少提交没有合并到master分支。把master和featrue/xiaohong换个位置就是master中有多少提交是featrue/xiaohong没有的。
对比不同的版本差异：分两种情况：
代码没提交，使用git diff HEAD； 代码已提交，git diff HEAD^ HEAD； 把缓存区的代码按功能分次提交：git add -i进入交互模式，选择部分文件从缓存区中还原到unchecked状态，就是选择revert，然后选择文件，然后先把缓存区中的文件提交，在把剩下的文件add --all……；
暂存代码：比如说你正在开发，突然说线上的代码有bug，这时候你需要创建bugfix分支去修改bug，但是切换分支要提交代码，提交开发一半的代码就很low，这个时候可以用暂存功能。执行git stash，就会把代码暂存，然后你修改的代码会恢复到上次提交状态，修改的代码不见了，这个时候就可以去修复bug了，改完了之后切换回这个分支执行git stash apply，把之前暂存的代码恢复然后继续开发。
对commit的备注和代码调整（本地）：git commit --amend，对上次的commit修改备注，然后:wq退出就修改了备注；如果想在提交之后补充代码，直接改代码，然后git add --all .然后在执行git commit --amend，就可以；
...</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 基本概念" href="http://localhost:1313/posts/git/git/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">常用命令
    </h2>
  </header>
  <div class="entry-content">
    <p> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 # 设置用户名和邮箱 # --global：设置当前用户范围内的配置，对机器上的其他用户是无效的 # --system：对当前机器上所有用户都生效 # 什么都不写是对当前所在的git项目本身生效 git config --global user.name &#34;xiaohong&#34; git config --global user.email &#34;2211966086@qq.com.com&#34; # 查看git配置 git config --list # windows初始化git之前需要执行这个 git config --global core.autocrlf false # 初始化git项目 git init # 添加变更，如果不写--all，被删除的文件不会提交 git add --all . # 提交变更 git commit -m &#39;description&#39; # 添加远程仓库，初始化后需要执行一次 git remote add origin https://gitee.com/HongJie123/gitTest.git # 提交到远程仓库。-u的意思是和远程仓库关联，第一次使用之后就不用了 git push -u origin master # 查看托管到git的文件的状态 git status # 查看最近2次提交历史，没有用，有的时候提交的内容很多，根本显示不下，看的你头皮发麻 git log --patch -2 # 只用一行显示，显示commit内容用SHA1的hash算法算出来的hash值，默认显示前7位，--graph是图形化的 git log --oneline --abbrev-commit --graph # 拉取代码 git pull # 变基拉取代码 git pull --rebase # 回退到上一个版本，加上--hard会把工作区也还原 git reset --hard HEAD^ # 回退到倒数第5个版本 git reset --hard HEAD~5 # 回退到d324644的版本，包括回退之前的版本也可以回退 git reset --hard HEAD d324644 # 也是查看log，他可以看到被删除的commit记录和reset的记录，想要还原reset可以用这个命令查看然后git reset --hard HEAD d324644进行还原 git reflog # 创建分支 git branch testing # 切换分支 git checkout testing # 将分支推送到远程仓库 git push -u origin testing # 创建featrue/张三分支并切换 git checkout -b featrue/张三 # 合并分支 git merge featrue/张三 # 删除分支 git branch -d featrue/张三 SSH多账户(云效平台) 多个项目不同的代码管理平台时需要使用多个SSH账户分别绑定项目，先为每个项目创建ssh密钥对：
...</p>
  </div>
  <footer class="entry-footer">2 min</footer>
  <a class="entry-link" aria-label="post link to 常用命令" href="http://localhost:1313/posts/git/%E5%91%BD%E4%BB%A4/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">建模
    </h2>
  </header>
  <div class="entry-content">
    <p>建模有普通建模，就是逻辑外键、冗余建模，一对多的关系放在一个document下，父子关系建模（要求父子在一个shard中）。
父子关系建模 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 PUT /company { &#34;mappings&#34;: { &#34;rd_center&#34;: {}, // 研发中心type &#34;employee&#34;: { // 员工type &#34;_parent&#34;: { // 指定parent是研发中心 &#34;type&#34;: &#34;rd_center&#34; } } } } // 添加员工时指定parent就OK，指定了parent之后会使用parentid路由，这样就会保证父子数据在同一shard中 PUT /company/employee/1?parent=1 { &#34;name&#34;: &#34;张三&#34;, &#34;birthday&#34;: &#34;1970-10-24&#34;, &#34;hobby&#34;: &#34;爬山&#34; } 父子关系查询 根据child查询parent 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 查询有员工在1980-01-01以后出生的研发中心 GET /company/rd_center/_search { &#34;query&#34;: { &#34;has_child&#34;: { &#34;type&#34;: &#34;employee&#34;, &#34;query&#34;: { &#34;range&#34;: { &#34;birthday&#34;: { &#34;gte&#34;: &#34;1980-01-01&#34; } } } } } } // 查询至少有两个员工的研发中心 GET /company/rd_center/_search { &#34;query&#34;: { &#34;has_child&#34;: { &#34;type&#34;: &#34;employee&#34;, &#34;min_children&#34;: 2, &#34;query&#34;: { &#34;match_all&#34;: {} } } } } 根据parent查询child 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 查询研发中心在中国的员工信息 GET /company/employee/_search { &#34;query&#34;: { &#34;has_parent&#34;: { &#34;parent_type&#34;: &#34;rd_center&#34;, &#34;query&#34;: { &#34;term&#34;: { &#34;country.keyword&#34;: &#34;中国&#34; } } } } } 聚合统计 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 统计每个国家的员工爱好，及爱好人数 GET /company/rd_center/_search { &#34;size&#34;: 0, &#34;aggs&#34;: { &#34;group_by_country&#34;: { &#34;terms&#34;: { &#34;field&#34;: &#34;country.keyword&#34; }, &#34;aggs&#34;: { &#34;group_by_children_employee&#34;: { &#34;children&#34;: { &#34;type&#34;: &#34;employee&#34; }, &#34;aggs&#34;: { &#34;group_by_hobby&#34;: { &#34;terms&#34;: { &#34;field&#34;: &#34;hobby.keyword&#34; } } } } } } } } 如果是三代，在添加数据的时候只指定parent，那么就不能保证祖孙三代都路由到同一shard上，需要使用routing，指定祖先id。
</p>
  </div>
  <footer class="entry-footer">2 min</footer>
  <a class="entry-link" aria-label="post link to 建模" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/es/8.%E5%BB%BA%E6%A8%A1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">持久化
    </h2>
  </header>
  <div class="entry-content">
    <p>RDB和AOF的区别 rdb是每达到一定条件就生成一个新的文件快照，快照内容是redis中当前内容的全量数据，文件名是dump.rdb，配置文件中的属性如下：
1 2 3 save 900 1 save 300 10 save 60 10000 意思是达到60s并且数据变化超过10000条或者300s数据变化超过10条或者900s数据变化超过1条就生成一个新的dump.rdb文件，生成完成后覆盖老的快照文件。
aof存储的向redis中写入数据的指令，以append-only的模式追加，默认关闭，aof备份文件名是appendonly.aof，redis先将指令写入os cache中，然后根据配置将os cache中的指令写入aof文件，当aof文件很大时会执行rewrite操作，此时会新生成一个新的aof文件，基于当前redis中的数据向新aof文件中写入指令，如果redis中数据发生变化，会追加到老aof文件中，当新aof文件追加结束再把新增的指令追加到新aof中，追加结束后删除老aof文件，aof相关配置如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 是否开启aof appendonly no # aof备份名称 appendfilename &#34;appendonly.aof&#34; # aof备份模式 # 每次redis中写入数据就同步写入到磁盘 # appendfsync always # 每秒执行一次写入 appendfsync everysec # 将写入指令放到os cache中不管，由操作系统控制 # appendfsync no #rewirte条件，当下面两个条件都满足时进行rewrite操作 # aof文件大小超过上次rewrite之后大小的100% auto-aof-rewrite-percentage 100 # aof文件最小64m auto-aof-rewrite-min-size 64mb RDB优缺点 rdb中数据可能不是最全的，但是恢复是最快的，因为存储的是数据，直接放到redis中就可以了； 如果redis中数据很多每次生成快照文件时可能导致redis服务暂停一段时间，类似jvm的stop the world； 很适合配合脚本做冷备份，比如传到oss上容灾； AOF优缺点 最多只有1s的数据丢失； 每次都要写入os cache，但比写磁盘快很多； 回复数据慢； 使用 一般都是同时开启RDB和AOF，这样，aof可以保证数据不丢，aof损坏时可以使用rdb的冷备快速恢复，防止雪崩；
...</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 持久化" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/5.rdb%E5%92%8Caof/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">数据分析-大纲
    </h2>
  </header>
  <div class="entry-content">
    <p>指标 核心指标：
初创公司的指标更关注新增用户量，中期更关注活跃用户，后期更关注营收
数字的意义没有比率大，比如说注册成功数，1000个人里100个人注册成功要比10000个人里200个人注册成功要好，比率形式的指标可以更好对比，单一的看一个数字指标很容易变成虚荣的。
产品运营指标：AARRR框架 用户获取 广告曝光量 下载量：下载量有个尴尬的地方是app store点击下载跳转到商店，并不一定是真的下载，这样会造成一部分数据失真； 日新增用户：日新增用户应该以注册完成为准； 获客成本 一次回话用户数占比：一次会话用户数占比是指下载完成功只打开1次app并且使用时间在2分钟内； 渠道转化率：曝光次数CPM，点击次数CPC，卖出一次CPS，下载次数CPD，曝光时间CPT； 邀请转化率：用户邀请新人并完成注册； ROI 用户活跃 日/周/月活，广义上浏览官网、公众号下单都算使用，不局限于打开app； 活跃用户占比：活跃用户数在总用户数的比例，可以判断一个app的健康程度； 新老用户占比 用户session次数：打开产品-&gt;使用-&gt;退出算一次session，打开后3分钟内没有使用也算退出，为什么是3分钟？社交app中如果打开app3分钟什么也没做基本上就是走开了; 用户访问时长：一次session的时长； 平均访问次数：一段时间内用户的平均session数； 其他的推送唤回指标 用户留存 一般就是次日留存，七日留存，还有七日内留存之类的
营收 付费用户数 付费用户数占比：每日付费用户占活跃用户数比，或者总付费用户占总用户数比； ARPU：一段时间内每个用户的平均收入，他是有时间维度的客单价概念，其实就是销售总额/用户数； ARPPU： LTV：生命周期价值 = ARPU / 流失率，比如1个月内留存为60%，那么流失率就是40%，那1月份的用户平均每个人能创造的价值(LTV) = 1月份的ARPU * 100 / 40; 传播 k因子：每个用户能够带来几个新用户，k因子 = 用户数 * 平均邀请人数 * 邀请转化率； 用户分享率：分享功能占浏览页面人数； 活动/邀请页曝光量 有的app一些设计很不友好，比如王者一上来就全是小红点，都是为了完成kpi，全是小红点就有用户忍不住去点，可以增加用户使用时长，不应该学。
具体需要哪些指标需要根据业务梳理，梳理出流程图后根据流程图梳理指标，比充值的流程，充值又分成内购和订阅，再加上新老用户维度画出流程图可能就有了哪个页面出发的付费、付费转化率、回购率等指标。
Excel 文本清洗函数 Find： Substitute： Left Right Mid： Text： Concatenate： Trim： Replace： Len： 关联匹配函数 Lookup： Row： Vlookup： Column： Index： Offset： Match： Hyperlink： 逻辑运算函数 And Or If Is Not 计算统计函数 Sum Sumproduct Count Max Min Rank Rand Randbetween Average Quartile Stdev Substotal Int Round 时间序列函数 Year Month Weekday Weeknum Day Date Now Today Excel技巧 ctrl&#43;方向键：光标快速移动； ctrl&#43;shift&#43;方向键：快速框选； ctrl&#43;空格：选定整列； shift&#43;空格：选定整行； ctrl&#43;a：选定整张表； alt&#43;enter：换行； 使用拆分列功能把范围的数据(比如7k-10k)拆成两列方便统计； 使用条件格式让结果更直观； 使用数据透视表对数据进行统计和切片(按条件拆成不同sheet页); 视图中选择冻结首行将表头固定，方便查看数据； 数据可视化</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 数据分析-大纲" href="http://localhost:1313/posts/%E5%85%B6%E4%BB%96/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/page/24/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:1313/page/26/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">王小红的笔记</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
