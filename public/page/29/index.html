<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.150.0"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>王小红的笔记</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css" integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="/katex/katex.min.css">
<script defer src="/katex/katex.min.js"></script>
<script defer src="/katex/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: "$$", right: "$$", display: true},
        {left: "$", right: "$", display: false},
        {left: "\\(", right: "\\)", display: false},
        {left: "\\[", right: "\\]", display: true}
      ]
    });
  });
</script>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="王小红的笔记 (Alt + H)">王小红的笔记</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="笔记">
                    <span>笔记</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">行为型-解释器模式
    </h2>
  </header>
  <div class="entry-content">
    <p>给定一个语言，并且定义语法的表示和一个解释器，解释器来解释语言中的句子。比如正则。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public abstract class AbstractExpression { public abstract void interpret(Context context); } public class TerminalExpression extends AbstractExpression { @Override public void interpret(Context context) { System.out.println(&#34;终端解释器&#34;); } } public class NonterminalExpression extends AbstractExpression { @Override public void interpret(Context context) { System.out.println(&#34;非终端解释器&#34;); } } @Getter @Setter public class Context { private String input; private String output; } public static void main(String[] args) { Context context = new Context(); List&lt;AbstractExpression&gt; list = new ArrayList&lt;&gt;(); list.add(new TerminalExpression()); list.add(new TerminalExpression()); list.add(new TerminalExpression()); list.add(new NonterminalExpression()); for (AbstractExpression exp : list) { exp.interpret(context); } } 没啥用。
</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 行为型-解释器模式" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">行为型-访问者模式
    </h2>
  </header>
  <div class="entry-content">
    <p>访问者模式可以使我们在不改变各个元素类的前提下定义作用于这些元素的新操作。
他比组合模式更灵活，将组合模式的操作方法拿出来每个功能定义一个类，然后再把类穿进去，通过组合模式调用，这样就可以灵活的执行各种操作。其实就是以类或者方法为参数传进去执行。这是GoF中最复杂的模式。
访问者类的参数element，访问者中的方法跟element有几个子类相关，就是说只有到element的状态确定才会考虑访问者模式，比如element是人，那他的子类只有男和女，这样访问者里的方法数量是固定的，如果element的子类个数不确定，那么在修改需求的时候需要增加或者删除访问者类中的方法，违反了开放-封闭原则。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 public abstract class Visitor { public abstract void VisitConcreteElementA(ConcreteElementA element); public abstract void VisitConcreteElementB(ConcreteElementB element); } public class concreteVisitor1 extends Visitor { @Override public void VisitConcreteElementA(ConcreteElementA element) { System.out.println(&#34;ConcreteElementA被concreteVisitor1访问&#34;); } @Override public void VisitConcreteElementB(ConcreteElementB element) { System.out.println(&#34;ConcreteElement被concreteVisitor1访问&#34;); } } public class concreteVisitor2 extends Visitor { @Override public void VisitConcreteElementA(ConcreteElementA element) { System.out.println(&#34;ConcreteElementA被concreteVisitor2访问&#34;); } @Override public void VisitConcreteElementB(ConcreteElementB element) { System.out.println(&#34;ConcreteElementB被concreteVisitor2访问&#34;); } } public abstract class Element { public abstract void accept(Visitor visitor); } public class ConcreteElementA extends Element { @Override public void accept(Visitor visitor) { visitor.VisitConcreteElementA(this); } // 其他相关方法 public void operationA() {} } public class ConcreteElementB extends Element { @Override public void accept(Visitor visitor) { visitor.VisitConcreteElementB(this); } // 其他相关方法 public void operationB() {} } public class ObjectStrustrue { private List&lt;Element&gt; elements = new ArrayList&lt;&gt;(); public void attach(Element element) { elements.add(element); } public void detach(Element element) { elements.remove(element); } public void accept(Visitor visitor) { for (Element element : elements) { element.accept(visitor); } } } public static void main(String[] args) { ObjectStrustrue o = new ObjectStrustrue(); o.attach(new ConcreteElementA()); o.attach(new ConcreteElementB()); concreteVisitor1 v1 = new concreteVisitor1(); concreteVisitor2 v2 = new concreteVisitor2(); o.accept(v1); o.accept(v2); } </p>
  </div>
  <footer class="entry-footer">2 min</footer>
  <a class="entry-link" aria-label="post link to 行为型-访问者模式" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">行为型-责任链模式
    </h2>
  </header>
  <div class="entry-content">
    <p>避免发送者和请求者直接的耦合关系，将一批对象连城一条链，沿着这条链传递请求。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public abstract class Handler { protected Handler successor; public void setSuccessor(Handler successor) { this.successor = successor; } public abstract void hendleRequest(int request); } public class ConcreteHandler1 extends Handler { @Override public void hendleRequest(int request) { if (request &gt;= 0 &amp;&amp; reqest &lt; 10) { System.out.println(&#34;ConcreteHandler1处理请求:&#34; &#43; request); } if (null != successor) { successor.hendleRequest(request); } } } public class ConcreteHandler2 extends Handler { @Override public void hendleRequest(int request) { if (request &gt; 20) { System.out.println(&#34;ConcreteHandler2处理请求:&#34; &#43; request); } if (null != successor) { successor.hendleRequest(request); } } } public static void main(String[] args) { Handler h1 = new ConcreteHandler1(); Handler h2 = new ConcreteHandler2(); h1.setSuccessor(h2); h1.hendleRequest(10); } 通过集成一个抽象类，再把下一个要执行的功能通过构造方法传进去，这样就形成了一个链条，一个一个去执行，客户端要做的就是定义链条。
</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 行为型-责任链模式" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">行为型-迭代器模式
    </h2>
  </header>
  <div class="entry-content">
    <p>迭代器模式是提供一种方法顺序访问一个聚合对象中的各个元素，又不暴露该对象的内部展示。就是为不同的聚集结构提供开始、下一个、是否结束、当前哪一项等接口。
场景：比如有一个实体里面的成员有一个数组，使用加强for循环是可以遍历的，但是有一天数组变成了map，那么遍历的代码全部都要改。这个模式基本上没有实用价值，因为java、c#等等已经把这个模式放在语言中了。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 /** * 定义一个迭代器抽象类 */ public abstract class Iterator&lt;T&gt; { public abstract T first(); public abstract boolean isDone(); public abstract T next(); public abstract T currentItem(); } /** * 集合抽象类 */ public abstract class Aggregate { // 创建迭代器 public abstract Iterator createIterator(); } /** * 具体迭代器 */ public class ConcreteIterator extends Iterator { // 具体聚合对象 private ConcreteAggregate aggregate; private int current = 0; public ConcreteIterator(ConcreteAggregate aggregate) { this.aggregate = aggregate; } public T first() { return aggregate[0]; } public boolean isDone() { return current &gt;= aggregate.count(); } public T next() { T res = null; current &#43;&#43;; if (current &lt; aggregate.count()) { res = aggregate.getI(current); } return res; } public T currentItem() { aggregate.getI(current) } } /** * 具体集合类 */ public class ConcreteAggregate extends Aggregate { private List&lt;T&gt; items = new List&lt;&gt;(); @Override public Iterator createIterator() { return new ConcreteIterator(this); } public int count() { return this.items.size(); } public T getI(int index) { return this.items.get(index); } } public static void main(String[] args) { ConcreteAggregate a = new ConcreteAggregate(); // ……赋值 Iterator i = a.createIterator(); while (!i.isDone()) { i.next(); } } </p>
  </div>
  <footer class="entry-footer">2 min</footer>
  <a class="entry-link" aria-label="post link to 行为型-迭代器模式" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">设计模式-UML类图
    </h2>
  </header>
  <div class="entry-content">
    <p>
类和接口 矩形表示类或者接口，接口分2层，第一层是类名，类名的上方使用&lt;&lt;interface&gt;&gt;标记，图里最下面是接口的另一种画法，棒棒糖表示法，圆圈表示接口，下面的文字是接口名，棒棒糖的另一端是指向实现类。
类可以是3层也可以是两层，第一层是类名，斜体表示抽象类，第二层是变量，第三层是方法。
类和接口的变量或者方法前面如果是&#39;&#43;&#39;表示public，&#39;-&#39;表示private，&#39;#&#39;表示protected。
关系表示 继承：使用空心三角形&#43;实线；
实现：使用空心三角形&#43;虚线；
关联：使用实线箭头，表示一个类需要知道另一个类时表示关联关系：
1 2 3 4 public class Penguin extends Bird { // 在企鹅(Penguin)类中，引用气候(Climate)对象 private Climate climate; } 依赖：使用虚线箭头，这种关系是临时性的，通常是作为方法的参数传递：
1 2 3 4 public class Animal { // 新陈代谢方法需要用到氧气和水 public Metabolism metabolism(Oxygen oxygen, Water water) {} } 聚合：使用空心菱形&#43;实线箭头，聚合是弱拥有：
1 2 3 4 public class WideGooseAggregate { // 雁群类中有大雁数组对象 private WideGoose[] arrayWideGoose; } 组合：使用实心菱形&#43;实线箭头，组合是强拥有，部分和整体的生命周期一样，组合是关联的一种，组合强调的是不同整体不能同时拥有同一部分：
...</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 设计模式-UML类图" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/uml%E7%B1%BB%E5%9B%BE/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">设计模式-编码规范
    </h2>
  </header>
  <div class="entry-content">
    <p>命名 长度 模块、类、方法等命名不能太长也不能太短，对于一些相对熟悉的名词可以使用缩写代替，比如num代替number，str代替string，doc代替document，sec代替second，方法中的局部变量也不推荐使用太长的名字，因为他的作用域比较小。
利用上下文 比如User实体的变量可以把user起始标记去掉，userName改为name，同理方法的变量也可以把和方法名重复的地方去掉。
可读可搜索 单词不要用生僻的难发音的单词，比如eyrie，我现在还不会读呢，当别人想向你了解eyrie模块或者方法、变量的时候乱读，你都不知道他问的是啥，可搜索的意思是功能相同的方法以统一单词打头，比如查询就都是select*，修改都是update*。
接口和抽象类的命名 接口命名有两种方式：
以i开头，比如IUserService，对应的实现类就是UserService； 没有前缀，接口叫UserService，对应的实现类叫UserServiceImpl； 抽象类：名称前加上Abstract。
注释 命名有长度限制，不一定能把所有东西都表达出来，所以注释很重要，一般要写上方法或者类主要功能，具体思路，有必要在加上如何用，对于逻辑复杂的函数，可以使用总结性注释，就是在一段代码上写&#39;// 这一段代码的思路总结&#39;
代码风格 函数长度 网上说最好不要超过显示屏高度，我觉有点道理，超过显示屏高度来回翻就很烦，当函数中设计几个逻辑，调用这个方法时，发现总有不同的几个逻辑处理用不到，就说明这个函数过长。
行长度 也不能超过显示器的宽度吧。
空行 如果一个方法中有有独立逻辑的代码块又拆分不出来小函数，除了使用总结性注释，还可以会用空行，更有条理，处理方法中，成员变量和成员变量间、成员变量和方法、方法和方法也可以使用空行。
成员顺序 先变量后方法，先静态后普通，public protected private依次排列。
避免函数参数过多 函数参数超过五个就有点多了，当函数参数过多时，首先先查看能否将函数拆开，如果不能就把参数封装成对象，封装对象还可以提高接口的兼容性。
通过参数控制流程 避免通过boolean或者null类型控制流程，尽量吧每个流程拆分成单独的函数。
</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 设计模式-编码规范" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">设计模式-设计原则
    </h2>
  </header>
  <div class="entry-content">
    <p>SOLID原则 单一职责原则（SRP）：不要设计大而全的类，要设计粒度小、功能单一的类；具体是否是单一需要根据具体的业务来定，比如用户信息和登录信息，当只有一个平台需要使用登录名密码时，可以和用户信息放到一起，如果多个平台使用同一个账号，最好是把登陆信息抽取出来，但是如果粒度分的很细又会降低内聚性。在类命名时，能够取出体现其职责的名字即可； 开闭原则（OCP）：模块、类、方法应该对扩展开放，对修改关闭。当添加或者修改功能的时候不可能做到完全的对修改关闭，只要做到修改最少、最外层，让核心、复杂的代码满足开闭原则； 里氏替换原则（LSP）：子类重写父类方法时，要保证父类方法对输入、输出和异常的约定。比如父类方法要求输入整数，子类方法要求输入正整数，是不对的；父类方法结果为空时返回空集合而子类方法结果为空时返回null也是不对的；子类方法和父类方法抛出的异常不完全相同也是不对的。 接口隔离原则（ISP） 依赖反转原则（DIP）：高层模块（调用者）不应该依赖底层模块（被调用者），应该通过抽象互相依赖，一般用于框架的设计 控制反转：一种设计思想，控制说的是对程序流程的控制，反转说的是控制权由程序员转到框架；
依赖注入：一种编码技巧，类中依赖的对象通过构造方法传入而不是在类中自己实例化；
KISS原则 尽量保持代码简单，不要写出同事看不懂的代码，比如复杂的正则表达式、位运算；不要重复造轮子，尽量使用现有工具类，比如开源类库CollectionUtils；不是代码行数越少越简单；业务复杂导致的代码复杂并不违反KISS原则；
YAGNI原则 不能过度设计，以后可能会用到的代码或者插件只需要留好扩展点，不能编写或者引入jar包，也叫不要过度设计；
迪米特法则 不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。每个类越独立越好，比如单一职责原则，高内聚；每个类都应该少接触系统的其他部分，这样在修改其他部分时，这个类的变化也会更少，低耦合。
</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 设计模式-设计原则" href="http://localhost:1313/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">调优
    </h2>
  </header>
  <div class="entry-content">
    <p>优化方法论 软件层面： 增大CPU利用率 增大内存利用率 增大磁盘io利用率 增大网络带宽利用率 硬件层面 万兆网卡、固态磁盘、更快主频，多核的CPU、更大的内存
使用DNS&#43;nginx集群
可以安装numactl工具查看CPU信息，比如核数、命中率什么的。
设置worker进程数：
1 2 3 4 # 默认是1 # 如果是auto，会根据CPU核数自动创建 # 可以设置number worker_processes number | auto; 使用pidstat -w -p [pid] 1美妙打印一次进程的上下文切换次数，生产环境要让这个次数不要太高，可以设置nginx的静态优先级，最低是-20，最高是19，越低就说明越不友好，越不想把CPU让出去
1 2 # 默认是0，设置成-20 worker_priority -20; 打开reuseport
1 2 3 # 在listen的端口号后面加上就可以了 # 同一个nginx实例下针对同一个IP&#43;端口，其中一个设置了reuseport即可全部生效 listen 80 reuseport; 绑核
...</p>
  </div>
  <footer class="entry-footer">2 min</footer>
  <a class="entry-link" aria-label="post link to 调优" href="http://localhost:1313/posts/nginx/4.%E8%B0%83%E4%BC%98/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">配置修改
    </h2>
  </header>
  <div class="entry-content">
    <p>linux参数调整 1 2 3 4 5 6 7 8 # 修改vm.overcommit_memory=1，避免中间件申请内存时候报错 echo &#39;vm.overcommit_memory=1&#39; &gt;&gt; /etc/sysctl.conf # 这个参数会影响开启线程的数量，默认是65535 echo &#39;vm.max_map_count=65536&#39; &gt;&gt; /etc/sysctl.conf # 在centos磁盘上有一块区域叫swap，用来存放不活跃进程的数据，让该进程进入睡眠状态，最大值是100：最大限度让进程睡眠 echo &#39;vm.swappiness=10&#39; &gt;&gt; /etc/sysctl.conf # linux上的最大文件连接数，如果并发量很高可能会报‘error: too many open files’，需要提高连接数 echo &#39;ulimit -n 100000&#39; &gt;&gt; /etc/profile 根据需要调整RocketMQ的jvm参数 配置文件参数调整 1 2 # 发送消息的线程池的线程数量，可以根据CPU核数调整 sendMessageThreadPoolNums=16 </p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 配置修改" href="http://localhost:1313/posts/%E6%A1%86%E6%9E%B6/mq/rocketmq/%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">链路追踪-1.原理
    </h2>
  </header>
  <div class="entry-content">
    <p>APM(Application Performance Monitor) 应用性能监控系统，他要监控到每个请求链路调用了那些环节，那些节点，每个节点的耗时，是否有异常，整个请求链路的TPS、性能延迟，出了问题能够快速便捷的看到某一次请求的日志。
SkyWalking模块 探针：在要监控的节点上通过注解的方式加上探针，这种无侵入的加探针的方式叫做插桩。 OAP平台：observability analysis platform，观察分析平台，需要独立部署。他会接收探针上报数据的请求。 存储模块：支持多种存储，es、mysql、hbase等等。 UI模块：统计数据查询和展现。 增强原理 主要是依靠java agent技术实现class字节码增强，当jvm加载class的时候会触发ClassFileLoadHool事件，然后遍历所有的instrumentation并执行里面的ClassFileTransformer的transform()方法，instrumentation就相当于类信息，transform()方法的入参有ClassLoader、ClassName、byte[]等等类信息，在SkyWalking的java agent中，就是在他的premain()方法中把所有的ClassFileTransformer添加到instrumentation里。
链路追踪模型 在sky walking中一次方法的调用成为span，span中有spanId和parent spanId，第一个span的parent id是null，第一个parent id为null的span会开启一个trace id，一个trace id对应一条链路。span有3中类型，entry、local、exit。
entry是一般是http server收到的请求。 local是相同进程内的方法的调用。 exit表示trace segment出来，比如发起rpc请求或者调用数据库。 sky walking的trace segment是进程内所有span的集合，上报时会以segment为单位组装上报，提升效率，entry span就是trace segment的第一个span。
内核轻量级队列模型 oap server收到上报数据之后会把数据放到内存队列中，在去进行消费、聚合、计算、持久化，oap server使用的内存队列是一个循环队列。
首先有个概念叫DataCarrier，他负责管理Channel，Channel负责管理buffer，每个Buffer表示一个数组，这个数组才是一个真正的队列。DataCarrier有两个参数，channel_size和buffer_size，channel_size表示Channel中有多少个buffer，buffer_size表示buffer中的数组长度。DataCarrier中还有一个组件IDataPartitoner，他负责处理数据应该路由到那个buffer。
buffer中持有一个index(此次数据应该写入的索引)和BufferStrategy strategy(队列策略)，因为buffer的数据是个循环数组，所以当往index上写入数据的时候发现这个数据没有被消费，需要对应的策略，他有三种实现，blocking阻塞等待&#43;callbacks回调，override覆盖以及if_possible往后找空闲位置。
当buffer注册到DataCarrier上时会指定n个线程去消费，1个线程消费1个或者多个buffer，也有可能多个线程消费一个buffer，每个线程内部有一个consumeList，大小为1500，间隔consumCycle秒时开始扫描buffer，当发现存在不为null的数据后就放入自己的consumeList，扫描完后如果有数据就交给处理器中的处理函数。
</p>
  </div>
  <footer class="entry-footer">1 min</footer>
  <a class="entry-link" aria-label="post link to 链路追踪-1.原理" href="http://localhost:1313/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/2.%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/1.%E5%8E%9F%E7%90%86/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/page/28/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:1313/page/30/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">王小红的笔记</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
