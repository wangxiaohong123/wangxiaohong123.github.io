<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>框架 | 王小红的笔记</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/categories/%E6%A1%86%E6%9E%B6/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/categories/%E6%A1%86%E6%9E%B6/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/categories/%E6%A1%86%E6%9E%B6/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wangxiaohong123.github.io/categories/%E6%A1%86%E6%9E%B6/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="框架"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="框架"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>框架</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>6.AOP</h2></header><div class=entry-content><p>AOP和OOP是对应的，OOP是面象对象，AOP是面象切面，在程序运行的过程中可能会产生一些横切性的问题，这些问题一般不会对业务产生影响，比如日志记录，如果不把这些横切性的问题集中到切面里就会散落到整个代码，比如日志，如果不使用AOP那么每个controller的每个方法都需要手动编写日志打印。
Spring通过CGLib和JDK的动态代理实现的AOP。
Join point：连接点，程序运行的一个点，由于Spring中使用的CGLib或者JDK动态代理是以方法为单位的，所以join point也就是一个被增强了的方法。 Point cut：切点，表示一组连接点。 Advice：通知，包括通知内容(增强一个方法的具体业务逻辑);通知的时机(before、after、around、after);通知的目标(通知要作用到那些连接点上)。 Introduction：导入，这个可以实现导入某个接口的某个实现类中的某个方法到别的类里。 Target object：目标对象，要被增强的对象。 AOP proxy：代理对象，增强之后的对象。 Aspect：切面，上面的加到一起叫切面，对应了一个包括上面内容的类。 Spring借助了AspectJ的注解，但是处理的逻辑是自己实现的。
最简单的demo：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Aspect @Component public class MyAspect { /** * 切点：某个包下的所有类 */ @Pointcut("execution(* com.spring.aop.service.impl..*.*(..))") public void pointCutPackage() {} /** * 通知 * Before：通知的时机 * pointCutPackage()：通知的切点 */ @Before("pointCutPackage()") public void adviceBefore() { System.out.println("before aop"); } } 切点表达式含义 execution：用来匹配连接点，最小粒度是方法。
...</p></div><footer class=entry-footer>3 min</footer><a class=entry-link aria-label="post link to 6.AOP" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/framework/6.aop/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>eureka</h2></header><div class=entry-content><p>为什么要有注册发现中心 比如说两个服务都只部署了一台机器，这个时候随便一个http client就可以访问，但是如果有一个服务加了一台机器，还要去修改代码，自己写轮询算法，如果在加机器呢？有了注册发现中心就不会出现这些问题。
eureka集群 比如说两台eureka服务：
1 2 3 4 5 6 7 8 9 # 8761向8762注册 server: port: 8761 eureka: instance: hostname: peer1 client: serviceUrl: defaultZone: http://peer2:8762/eureka/ 1 2 3 4 5 6 7 8 9 # 8762向8761注册 server: port: 8762 eureka: instance: hostname: peer2 client: serviceUrl: defaultZone: http://peer1:8761/eureka/ 正常服务也可以配置eureka集群参数：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to eureka" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud/eureka/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>feign</h2></header><div class=entry-content><p>feign的参数配置：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 spring: cloud: loadbalancer: retry: # 这个参数不影响下面的重试 # 不加这个配置会多重试5次 enable: true ribbon: ConnectTimeOut: 1000 ReadTimeOut: 1000 # 无论请求超时还是报错都会走重试机制 OkToRetryOnAllOperations: true # 失败后重试1次 MaxAutoReties: 1 # 失败后重试访问几次 MaxAutoRetriesNextServer: 3 feign: client: config: # 单独配置 ServiceA: connectTimeout: 5000 readTimeout: 5000 loggerLevel: full decode404: false compression: request: # 启用压缩 enabled: true # 那些请求要压缩 mime-types: text/xml,application/xml,application/json # 超过多少字节压缩 min-request-size: 2048 response: enabled: true feign: client: config: default: connectTimeout: 5000 readTimeout: 5000 loggerLevel: full 核心组件：编码器和解码器、logger、contract：解释springMVC注解的、FeignClient：核心入口。
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to feign" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud/feign/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>hystrix配置</h2></header><div class=entry-content><p>默认配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 是否允许动态扩容 hystrix.threadpool.ServiceA.allowMaximumSizeToDivergeFromCoreSize = false; // 扩容出来的线程存活时间 hystrix.threadpool.ServiceA.keepAliveTimeMinutes = 1; // 最大线程数 hystrix.threadpool.ServiceA.maximumSize = 10; // 核心线程数 hystrix.threadpool.ServiceA.coreSize = 10; // 队列大小，设置成-1使用SynchronousQueuS，就是没有队列 hystrix.threadpool.ServiceA.maxQueueSize = -1; // 队列最多存的任务数，如果队列是10，但是这个参数是5，如果队列的任务数超过5个也会拒绝 hystrix.threadpool.ServiceA.queueSizeRejectionThreshold = 5; // 统计请求次数的时间窗口 hystrix.threadpool.ServiceA.metrics.rollingStats.numBuckets = 10; // 每隔10s统计一下线程池信息 hystrix.threadpool.ServiceA.metrics.rollingStats.timeInMilliseconds = 10000; // 在numBuckets时间内超过多少请求判断是否熔断 circuitBreaker.requestVolumeThreshold = 20; // 超过多少百分比的请求失败会打开熔断开关 circuitBreaker.errorThresholdPercentage = 50; // 熔断器打开多久会尝试请求 circuitBreaker.sleepWindowInMilliseconds = 5000;</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to hystrix配置" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud/hystrix/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>nacos-1.集群搭建</h2></header><div class=entry-content><p>官网推荐vip模式集群，VIP是指虚拟ip，单点故障的时候会自动漂移到可用节点。 三台机器分别安装keepalived和nacos：
先整个jdk；
安装keepalived：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 yum install -y gcc openssl-devel popt-devel yum install -y libnl libnl-devel yum install -y libnfnetlink-devel yum install -y curl gcc openssl-devel libnl3-devel net-snmp-devel libnfnetlink-devel # 解压安装 tar -xzvf keepalived-2.1.5.tar.gz cd keepalived-2.1.5/ ./configure --prefix=/usr/local/keepalived make && make install # 创建启动文件 cd /usr/local/ cp -a keepalived/etc/keepalived /etc/init.d/ cp -a keepalived/etc/sysconfig/keepalived /etc/sysconfig/ cp -a keepalived/sbin/keepalived /usr/sbin/ # 创建配置文件 mkdir /etc/keepalived cd /etc/keepalived ##复制配置文件 cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived 修改keeplived.conf
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to nacos-1.集群搭建" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/nacos/1.%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>nacos-2.基础</h2></header><div class=entry-content><p>一 概念 命名空间：用来区分不同的开发环境，生产(prod)、预发布(staging)、联调测试(test)、开发自测(beta)、开发(dev) 分开，防止配置、服务错乱。 分组：一个完整的大系统由很多服务组成，一般分组名称由系统名称命名。 健康探测机制：dubbo服务注册到nacos时，如果ephemeral是true表示临时节点(默认)： 临时节点：每个服务都会定时向nacos发送心跳，默认5s，如果15s没收到心跳就会把这个实例标记成不健康实例，30s没收到心跳会摘除这个服务实例。 持久节点：nacos每20s主动探测实例是否可用，如果不可用标记成不健康状态，不会摘除实例。 保护阈值：比如一个下游服务的实例中宕机了一半，这个时候剩下的一半也可能因为流量变大被打死，保护阈值的作用是健康实例的比例低于这个阈值就会让不健康的服务实例也参与被调用，可以防止服务雪崩，取值范围是0~1。触发保护阈值虽然可以保证可用性，但是会导致一致性问题，因为会有部分请求打到不可用的服务上，如果这个时候触发了熔断降级，拿到的数据就是不一致的。 二 元数据 每个服务、集群、实例都有自己的元数据，格式就是key=value。默认服务、集群的元数据是空，实例的元数据：
1 2 3 4 5 6 7 8 # dubbo服务url元数据 dubbo.metadata-service.urls=[ "dubbo://172.30.60.105:20886/com.alibaba.cloud.dubbo.service.DubboMetadataService?anyhost=true&amp;application=stars-report-service&amp;bind.ip=172.30.60.105&amp;bind.port=20886&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;group=stars-report-service&amp;interface=com.alibaba.cloud.dubbo.service.DubboMetadataService&amp;metadata-type=remote&amp;methods=getAllServiceKeys,getServiceRestMetadata,getExportedURLs,getAllExportedURLs&amp;pid=8518&amp;qos.enable=false&amp;release=2.7.8&amp;revision=2.2.6.RELEASE&amp;service.filter=customerExceptionFilter&amp;side=provider&amp;timestamp=1664088868313&amp;version=1.0.0" ] dubbo.metadata.revision=722115F0F6F280A931188D6CEB16F05C dubbo.protocols.dubbo.port=20886 preserved.register.source=SPRING_CLOUD 三 distro协议（ap，保证最终一致） nacos集群需要维护服务实例的信息、状态等数据，但是服务实例找那个nacos节点发起注册？实例数据存储在哪个nacos节点上？服务发现的时候去找那个nacos节点？nacos自研的distro分布式一致性协议就是解决这3个问题的。
1.注册流程 服务在启动的时候会随机拿到一个nacos实例的地址发起注册请求，nacos收到注册请求之后根据服务实例的ip+port计算这个服务应该由哪个nacos节点负责，然后转发给对应的nacos实例。目标nacos会把服务实例信息缓存到内存里，然后返回响应给转发的nacos节点，转发的nacos节点在把响应返回给服务实例。
2.数据分片和订阅处理 按照注册的流程，每个nacos节点只会保存一部分服务实例的数据，这样的话会有两个问题，服务实例获取订阅节点信息怎么获取，怎么订阅；nacos节点宕机怎么办。
distro的实现是nacos节点会定时把自己的服务数据发送给其他节点，也会收到其他节点上的服务信息，相当于是推模式的全量保存实现了最终一致性。订阅时随机选择一个nacos节点，这里可能有个时间差：当服务刚注册的时候，其他nacos节点时没有这个服务的信息的，此时获取服务信息的请求会失败，然后添加一个监听，数据同步完之后会去回调监听。
3.数据补偿 nacos各个节点之间会定期发送心跳，当发现自己保存的其他节点上的数据和发心跳这个节点的数据不一致，会全量同步一下，这样可以解决网络分区导致的长时间定时同步失败的情况。
四 raft协议（弱cp，保证一致） raft协议下要求nacos集群选举一个leader，只能leader写入，但是当节点写完之后需要全量同步所有服务信息到其他节点，当过半节点都成功了之后才会返回注册成功，这样会大大降低nacos的吞吐。弱cp就是因为过半而不是全量。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to nacos-2.基础" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/nacos/2.%E5%9F%BA%E7%A1%80/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>nacos-3.核心源码</h2></header><div class=entry-content><p>1.服务注册源码 服务注册、订阅什么的接口是NamingClientProxy，这个接口主要有两个实现类：NamingGrpcClientProxy和NamingHttpClientProxy，注册的方法是registerService，NamingGrpcClientProxy的流程：
1 2 3 4 5 6 7 8 9 10 11 12 13 /** * Register a instance to service with specified instance properties. * * @param serviceName 服务名 * @param groupName 服务分组 * @param instance 实例信息，保存实例id、ip、端口、权重等信息 */ public void registerService(String serviceName, String groupName, Instance instance) throws NacosException { // 先把实例存储到NamingGrpcRedoService的registeredInstances（ConcurrentMap）里 redoService.cacheInstanceForRedo(serviceName, groupName, instance); // 注册服务 doRegisterService(serviceName, groupName, instance); } 注册服务的方法：
...</p></div><footer class=entry-footer>7 min</footer><a class=entry-link aria-label="post link to nacos-3.核心源码" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/nacos/3.%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ribbon</h2></header><div class=entry-content><p>Ribbon三剑客：ILoadbalancer、IRule、IPing。
ILoadBalancer就是RestClient底层的负载均衡器，基于BaseBalance实现，负载均衡的规则都是基于IRule。
@LoadBalanced，这个注解的意思就是把RestTemplate标志为底层采用LoadBalanceClient来执行http请求，支持负载均衡。目前这个类里啥都没有，可以去看看这个注解所在包下有什么。看看有没有LoadBalanceAutoConfiguration，真的有。但是有两个：AsyncLoadBalancerAutoConfiguration和LoadBalancerAutoConfiguration。能看出来他是支持异步负载均衡请求的。
LoadBalancerAutoConfiguration 1 2 3 4 5 6 7 8 9 10 /** * Auto configuration for Ribbon (client side load balancing). * 看这注释，专门为ribbon的Auto configuration * @author Spencer Gibb * @author Dave Syer * @author Will Tran * @author Gang Li */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 这块可能是我在controller或者service定义的RestTemplate，会被放到这个集合里 @LoadBalanced @Autowired(required = false) private List&lt;RestTemplate> restTemplates = Collections.emptyList(); // 这就是最后执行完来处理一些东西 @Bean public SmartInitializingSingleton loadBalancedRestTemplateInitializer( final List&lt;RestTemplateCustomizer> customizers) { return new SmartInitializingSingleton() { @Override public void afterSingletonsInstantiated() { // 然后遍历RestTemplate在定制化什么的，先猜成这样 for (RestTemplate restTemplate : LoadBalancerAutoConfiguration.this.restTemplates) { for (RestTemplateCustomizer customizer : customizers) { customizer.customize(restTemplate); } } } }; } // 下面有一个类restTemplateCustomizer // 能看出来就是给restTemplate设置了拦截器 // 拦截器就是上面的LoadBalancerInterceptor @Bean @ConditionalOnMissingBean public RestTemplateCustomizer restTemplateCustomizer( final LoadBalancerInterceptor loadBalancerInterceptor) { return new RestTemplateCustomizer() { @Override public void customize(RestTemplate restTemplate) { List&lt;ClientHttpRequestInterceptor> list = new ArrayList&lt;>( restTemplate.getInterceptors()); list.add(loadBalancerInterceptor); restTemplate.setInterceptors(list); } }; } // 下面就是retry相关的代码，先不看 LoadBalancerInterceptor LoadBalanceInterceptor继承了ClientHttpRequestInterceptor
...</p></div><footer class=entry-footer>3 min</footer><a class=entry-link aria-label="post link to ribbon" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud/ribbon/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>saga事务</h2></header><div class=entry-content><p>saga和tcc很像，tcc是把接口拆成三个，try、confirm、cancel，saga就是两个，try和confirm合并为一个。
两种思想 编排模式：事件驱动模式，服务之间的调用时通过发布事件，监听时间来驱动，比如借助mq，回滚也是一样的，通过事件来驱动。编排模式很有去中心化的思想，而且是异步调用，缺点就是异步发生异常不好排查问题，而且需要依赖mq。 命令模式：类似tcc，有一个saga分布式事务管理器，同步调用。优点和缺点和编排模式相反。 AxonFramework AxonFramework是一个CQRS框架，在国内几乎没人用，不过它是基于DDD，现在国内DDD正火，而且这个框架自带saga事务的实现，
aggregate：聚合，就是类图中的聚合。
event sourcing：回溯，存储数据变化的历史版本，这样就可以找到历史的版本。
Actor模型：每个actor都是一个线程，都有个mailbox，各个actor都可以通过mailbox相互通信，这样的话就没有并发问题了，因为线程值直接修改数据的。
CQRS：命令和查询职责分离，c就是command，增删改的操作，q就是query，查询，大概意思就是增删改和查询时两个服务，写服务写到单独的存储里去，比如mysql，有一个单独的同步组件，把数据同步到读用到的存储中，比如es。
这些都是DDD中的概念。DDD中提到了一种事务模型，就是saga事务模型。
saga事务框架 Eventuate Tram Saga：gitbub才100多star，哈哈哈哈哈哈，作者还出了本书。
AxonFramework：1000多star，他不是事务框架，只是顺带包括了saga事务。
华为的ServiceComb：这是一套分布式的技术栈，包括了saga的支持。
这就能看出来，saga的运用还是比较少的，也没有单独的成熟的方案，都是包括在了框架中。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to saga事务" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/%E4%BA%8B%E5%8A%A1/4.saga%E9%9D%9E%E9%87%8D%E7%82%B9/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>transactional</h2></header><div class=entry-content><p>在Spring中如果想使用注解声明的事务需要添加@EnableTransactionManagement注解，从这个注解进去是个ImportSelector类，然后进入ProxyTransactionManagementConfiguration，这是个全配置类，里面创建了一个Bean：TransactionInterceptor，他是AOP事务的增强逻辑。
被transactional修饰的方法会被spring生成一个动态代理对象，controller注入的bean也是被代理过的，代理对象的方法中调用方法之前会使用transactional.start()启动一个MySQL的事务，如果执行法法的过程中有报错就会调用MySQL的事务回滚，方法执行完之后会调用MySQL的事务提交。
被transactional修饰的类就是一个切面。spring的事务的核心逻辑都在spring-tx的jar包下。
调用@transactional修饰的方法之前先会走TransactionInterceptor（org.springframework.transaction.interceptor包下），这个类下的invoke()方法是事务控制的核心，这个方法中调用了invokeWithinTransaction()。这个方法是父类（TransactionAspectSupport）的方法，核心就是这行代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 这段代码实在动态代理的类执行时候进行拦截的 // 创建事务，在点进去看到是用PlatformTransactionManager开启事务，这是jpa里的代码 TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification); Object retVal = null; try { // This is an around advice: Invoke the next interceptor in the chain. // This will normally result in a target object being invoked. // 执行代码逻辑 retVal = invocation.proceedWithInvocation(); } catch (Throwable ex) { // target invocation exception // 回滚事务，在抛出异常 completeTransactionAfterThrowing(txInfo, ex); throw ex; } finally { cleanupTransactionInfo(txInfo); } // 提交事务 commitTransactionAfterReturning(txInfo); 代码很好找，一直往下跟就行，看到底层可以看到是基于hibernate来实现的。最后的找到的最最最底层的代码在AbstractLogicalConnectionImplementor（org.hibernate.resource.jdbc.internal）里：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to transactional" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/%E4%BA%8B%E5%8A%A1/1.transactional/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wangxiaohong123.github.io/categories/%E6%A1%86%E6%9E%B6/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://wangxiaohong123.github.io/categories/%E6%A1%86%E6%9E%B6/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>