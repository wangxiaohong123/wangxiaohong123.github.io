<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>基础 | 王小红的笔记</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><meta property="og:url" content="https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="基础"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="基础"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>基础</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>创建型-单例模式</h2></header><div class=entry-content><p>什么时候用单例？
比如配置文件这种，存在一份就够了，每次使用都创建实例的话就会浪费资源；
或者一个操作文件的类，每次都创建一个实例去写文件在高并发的场景很可能会相互覆盖；
第二种情况使用分布式锁或者将写操作放到队列中排队消费，但是都很复杂，这些情况都可以使用单例很容易的解决。
我们实现的单例都是类加载器级别的单例，他的作用域介于线程和进程之间，因为java中确定类的唯一是通过类全名+类加载器实例。
饿汉单例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 饿汉是第二简单的实现方法，由于Singleton实例在类加载的时候就已经创建好了，所以是线程安全的 * 缺点就是不支持延迟加载 * 如果类的初始化耗时长还是应该使用这种方法，在用到的时候再去创建反倒会影响系统性能 * @author xiaohong */ public class Singleton { private Singleton() {} private static final Singleton instance = new Singleton(); public static Singleton getInstance() { return instance; } } 懒汉单例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * 懒汉单例也比较简单，并且可以支持延迟加载 * 但是getInstance()方法上有一把锁，这让这个函数的操作都会变成串行，在高并发的时候非常影响性能 * @author xiaohong */ public class Singleton { private Singleton(){} private static Singleton instance; public static synchronized Singleton getInstance() { if(instance == null){ instance = new Singleton(); } return instance; } } 双重检查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * 双重检查就是更细粒度的锁，提升了一点性能 * 网上有人说这种写法会发生指令重排，然后在创建完实例还没初始化（调用构造函数）的时候就会被别的线程使用了，需要加上volatile关键字禁止指令重排 * 其实在高版本java中已经解决了这个问题，在java中把new的操作和初始化的操作设计成立原子操作，不存在编译优化问题 * @author xiaohong */ public class Singleton { private Singleton(){} private static Singleton instance; public static Singleton getInstance() { if(instance == null){ synchronized(Singleton.class){ if(instance == null){ instance = new Singleton(); } } } return instance; } } 静态内部类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 主流的单例模式创建方法 * 由内部类实现，instance的唯一和线程安全都有jvm保证，还支持延迟加载 * @author xiaohong */ public class Singleton { private Singleton(){} private static class SingletonHolder { private static Singleton instance = new Singleton(); } public static Singleton getInstance() { return SingletonHolder.instance; } } 枚举类 查看JAD反编译之后的文件感觉枚举的单例和饿汉模式很像
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 创建型-单例模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>创建型-原型模式</h2></header><div class=entry-content><p>原型模式就是从一个对象创建另一个可定制的对象，而且不需要知道创建的细节。
如果只是申请内存然后再给变量赋值，使用clone的方法提升的性能是可以忽略不计的，但是我觉得如果这种操作很多，比如循环一万次，每次都要创建一个新的实例，这时候可以使用原型模式； 当创建对象的操作比较复杂的时候，比如需要操作数据库、文件、计算hash值等等，这时候使用拷贝的对象就比较快了； 实现原型模式的类要继承Cloneable接口，并重写clone方法，因为继承这个接口也不具备复制对象的能力，需要在重写的clone中调用super.clone()：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Student implements Cloneable { private String name; private Date birth; public String getName(){ return name; } public void setName(String name){ this.name= name; } public Date getBirth() { return birth; } public void setBirth(Date birth) { this.birth = birth; } /** * 重写clone方法 * @return */ @Override public Student clone(){ Student student = null; try{ // 调用Object的clone方法 student = (Student) super.clone(); student.birth = (Date) student.birth.clone(); }catch(CloneNotSupportedException e){ e.printStackTrace(); } return student; } } 使用时直接调用Student的clone方法：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 创建型-原型模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>创建型-工厂方法</h2></header><div class=entry-content><p>简单工厂的优点是工厂类中包含了必要的逻辑判断，根据条件动态实例化相关的类，对于客户端来说没有具体类的依赖。工厂方法和简单工厂的区别是工厂方法将类的实例化操作放在子类或者实现类中，而且对于简单工厂来说，说过添加子类需要增加工厂方法中的分支，这也违背了对扩展开放，对修改关闭原则，而且当一个类的创建过程有点复杂，创建这个类会产生大量的重复代码的时候可以提取到工厂方法中创建：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * 工厂方法抽象类 * 当创建类有公用的代码段时可以使用抽象类实现 * * @author xiaohong */ public abstract class FactoryMethod { /** * 创建类实例 * @return */ public abstract MainTestClass getMainTestClass(); } 1 2 3 4 5 6 7 8 9 10 /** * 工厂方法的一个子类 * @author xiaohong */ public class TestClass01FactoryMethod extends FactoryMethod { @Override public MainTestClass getMainTestClass() { return new TestClass01(); } } 测试：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 创建型-工厂方法" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>创建型-建造者模式</h2></header><div class=entry-content><p>建造者模式也叫生成器模式
建造者模式 当构造函数需要很多参数，直接调用很容易产生顺序问题； 构造函数参数多的问题可以使用set方法代替，但是如果很多参数需要联合校验，比如判断大小、多个内部属性需要计算赋值等，这时候使用set实现就很麻烦； 如果希望这个对象创建完之后属性不可变，使用set也无法实现； 这时就需要使用建造者模式，并且将构造函数私有化，这时候就只能使用内部的构建类创建对象。JDK中的StringBuilder和StringBuffer就是使用的建造者。
和工厂方法的区别 工厂模式是为了创建相关类型的对象（继承同一父类或者接口），建造者模式是定制化（根据参数的不同和顺序的不同）一个类。在建造者模式中创建的类的属性会在建造类中有一份一模一样的，这部分算是重复代码但是还不能去掉。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 /** * 建造者模式测试实体 * @author xiaohong */ public class Course { private Course(CourseBuilder courseBuilder) { this.courseName = courseBuilder.courseName; this.courseVideo = courseBuilder.courseVideo; this.courseArticle = courseBuilder.courseArticle; } private String courseName; private String courseVideo; private String courseArticle; public String getCourseName() { return courseName; } public void setCourseName(String courseName) { this.courseName = courseName; } public String getCourseVideo() { return courseVideo; } public void setCourseVideo(String courseVideo) { this.courseVideo = courseVideo; } public String getCourseArticle() { return courseArticle; } public void setCourseArticle(String courseArticle) { this.courseArticle = courseArticle; } @Override public String toString() { return "Course{" + "courseName='" + courseName + '\'' + ", courseVideo='" + courseVideo + '\'' + ", courseArticle='" + courseArticle + '\'' + '}'; } /* * 通过静态内部类实现链式调用 */ public static class CourseBuilder { private String courseName; private String courseVideo; private String courseArticle; public CourseBuilder buildCourseName(String courseName) { this.courseName = courseName; return this; } public CourseBuilder buildCourseVideo(String courseVideo) { this.courseVideo = courseVideo; return this; } public CourseBuilder buildCourseArticle(String courseArticle) { this.courseArticle = courseArticle; return this; } public Course build() { // 集中校验 if(StringUtils.isEmpty(courseName)){ throw new IllegalArgumentException("..."); } return new Course(this); } } } 把实体和构建类写到一起在以后维护时很方便，而且链式调用合一选择构建哪些属性和顺序，调用也很简单：
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 创建型-建造者模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>创建型-抽象工厂</h2></header><div class=entry-content><p>工厂方法针对的是产品的等级结构，而抽象工厂针对的是产品族，用来创建多个相关或相互依赖的对象。
产品等级：不同厂商的相同产品，比如鞋子，所有的厂商的鞋都属于同一等级，比如Nike的鞋，阿迪的鞋； 产品族：相同厂商的不同产品，比如Nike的鞋、Nike的书包属于同一产品族； 通过抽象工厂创建对象需要指定厂商和产品，因为这种情况使用工厂方法模式需要创建跟多的子类或者实现类：
代码就比工厂方法的子类或者实现类多了几个获取实例的方法。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 创建型-抽象工厂" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>创建型-简单工厂</h2></header><div class=entry-content><p>简单工厂并不是23种设计模式中的，在23中设计模式中，工厂只有两种模式：工厂方法模式和抽象工厂模式。
首先要有一个总的抽象类或者接口MainTestClass，然后利用简单工厂模式创建她的实现类，简单工厂代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * 简单工厂方法 * @author xiaohong */ public class SimpleFactory { /** * 静态方法，当没有继承的需求时比较好用 * @param c * @return */ public static MainTestClass getMainTestClass(Class c) { MainTestClass mainTestClass = null; try { // 根据传入方法的值使用if判断并创建不符合开闭原则，所以这里使用反射创建 mainTestClass = (MainTestClass) Class.forName(c.getName()).newInstance(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } return mainTestClass; } } 测试：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 创建型-简单工厂" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>线上问题排查</h2></header><div class=entry-content><p>服务器 端口号被占用
启动服务发现端口号被占用可以使用netstat或者lsof查看占用端口号进程，没有用就杀掉
1 2 3 netstat -tunlp | grep 80 lsof -i:80 kill -9 [pid] 磁盘
当磁盘不足的时候可能会收到类似java.io.IOException: 磁盘空间不足这种信息，可以先使用以下指令查看磁盘状态
1 df -h 比如显示下面的信息就表示/目录下的磁盘占用很大
就要去/下面查看文件夹大小，一层一层一直找到大文件
1 2 3 4 5 6 du -sh * # 然后可以使用ls查看文件大小 ls -lh # 或者直接找到大文件，max-depth就是查找文件夹的深度 du -h --max-depth=1 | sort -n 或者直接使用find命令把大文件筛选出来
...</p></div><footer class=entry-footer>3 min</footer><a class=entry-link aria-label="post link to 线上问题排查" href=https://wangxiaohong123.github.io/posts/linux/1.%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>线程</h2></header><div class=entry-content><p>工作线程：main方法就是一个线程，在main线程中在启动一个线程，线程中是一个死循环，比如定时发送心跳，这时候就算main执行完成，jvm也不会退出，因为有一个非后台的工作线程在一直运行。 daemon线程：非工作线程就是daemon线程，如果说所有的工作线程都停止了，daemon线程会跟着jvm一起退出了。使用**setDaemon(true)**将工作线程设置成daemon线程，什么时候需要设置成daemon线程呢？比如说有一个后台的监控线程，在工作线程都结束之后，后台的监控也没用了，jvm就可以退出了，不让监控线程影响jvm的退出就要把监控线程设置成daemon线程。 ThreadGroup：线程是有父子概念的，比如在main中创建一个线程，那main就是创建线程的父线程，如果没指明线程组，会被分配到父线程所在的线程组中。main线程的名字就是main，平时创建的线程可以使用**setName("ServiceAliveMonitor")**设置线程名。手动创建线程组 1 2 3 4 // 创建一个线程组 ThreadGroup daemonThreadGroup = new ThreadGroup("daemon"); // daemon是我自己创建的线程，在线程中的构造方法中调用super(ThreadGroup, ThreadName)就可以分配线程组了 this.daemon = new Daemon(daemonThreadGroup, "ServiceAliveMonitor"); 线程优先级:setPriority(8)，理论上来说数越大越会CPU更多的执行，默认是5。 Thread.yield()：告诉CPU说不执行这个线程了，暂停。 join()就是要等待这个线程执行完才能往下走。 Interrupt：打断一个线程，就是修改线程里的interrupt标志位，线程中可以通过isInterrupted()来感知到被打断，在决定是否继续运行，还可以打断一个线程的休眠。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 Thread thread = new Thread() { @Override public void run() { while (!isInterrupted()) { System.out.println("线程1执行在工作"); } } }; thread.start(); TimeUnit.MILLISECONDS.sleep(200); // interrupt并不会停止线程，只是修改一下标志位 // 要在线程中判断被打断了以后怎么操作 thread.interrupt(); /** * 唤醒睡眠的线程 */ public static void main(String[] args) throws Exception { MyThread thread = new MyThread(); thread.start(); // 让线程执行一会 Thread.sleep(1000); // 修改线程的while条件 thread.setShouldRun(false); // 然后在唤醒，这样的话线程被唤醒就退出了 thread.interrupt(); } private static class MyThread extends Thread { private boolean shouldRun = true; @Override public void run() { while (shouldRun) { try { System.out.println("线程1执行在工作"); Thread.sleep(30 * 1000L); } catch (InterruptedException e) { e.printStackTrace(); } } } public void setShouldRun(boolean shouldRun) { this.shouldRun = shouldRun; } }</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 线程" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/1.%E7%BA%BF%E7%A8%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>线程</h2></header><div class=entry-content><p>Synchronized原理
Mark Word结构
Synchronized修饰普通方法，锁的是实例对象，修饰的是静态方法的时候锁的是类，class对象。
每个对象都有monitor对象，monitor中有一个计数器，编译的时候碰到了Synchronized时候会生成MonitorEnter和对应的MonitorExit，线程执行到Synchronized修饰的代码块或者方法的时候，先看看monitor对象中的计数器是不是0，如果不是0就根据owner判断持有锁的对象是不是自己，如果不是就等待，如果是就把计数器在加1，调用wait方法的时候会把计数器清0，owner变成null，然后waitset中添加当前线程，调用notify的时候就唤醒waitset中的线程。
双重检查的单例需要使用volatile并不是因为volatile的可见性，因为Synchronized本身就可以保证可见性，而是因为双重检查的写法可能会导致指令重排，打乱了创建对象实例的时候的顺序，比如单例的构造函数中实例化了其他的对象，可能会重排成对象没实例化，但是指针有了，这时候线程2走if判断，发现是true直接返回实例，但是实例的对象还没全部初始化，只是有了一个指针，用这个实例就会有问题。加上volatile根据happens-before原则不会进行重排序。
synchornized使用锁来保证原子性，通过在释放锁的时候执行flush操作，在进入代码块的时候执行refresh操作，通过内存屏障来解决有序性，和可见性。
在执行完monitorenter之后会执行Load内存屏障，执行monitorexit之后会执行Store内存屏障。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // synchronized通过Acquire和Release屏障可以保证代码块内部和外部不发生指令重排 // 代码块里面还是可能会发生指令重排 int b = 0; int c = 0; synchronized(this) { // -> monitorenter // Load内存屏障 // Acquire内存屏障 int a = b; c = 1; // Release内存屏障 } // -> monitorexit // Store内存屏障 锁升级 偏向锁 偏向锁就是在Mark Word中存储线程ID，为了提升同一个线程多次加锁释放锁的性能，比如循环调用Synchronized代码块，如果高并发而且并不存在同一个线程多次调用同一个Synchronized代码块时，会频繁的发生stop the world和CAS，影响性能，这时候应该关闭偏向锁：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 线程" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/3.synchronized/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>线程池</h2></header><div class=entry-content><p>四种线程池：
fixed：固定数量 cached：数量不固定，有新任务就创建线程，空闲的线程会回收 single：只有一个线程池 scheduled：在指定时间后执行提交的线程 fixed，fixed中并不会触发reject策略，和maximumPoolSize，因为他用的是无界队列。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 /** * Executors类的newFixedThreadPool方法 * 虽然LinkedBlockingQueue是有界队列，但是声明线程池的时候没有设置capacity，相当于一个无界队列，容易OOM * 核心线程数和最大线程数是相同的，如果nThreads都在处理任务就会把任务压进队列中 * 如果线程报错挂掉，会在创建一个新的线程来顶替 * 线程空闲的时候不会被销毁，因为核心线程数就是最大线程数 */ public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable>()); } /** * ThreadPoolExecutor类的构造方法 * 他的父类实现了ExecutorService * 所以创建普通线程池一般都用ExecutorService来接收： * ExecutorService threadPool = Executors.newFixedThreadPool(10); */ public ThreadPoolExecutor(int corePoolSize, // 核心线程数 // 最大线程数 int maximumPoolSize, // 多余线程的空闲存活时间 long keepAliveTime, TimeUnit unit, // 任务队列 BlockingQueue&lt;Runnable> workQueue, // 创建线程的工厂 ThreadFactory threadFactory, // 线程数达到最大并且队列也满了之后在收到任务的拒绝策略 RejectedExecutionHandler handler) { if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } // ThreadPoolExecutor中除了构造函数的参数，还有一些关键的参数 // 通过一个32位的二进制数，来表示线程状态和数量， // 前3位是线程池的状态，后29为是数量，通过一些二进制计算来查询和修改 private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); // 获取状态 private static int runStateOf(int c) { return c & ~CAPACITY; } // 获取线程数量 private static int workerCountOf(int c) { return c & CAPACITY; } // 设置线程数量和线程池状态 private static int ctlOf(int rs, int wc) { return rs | wc; } /** * 提交线程的方法 */ public void execute(Runnable command) { if (command == null) throw new NullPointerException(); // 获取上面说得那个32位数字 int c = ctl.get(); // 如果线程数小于核心线程数就创建一个线程 if (workerCountOf(c) &lt; corePoolSize) { // addWorker传的true表示是核心线程 // 使用cas增加核心线程数 if (addWorker(command, true)) return; c = ctl.get(); } // 任务入队成功，使用的是offer，这个是非阻塞的，如果队列满了就返回false if (isRunning(c) && workQueue.offer(command)) { int recheck = ctl.get(); // 下面的操作是双重检查 // 如果线程池关闭了，删除任务，然后拒绝 if (! isRunning(recheck) && remove(command)) reject(command); // 如果线程数是0就创建线程 else if (workerCountOf(recheck) == 0) addWorker(null, false); } // 任务入队失败，说明核心线程数达到最大并且队列已经满了 // 尝试创建新线程，直到线程达到最大线程数 // 如果这个时候创建线程失败就走拒绝策略 else if (!addWorker(command, false)) // 拒绝策略 reject(command); } 关闭，关闭不会马上关闭有任务的线程，而是先关闭线程池，线程池状态是关闭时，不接受新任务，在线程把队列和自己的任务执行完之后while循环中的take（不是阻塞队列的take）就会返回null，线程就结束了。
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to 线程池" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/12.%E7%BA%BF%E7%A8%8B%E6%B1%A0/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/page/4/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/page/6/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>