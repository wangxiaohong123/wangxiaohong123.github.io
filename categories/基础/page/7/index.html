<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>基础 | 王小红的笔记</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><meta property="og:url" content="https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="基础"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="基础"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>基础</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>行为型-模板方法模式</h2></header><div class=entry-content><p>场景：比如说商品有多重优惠策略，有一些是基础策略，比如积分抵扣现金，还有一些是可选优惠，比如满减券和会员折扣二选一，这个时候就可以使用模板方法，或者很多业务的流程是类似的，可以使用模板，这样不容易乱。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public interface DiscountCalculator { void calculator(); } public abstract class AbstractDiscountCalculator implements DiscountCalculator { @Override public void calculator() { commonCalculator(); specificCalculate(); } public void commonCalculator() { System.out.println("通用的计算逻辑"); } /** * 特殊折扣计算逻辑 */ protected abstract void specificCalculate(); } public class DiscountCalculator1 extends AbstractDiscountCalculator { @Override public void specificCalculate() { System.out.println("特殊计算1"); } } public class DiscountCalculator2 extends AbstractDiscountCalculator { @Override public void specificCalculate() { System.out.println("特殊计算2"); } }</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 行为型-模板方法模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>行为型-状态模式</h2></header><div class=entry-content><p>只要对象有状态就适合这个模式，他就是把每个状态变更时封到不同的类中，修改状态的代码封装到context类中，这样变更状态就会自动执行对应的代码，主要解决当一个对象的转换条件国语复杂的时候，把判断状态的逻辑转移到表示不同状态的一系列类中，如果状态很简单就没必要用这个模式了。
类图： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 /** * 抽象状态类 */ public abstract class State { public abstract void handle(Context context); } /** * 具体状态类 */ public class ConcreteStateA extends State { @Override public void handle(Context context) { // 设置下一个状态是ConcreteStateB context.setState(new ConcreteStateB()); } } /** * 具体状态类 */ public class ConcreteStateB extends State { @Override public void handle(Context context) { // 设置下一个状态是ConcreteStateA context.setState(new ConcreteStateA()); } public class Context { private State state; public Context(State state) { this.state = state; } public void setState(State state) { System.out.println("当前状态" + state.getClass().getName()); this.state = state; } public State getState() { return this.state; } public void request() { state.handle(this); } } /** * 客户端代码 */ public void main(String[] args) { Context c = new Context(new ConcreteStateA()); // 不断请求，同时改变状态 c.request(); c.request(); c.request(); c.request(); c.request(); } 当一个对象的行为取决于他的状态，并且必须在运行时根据状态改变行为时，可以考虑状态模式了。主要就是为了消除大量的if分支。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 行为型-状态模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>行为型-策略模式</h2></header><div class=entry-content><p>策略模式是为了去掉if else，因为if else中可能包含大量的代码，而且判断条件不是很清晰，很容易出问题，并不是说因为if分支多了才要去掉，策略模式的实现：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 public class Demo { public static void main(String[] args) { Context context; switch (expression) { case "a": context = new Context(new DiscountCalculateA()); break; case "b": context = new Context(new DiscountCalculateB()); break; case "c": context = new Context(new DiscountCalculateC()); break; } context.calculate(); } // 抽象算法类 public abstract class DiscountCalculateStrategy { public abstract void calculate(); } // 具体算法A public static class DiscountCalculateA extend DiscountCalculateStrategy { @Override public void calculate() { System.out.println("算法A实现"); } } // 具体算法B public static class DiscountCalculateB extend DiscountCalculateStrategy { @Override public void calculate() { System.out.println("算法B实现"); } } // 具体算法C public static class DiscountCalculateC extend DiscountCalculateStrategy { @Override public void calculate() { System.out.println("算法C时间"); } } // 上下文 public static class Context { DiscountCalculateStrategy discountCalculateStrategy; public static Context(DiscountCalculateStrategy discountCalculateStrategy) { this.discountCalculateStrategy = discountCalculateStrategy; } public static void contextInterface() { this.discountCalculateStrategy.calculate(); } } } 每个if分支对应了一个类，通过context实例化对应的算法实现类，这样有个问题就是判断的操作还是在客户端，可以结合工厂去掉客户端的判断分支：
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 行为型-策略模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>行为型-观察者模式</h2></header><div class=entry-content><p>观察者模式也叫发布订阅模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，当主题对象状态发生变更的时候通知所有观察者。
类图： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 /** * 抽象主题类 */ public abstract class Subject { private List&lt;Observer> observers = new ArrayList&lt;>(); /** * 增加观察者 */ public void attach(Observer observer) { observers.add(observer); } /** * 移除观察者 */ public void detach(Observer observer) { observers.remove(observer); } /** * 通知 */ public void notify() { for (Observer observer : observers) { observer.update(); } } } /** * 抽象观察者 */ public abstract class Observer { public abstract void update(); } /** * 具体主题类 */ public class ConcreteSubject extends Subject { /** * 具体主题状态 */ private String subjectState; public void setSubjectState(String subjectState) { this.subjectState = subjectState; } public String getSubjectState() { return this.subjectState; } } /** * 具体观察者 */ public class ConcreteObserver extends Observer { private String name; private String observerState; private ConcreteSubject subject; public ConcreteObserver(ConcreteSubject subject, String name) { this.subject = subject; this.name = name; } @Override public void update() { this.observerState = this.subject.getSubjectState(); System.out.println("观察者" + name + "的新状态是" + observerState); } } public static void main(String[] args) { ConcreteSubject s = new ConcreteSubject(); s.attach(s, "X"); s.attach(s, "Y"); s.attach(s, "Z"); s.setSubjectState("ABC"); s.notify(); } 如果一个业务需要一系列类的协作，这样有个不好的地方就是要维护相关对象的一致，维护一致就要产生耦合，而观察者就是不需要知道观察者是谁，当一个对象的改变需要通知其他对象的时候就很适合观察者模式。比如说intellij，点击运行的时候下面的run窗口会弹出，这里run窗口就是程序的观察者，当程序状态变成运行的时候会自动弹出，还有zk的节点监听。
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 行为型-观察者模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>行为型-解释器模式</h2></header><div class=entry-content><p>给定一个语言，并且定义语法的表示和一个解释器，解释器来解释语言中的句子。比如正则。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public abstract class AbstractExpression { public abstract void interpret(Context context); } public class TerminalExpression extends AbstractExpression { @Override public void interpret(Context context) { System.out.println("终端解释器"); } } public class NonterminalExpression extends AbstractExpression { @Override public void interpret(Context context) { System.out.println("非终端解释器"); } } @Getter @Setter public class Context { private String input; private String output; } public static void main(String[] args) { Context context = new Context(); List&lt;AbstractExpression> list = new ArrayList&lt;>(); list.add(new TerminalExpression()); list.add(new TerminalExpression()); list.add(new TerminalExpression()); list.add(new NonterminalExpression()); for (AbstractExpression exp : list) { exp.interpret(context); } } 没啥用。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 行为型-解释器模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>行为型-访问者模式</h2></header><div class=entry-content><p>访问者模式可以使我们在不改变各个元素类的前提下定义作用于这些元素的新操作。
他比组合模式更灵活，将组合模式的操作方法拿出来每个功能定义一个类，然后再把类穿进去，通过组合模式调用，这样就可以灵活的执行各种操作。其实就是以类或者方法为参数传进去执行。这是GoF中最复杂的模式。
访问者类的参数element，访问者中的方法跟element有几个子类相关，就是说只有到element的状态确定才会考虑访问者模式，比如element是人，那他的子类只有男和女，这样访问者里的方法数量是固定的，如果element的子类个数不确定，那么在修改需求的时候需要增加或者删除访问者类中的方法，违反了开放-封闭原则。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 public abstract class Visitor { public abstract void VisitConcreteElementA(ConcreteElementA element); public abstract void VisitConcreteElementB(ConcreteElementB element); } public class concreteVisitor1 extends Visitor { @Override public void VisitConcreteElementA(ConcreteElementA element) { System.out.println("ConcreteElementA被concreteVisitor1访问"); } @Override public void VisitConcreteElementB(ConcreteElementB element) { System.out.println("ConcreteElement被concreteVisitor1访问"); } } public class concreteVisitor2 extends Visitor { @Override public void VisitConcreteElementA(ConcreteElementA element) { System.out.println("ConcreteElementA被concreteVisitor2访问"); } @Override public void VisitConcreteElementB(ConcreteElementB element) { System.out.println("ConcreteElementB被concreteVisitor2访问"); } } public abstract class Element { public abstract void accept(Visitor visitor); } public class ConcreteElementA extends Element { @Override public void accept(Visitor visitor) { visitor.VisitConcreteElementA(this); } // 其他相关方法 public void operationA() {} } public class ConcreteElementB extends Element { @Override public void accept(Visitor visitor) { visitor.VisitConcreteElementB(this); } // 其他相关方法 public void operationB() {} } public class ObjectStrustrue { private List&lt;Element> elements = new ArrayList&lt;>(); public void attach(Element element) { elements.add(element); } public void detach(Element element) { elements.remove(element); } public void accept(Visitor visitor) { for (Element element : elements) { element.accept(visitor); } } } public static void main(String[] args) { ObjectStrustrue o = new ObjectStrustrue(); o.attach(new ConcreteElementA()); o.attach(new ConcreteElementB()); concreteVisitor1 v1 = new concreteVisitor1(); concreteVisitor2 v2 = new concreteVisitor2(); o.accept(v1); o.accept(v2); }</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 行为型-访问者模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>行为型-责任链模式</h2></header><div class=entry-content><p>避免发送者和请求者直接的耦合关系，将一批对象连城一条链，沿着这条链传递请求。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public abstract class Handler { protected Handler successor; public void setSuccessor(Handler successor) { this.successor = successor; } public abstract void hendleRequest(int request); } public class ConcreteHandler1 extends Handler { @Override public void hendleRequest(int request) { if (request >= 0 && reqest &lt; 10) { System.out.println("ConcreteHandler1处理请求:" + request); } if (null != successor) { successor.hendleRequest(request); } } } public class ConcreteHandler2 extends Handler { @Override public void hendleRequest(int request) { if (request > 20) { System.out.println("ConcreteHandler2处理请求:" + request); } if (null != successor) { successor.hendleRequest(request); } } } public static void main(String[] args) { Handler h1 = new ConcreteHandler1(); Handler h2 = new ConcreteHandler2(); h1.setSuccessor(h2); h1.hendleRequest(10); } 通过集成一个抽象类，再把下一个要执行的功能通过构造方法传进去，这样就形成了一个链条，一个一个去执行，客户端要做的就是定义链条。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 行为型-责任链模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>行为型-迭代器模式</h2></header><div class=entry-content><p>迭代器模式是提供一种方法顺序访问一个聚合对象中的各个元素，又不暴露该对象的内部展示。就是为不同的聚集结构提供开始、下一个、是否结束、当前哪一项等接口。
场景：比如有一个实体里面的成员有一个数组，使用加强for循环是可以遍历的，但是有一天数组变成了map，那么遍历的代码全部都要改。这个模式基本上没有实用价值，因为java、c#等等已经把这个模式放在语言中了。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 /** * 定义一个迭代器抽象类 */ public abstract class Iterator&lt;T> { public abstract T first(); public abstract boolean isDone(); public abstract T next(); public abstract T currentItem(); } /** * 集合抽象类 */ public abstract class Aggregate { // 创建迭代器 public abstract Iterator createIterator(); } /** * 具体迭代器 */ public class ConcreteIterator extends Iterator { // 具体聚合对象 private ConcreteAggregate aggregate; private int current = 0; public ConcreteIterator(ConcreteAggregate aggregate) { this.aggregate = aggregate; } public T first() { return aggregate[0]; } public boolean isDone() { return current >= aggregate.count(); } public T next() { T res = null; current ++; if (current &lt; aggregate.count()) { res = aggregate.getI(current); } return res; } public T currentItem() { aggregate.getI(current) } } /** * 具体集合类 */ public class ConcreteAggregate extends Aggregate { private List&lt;T> items = new List&lt;>(); @Override public Iterator createIterator() { return new ConcreteIterator(this); } public int count() { return this.items.size(); } public T getI(int index) { return this.items.get(index); } } public static void main(String[] args) { ConcreteAggregate a = new ConcreteAggregate(); // ……赋值 Iterator i = a.createIterator(); while (!i.isDone()) { i.next(); } }</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 行为型-迭代器模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>设计模式-UML类图</h2></header><div class=entry-content><p>类和接口 矩形表示类或者接口，接口分2层，第一层是类名，类名的上方使用&lt;&lt;interface>>标记，图里最下面是接口的另一种画法，棒棒糖表示法，圆圈表示接口，下面的文字是接口名，棒棒糖的另一端是指向实现类。
类可以是3层也可以是两层，第一层是类名，斜体表示抽象类，第二层是变量，第三层是方法。
类和接口的变量或者方法前面如果是'+'表示public，'-'表示private，'#'表示protected。
关系表示 继承：使用空心三角形+实线；
实现：使用空心三角形+虚线；
关联：使用实线箭头，表示一个类需要知道另一个类时表示关联关系：
1 2 3 4 public class Penguin extends Bird { // 在企鹅(Penguin)类中，引用气候(Climate)对象 private Climate climate; } 依赖：使用虚线箭头，这种关系是临时性的，通常是作为方法的参数传递：
1 2 3 4 public class Animal { // 新陈代谢方法需要用到氧气和水 public Metabolism metabolism(Oxygen oxygen, Water water) {} } 聚合：使用空心菱形+实线箭头，聚合是弱拥有：
1 2 3 4 public class WideGooseAggregate { // 雁群类中有大雁数组对象 private WideGoose[] arrayWideGoose; } 组合：使用实心菱形+实线箭头，组合是强拥有，部分和整体的生命周期一样，组合是关联的一种，组合强调的是不同整体不能同时拥有同一部分：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 设计模式-UML类图" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/uml%E7%B1%BB%E5%9B%BE/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>设计模式-编码规范</h2></header><div class=entry-content><p>命名 长度 模块、类、方法等命名不能太长也不能太短，对于一些相对熟悉的名词可以使用缩写代替，比如num代替number，str代替string，doc代替document，sec代替second，方法中的局部变量也不推荐使用太长的名字，因为他的作用域比较小。
利用上下文 比如User实体的变量可以把user起始标记去掉，userName改为name，同理方法的变量也可以把和方法名重复的地方去掉。
可读可搜索 单词不要用生僻的难发音的单词，比如eyrie，我现在还不会读呢，当别人想向你了解eyrie模块或者方法、变量的时候乱读，你都不知道他问的是啥，可搜索的意思是功能相同的方法以统一单词打头，比如查询就都是select*，修改都是update*。
接口和抽象类的命名 接口命名有两种方式：
以i开头，比如IUserService，对应的实现类就是UserService； 没有前缀，接口叫UserService，对应的实现类叫UserServiceImpl； 抽象类：名称前加上Abstract。
注释 命名有长度限制，不一定能把所有东西都表达出来，所以注释很重要，一般要写上方法或者类主要功能，具体思路，有必要在加上如何用，对于逻辑复杂的函数，可以使用总结性注释，就是在一段代码上写'// 这一段代码的思路总结'
代码风格 函数长度 网上说最好不要超过显示屏高度，我觉有点道理，超过显示屏高度来回翻就很烦，当函数中设计几个逻辑，调用这个方法时，发现总有不同的几个逻辑处理用不到，就说明这个函数过长。
行长度 也不能超过显示器的宽度吧。
空行 如果一个方法中有有独立逻辑的代码块又拆分不出来小函数，除了使用总结性注释，还可以会用空行，更有条理，处理方法中，成员变量和成员变量间、成员变量和方法、方法和方法也可以使用空行。
成员顺序 先变量后方法，先静态后普通，public protected private依次排列。
避免函数参数过多 函数参数超过五个就有点多了，当函数参数过多时，首先先查看能否将函数拆开，如果不能就把参数封装成对象，封装对象还可以提高接口的兼容性。
通过参数控制流程 避免通过boolean或者null类型控制流程，尽量吧每个流程拆分成单独的函数。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 设计模式-编码规范" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/page/6/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/page/8/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>