<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>基础 | 王小红的笔记</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="基础"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="基础"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>基础</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>linux-1.简介</h2></header><div class=entry-content><p>常见CPU架构 精简指令集(RISC)：这种CPU中的每个指令的运行时间都很短，指令集比较精简，如果要执行复杂的指令需要多个指令组合，常见的有：
甲骨文(Oracle)的SPARC系列，用在学术领域的大型工作站，有的银行的主服务器。 IBM公司的Power Architectrue(包括PowerPC)系列，索尼的PS3系列最早用的就是这个，现在不知道了，06年之前Mac也是用的这个CPU，06年到20年Mac使用的是Intel的x86架构CPU。 ARM的CPU，一些手机、导航、路由器很多使用的都是这个，应该是目前使用最广泛的。 复杂指令集(CICS)：他的指令多而且复杂，每个指令都可以执行一些低级的硬件操作，常见的有AMD、Intel、VIA等x86架构的CPU。因为现在的电脑除了AMD就是Intel，所以也被成为x86架构电脑。
x86架构：Intel最早研发的CPU叫8086，后来又是80286、80386，所以这中架构就被成为x86，最开始也是从8位一直到升到32位，后来AMD在这个架构的基础上改成了64位，64位的电脑CPU改成了x86-64。这里的8、16、32、64是指bit，是CPU一次读取的数据的最大量，32就是每次读取32位，转成内存就是1G，64位就超级大了。
UNIX系统的历史 在1969年之前计算机只有科学、军事这些领域才能用，并且非常慢，操作方式也是读卡机+打印机，程序员把信息在读卡纸上打洞，然后然后计算机把结果输出到打印机。在6几年的时候麻省理工(MIT)开发了兼容分时系统，这个系统就是提供多个终端共同使用一个主机，其实就是CPU在终端之间切换，可以说是近代操作系统的鼻祖了，但是这样有个问题就是终端没有计算能力，而且最多只支持30个终端。
1965年贝尔实验室(Bell)+麻省理工+通用电气公司(GE)发起了Multics计划，目的是让主机支持300个以上的终端联机使用，到了69年资金紧张，Bell也退出了，但是最后Multics计划成功了，不过没被重视。汤普森是Multics计划的一员，最开始他是想把太空旅游的游戏移植到EDC公司推出的PDP-7主机上，因为这个主机没人用，他花了4个星期用汇编语言写了一个内核程序，其实就是把Multics各种简化，所以最开始被叫做Unics，后来因为这个系统太好用了，贝尔实验室都在用，不过他有个缺点，就是安装到不同的机器都需要重写，然后汤普森和李奇用B语言重写，但是性能不好，李奇又用C语言重写了，命名UNIX。
C语言写的版本到现在还在使用，真的牛逼，谁能想到UNIX的诞生是因为一个游戏，如果想做的现实中还没有，自己动手搞一个来玩。
UNIX虽然没有版权问题，没加公司都可以二开自己的UNIX，但是只能支持自己的硬件，后来79年的时候AT&amp;T(Bell实验室的母公司)退出的system v第七版开始支持x86架构，同时也提出不能对学生提供源代码，因为他想把版权收回去，直到现在为止纯种的UNIX也是指System V+BSD(UNIX的一个分支)。86年的时候有一个大学教授自己写了一个Minix，删减版的UNIX，写的时候没有参照UNIX，但是还兼容UNIX上的软件，他当时是为了教学，并且没有时间完善，所以这个系统没有迭代，但是当时确实很好用。
GNU计划 斯托曼在1984年发起GNU计划，当时的黑客是指计算机能力很强的人，不是破坏计算机的骇客。当时黑客都喜欢分享，互相学习代码，当时UNIX已经是专利软件了，但是架构还是开放的。斯托曼最开始就要写个开放的系统，但是太复杂，他自己写不完，所以开始抄UNIX上的付费软件，他写的就是完全免费，后来大家发现功能都差不多，但是GNU的软件全免费，用的人就多了，出名的有c语言编译器GNU C Compiler(gcc)、很多C语言函数库、可以运行操作系统基本接口的eBash Shell。
gcc是斯托曼成立的自由软件基金会(FSF)，请了很多志愿者工程师一起开发的。为了避免GNU的软件被别人变成专利软件，1985年他找律师草拟了通用公共许可证(GPL)，也被成为copyleft，对应专利软件的copyright。GNU其实开发出来一个内核叫hurd。
GNU这个名称的解释非常有意思，就是GNU is not UNIX，那GNU是什么呢？就是GNU is not UNIX，无穷递归。
GPL说得是开放源码，进制修改授权，进制销售，但是室友商业空间的，目前大部分的Linux开发商都是卖售后服务的。GPL只是开源授权的一种，可以参考OSI协会的介绍。
LInux的发展 Linux的诞生也是作者托瓦兹为了玩写的，他在上学的时候抢不到机器，然后就买了一台intel 386机器，装上了Minix系统，当时学校的计算机属于工作站类型了，是可以进行多任务的，个人计算机就不行，就现在来讲，如果在一个CPU上同时打开多个程序也要比先打开一个在打开另一个要慢，因为来回切换任务需要消耗资源。所以托瓦兹参考Minix源码写了一个小内核，实现了286机器上的多任务处理，然后放到一个FTP网站上开源，网站的管理员把目录起名为Linux(Linus UNIX的意思)，第一个版本的Linux就诞生了，第一个内核版本起名0.0.2，不是0.0.1。
为了能兼容UNIX系统，托瓦兹有参照POSIX规范(可移植操作系统规范，由美国电器与电子工程协会IEEE发布)改写，他的思想和Minix完全相反，如果当时Minix和hurb能满足托瓦兹，说不定就不会有Linux了。
最开始Linux的问题托瓦兹还能维护一下，后来问题越来越多，而且他也没钱，比如出现某个硬件不适配，他又没有这个硬件就解决不了，这个时候就会有志愿者跳出来说这个硬件我有，我来改写，然后托瓦兹简单测试一下就合到了内核代码中，思想就是现有且能运行，然后在优化，功能多了之后就开始模块化，大概意思就是分驱动，在后来测试也测不过来了，就有志愿者出来测试，然后把结果发给托瓦兹。Linux的官网：https://kernel.org/
这种开发模式让Linux的发展非常快，1994年正式版1.0就出来了，1996年2.0，2011年3.0,2015年4.0。在2.0版本的时候把企鹅作为Linux的吉祥物，因为托瓦兹小时候被企鹅咬过一口。
Linux的出现让GNU彻底放心了，他们可以不运行在UNIX上了，因为Linux是GNU GPL授权模式，又参考了POSIX规范，斯托曼认为应该叫GNU/Linux。
版本 内核版本 内核版本类似于下面这样：
3.10.0-957.21.3.el7.x86_64 ==> 主版本.次版本.发布版-修改版本，例子里主版本就是3，次版本是10，发布版本0，修改版本957。
在3.0版本之前，主版本和次版本都是偶数叫稳定版，不会改变内核架构，只会在这个基础上修复问题。相反就是开发版，一般会增加内核级代码。在3版本只后没有开发版和稳定版这说了，每一个版本都叫主线版本(mainLine)，一般的主线版本开发结束之后就不在维护了，一般2到3个月推出一个主线版本，有一些版本是在长期维护的，这种版本叫长期维护版本(Longterm)，官网给出的长期维护版本有4.9、4.14、4.19、5.4、5.10、5.15。
使用uname -a查看系统信息
1 2 3 4 5 # 节点名称 iZ2ze7bb75hzl5dpgd13uhZ # 发行版本 3.10.0-957.21.3.el7.x86_64 # 内核版本 1 SMP Tue Jun 18 16:35:19 UTC 2019 # 系统CPU体系结构 x86_64 Linux iZ2ze7bb75hzl5dpgd13uhZ 3.10.0-957.21.3.el7.x86_64 #1 SMP Tue Jun 18 16:35:19 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux 发行版本 为了让用户能够使用Linux，很多非盈利团队或者商业公司把内核和一些软件打包到一起，可以使用网络或者光盘安装的程序叫做发行版(Distribution)，各大开发商的发行版其实差异性不大，因为内核相同，软件也都是当下主流的，而且他们还需要遵守LSB标准和目录结构标准(FHS)。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to linux-1.简介" href=https://wangxiaohong123.github.io/posts/linux/1.%E7%AE%80%E4%BB%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>linux-2.文件和目录管理</h2></header><div class=entry-content><p>用户和用户组 Linux是多人多任务系统，可能同时有多人使用服务器，考虑每个人的隐私权限和每个人喜好的工作环境，这样每个用户都可以把自己的文件权限设置成自己可见，就保证了隐私。用户组主要是为了团队协同工作，这样既能保证每个人的隐私，又能实现多人共同维护服务。
用户组就相当于一个家庭，谁都可以在客厅玩、吃饭、看书，用户相当于每个人自己的卧室，需要得到本人的允许才能进入，others就是陌生人，连进到客厅都需要得要允许。
root用户就是天神，所有文件对于他来说都没有权限。
所有的账号信息都在**/etc/passwd文件里，个人的密码在/etc/shadow文件里，所有的组名在/etc/group**文件里。
文件权限 执行ls -al查看文件权限，他的缩写是ll，执行之后可以得到类似下面的内容：
1 2 -rw-r--r-- 1 root root 1879158 4月28 17:17 test.sql # 权限 连接 用户 用户组 文件大小 修改日期 文件名 ls是list的意思。链接就是有多少文件名链接到了这个节点(inode)。文件大小的默认单位是byte。如果文件名前面多个[.]表示隐藏文件。
ls的更多更多用法使用ls –help或者man ls或者info ls查看。
文件类型 常规文件：[-]表示常规文件，按照文件内容可以分成3类： 纯文本文件，纯文本文件的内容我们可以直接看到，比如数字、字母。 二进制文件，linux中可以执行的文件就是二进制文件，不包括脚本，比如他一些命令，就是一个为进制文件。 数据文件，有些程序在运行的时候会读取某些特定格式的文件，比如在用户登录的时候会记录登录数据在/var/log/wtpm里，如果使用cat查看就是乱码，可以使用last命令查看。 目录：就是文件夹。 链接文件：类似windows的快捷方式， 设备和设备文件：和系统周边及存储相关的文件，一般都在/dev下，通常可以分成两类： 区块设备，提供系统随机读写的接口设备，比如硬盘。 字符设备，一些串行端口的接口设备，鼠标键盘这种，这些设备的特点就是一次性读取，不能断，比如说可以让鼠标移动到一个位置，但是不能让鼠标跳到一个位置。 数据接口文件：一般是网络上的数据交换，在/run或者/tmp目录里。 数据输送文件(FIFO,pipe)：他是为了解决多个程序同时写一个文件的问题，FIFO全称是first-in-first-out，就是管道。 可以使用man fifo和man socket查看数据输送文件和数据接口文件的说明。
权限说明 权限栏一共有10个字符，第一个字符表示这个文件是目录、文件还是链接，如果是[d]就表示目录，如果是[-]就表示文件；如果是[l]就表示链接文件；如果是[b]就表示可以存储的周边设备；如果是[c]就表示串行端口设备；[s]表示数据接口文件；[p]表示数据传送文件。
后面的9个字符每3个一组，均为[rwx]的组合，位置不会变，如果没有权限就是[-]。
文件权限 [r]代表可读，就是读取文件的文字内容。 [w]代表可编辑，新增、修改、删除内容，但是不能删除文件。 代表可执行，跟扩展名无关，只要有x属性就可以执行。 第一组是文件拥有者的权限，第二组是所属用户组的其他账号的权限，第三组是没有加入用户组的其他账号的权限。
目录权限 [r]代表查看目录里的文件。 [w]代表可以创建新的目录和文件、删除文件或者目录、移动目录里的文件或者目录。 代表可执行，跟扩展名无关，只要有x属性就可以执行。 修改文件属性和权限 chgrp [-R] groupName dirname/filename修改文件所属用户组，-R表示递归修改，把子目录下的所有文件、目录都改成这个用户组，同时group name需要在/etc/group文件中存在。
...</p></div><footer class=entry-footer>3 min</footer><a class=entry-link aria-label="post link to linux-2.文件和目录管理" href=https://wangxiaohong123.github.io/posts/linux/2.%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>linux-3.磁盘和文件系统</h2></header><div class=entry-content><p>磁盘的物理组成：
原型碟片：记录数据。 机械手臂：包括手臂和磁头(擦写碟片上的数据)。 主轴马达：可以转动碟片。 扇区：最小的物理存储单元，有512B和4k两种格式。 柱面：扇区组成的一圈。早起分区以柱面为单位，现在使用扇区。 磁盘分区表：一种是限制比较多的MBR(Master boot record)，一种是比较新的GPT，MBR中第一个扇区最重要，里面放的主引导记录(MBR，446B)+分区表(64B)，目前最新的是GPT分区表。 磁盘文件名：
物理磁盘的文件名一般都叫/dev/sd[a-p][1-128] 虚拟磁盘的文件名一般是/dev/vd[a-d][1-128] 如果是磁盘阵列的话一般是/dev/md[0-128] LVM一般是/dev/VGNAME/LVNAME这种 分区之后一般都需要格式化一下，因为每个系统使用的文件系统不一样，比如win98以前用FAT，win2000之后用NTFS，Linux正统文件系统是ext2，一些发行版的Linux使用其他文件系统，比如CentosOS7使用xfs文件系统。
文件系统 文件系统特性 linux的文件系统可以分成6个区块的数据：
超级区块的数据：记录文件系统的整体信息，比如inode和数据区块的总量、使用量、剩余量、文件系统的格式和相关信息。 inode：记录文件信息，比如文件的属性(时间、属组)、权限、文件数据所在区。一个文件占用一个inode。每个inode是128B或者256B。 数据区块：实际记录文件内容，文件太大的时候会占用多个区块，并且一个区块只能写一个文件，如果有剩余空间就浪费了。 文件系统描述：描述每个区块群组的开始、结束区块，以及inode、超级区块等介于那个区块之间。 区块对照表：记录空的区块。 inode对照表：记录使用和未使用的inode号。 上面除了超级区块的5个组成一个区块群组(block group)，一个文件系统只有一个超级区块的数据，如果有多个也是这个的备份。
Linux在读取文件的时候先根据inode把数据所在的区块都读出来，而FAT格式的文件系统，比如U盘是没有inode的，他只是在数据区块中记录下一个数据区块的编号，所以没法一次读取，只能一个一个读，这样就会有个问题，磁盘转一圈可能没读完，需要转好几圈，所以这种系统可以经常清理磁盘碎片，让同一个数据区块挨的进点，方便读取。
可以使用dumpe2fs [-bh] 设备文件名查看超级区块信息，但是xfs是不支持这个命令的：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 # 打印块设备属性，可以看到我的是ext4 blkid # /dev/vda1: UUID="1114fe9e-2309-4580-b183-d778e6d97397" TYPE="ext4" # -b 列出保留为坏道的部分 # -h 只显示超级区块信息，不展示其他区段内容 dumpe2fs /dev/vda1 dumpe2fs 1.42.9 (28-Dec-2013) # 文件系统名称 Filesystem volume name: &lt;none> # 上一次挂载的目录位置 Last mounted on: / Filesystem UUID: 1114fe9e-2309-4580-b183-d778e6d97397 Filesystem magic number: 0xEF53 Filesystem revision #: 1 (dynamic) # 文件系统特性 Filesystem featrues: has_journal ext_attr resize_inode dir_index filetype needs_recovery extent flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize Filesystem flags: signed_directory_hash # 默认挂载参数 Default mount options: user_xattr acl # 文件系统状态，如果是dirty就说明有被修改过的文件但是还在内存，没有刷到粗盘 Filesystem state: clean Errors behavior: Continue Filesystem OS type: Linux # inode总数 Inode count: 2621440 # 区块总数 Block count: 10484164 # 保留区块总数 Reserved block count: 471777 # 可用区块数量 Free blocks: 5941100 # 可用inode数量 Free inodes: 2484489 First block: 0 # 单个区块的大小 Block size: 4096 Fragment size: 4096 Reserved GDT blocks: 1021 Blocks per group: 32768 Fragments per group: 32768 Inodes per group: 8192 Inode blocks per group: 512 Flex block group size: 16 Filesystem created: Thu Jul 11 10:52:00 2019 Last mount time: Thu Mar 10 16:03:03 2022 Last write time: Fri Mar 11 00:03:02 2022 Mount count: 6 Maximum mount count: -1 Last checked: Thu Jul 11 10:52:00 2019 Check interval: 0 (&lt;none>) Lifetime writes: 3907 MB Reserved blocks uid: 0 (user root) Reserved blocks gid: 0 (group root) First inode: 11 # inode容量 Inode size: 256 Required extra isize: 28 Desired extra isize: 28 Journal inode: 8 First orphan inode: 1050033 Default directory hash: half_md4 Directory Hash Seed: 0163c9aa-b271-4625-b08d-5a774c70359e # 日志相关信息 Journal backup: inode blocks Journal featrues: journal_incompat_revoke 日志区块总大小: 128M Journal length: 32768 Journal sequence: 0x0380a708 Journal start: 14867 # 第一区块群组信息 Group 0: (Blocks 0-32767) [ITABLE_ZEROED] Checksum 0x0314, unused inodes 8175 # 主要超级区块位置 主 superblock at 0, Group descriptors at 1-3 保留的GDT块位于 4-1024 Block bitmap at 1025 (+1025), Inode bitmap at 1041 (+1041) Inode表位于 1057-1568 (+1057) 14316 free blocks, 8177 free inodes, 2 directories, 8175个未使用的inodes # 那些区块可用 可用块数: 11727-12287, 12301, 12318, 12336, 12352, 12374, 12390, 12409, 12426, 12440-12719, 13296-13708, 14304-17854, 18201-25833, 27287-28583, 30376-30604, 32424-32767 可用inode数: 12, 14, 18-8192 # 其他区块群组信息 Group 1: (Blocks 32768-65535) [INODE_UNINIT, ITABLE_ZEROED] …… xfs系统相比ext2、ext3、ext4来说多了两个区，他的数据区(data section)可以理解成ext系列的所有区块，但是不包括ext3和ext4的日志，xfs的文件系统活动区(log section)就是用日志用来记录文件的变化，xfs的实时运行区(realtime section)是用来实时分配inode和区块的，这也是他和ext系列系统的最大区别。可以使用xfs_info 挂载点/设备文件名命令查看xfs文件系统信息。
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to linux-3.磁盘和文件系统" href=https://wangxiaohong123.github.io/posts/linux/3.%E7%A3%81%E7%9B%98%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>linux-4.vi</h2></header><div class=entry-content><p>比vi好用的编辑器有很多，比如nano，但是不是所有发行版都内置除vi意外的编辑器。最重要的是很多软件的编辑接口都会主动调用vi，比如crontab、visudo，所以vi是最重要的。vim是vi的升级版，他会根据文件的扩展名和文件内的开头信息显示对应的语法样式，其实感觉就是多个颜色、下划线等样式，缩进啥的还是很痛苦。
大部分的发行版都用vim替换vi了，如果输入alias时出现**alias vi=‘vim’**表示执行vi就是在执行vim，否则还是要手动执行vim。
vi分为3中模式：
一般命令模式：vi 文件名 就进入一般命令模式了，简称一般模式，在这个模式里可以使用上下左右移动光标，删除字符或者删除整行，也可以使用复制粘贴； 编辑模式：一般模式不能编辑，直到按下【i、l、o、O、a、A、r、R】任意一个字母才会进入编辑模式，一般编辑模式屏幕左下方会出现insert、replace等字样，按【esc】退出编辑模式； 命令模式：在一般模式下输入【:、/、?】任意一个进入命令模式，在这个模式里可以查找数据、保存、批量替换、退出vi、显示行号等操作； 一般命令模式的按键： 移动光标方法 可以使用数字加命令，比如30↓就是向下移动30个字符 h或者← 光标向左移动一个字符 j或者↓ 光标向下移动一个字符 k或者↑ 光标向上移动一个字符 l或者→ 光标向右移动一个字符 ctrl+f 屏幕向下翻页 ctrl+b 屏幕向上翻页 ctrl+d 屏幕向下翻半页 ctrl+u 屏幕向上翻半页 + 光标移动到非空格的下一行 - 光标移动到非空格的上一行 N + 空格 n是数字，光标向右移动n个字符 0或者home键 移动到这一行的第一个字符位置，这个是数字0 $或者end键 移动到这一行的最后一个字符位置 H 移动到屏幕最上方第一行第一个字符 M 移动到屏幕中央那行的第一个字符 L 移动到屏幕最下方最后一行的第一个字符 G 移动到文件的最后一行 nG n是数字，移动到文件的第n行 gg 移动到文件的第一行，相当于1G n + 回车 n是数字，光标向下移动n行 查找和替换 /word 向光标之下查找第一个名为word的字符串 ?word 向光标之上查找第一个名为word的字符串 n n是按键，代表重复前一个查找的操作，比如/word之后在按n就是继续查找 N N是按键，和n相反，反向前一个查找的操作，/word会变成?word :n1,n2/word1/word2/g n1和n2是数字，在第n1和n2行之间查找word1，并把word1替换成word2 :1,$s/word1/word2/g 从第1行到最后一行之间查找word1，并把word1替换成word2 :1,$s/word1/word2/gc 从第1行到最后一行之间查找word1，并把word1替换成word2，且在替换前给用户显示确认提示字符 删除，复制和粘贴 x、X x表示向后删除一个字符，X表示向前删除一个字符 nx n是数字，向后删除n个字符 dd 删除光标所在一整行 ndd n是数字，向下删除光标所在的下n行 d1G 删除光标到第一行的所有数据 dG 删除光标到最后一行的所有数据 d$ 删除光标所在位置到这行最后一个字符 d0 删除光标所在位置到这行第一个字符 yy 复制光标所在行 nyy n是数字，复制光标所在行的下n行 y1G 复制光标所在行到第一行的所有数据 yG 复制光标所在行到最后一行的所有数据 y0 复制光标所在字符到行首的所有数据 y$ 复制光标所在字符到行尾的所有数据 p、P p是把复制的数据在光标下一行粘贴，P是在上一行粘贴 J 把光标所在行和下一行合成同一行 c 删除重复多个数据 u 恢复前一个操作 ctrl + r 重做上一个操作 一般命令模式切换到编辑模式的按键： i和I 插入，i是从光标处开始插入，I是从光标所在行的第一个非空格开始插入 a和A 插入，a是从光标所在的下一个字符开始插入，A是光标所在行的最后一个字符开始插入 o和O o是在光标所在行的下一行插入一个新空行，O是在上一行插入一个空行 r和R r会替换光标所在的字符，R会一直替换光标所在的字符，直到按下esc键 esc 退出编辑模式 一般命令模式切换到命令模式的按键 :w 将编辑的数据写入到硬盘 :w! 如果文件的权限是只读，强制写入，能不能强制跟你对该文件的权限有关 :q 退出 :q! 强制退出，不保存 :wq 保存后退出，如果是:wq!就是强制保存退出 ZZ 和:wq的效果一样 :w [filename] 另存为 :r [filename] 把文件内容加载到光标所在行后面 :n1,n2 w [filename] 把n1到n2的内容另存为新文件 :! command 暂时退出vi到命令模式下执行command的显示结果例如【:! ls /home】就是在vi中查看/home下面以ls输出文件信息 :set nu(针对vim) 显示行号 :set nonu(针对vim) 取消行号 vim的缓存 vim防止某些原因导致的程序异常退出的情况会在编辑文件时创建一个.filename.swp的文件，这个文件里缓存了对filename的操作，如果打开文件之前出现了.swp文件就会报错，说什么found a swap file之类的，出现这个错误可能有两种情况：第一个就是多人维护同一个文件，第二个就是异常退出了。
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to linux-4.vi" href=https://wangxiaohong123.github.io/posts/linux/4.vi/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>linux-5.bash</h2></header><div class=entry-content><p>bash是shell的一种 操作系统就是一组软件，通过这组软件来管理硬件和监控，如果这组软件能被用户随意使用，那么操作系统就很容易崩溃，但是又不能不让用户使用操作系统，所以就有了操作系统之上的一层程序，通过这层程序指挥内核，然后内核再去操作硬件。现在关系变成了应用程序–>内核–>硬件，这样一层一层的关系，我理解的就是硬件像蛋黄，内核是蛋清，应用程序是蛋壳，所以叫shell(壳程序)。壳程序的功能是提供用户操作系统的一个界面。
也就是说只要能操作内核程序的软件都叫壳程序，比如图形界面的软件(视频播放器这种)，比如bash，我们可以在bash中运行操作内核的命令，比如man、chmod等等。
shell有很多个 最开始的时候UNIX有很多的发展者，就会对应多个shell的版本，比如Bourne shell(sh)，Sun里的C shell，商用的K shell，TCSH(增强版C shell)。Linux使用的是Bouren Again Shell(bash)，是Bourne shell的增强版本，在/etc/shells里可以看到能够使用的shell：
1 2 3 4 /bin/sh # 等于/usr/bin/sh /bin/bash # 等于/usr/bin/bash /usr/bin/sh /usr/bin/bash 我的虚拟机里有两种shell，sh和bash，而在/etc/passwd文件中记录的账号信息外，最后就有一个字段标记这个账号登录后使用的shell类型，差不多长这样：
1 2 3 root:x:0:0:root:/root:/bin/bash # /sbin/nologin是一个奇怪的shell，他的目的是不想让用户以其他服务登录主机 bin:x:1:1:bin:/bin:/sbin/nologin 查询是否是bash shell的内置命令 使用type [-tpa] name来查询name是否是bash内置的命令，没有参数时只会显示是外部命令还是内部命令，参数说明：
-t：把name以以下字眼显示意义：file(外部命令)，alias(别名设置的命令)，builtin(bash内置命令)。 -p：如果name是外部命令，显示完整文件名。 -a：把PATH变量定义的路径中，所有包含name的命令都列出来，包括alias。 1.变量的使用和设置 查看变量使用echo，但是变量前要加$。$更多的用法使用man echo查看，赋值变量直接使用等号，例如：
1 2 3 4 5 6 7 # echo ${myname}也是输出变量 # 如果没有这个变量在bash中会输出一个空 echo $myname # 给变量赋值后在打印变量就可以看到变量的值了 myname=xiaohong echo ${myname} 不同的shell处理不存的变量也不同，bash中返回空，但是有的shell中会抛出异常，同时变量的设置也要遵循规则：
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to linux-5.bash" href=https://wangxiaohong123.github.io/posts/linux/5.bash/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>linux-6.shell脚本</h2></header><div class=entry-content><p>shell脚本不光是一些命令的集合，他还可以做一些简单的数据处理，比如自动化的服务器管理、日志的处理等等。
执行脚本的方法：
直接执行xx.sh，前提是脚本必须要有可读和可执行的权限； 路径执行：/home/xx.sh或者./xx.sh； 设置变量，在PATH中增加脚本的路径，或者把脚本放到PATH配置的路径中，然后就可以直接执行脚本了； 以bash程序来执行：bash xx.sh或者sh xx.sh，因为/bin/sh是/bin/bash的链接文件，只要脚本有可读属性就可以使用bash的方式执行脚本，还可以加上-n或者-x这种参数检查语法啥的； 上面的执行方式都是创建一个新的子进程来执行脚本，就是说在脚本中修改的变量不会对主进程中的变量有影响，还有一种执行脚本的方式：source xx.sh，这个是之前修改变量后刷新的命令，他会在主进程中执行，所以变量才会刷新，换句话说刷新配置时使用sh ~/.bbash.sh是不生效的。
搞一个hello world：
1 2 3 4 5 6 7 8 9 #! /bin/bash # program: # This program shows "Hello World!" in your screen. # History: # 2022/01/01 xiaohong First release PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin export PATH echo -e "Hello World! \a \n" exit 0 #!/bin/bash表示声明这个脚本使用哪个shell的语法，#和!中间是没有空格的，这种叫做shebang行，脚本被执行的时候会根据这行来加载需要的配置文件，bash的话就是~/.bashrc。没有这一行系统就不知道下面是什么shell，可能就无法执行。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to linux-6.shell脚本" href=https://wangxiaohong123.github.io/posts/linux/6.shell%E8%84%9A%E6%9C%AC/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Set</h2></header><div class=entry-content><p>HashSet 因为HashMap的key是不会重复的，因为重复的key执行的是替换操作，HashSet就是基于HashMap实现的。value存成new Object()就完事了。源码里也能看到，就是声明了一个HashMap，所有操作就是去操作map。
LinkedHashSet 他继承了HashSet，初始化时调用了HashSet的构造方法，HashSet中会创建一个LinkedHashMap
1 2 3 HashSet(int initialCapacity, float loadFactor, boolean dummy) { map = new LinkedHashMap&lt;>(initialCapacity, loadFactor); } TreeSet 里面实现了一个TreeMap。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to Set" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/1.%E9%9B%86%E5%90%88/6.set/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Threadlocal</h2></header><div class=entry-content><p>线程变量的副本。每个Thread内部有一个ThreadLocalMap，这个map是一个Entry数组，只能是线程自己内部使用，因为他就是内部的变量嘛，Entry中有两个变量，一个是k（ThreadLocal类型），一个是value（自己定义类型）
set
1 2 3 4 5 6 7 8 9 10 11 public void set(T value) { Thread t = Thread.currentThread(); // 获取线程内部的ThreadLocalMap ThreadLocalMap map = getMap(t); // 如果map已经创建了就添加元素 if (map != null) map.set(this, value); // 不存在就创建 else createMap(t, value); } get
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to Threadlocal" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/6.threadlocal/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Vector和stack</h2></header><div class=entry-content><p>Vector也是基于数组来实现的。Stack继承了Vector。
push操作就是往数组中添加元素
1 2 3 4 5 6 7 public synchronized void addElement(E obj) { modCount++; // 扩容相关，调用的是Vector的方法 ensureCapacityHelper(elementCount + 1); // 添加元素 elementData[elementCount++] = obj; } pop()
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public synchronized E pop() { E obj; // 获取数组长度 int len = size(); // peek就是获取最后一个元素 obj = peek(); // 删除最后一个元素 removeElementAt(len - 1); return obj; } public synchronized E peek() { int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); }</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to Vector和stack" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/1.%E9%9B%86%E5%90%88/3.vector%E5%92%8Cstack/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>volatile</h2></header><div class=entry-content><p>volatile是为了解决修改数据后，其他线程可以立即感知到数据的变化。
因为CPU读写主内存的速度比较低，所以数据的处理都是在CPU缓存中。CPU会读写的自己缓存，缓存在刷新到主内存或者别的地方，提高性能。但是这样的话就会导致别的线程修改了数据，不会马上写回主内存，就算写回主内存，有些线程可能也不会去主内存读，还是读取自己的缓存中的数据。
被volatile修饰后就符合MESI协议，当数据被修改之后也就是assign步骤结束后，会强制执行store和write操作，同时所有CPU会嗅探到数据过期，在重新读取数据。
java内存模型 可以看出来和CPU的缓存模型很像，也存在同样的问题，线程1在修改数据后，线程2感知不到。
并发三大问题 可见性：上面说得都是可见性。
原子性：多个线程读，一个线程写，会发生可见性，如果多个线程写就会发生原子性了，可能两个线程都执行+1操作，结果执行完了结果还是1。jvm规定变量的简单赋值都是原子性的，包括引用类型的赋值。复杂的赋值比如i = j + 2;这种待计算的就不保证原子性。但是在32位虚拟机中，赋值long和double是不保证原子性的，加上volatile就可以了，但是仅仅在这种情况使用volatile可以保证原子性。
有序性：编译器和指令器会进行指令重排。在静态编译（javac）和动态编译（JIT）过程中，都可能会发生指令重排，尤其是JIT。处理器在收到JIT编译好之后的机器码指令后，可能对指令进行重排序，处理器执行完到写缓冲器、无效队列、高速缓存中执行指令可能又发生下指令重排。
处理器在执行的时候哪个指令先就绪，就执行哪个指令，执行完了以后把结果放到重排序处理器，重排序处理器根据CPU收到的指令顺序把结果写到高度缓存或者写缓冲器中。
volatile是无法保证保证原子性的，因为就算数据被强制加载到工作内存，但是线程可能正在修改或者正在执行write操作，这时候就算工作内存中的数据变化了，也没用。
MESI协议 tag是保存主内存中数据的地址，flag是数据的状态，cache line里可以包含多个变量，就是具体的值。
处理器根据index、tag、offect来定位到数据，index定位到缓存中的bucket，tag定位到tag entry，offect定位到cache line中的数据。
flag的状态：
invalid：无效的
shared：共享的
exclusive：独占的
modified：修改过的
读取数据的时候，CPU1向总线发送read消息，主内存把数据返回，这时，数据的flag是S（共享的），修改数据的时候向总线发送invalidate消息，其他CPU嗅探到这条消息会把数据的flag变成I，然后返回ack给总线，CPU收到所有CPU的ack消息之后把flag变成E，修改完了把flag改成M，有的处理器还会把主内存的数据刷新。其他CPU在读取数据的时候发现flag是I，就要在发送read消息。这样会有一个问题，操作数据变成串行了，效率非常低。
在发invalidate消息之前把数据写到写缓冲器里，就可以去干别的了，收到invalidate消息之后把消息写到无效队列中，就返回ack，CPU1收到所有处理器的ack之后从写缓冲器中取出写入的数据，把flag变成E，然后在修改数据，在变成M，其他处理器从无效队列中消费完消息就把flag变成I，然后返回ack。这种异步的就会导致消息不会马上更新到高速缓存或者主内存，产生了可见性问题。还可能发生StoreLoad、StoreStore。
从图中可以看出，可见性是因为处理器更新数据副本可能写到寄存器、高速缓存或者写缓冲器，写到这几个地方其他处理器都不能马上感知到数据的变化。
flush操作：在刷新数据到写缓冲器的同时，也要把数据刷新到高速缓存中，有的硬件还需要把数据刷到主内存中，刷新完了会发送消息到消息总线。
refresh操作：处理器接收到总线的消息后会把变量副本过期，然后从发消息的处理器的高速缓存或者主内存中加载数据（根据硬件决定）。
happens-before 只要是符合这个原则，就不能重排序。
内存屏障 Load屏障：执行refresh操作，收到invalidate消息之后马上修改flag为I；
Store屏障：执行flush操作，把数据写到写缓冲器中后必须等到所有ack之后写到高速缓存或者主内存中；
Acquire屏障（LoadLoad + LoadStore）：禁止读操作和读写操作发生指令重排；
Release屏障（StoreLoad + StoreStore）：禁止写操作和读写操作发生指令重排；
1 2 3 4 5 6 7 8 9 10 11 boolean volatile isRunning; // Release屏障 isRunning = false; // Store屏障 // Load屏障 while(isRunning) { // Acquire屏障 …… }</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to volatile" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/2.volatile/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>