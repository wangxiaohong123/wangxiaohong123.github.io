<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>基础 | 王小红的笔记</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><meta property="og:url" content="https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="基础"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="基础"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>基础</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>1.union find</h2></header><div class=entry-content><p>union find的定义是有一系列的整数对，每队整数表示互相相连，这些整数对有以下特性：
如果整数对p和q是相连的，那么q和p也是相连的； p和p是相连的； 如果p和q相连，q和r相连，那么p和r也是相连的； union find如果整数对表示网卡之类的东西可以实现在网络中快速判断两台计算机是否可以通信，我们把节点之间的连接叫做分量，首先需要设计一份API封装所需要的操作，比如初始化，两个节点新建连接、判断两个节点是否可以连接等：
1 2 3 4 5 6 7 8 9 10 // 初始化N个节点，每个节点的值为N UF(int N); // 在p和q之间建立连接 void union(int p, int q); // p所在分量的标识符 int find(int p); // 判断p和q是否在同一个分量中 boolean connected(int p, int q); // 拿到分量数 int count(); 基本思路就是把同一个分量内的节点的分量值都设置成一样的，这样在判断两个节点是否互通就可以通过比较两个节点的分量值来实现，所以每个节点都需要有一个存储位保存分量值，基础的数据就可以满足这种需求，数组的索引就是节点值，数组值表示分量值，比如id[1]=4，表示节点1的分量值是4，id[3]=9，表示节点3的分量值是9，这样1和3就不是互通的，因为节点值不同。
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to 1.union find" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/1union-find/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>2.基础排序</h2></header><div class=entry-content><p>基础算法模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class Example { /** * 排序方法 */ public static void sort(Comparable[] a) {} /** * 判断数组是否有序 * 从小到大排序 */ public static boolean isSorted(Comparable[] a) { for(int i = 1; i &lt; a.length; i++) { if (less(a[i], a[i - 1])) { return false; } } return true; } /** * 比较方法 */ private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) &lt; 0; } /** * 交换两个元素 */ private static void exch(Comparable[] a, int i, int j) { Comparable t = a[i]; a[i] = a[j]; a[j] = t; } /** * 打印数组 */ private static void show(Comparable[] a) { for (Comparable comparable : a) { System.out.println(comparable); } } } 这套模板可以用在任何实现了Comparable接口的数据类型。我把这个模板里除了排序的方法都放在抽象类中，以后的排序只继承这个抽象类重写sort()方法。BaseSort如下：
...</p></div><footer class=entry-footer>3 min</footer><a class=entry-link aria-label="post link to 2.基础排序" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/2.%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>3.归并排序</h2></header><div class=entry-content><p>我觉得归并排序的归并意思是递归、合并，因为这个算法就两步递归和合并。主要的思想就是把数组拆分成两个，两个数组排序完在合并到一起，差分出来的这个数组又可以继续调用这个方法，递归起来了。
归并主要分成自顶向下和自底向上，不管是那种都会有合并的过程，合并方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 把a[lo]~a[mid]he a[mid+1]~a[hi]合并 */ public void merge(Comparable[] a, int lo, int mid, int hi) { int i = lo, j = mid + 1; if (hi + 1 - lo >= 0) { System.arraycopy(a, lo, aux, lo, hi + 1 - lo); } for (int k = lo; k &lt;= hi; k++) { if (i > mid) { a[k] = aux[j++]; } else if (j > hi) { a[k] = aux[i++]; } else if (less(aux[j], aux[i])) { a[k] = aux[j++]; } else { a[k] = aux[i++]; } } } 自顶向下 1 2 3 4 5 6 7 8 9 10 private void sort(Comparable[] a, int lo, int hi) { if (lo >= hi) { return; } int mid = lo + (hi - lo) / 2; sort(a, lo, mid); sort(a, mid + 1, hi); merge(a, lo, mid, hi); } 分析一下时间复杂度，首先可以推出来整个排序的复杂度：C(N) = C(N/2) + C(N/2) + N，第一个C(N/2)表示sort(a, lo, mid);第二个C(N/2)表示sort(a, mid + 1, hi);最后一个N表示merge(a, lo, mid, hi);这个取值最小为N/2，最大才是N，因为merge方法里涉及到计算的是less(aux[j], aux[i])，最好的情况就是比较了N/2次之后就不比较了，最坏情况就是数组的左半部分和有半部分就是一大一小、一大一小，一直比较N次，这里可以就是约等于N。
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 3.归并排序" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/3.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>4.快速排序</h2></header><div class=entry-content><p>快排和归并一样都是一种分治的思想，但是快排不需要额外的数组，主要的思路和归并相反，先找到一个基准，把大于这个基准的元素移到左边，小于的放在右边，然后左边和右边继续递归：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @Override public void sort(Comparable[] a) { // 这里最好打乱一下顺序 sort(a, 0, a.length - 1); } private void sort(Comparable[] a, int lo, int hi) { if (hi &lt;= lo) { return; } int j = partition(a, lo, hi); sort(a, lo, j - 1); sort(a, j + 1, hi); } /** * 找到切分点 * 然后把数组按大小分开 */ private int partition(Comparable[] a, int lo, int hi) { Comparable k = a[lo]; int i = lo, j = hi + 1; while (true) { while (less(a[++i], k)) { if (i == hi) { break; } } while (less(k, a[--j])) { if (j == lo) { break; } } if (i >= j) { break; } exch(a, i, j); } exch(a, lo, j); return i; } 首先正在空间上就要比归并小，快排有个问题就是当选择的基点最小的时候，复杂度就变成了N^2^，所以在排序之前可以先打乱一下数组的顺序，或者是找一部分元素的中位数，然后按照中位数切分，这样的代价是需要计算中位数，而且是每次递归都需要找中位数，这样的代价要比打乱顺序大，尤其是在数组很大的时候。然后快排的第一个优化点就是在排序里如果数组的元素很少，可以用插入排序代替，优化：
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 4.快速排序" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/4.%E5%BF%AB%E6%8E%92/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>5.二叉查找树</h2></header><div class=entry-content><p>二叉查找树是一颗二叉树，每个节点都含有一个Comparable的键和关联的值，并且每个节点的键都大于左子树中任意节点的键，小于右子树中任意节点的键。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 5.二叉查找树" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/5.%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>AQS</h2></header><div class=entry-content><p>谈谈对AQS的理解 ReentrantLock 全局有一个sync实例，这是一个内部类，继承了AbstractQueuedSynchronizer，加锁和释放锁都是基于sync实现的。AQS中定义了一个node，这是自己实现的双向链表，当做队列使用，还有一个state，记录加锁的次数。Sync有两个实现类，一个NonfairSync，一个FairSync，就是公平锁和非公平锁，他俩就是重写了加锁和释放锁的逻辑。Node中定义挺多东西的
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 一些状态，共享锁、排它锁 static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; volatile int waitStatus; // 前一个线程 volatile Node prev; // 后一个线程 volatile Node next; // 当前线程 volatile Thread thread; // 如果是排它锁，nextWaiter就是null，否则就是Node Node nextWaiter; 非公平锁的加锁
...</p></div><footer class=entry-footer>5 min</footer><a class=entry-link aria-label="post link to AQS" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/5.aqs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ArrayList</h2></header><div class=entry-content><p>使用默认的构造函数，ArrayList会把数组的长度设置为10（DEFAULT_CAPACITY）。
插入数据很简单，首先判断是否需要扩容ensureCapacityInternal()，如果添加完元素的长度大于现在的长度就扩容成1.5倍。然后把数组赋值。
1 2 3 4 5 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } 1 2 3 4 5 6 7 8 9 10 11 12 public void add(int index, E element) { // 判断是否数组越界 rangeCheckForAdd(index); // 判断是否扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 拷贝数组，向后移1位 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 设置最新值 elementData[index] = element; // 数组大小加1 size++; } 1 2 3 4 5 6 7 8 9 public E set(int index, E element) { // 判断是否数组越界 rangeCheck(index); // 获取index位置的元素的值 E oldValue = elementData(index); // 设置index为新值 elementData[index] = element; return oldValue; } set不是把元素往后挤，而是替换。
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to ArrayList" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/1.%E9%9B%86%E5%90%88/1.arraylist/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>atomic</h2></header><div class=entry-content><p>底层基于jdk内部使用UnSafe类，这个类只能在jdk内部用，他把构造函数私有了，并且验证类加载器，如果是应用程序加载器就报错，在类中使用offect记录当前值，自增时调用CompareAndSwap操作，并且是在while循环中。
CPU可以保证在一个线程执行UnSafe的CAS时，其他线程不能执行。
缺点：
ABA问题：可以使用AtomicStampedReference解决，我记着这个类是通过增加时间戳比较来解决的。 无限循环问题：会让CPU负载过高，可以使用jdk1.8的LongAdder来解决 LongAdder在线程很多的时候会使用分段CAS，把多个线程的CAS操作打散到一个cell[]数组上，如果一个线程在一个cell上多次空旋，会去别的cell上操作。获取的时候会把base的值和所有cell的值加到一起。
CAS在修改数据的时候就是把cache entry的flag变成E，然后执行查找在比较在修改操作，修改完了把flag变成M，就结束了。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to atomic" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/4.atomic/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ConcurrentHashMap</h2></header><div class=entry-content><p>1.8中使用了分段加锁，刚开始是CAS，hash冲突在使用synchronized
put
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 // 计算hash值 int hash = spread(key.hashCode()); for (Node&lt;K,V>[] tab = table;;) { // 如果是第一次添加，初始化数组，因为是死循环，这块直接退出了 if (tab == null || (n = tab.length) == 0) tab = initTable(); // 如果数组这个索引没有元素，使用乐观锁添加，只有一个线程能添加成功 // 因为是死循环，所以多线程来添加，失败的线程会在进来重新添加 else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { if (casTabAt(tab, i, null, new Node&lt;K,V>(hash, key, value, null))) break; // no lock when adding to empty bin } else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else { V oldVal = null; // 加锁，只锁数组当前索引的元素 synchronized (f) { if (tabAt(tab, i) == f) { if (fh >= 0) { binCount = 1; // binCount是链表的节点数量 for (Node&lt;K,V> e = f;; ++binCount) { K ek; // 判断key是否相同，相同就覆盖value if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node&lt;K,V> pred = e; // 在链表后面追加 if ((e = e.next) == null) { pred.next = new Node&lt;K,V>(hash, key, value, null); break; } } } // 红黑树添加元素 else if (f instanceof TreeBin) { Node&lt;K,V> p; binCount = 2; if ((p = ((TreeBin&lt;K,V>)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } if (binCount != 0) { // 如果链表节点数量大于8，就转成红黑树 if (binCount >= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } // 在这里进行扩容 addCount(1L, binCount); get的时候使用的UnSafe类的volatile读，volatile会加上Load内存屏障，这样会保证独到的是最新值。
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to ConcurrentHashMap" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/8.concurrenthashmap/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ConcurrentLinkedQueue</h2></header><div class=entry-content><p>concurrentLinkedQueue是线程安全的无界队列，里面有两个指针，head和tail，还有一个单向链表Node。
offer()，看这个代码能看出来链表中只有一个元素的时候，tail指向是null的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public boolean offer(E e) { // 如果是空就抛出异常 checkNotNull(e); final Node&lt;E> newNode = new Node&lt;E>(e); for (Node&lt;E> t = tail, p = t;;) { Node&lt;E> q = p.next; // 如果tail的next是空，就把tail的next指向newNode if (q == null) { // cas写，如果写失败了还会在进循环 if (p.casNext(null, newNode)) { if (p != t) casTail(t, newNode); return true; } // Lost CAS race to another thread; re-read next } else if (p == q) p = (t != (t = tail)) ? t : head; // tail有值的时候会走到这里，移动p的指针，然后继续走循环，就会走到第一个if中 else p = (p != t && t != (t = tail)) ? t : q; } } poll
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to ConcurrentLinkedQueue" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/10.concurrentlinkedqueue/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://wangxiaohong123.github.io/categories/%E5%9F%BA%E7%A1%80/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>