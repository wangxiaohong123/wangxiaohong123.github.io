<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DDD | 王小红的笔记</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/categories/ddd/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/categories/ddd/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/categories/ddd/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wangxiaohong123.github.io/categories/ddd/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="DDD"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="DDD"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>DDD</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>3.DDD框架之cola</h2></header><div class=entry-content><p>COLA是一个应用架构，作者对应用架构的解释是处理模块（Module）、组件（Component）、包（Package）和类（Class）之间的关系，让系统有章法，有结构。提倡以业务为核心，解耦外部依赖，分离业务复杂度和技术复杂度。
COLA架构 适配层（Adapter Layer）：负责对前端展示（web，wireless，wap）的路由和适配，相当于MVC中的controller，主要用来解释用户指令； 应用层（Application Layer）：主要负责获取输入，组装上下文，参数校验，调用领域层做业务处理，如果需要的话，发送消息通知等，其实就是对业务编排。层次是开放的，应用层也可以绕过领域层，直接访问基础实施层； 领域层（Domain Layer）：主要是封装了核心业务逻辑，并通过领域服务（Domain Service）和领域对象（Domain Entity）的方法对App层提供业务实体和业务逻辑计算。领域是应用的核心，不依赖任何其他层次； 基础实施层（Infrastructrue Layer）：主要负责技术细节问题的处理，比如数据库的CRUD、搜索引擎、文件系统、分布式服务的RPC等。此外，领域防腐的重任也落在这里，外部依赖需要通过gateway的转义处理，才能被上面的App层和Domain层使用。 可以看出来COLA和DDD的分层是一模一样的，只不过对于一些组件比如防腐层什么的所在的层级做了一些改动，这三种架构的普适性都是针对前端需求的变和领域模型的不变。
COLA的包结构 Adapter层 mobile：文档上写的是wireless，但是生成的代码里叫mobile，就是app端对应的controller接口； web：电脑端页面对应的controller； wap：移动端页面对应的controller； App层 executor：处理request，包括command和query； consumer：处理外部message，就是对应的事件消费者； scheduler：处理定时任务； Domain层 model：领域模型，就是实体、聚合这些东西； ability：领域能力，就是领域服务； gateway：领域网关， Infra层 gatewayimpl：网关实现； mapper：ibatis数据库映射； config：配置信息； Client层 api：服务对外暴露的api接口； dto：服务对外的DTO； Start层 里面只有服务的配置和启动类；
其实不管我们用不用DDD的模型设计都可以用这一套包架构，只不过就是model里有没有东西的事儿。
对于领域层和基础层的gateway包说明： 这里的gateway并不是微服务的网关，而是代表DDD中的防腐层或者仓储，操作数据库时，通过仓储+po和实体的转换实现解耦，rpc调用其他服务或者三方的时候通过防腐层进行实体转换，给我的感觉都是一样的，只要有依赖就有耦合，这几个做法都是为了降低耦合的可接受成都，主要的思想也都是一样的。cola中的gatewayImpl就是他的防腐层，他把数据库、es这些也定义成了外部依赖，这样做不管是应用层还是领域层都可以调用三方服务了。
基于DDD+cola改造开发 分析方法 DDD的分析方法有三种，事件风暴、领域故事陈述和4色建模：
事件风暴：类似于大家在一起的头脑风暴，每个人针对业务都想说什么说什么，然后有一个人专门根据大家的发言提炼出业务流、事件和命令，然后在根据事件的语义划分出实体、聚合、子域以及限界上下文。 领域故事陈述：梳理出每个业务的流程图 COLA相关修改 COLA中每一层就是一个模块，每一个子域对应一个工程，这样对人少的团队会增加维护成本，我们还是一个项目对应一个工程对应多个子域，每个子域只有两个服务，业务服务和api服务，api专门堆外暴露接口，其他层使用包的方式存在业务服务中。 在COLA中client层除了对外的接口和dto还有命令和事件，我们把client层去掉后，把命令放到了app层，事件放到了领域层，事件的处理(publisher、subscriber)也在app层，还有一种方式是对于事件的publisher组件放到了gateway中，这么做是考虑下层不应该调用上层，publisher组件放到了gateway中方便在domain层调用。 COLA的应用服务接口也放到了Client层，我觉得没必要，也没必要设计成依赖倒置的，所以我们直接在app层创建一个应用服务用来编排命令，app的executor包下有cmd和qry的包对应查询和命令的处理逻辑。 COLA中并没有出现工厂的概念，我们需要，也放在app层，同时infra层需要convertor实现实体和其他dto或者do转换。</p></div><footer class=entry-footer><span title='2021-06-24 06:27:35 +0000 UTC'>June 24, 2021</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to 3.DDD框架之cola" href=https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/ddd/4.cola/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>DDD-2.入门</h2></header><div class=entry-content><p>DDD是一套软件/系统的设计思想，目前没有一套完整的方法论。他建议用现实的场景映射我们的代码设计，传统的MVC主要是快，但是代码会全部堆积在service层，在拿到需求后，开始建库表，然后所有的代码都是面向数据库的，这样service的代码会越来越多，并且在面对复杂业务会很无力，DDD就是为了解决复杂场景下的代码设计。但是目前使用DDD做代码设计的非常少，因为资料少，实践困难，如果是一个微型团队，每个人负责几个子系统，每个人都需要定义自己子系统的通用语言，这样沟通很容易产生误会，最好是一个二三十人的团队，负责十几个系统，每个小团队负责一个系统（一个系统里可能包含很多服务），这样小团队之间用自己的自定语言，项目leader先划分好领域，然后建模，每个团队的leader在把自己的系统建模，这样才可以。
为什么要用DDD？ 首先DDD的思想是面向对象的，更接近真实场景，其次在复杂系统的设计上DDD更优于传统三层架构，但如果三层架构把服务拆的足够微，我不觉得他比DDD弱，其实现在的DDD和十几年前的三层架构一样，当时三层架构刚刚开始流行，大部分公司没有接触过，就感觉很厉害，很难，几年之后，三层架构变成标配，在这种分层的思想已经固化的时候，出来了一个DDD，思想和三层架构有些差别，使用的少或者没使用就会感觉DDD很深奥，可能再过几年DDD普及之后就和现在的MVC一样了。DDD的价值是让开发和产品对业务有相同的理解，DDD的流程差不多是这样：
需求评审->和产品、运营、用户定义通用语言->业务建模->架构设计(业务架构+技术架构)->团队成员开始建模(实体、值对象、互动的流程)->搭建工程、定义接口、代码落地(根据通用语言)
可以看到和产品的沟通变多了，和产品一起定义的名词和业务挂钩，沟通无障碍，新人在看完需求文档，在看代码也很轻松。
其实传统的service+controller+dao+domain除了开发快，还有一个优点，就是门槛低，随便一个培训出来的人都能开发。但是DDD更适合大型的复杂的业务系统，而且他更贴合显示，业务模型和业务代码特别清晰，代码非常好看，如果一直维护面向数据库的代码肯定会越来乱。
如果一个大团队没搞DDD，小团队自己能不能搞？能，只要把只要把团队负责的几个系统定义一套通用语言就可以，小团队不搞，自己负责的几个服务能不能搞？能，自己负责的每个服务都是一个子域，使用一个通用语言也可以。
基础概念 1.限界上下文 他是一个独立的业务领域，可以是一个或多个子域，一般就是一个子域，也建议这么划分，建议每个限界上下文最好是一个独立的子系统，拥有独立的git仓库，独立的数据仓库，独立的测试环境，独立的团队。
2.通用语言 针对同一限界上下文需要定义一套自己的名词，比如同样的orderNumber，在订单域里是充值、消费的订单号，在匹配域里，是发起一次群聊请求的订单号/房间号。
3.子域（domain） 其实说的就是限界上下文，主要有3种子域，一般一个子域最好对应唯一一个限界上下文。
核心域：核心业务系统，比如订单、钱包、动态。
支撑子域：非核心系统，但是有了锦上添花或者是辅助性的系统，比如BI系统、爬虫系统、社会化治理系统。
通用子域：一般具有普适性，全公司都可以用的类似OA系统、权限系统这种。
一个子域可以拆分成多个module，一般一个子域也是一个独立运行的大系统。
4.module 一般一个module就是一个服务。
5.上下文映射 就是子域进行集成，就是不同系统之间的接口调用，因为不同的系统可能会有通用语言的冲突，就需要在接口调用的时候把冲突的单词映射成另一个。
上下文映射的种类，U-D就是调用链的上下游，下游调用，上游提供，箭头是由上游指向下游，表示数据的流向：
合作关系（Partnership）：两个上下文强耦合在一起，多个服务完成一整个业务，一般都是一起需求评审，一起开发，一起上线。这种关系需求变更对应的服务也要改动。 共享内核（Shared Kernel）：两个系统共同维护一些模型，比如A系统的API里的一些类是B系统认可的，或者一个单独的公共的模块，他们共用并且共同维护这些实体，很少见。 客户方-供应方（Customer-Supplier Development）：就是系统B根据系统A的需求定制接口，返回值还是系统A（客户方说的算），一般都是和合作关系配合用，你需要接口，人家没有就一起商量一下。 发布订阅（Publish-Subscribe）：比如那种发mq消息的。 尊奉着/没商量（Conformist）：系统A调用系统B，但是A说得不算，B只暴露一些接口，你要是用就调一下，你想要修改人家也不配合你，一般就是中间件部门写的接口，或者其他独立的系统。 开放主机服务OHS（Open Host Service）和发布语言PL（Published Language）：相当于是开放的API了，一般指三方或者公司自己的平台，比如云片短信，定义一种协议，一般都是http。基于消息机制也是发布语言的实现方式。 防腐层ACL（Anticorruption Layer）：为了防止系统B接口改动频繁，把调用系统B的代码抽离出来，以后系统B再次改动，这需要改防腐层的代码即可，一般和尊奉着/开放主机服务一起使用。 大泥球（Big Ball of Mud）：上下文没有关系，各行其道，混乱的组织在一起，一般说得就是本该拆成几个子域，结果混在了一个服务里。 独立路线/隔离模式（SeparateWay）：没关系。 6.实体和值对象 实体：先理解成传统MVC的domain下的实体，但其实远不止，实体是有状态和行为的，也就是说实体的变量是可变的。 值对象：就是实体中包含的数据，比如订单中的值对象可以有订单详情，代表的是封装了一份数据，最经典的例子，前端返回的实体一般起名都以VO结尾，VO就是value object的缩写，翻译过来就是值对象，比如返回给前端的订单信息中有OrderInfo、OrderItem、Product、PurchaseCart。其实实体和值对象的区别可以理解成实体有id，值对象没有id。标准的DDD中规定值对象只能替换，不能修改。 聚合（Aggregate）：多个实体或者值对象的组合关系，一个订单实体中有多个订单明细实体，他们就是聚合关系，他可以看成是特殊的实体。 根实体：每个聚合关系里都有一个根实体，在订单里，大订单就是跟实体，也叫聚合根。 事务：说的是聚合实体的事务关系，比如说一起更新，要保证事务更新了这个聚合实体的整体或者部分的时候，实体内的数据是一致的。 聚合关系应尽量通过实体id引用，不要通过面向对象的引用，尽可能保证小型，主要就是通过事务规则，符合事务原则的实体，可以设计成聚合关系。
7.资源库(repository) 负责对实体对象进行持久化。
8.应用服务 负责对业务流程的编排，对应service接口。
9.领域服务 实体/值对象/资源库/工厂/聚合不适合放在里面的复杂性为的补充。里面的行为就是指挥多个实体/值对象完成业务逻辑。
10.领域事件 系统交互的核心事件，比如支付订单事件，一般用过去式命名。
11.业务组件 对领域事件的发布和处理。
12.用户界面 对应controller接口。
13.基础设施 MySQL、es、redis什么的，业务组件、领域服务、实体、资源库都可以用，根据业务决定。
14.命令 command和查询query 用来驱动领域服务的业务逻辑核方法的执行，一般就是人通过web或者app这种UI界面发起的指令，是从CQRS架构里延伸出来的，牵扯到了下面的类DDD和泛DDD。
15.战略设计/战略建模/领域对象建模 对子域划分、上下文映射、子域集成、实体、值对象和领域服务建模，完全没必要说得这么高大上，其实就是业务建模。一般一块业务就对应一个领域，一个领域又可以拆成多个子域，拆分域还是很容易的。
业务领域 -> 各个子域（module） -> 自己子域的通用语言（你应该跟子域里的其他人一起合作） -> 上下文映射（上下游关系）
...</p></div><footer class=entry-footer><span title='2021-06-24 06:27:35 +0000 UTC'>June 24, 2021</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to DDD-2.入门" href=https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/ddd/2.ddd/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>DDD-3.DDD的分层架构</h2></header><div class=entry-content><p>目前没有一套完整的DDD方法论，他仅仅提供了一些思想，所以每个公司可能都有自己的DDD目录结构，一般都是用到他的概念和分层，有的简单业务甚至只用到他的分层。
推进DDD是很难的，第1花时间还没有产出，第2就是没有完整的方法论，包结构数据怎么流转等等都没有统一的规定。而且完全按照DDD的规范来开发不适合互联网，DDD讲究的是把聚合、值对象这些东西分的很细还有对以后扩展的预留，完全用这个会把开发周期拖长，对业务不熟或者赶工的时候非常容易走样。
一些普适性架构 清洁架构 也叫洋葱架构，因为分层的图画出来很像洋葱：
越里层，越是核心能力，并且外圆只能依赖内圆，基础资源除外，或者说最外层除外。在DDD中4层架构的功能边界如下：
传统4层架构的调用方式看起来像下面这样：
就很怪，为什么接口可以直接调用基础层，数据库什么的都在这里？？？
六边形架构 也叫端口适配器架构，红框内是核心逻辑，核心逻辑不变采用适配器适配不同端，同理和基础架构的交互也是使用了依赖倒置，置于为什么叫6边型，是为了形容一套逻辑可以适配多个端口。
四层架构里的接口层虽然有web界面这些东西，但是他定义的不是传统3层架构的controller，6变形架构就是为了解决这个问题，并且他把基础设施也定义成了api的方式提供其他层调用。</p></div><footer class=entry-footer><span title='2021-06-24 06:27:35 +0000 UTC'>June 24, 2021</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to DDD-3.DDD的分层架构" href=https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/ddd/3.ddd%E7%9A%84%E5%88%86%E5%B1%82/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>