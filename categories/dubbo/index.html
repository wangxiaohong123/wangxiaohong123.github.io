<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Dubbo | 王小红的笔记</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/categories/dubbo/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/categories/dubbo/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/categories/dubbo/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wangxiaohong123.github.io/categories/dubbo/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="Dubbo"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Dubbo"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Dubbo</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>1.dubbo-源码环境</h2></header><div class=entry-content><p>先在github上找到dubbo：https://github.com/apache/dubbo，然后把3.0的源码下载到本地。之前dubbo使用的最普及的是2.7，但是现在3.0用的也很多，而且3.0的源码变化有点大。
接着进入到下载的源码目录执行mvn安装：
1 2 3 mvn install -Dmaven.test.skip=true # 为idea准备dubbo的工程目录 mvn idea:idea 然后用idea打开项目，然后我们就可以通过dubbo自带的demo：dubbo-demo作为入口，跟着功能进行断点，一点一点分析源码。dubbbo-demo下面有很多demo模块，是不同的使用方式，我只看dubbo-demo-api就可以，dubbo-demo-api下面又有两个模块，一个请求消费，一个请求发送。
因为dubbo-demo-api-consumer和dubbo-demo-api-provider都有两种模式，我使用经典模式，需要设置启动参数是classic：
1 2 3 4 5 6 7 8 9 10 11 public static void main(String[] args) throws Exception { if (isClassic(args)) { startWithExport(); } else { startWithBootstrap(); } } // 参数中有classic就是经典模式 private static boolean isClassic(String[] args) { return args.length > 0 && "classic".equalsIgnoreCase(args[0]); } ...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 1.dubbo-源码环境" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/dubbo/1.%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>10.dubbo-总结</h2></header><div class=entry-content><p>1.门面模式思想在dubbo的使用 model体系中封装了一堆组件，这些组件比如SPI、Repository等公共组件在dubbo框架运行过程中会经常被用到，如果没有Model，每个使用到的地方要自己维护，开源框架的公共部分开发是一个难点，因为是多人协作开发，如果每个人都根据自己的习惯处理公共组件会很混乱，比如有些人喜欢单例，有些人喜欢缓存。尤其是dubbo的大部分组件都是使用SPI支持扩展，如果有的人就不用SPI获取组件就很麻烦，放到Model中让公共组件有一个统一的使用标准和方法。
比如SPI的使用，通过注解配置让我们只关心接口有哪些方法就可以，而不去关心具体的实现。
2.为什么要区分provider和consumer？ 首先根据单一职责原则就应该分开，如果不区分Service和Reference，比如果只有一个Service，这个时候一个Service耦合了暴露服务和调用服务两种不同的功能场景，这样代码耦合性高而且不好维护。
3.注册中心、元数据中心、配置中心为什么要分开 最开始dubbo只有一个注册中心，这3个数据都是放到配置中心上的，如果是小项目集群我觉得是够用的，但是如果是大项目，比如服务就有几百个，集群实例几千几万个，这个时候想要扩容是比较困难的，而且如果只是注册中心要扩容，其他两个是没必要一起扩容的，第二如果注册中心挂了，不应该影响其他两个。
4.为什么要有exchanger这一层 官方的解释是为了同步转异步，在发送请求的时候默认实现是HeaderExchangeChannel，这个实现把我们的业务对象封装成了网络通信里的请求/响应对象，也是在这一层把调用channel的send然后把结果封装成了DefaultFutrue返回，把发送转成了异步。
5.为什么要有transporter层 现在底层的服务通信使用的是netty，如果要换成其他的就需要修改大量的exchanger的代码，有了transportet层还以定义一套标准，以后换网络框架可以先新增在修改transporter的实现类，不需要修改Exchanger。
6.全链路异步思想 客户端看网络请求模型，借助exchanger同步转异步。服务端借助AllDispatcher将请求提交到线程池。
7.dubbo协议标准 2个字节的魔数，主要用来标记消息开始；1个字节标识(可以区分请求类型、two way这种)；1个字节的空位置；8个字节的请求id；4个字节的body长度。一共16个字节。
8.dubbo3.0之后的优化 3.0之前注册的节点是方法级粒度的，这样在服务变化的时候消费端会收到大量的反向推送并且计算，这对消费者的内存、带宽的压力都大，同时注册中心的内存消耗也很大。 将公共组件放到Model中。 增加对nacos、consul等注册中心的支持。 新增triple协议，feign用的http1.1，grpc用的http2.0。基于http2.序列化除了protobuf还支持hessian2等，老协议无缝升级。 9.注册中心类结构 注册中心最底层是具体实现，比如ZookeeperRegistry、NacosRegistry，他们的父类是CacheableFailbackRegistry负责缓存，父类的父类是FailbackRegistry，负责故障重试，最顶层的类是AbstractRegistry实现通用的公共能力(基于本地磁盘的缓存写入和重启恢复和注册、取消注册、订阅、取消订阅、节点变更通知)，这种分层的思想非常好。
10.zk网络抖动导致节点丢失问题 在Curator5ZookeeperClient创建临时节点时，如果捕获到了NodeExistsException异常，需要先删除节点，再创建。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 10.dubbo-总结" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/dubbo/10.%E6%80%BB%E7%BB%93/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>2.dubbo-provider启动源码</h2></header><div class=entry-content><p>启动 进到ServiceConfig的export()方法中，看到3.0的代码把服务启动的代码都放到了ModuleDeployer中，猜测是在start方法中做的启动准备工作，有的版本调用的不是start()方法，而是prepare()方法。
然后在下面加了一个锁再去判断服务的export状态，首先不明白这里为什么要加锁，然后下面有初始化也有发布，但是还有个刷新，这里在刷新什么？
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /** *ServiceConfig的export() */ public void export() { // 如果这个服务已经启动了，就直接返回 // exported被volatile修饰 if (this.exported) { return; } // 3.0新引入的ScopeModel，管理各种组件的，这里的getScopeModel()拿到的是ScopeModel的子类ModuleModel // getDeployer()拿到的是DefaultModuleDeployer // 判断DefaultModuleDeployer就是对服务启动做初始化的组件 getScopeModel().getDeployer().start(); synchronized (this) { if (this.exported) { return; } // 执行刷新 if (!this.isRefreshed()) { this.refresh(); } // 服务实例的初始化 if (this.shouldExport()) { this.init(); // 延迟发布 if (shouldDelay()) { doDelayExport(); } else { doExport(); } } } } DefaultModuleDeployer的start()方法：
...</p></div><footer class=entry-footer>12 min</footer><a class=entry-link aria-label="post link to 2.dubbo-provider启动源码" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/dubbo/2.provider%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>3.dubbo-consumer启动源码</h2></header><div class=entry-content><p>进到consumer的api的启动demo，首先创建的是一个ReferenceConfig。provider创建的是ServiceConfig。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private static void runWithRefer() { // reference是要调用的实例 // 为每个实例创建一个reference ReferenceConfig&lt;DemoService> reference = new ReferenceConfig&lt;>(); // 配置注册地址、元数据地址和引用的服务接口 reference.setApplication(new ApplicationConfig("dubbo-demo-api-consumer")); reference.setRegistry(new RegistryConfig("zookeeper://127.0.0.1:2181")); reference.setMetadataReportConfig(new MetadataReportConfig("zookeeper://127.0.0.1:2181")); reference.setInterface(DemoService.class); // 通过reference的get，拿到的推断是DemoService的动态代理 // get结束后，consumer应该就启动完成了 DemoService service = reference.get(); // 调用代理的方法，就会实现和目标接口的建立连接、序列化、发送请求等等 String message = service.sayHello("dubbo"); System.out.println(message); } 直接进到get()方法里：
...</p></div><footer class=entry-footer>8 min</footer><a class=entry-link aria-label="post link to 3.dubbo-consumer启动源码" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/dubbo/3.consumer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>4.dubbo-rpc调用源码</h2></header><div class=entry-content><p>直接进InvokerInvocationHandler的invoke()方法
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 动态生成了实现类之后调用时其实这个代理并不直到你调用这个方法时要怎么处理 // 所以动态代理都会封装一个InvocationHandler，这个是dubbo自己实现的，通过代理调用的方法都会走到这里 // 在这里可以拿到代理的对象是谁，那个方法，什么参数 if (method.getDeclaringClass() == Object.class) { return method.invoke(invoker, args); } String methodName = method.getName(); Class&lt;?>[] parameterTypes = method.getParameterTypes(); // 基础方法比如tostring、equals啥的的处理 if (parameterTypes.length == 0) { if ("toString".equals(methodName)) { return invoker.toString(); } else if ("$destroy".equals(methodName)) { invoker.destroy(); return null; } else if ("hashCode".equals(methodName)) { return invoker.hashCode(); } } else if (parameterTypes.length == 1 && "equals".equals(methodName)) { return invoker.equals(args[0]); } // 封装rpc信息，serviceModel是目标服务信息 RpcInvocation rpcInvocation = new RpcInvocation(serviceModel, method, invoker.getInterface().getName(), protocolServiceKey, args); String serviceKey = url.getServiceKey(); rpcInvocation.setTargetServiceUniqueName(serviceKey); // invoker.getUrl() returns consumer url. RpcServiceContext.setRpcContext(url); if (serviceModel instanceof ConsumerModel) { rpcInvocation.put(Constants.CONSUMER_MODEL, serviceModel); rpcInvocation.put(Constants.METHOD_MODEL, ((ConsumerModel) serviceModel).getMethodModel(method)); } // 这里是发起服务调用的入口 // invoker就是MigrationInvoker // recreate()是拿到相应根据对应协议转成我们接口返回的对象 return invoker.invoke(rpcInvocation).recreate(); } 代码进到了MigrationInvoker的involer中，为什么叫MigrationInvoker？他里面其实还有一个invoker叫CurrentAvailableInvoker，每次获取currentAvailableInvoker的时候会在MockClusterInvoker和ServiceDiscoveryInvoker中选择一个，他可能吧这个切换的过程叫迁移。
...</p></div><footer class=entry-footer>10 min</footer><a class=entry-link aria-label="post link to 4.dubbo-rpc调用源码" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/dubbo/4.rpc%E8%B0%83%E7%94%A8%E6%BA%90%E7%A0%81/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>5.SPI实现源码</h2></header><div class=entry-content><p>SPI的全称就是Service Provider Interface，是一种动态替换的机制，用来动态替换接口的实现类，需要在工作目录下的META-INF/services目录中创建一个文件，这个文件名是要被动态替换实现类的接口的全限定名，文件的内容是接口实现类的全限定名。java中通过Service.providers(接口.class)或者ServiceLoader.load(接口.class)拿到所有实现类，之后就可以遍历调用了。
Dubbo自己实现了一套SPI机制，关键组件类都是通过自己的SPI动态实例化的，让我们只需要修改一些配置就可以替换默认的组件。
java的SPI会把所有的实现类都拿出来，而Dubbo的SPI会根据需要拿到实现类，而且Dubbo的SPI还提供了IOC、AOP的功能。
除了SPI这种扩展，还可以使用配置文件的方式，当发现配置了某个配置，就加载用户自己的实现类，但是这种方式只适合少量的组件扩展，dubbo使用SPI机制让大量的核心组件都是可以替换的。
SPI的实现在ExtensionLoader中，这个类主要有3种获取extension方式getExtension()根据name获取、getAdaptiveExtension()获取url中配置的extension、getActivateExtension()根据@Adaptive注解实现一个接口自动激活多个实现类。
getExtension() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public T getExtension(String name, boolean wrap) { // 检查的代码没看 checkDestroyed(); if (StringUtils.isEmpty(name)) { throw new IllegalArgumentException("Extension name == null"); } if ("true".equals(name)) { return getDefaultExtension(); } // 一个缓存key String cacheKey = name; if (!wrap) { cacheKey += "_origin"; } // 根据缓存key获取实例对应的holder // 如果没有就创建一个空的holder final Holder&lt;Object> holder = getOrCreateHolder(cacheKey); Object instance = holder.get(); // 双重检查 if (instance == null) { synchronized (holder) { instance = holder.get(); if (instance == null) { // 创建对象 instance = createExtension(name, wrap); holder.set(instance); } } } return (T) instance; } 创建对象方法就包括读取SPI配置文件、创建class和初始化实例：
...</p></div><footer class=entry-footer>5 min</footer><a class=entry-link aria-label="post link to 5.SPI实现源码" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/dubbo/5.spi%E5%AE%9E%E7%8E%B0/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>6.各种模型源码</h2></header><div class=entry-content><p>1.filter模型 这是一责任链模式。在DefaultFilterChainBuilder的buildInvokerChain()方法中拿到所有Filter，然后遍历添加到过滤链FilterChainNode里：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public &lt;T> Invoker&lt;T> buildInvokerChain(final Invoker&lt;T> originalInvoker, String key, String group) { Invoker&lt;T> last = originalInvoker; URL url = originalInvoker.getUrl(); // 这个就是读取SPI动态扩展配置里的实现类 // 他默认的应该就两个ZoneAwareFilter和ConsumerContextFilter List&lt;Filter> filters = ScopeModelUtil.getExtensionLoader(Filter.class, url.getScopeModel()).getActivateExtension(url, key, group); if (!filters.isEmpty()) { for (int i = filters.size() - 1; i >= 0; i--) { final Filter filter = filters.get(i); final Invoker&lt;T> next = last; last = new FilterChainNode&lt;>(originalInvoker, next, filter); } } return last; } AccessLogFilter：创建一步任务把日志写到磁盘文件
...</p></div><footer class=entry-footer>5 min</footer><a class=entry-link aria-label="post link to 6.各种模型源码" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/dubbo/6.%E5%90%84%E7%A7%8D%E6%A8%A1%E5%9E%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>7.cluster模块源码</h2></header><div class=entry-content><p>cluster模块里主要的组件有Directory(管理集群信息)、Cluster+ClusterInvoker(集群容错)、LoadBalance(负载均衡)、Router(筛选可以访问的invokers)。
1.Directory 在源码中关于这个接口主要用到的实现类就是RegistryDirectory，RegistryDirectory是DynamicDirectory的子类，这两个实现类都是在dubbo_registry模块里的。先看DynamicDirectory的代码。
DynamicDirectory的类注释上写的RegistryDirectory，因为在2.6.x、2.7.x的版本这个类就是叫RegistryDirectory，3.0之后改名为DynamicDirectory，他是用来做目标服务发现和集群信息维护的最核心的组件，Dynamic的意思是维护目标实例集群地址不光要主动拉取，一般第一次的时候会主动拉取，还需要在注册中心注册监听，动态维护目标实例集群。注意这里只是目标实例，每个目标实例都有自己的DynamicDirectory，看构造方法，没啥东西，都是一些变量的初始化，url设置什么的，之前看到在实例化这个类之后调用了subscribe()方法，在进到这个方法里：
subscribe()源码 1 2 3 4 5 6 7 public void subscribe(URL url) { // 这个就是设置了一下url，set方法，没啥看的 setSubscribeUrl(url); // 这个方法就很关键，用来在最开始的时候拿到目标服务实例集群地址 // 订阅！用zk相关的registry进行订阅 registry.subscribe(url, this); } 这个时候的registry是ListenerRegistryWrapper，这个ListenerRegistryWrapper不是重点，因为他里面就是一个try finally，继续调用registry.subscribe(url, listener);这个时候的registry是ServiceDiscoveryRegistry……，最后会走到ZookeeperRegistry的doSubscribe()方法里。这个方法里会为节点添加监听：
1 zkClient.addChildListener(path, zkListener); zk节点监听器中重写了childChanged()方法：
1 2 3 4 5 6 7 8 9 public void childChanged(String path, List&lt;String> children) { try { latch.await(); } catch (InterruptedException e) { logger.warn("Zookeeper children listener thread was interrupted unexpectedly, may cause race condition with the main thread."); } // notifier是在构造方法里创建的RegistryNotifier notifier.notify(children); } 最后会一层一层调用到RegistryDirectory的refreshInvoker()方法，在这里会建立netty连接，构建DubboInvoker。
...</p></div><footer class=entry-footer>28 min</footer><a class=entry-link aria-label="post link to 7.cluster模块源码" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/dubbo/7.cluster%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>8.model组件源码</h2></header><div class=entry-content><p>Model的相关组件在我们初始化provider之前就已经创建好了，先进到总父类ScopeModel中，看到他继承了ExtensionAccessor接口，看这个名就和SPI有关系，猜测只要实现了ExtensionAccessor接口就具备了使用SPI机制获取指定接口扩展实现的能力。
ScopeModel 看一下类中的变量：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 /** * 这个是他内部的id，用来定位model在model树中的位置 * &lt;ol> * &lt;li>1&lt;/li> * FrameworkModel (index=1) * &lt;li>1.2&lt;/li> * FrameworkModel (index=1) -> ApplicationModel (index=2) * &lt;li>1.2.0&lt;/li> * FrameworkModel (index=1) -> ApplicationModel (index=2) -> ModuleModel (index=0, internal module) * &lt;li>1.2.1&lt;/li> * FrameworkModel (index=1) -> ApplicationModel (index=2) -> ModuleModel (index=1, first user module) * &lt;/ol> */ private String internalId; /** * Public Model Name, can be set from user */ private String modelName; private String desc; /** * 一批要使用的类加载器 */ private Set&lt;ClassLoader> classLoaders; /** * 这个是父类，也就是通过这个属性构成的model树 */ private final ScopeModel parent; /** * 这个是枚举类，用来表示Extension实例对象的范围 * 因为有很多的Model组件，这个属性就决定了当前Model创建出的Extension实例在那个范围可以使用 * 是当前框架都能用还是当前模块都能用 */ private final ExtensionScope scope; /** * 他是一个Extension loader的管理组件 * 如果想针对某个接口加载SPI的实现类，就要用这个变量获取到接口对应的ExtensionLoader组件，再去获取对应的实现类 */ private ExtensionDirector extensionDirector; /** * 这个就和Spring类似的 * dubbo自己实现的，负责管理在dubbo框架内部共享的bean */ private ScopeBeanFactory beanFactory; /** * model组件的生命周期事件监听 */ private List&lt;ScopeModelDestroyListener> destroyListeners; /** * 这个应该放的是当前Model的属性 */ private Map&lt;String, Object> attributes; /** * 当前组件是否被销毁 */ private final AtomicBoolean destroyed = new AtomicBoolean(false); 这个父类的构造方法就是设置parent和ExtensionScope，还有一些属性实在initialize()方法中设置的：
...</p></div><footer class=entry-footer>5 min</footer><a class=entry-link aria-label="post link to 8.model组件源码" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/dubbo/8.model%E7%BB%84%E4%BB%B6/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>9.dubbo-高阶特性源码</h2></header><div class=entry-content><p>一、triple协议 使用triple协议时DubboProtocol会被替换成TripleProtocol。TripleProtocol的export()方法和DubboProtocol的区别就是调用的是PortUnificationExchanger的bind()方法：
1 2 3 4 5 6 7 8 9 10 11 12 /** * PortUnificationExchanger */ public static void bind(URL url) { servers.computeIfAbsent(url.getAddress(), addr -> { // 构建server final PortUnificationServer server = new PortUnificationServer(url); // 启动server，这里还是使用netty server.bind(); return server; }); } server.bind();方法就是启动netty服务，但是使用的handler和Dubbo协议不一样，triple使用的handler是PortUnificationServerHandler。
...</p></div><footer class=entry-footer>9 min</footer><a class=entry-link aria-label="post link to 9.dubbo-高阶特性源码" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/dubbo/9.%E9%AB%98%E9%98%B6%E7%89%B9%E6%80%A7%E6%BA%90%E7%A0%81/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>