---
title: 调优
tags:
  - nginx
categories: 网络
copyright: true
---

### 优化方法论

#### 软件层面：

* 增大CPU利用率
* 增大内存利用率
* 增大磁盘io利用率
* 增大网络带宽利用率

#### 硬件层面

万兆网卡、固态磁盘、更快主频，多核的CPU、更大的内存

使用DNS+nginx集群

***

可以安装numactl工具查看CPU信息，比如核数、命中率什么的。

设置worker进程数：

```nginx
# 默认是1
# 如果是auto，会根据CPU核数自动创建
# 可以设置number
worker_processes number | auto;
```

使用pidstat -w -p [pid] 1美妙打印一次进程的上下文切换次数，生产环境要让这个次数不要太高，可以设置nginx的静态优先级，最低是-20，最高是19，越低就说明越不友好，越不想把CPU让出去

```nginx
# 默认是0，设置成-20
worker_priority -20;
```

打开reuseport

```nginx
# 在listen的端口号后面加上就可以了
# 同一个nginx实例下针对同一个IP+端口，其中一个设置了reuseport即可全部生效
listen 80 reuseport;
```

绑核

```nginx
# 自动根据CPU和worker进程数绑定
worker_cpu_affinity auto [cpumask];
# 手动指定
worker_cpu_affinity cpumask...;
```

tcp优化，修改/etc/sysctl.conf

```shell
# 存放第一次握手成功后的请求的队列长度
net.core.netdev_max_backlog = 262144
# 等待第一次握手的队列长度
net.ipv4.tcp_max_syn_backlog = 262144
# 超出处理能力时，对信赖的syn丢弃连接
net.ipv4.tcp_abort_on_overflow
# 读缓冲区的最小值、默认值、最大值
net.ipv4.tcp_rmem = 4096    87380    6291456
# 写缓冲区的最小值、默认值、最大值
net.ipv4.tcp_wmem = 4096    16384    4194304
# 自动调整缓存
net.ipv4.tcp_moderate_rcvbuf = 1
# 复用time-wait状态的端口
net.ipv4.tcp_tw_reuse = 1
# time_wait状态的连接的最大数量
net.ipv4.tcp_max_tw_buckets = 262144
```

```shell
# 刷新，生效
sysctl -p
```

 修改文件句柄数

```nginx
worker_rlimit_nofile 102400;
# event中配置worker连接数，默认1024个
worker_connections 102400;
```

使用tcp fast open

```shell
# 0是关闭，1：当做客户端时使用，2：当做服务端时使用，3：任何时候都是用
net.ipv4.tcp_fastopen = 3
# nginx限制fastopen数量
listen ip:port [fastopen=200]
```

配置nagle

```nginx
# 在http、server、location在
# 关闭后会把数据包合并
tcp_nodelay off;
```

配置keepalive

```nginx
# server中配置
so_keepalive = on;
```

```nginx
location /empty.gif {
    add_header Cache-Control no-cache;
    add_header Cache-Control no-store;
    empty_gif;
}
```

#### 日志切割

进入nginx路径：

```shell
cd /usr/local/openresty/nginx/
```

编写脚本：

```shell
vim cut_nginx_log.sh
```

脚本内容：

```shell
#!/bin/bash
# 保留日志文件个数
ReservedNum=14
# nginx日志文件所在目录
LOG_PATH=/data/nginx/logs/
# 获取昨天的日期
YESTERDAY=$(date -d "yesterday" +%Y-%m-%d)
# nginx pid文件路径
PID=/usr/local/openresty/nginx/logs/nginx.pid
# 分割日志
mv ${LOG_PATH}access.log ${LOG_PATH}access-${YESTERDAY}.log
mv ${LOG_PATH}error.log ${LOG_PATH}error-${YESTERDAY}.log
# 向nginx主进程发送USR1信号，重新打开日志文件
kill -USR1 `cat ${PID}`

# 保留最近7个(access加err)日志文件
# ls -t | sed -n '15,$p' | xargs -I {} rm -rf {}
FileNum=$(ls -l  $LOG_PATH/ |grep ^- |wc -l)

while((FileNum > ReservedNum))
do
    OldFile=$(ls -rt  $LOG_PATH/| head -1)
    find $LOG_PATH -name $OldFile | xargs rm -f {}
    let "FileNum--"
done
```

设置文件执行权限：

```shell
chmod +x cut_nginx_log.sh
```

编写crontab：

```shell
crontab -e
```

增加定时任务：

```shell
0 0 * * * /bin/bash /usr/local/openresty/nginx/cut_nginx_log.sh
```

保存退出就可以了。
