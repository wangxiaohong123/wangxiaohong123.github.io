---
title: 3.机器学习算法
tags:
  - 机器学习
categories: 人工智能
copyright: true
---

##### 距离度量

一些算法会需要距离度量，比如K近邻、SVM、聚类等，距离有4个特性：

1.   非负性：两点的距离不能小于0；
2.   同一性：两点的距离=0说明时同1个点；
3.   对称性：x到y的距离时0时，y到x的距离也是0；
4.   直递性：dist(i,j)<=dist(i,k) + dist(k,j);

常见的距离公式：

1.   欧式距离：两个点就是勾股定理，n个点就开根号n；
2.   曼哈顿距离：曼哈顿距离是当两个点不能练成直线时的距离，计算公式：$\sum_{k=1}^n\vert X_{k}-X_{k-1} \vert$；
3.   切比雪夫距离：类比于国际象棋中的国王走棋的方式，国王可以在一个步长内向任何方向移动，两点的距离公式为$D(P,Q)=max(\vert x_1−x_2\vert,\vert y_1−y_2\vert,...,\vert x_n−x_{n+1}\vert)$​；
4.   闵氏距离：闵氏距离是将上面3个变成了1个公式，当p=1的时候是曼哈顿距离，p=2的时候是欧式距离，p>=3的时候是切比雪夫距离

### 1 K近邻算法

根据最近的距离判断类别，最近的样本数据是什么类别，你就是什么类别，这里的样本数量可以取n个。也叫KNN算法。

求两个坐标的距离使用勾股定理，多维也是一样的。

比如现有数据：

| 电影名     | 搞笑镜头 | 拥抱镜头 | 打斗镜头 | 电影类型 |
| ---------- | -------- | -------- | -------- | -------- |
| 功夫熊猫   | 39       | 0        | 31       | 喜剧片   |
| 叶问3      | 3        | 2        | 65       | 动作片   |
| 二次曝光   | 2        | 3        | 55       | 爱情片   |
| 代理情人   | 9        | 38       | 2        | 爱情片   |
| 步步惊心   | 8        | 34       | 17       | 爱情片   |
| 谍影重重   | 5        | 3        | 57       | 动作片   |
| 美人鱼     | 21       | 17       | 5        | 喜剧片   |
| 小鬼当家   | 45       | 2        | 9        | 喜剧片   |
| 唐人街探案 | 23       | 3        | 17       |          |

唐人街探案时测试数据，上面的事样本数据，需要判断唐人街探案是什么类型的电影时，就要先求出唐人街探案距离每个电影的距离：

比如唐人街探案距离功夫熊猫的距离：$\sqrt[3]{(23 - 39)^2 + (3 - 0)^2 + (17 - 31)^2} \approx 21.47$，依次算出唐人街探案和所有电影的距离：

| 电影名     | 搞笑镜头 | 拥抱镜头 | 打斗镜头 | 电影类型 | 距离  |
| ---------- | -------- | -------- | -------- | -------- | ----- |
| 功夫熊猫   | 39       | 0        | 31       | 喜剧片   | 21.47 |
| 叶问3      | 3        | 2        | 65       | 动作片   | 52.01 |
| 二次曝光   | 2        | 3        | 55       | 爱情片   | 43.42 |
| 代理情人   | 9        | 38       | 2        | 爱情片   | 40.57 |
| 步步惊心   | 8        | 34       | 17       | 爱情片   | 34.44 |
| 谍影重重   | 5        | 3        | 57       | 动作片   | 43.87 |
| 美人鱼     | 21       | 17       | 5        | 喜剧片   | 18.55 |
| 小鬼当家   | 45       | 2        | 9        | 喜剧片   | 23.43 |
| 唐人街探案 | 23       | 3        | 17       |          |       |

假设K=5时，就是找到距离最小的5个电影：美人鱼、小鬼当家、功夫熊猫、步步惊心、代理情人，这里有3个喜剧片和2个爱情片，所以推测唐人街探案是喜剧片。

#### 1.1 基本使用

```python
from sklearn.neighbors import KNeighborsClassifier

# 构造数据
# 样本
x = [[1], [2], [10], [20]]
# 特征
y = [0, 0, 1, 1]

# 训练模型
# 实例化估计器
# n_neighbors表示参考几个邻居
estimator = KNeighborsClassifier(n_neighbors=2)
# 训练
estimator.fit(x, y)

# 预测
print(estimator.predict([[100]]))
```

#### 1.2 kd树

kd树可以理解成一个多维度的平衡二叉树，每个节点存储多个维度的数据，比如(x，y)，(x，y，z)，就算有多个维度也只能按1个维度进行排序，但是每层排序的维度可能不一样，利用分维度排序的方式，将多维数据划分为超矩形（hyper-rectangle）区域，从而支持快速区域查询和最近邻查询。

##### 1.2.1 KD树的构建

一般是选择方差较大的维度进行划分，首先将每个维度各拆分成1个数组计算方差，找到方差最大的维度，将方差最大的维度进行排序，找到中位数作为根节点。如果想要在坐标系中划分出超矩阵，那么kd树每层的划分维度就不能相同。

**以数据{(2,3),(5,4),(9,6),(4,7),(8,1),(7,2)}数据举例**

两个维度的数据分别是[2,5,9,4,8,7]和[3,4,6,7,1,2]，第一个维度的方差约等于5.8，第二个维度的方差约等于4.5，所以根节点应该取第一维度的数据的中位数，也就是(5,4)或者(7,2)都可以，假设选择(7,2)当做根节点，此时(2,3),(5,4),(4,7)都在根节点的左侧，(9,6)和(8,1)在根节点的右侧，因为要划分超矩阵，所以第二层使用第二维度来划分(2,3),(5,4),(4,7)和(9,6)和(8,1)，第三层在使用第一维度划分，最后划分出的逻辑上的kd树和超矩阵类似下面这样：

![kd树](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/kd树.png)

更多维度是一样的道理，每层都选最分散的维度进行划分。

##### 1.2.2 KD树的搜索

搜索的时候首先从根节点遍历树，找到里目标点位最近的点，遍历的时候需要把路径上经过的点存到队列中，因为KD树有多个维度，并且每层都是用不同维度，所以当前找到的点可能不是举例最近的点，此时需要计算两点的距离，以这个距离为半径画圆；此时回溯队列计算最短距离，如果园和队列中取出的点划分的矩阵相交就需要将这个矩阵中的点拿出来放到队列中，如果没相交就继续遍历队列中的下一个点。这样就可以找到最短距离的点位。

#### 1.3 KNN算法完整代码：

```python
# 获取数据集
from sklearn.datasets import load_iris
# 将数据分割成训练数据和测试数据,GridSearchCV用来网格搜索和交叉验证
from sklearn.model_selection import train_test_split, GridSearchCV
# 特征与处理
from sklearn.preprocessing import StandardScaler
# 导入算法
from sklearn.neighbors import KNeighborsClassifier

# 1.获取数据
iris = load_iris()
# 2.数据基本处理,因为拿到的数据很规范，这里只把数据进行训练和测试的分割
x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=0.2, random_state=22)
# 3.特征工程-特征预处理
transfer = StandardScaler()
x_train = transfer.fit_transform(x_train)
x_test = transfer.fit_transform(x_test)
# 4.机器学习-KNN
# 这里不能指定n_neighbors=5，因为下面需要使用GridSearchCV进行调优
estimator = KNeighborsClassifier()

# 模型调优，网格搜索
param_grid = {'n_neighbors': [1, 2, 3, 4, 5]}
# param_grid:预设的超参数，cv:几折交叉验证
estimator = GridSearchCV(estimator, param_grid=param_grid, cv=4)

# 模型训练
estimator.fit(x_train, y_train)
# 5.模型评估
y_pre = estimator.predict(x_test)
print("预测值是:\n", y_pre)
print("预测值和真实值的对比是:\n", y_pre == y_test)
score = estimator.score(x_test, y_test)
print("准确率为:\n", score)

# 查看交叉验证，网格搜索的属性
print("在交叉验证中得到的最好结果是:\n", estimator.best_score_)
print("在交叉验证中得到的最好的模型是:\n", estimator.best_estimator_)
print("在交叉验证中得到的模型结果是:\n", estimator.cv_results_)
```

![KNN](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/KNN.png)

K近邻的有点就是简单，他没有模型，它属于惰性训练，效率不高。适合大样本自动分类，输出可解释性不强。

### 2 线性回归

线性回归就是利用回归方程，对一个或者多个特征值(自变量)和目标值(因变量)之间进行建模。只有一个自变量叫单变量回归，多个自变量叫多元回归。

**线性关系**回归公式：$h(w) = w_1x_1 + w_1x_1 + ··· + b$，可以理解为两个向量相乘：$\left(\begin{matrix}b\\w_1\\w_2\end{matrix}\right) * \left(\begin{matrix}1\\x_1\\x_2\end{matrix}\right)$。

上面说的是线性关系，如果是**非线性关系**就需要高次项，比如$h(w) = w_1x_1^2 + w_1x_1^2 + ··· + b$。

线性回归的简单使用：

```python
from sklearn.linear_model import LinearRegression

x = [[80, 86], [82, 80], [85, 78], [90, 90], [86, 82]]
y = [84.2, 80.6, 80.1, 90, 83.2]

# 实例化估计器，这里没有手动指定系数
estimator = LinearRegression()
# 训练
estimator.fit(x, y)

print("线性回归的系数是:\n", estimator.coef_)
print("输出预测结果:\n", estimator.predict([[100, 80]]))
```

### 3 逻辑回归

逻辑回归是一种分类的算法，主要解决而分类问题，适用于垃圾邮件判断、金融诈骗、虚假账号判断等等。

逻辑回归的输入就是线性回归的输出，将线性回归的输出映射到一个概率值进行分类。

逻辑函数(Sigmoid函数)：$\hat y = \sigma(z) = \dfrac 1{1 + e^ {-z}}$其中$\hat y$就是预测的概率值，z就是线性回归的输出h(w)：$h(w) = w_1x_1 + w_1x_1 + ··· + b$。在而分类问题中，通常会有一个阈值(默认是0.5)，概率大于阈值时模型的预测结果为1，否则为0。

逻辑函数的损失函数使用对数似然损失函数或者交叉熵损失函数：$L(\beta) = - \sum_{i=1}^m \left[ y_i \log(\hat{y}_i) + (1 - y_i) \log(1 - \hat{y}_i) \right]$，优化使用梯度下降函数。

逻辑回归demo:

```python
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression

# 获取数据
names = ["zz", "xxx", "dsds"]
data = pd.read_csv("文件链接", names=names)

# 数据处理
data = data.replace(to_replace="?", value=np.nan)
data = data.dropna()
# 特征值
x = data.iloc[:, 1:-1]
# 目标值
y = data["Class"]
# 数据分隔
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2)

# 特征工程
transfer = StandardScaler()
x_train = transfer.fit_transform(x_train)
x_test = transfer.fit_transform(x_test)

# 机器学习
estimator = LogisticRegression()
estimator.fit(x_train, y_train)

# 模型评估
res = estimator.score(x_test, y_test)
```

### 4 决策树

决策树的每个节点代表一个属性的判断，每个分支代表判断结果的输出，理解起来就像if-else结构。需要注意的是条件判断的优先级，就是如何决定哪个条件是第一次判断，哪个条件是第二次判断，由信息熵决定。

熵用来衡量物体的混乱程度，系统越混乱或者越分散，熵值越高，越有序熵值越低。在信息熵种，如果系统的有序状态一致，数据越集中的地方熵值越小；当数据量相同的时候系统越有序熵值越低。

##### 决策树划分方法

1.   信息增益：以某特征划分数据集前后的熵的差值，熵可以表示样本集合的不确定性，熵越大样本越不确定，因此可以使用划分前后集合的熵的差值来衡量当前特征对于样本集合划分效果的好坏。
2.   信息增益率：使用信息增益和当前属性固有的值相除得到的。他解决了信息增益可能优先选择属性类别更多的一项划分。
3.   基尼值(CART)和基尼值指数：基尼值是从数据集中随机抽取两个样本，被标记成不一致的概率，基尼值越小样本纯度越高。基尼值指数就是选择使划分后基尼系数最小的属性作为最优划分属性。

当噪声和样本冲突或者有些属性不应该作为分类标准的时候可能会导致决策树出现过拟合现象，这个时候就需要剪枝操作。剪枝的方法有2种，**预剪枝和后剪枝**。

##### 决策树demo

```python
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.featrue_extraction import DictVectorizer
from sklearn.tree import DecisionTreeClassifier

# 读取数据
titan = pd.read_csv('titanic.csv')

# 数据基本处理-确定特征值，目标值
x = titan[["pclass", "age", "sex"]]
y = titan["survived"]
# 数据基本处理-缺失值处理
x["age"].fillna(value=titan["age"].mean(), inplace=True)

# 数据集划分
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2)

# 特征工程-字典特征提取
x_train = x_train.to_dict(orient='records')
x_test = x_test.to_dict(orient='records')
transfer = DictVectorizer()
x_train = transfer.fit_transform(x_train)
x_test = transfer.fit_transform(x_test)

# 模型训练
# criterion 特征选择标准，gini表示基尼系数，entropy表示信息增益
# min_samples_split 内部节点在划分需要的最小样本数
# min_simples_leaf 叶子结点最小样本数
# max_depth 决策树最大深度
# random_state 随机数种子，控制两个特征同时满足条件时当前节点选择哪个特征
estimator = DecisionTreeClassifier(criterion='gini', max_depth=5)
estimator.fit(x_train, y_train)

# 模型评估
y_pred = estimator.predict(x_test)
ret = estimator.score(x_test, y_test)
print(ret)
```

可以使用export_graphviz()函数将决策树到处DOT格式，将文件内容复制到webgraphviz网站就能看到树的图形了。

决策树出了上面的分类决策树，还有**回归决策树**。

### 5 集成学习

生成多个分类器/模型，各自独立学习和预测，最后合成组合预测。

##### bagging学习方法

有放回的选取n条样本，训练出多个分类器，预测时多个分类器平权投票获得结果。

随机森林：bagging + 决策树，他是训练出多个弱决策树平权投票。

上面两种方法训练时都是使用样本的**部分特征**。

包外估计：不管取多少条样本，每次训练完平均有1/e(36.8%)的没有被取到。这些数据就是包外估计，他主要有两个用途：

*   辅助剪枝，可以用这些数据当作训练集。
*   学习器是神经网络时用来早期停止减少过拟合。

集成学习的损失函数：$-\dfrac 1 N \sum_{i=1}^N\sum_{j=1}^M y_{ij} log^{(p_{ij})}$，i是样本，j是类别，$p_{ij}$表示第i个样本属于j类别的概率；如果第i个样本属于j类别则$y_{ij}=1$否则为0。

随机森林demo：

```python
import pandas as pd
import matplotlib.pyplot as plt
from imblearn.under_sampling import RandomUnderSampler
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import log_loss
from sklearn.preprocessing import OneHotEncoder

# 数据获取
data = pd.read_csv('data.csv')

# 数据处理,如果数据量很大并且每个数量的类别相差很大，可以使用随机欠采样
y = data['target']
x = data.drop(['id', 'target'], axis=1)
rus = RandomUnderSampler(random_state=0)
x_resampled, y_resampled = rus.fit_resample(x, y)
# 数据处理-把标签转换成数字
le = LabelEncoder()
y_resampled = le.fit_transform(y_resampled)
# 数据处理-分割数据
x_train, x_test, y_train, y_test = train_test_split(x_resampled, y_resampled, test_size=0.2)

# 模型训练-基本模型训练,oob_score=True表示使用包外估计
rf = RandomForestClassifier(oob_score=True)
rf.fit(x_train, y_train)
y_pred = rf.predict(x_test)

# 模型评估,log_loss必须要将输出用one-hot表示
one_hot = OneHotEncoder(sparse=False)
log_loss(one_hot.fit_transform(y_test.reshape(-1, 1)),
         one_hot.fit_transform(y_pred.reshape(-1, 1)),
         eps=1e-15, normalize=True)
```

##### boosting学习方法

将多个弱学习器结合起来，在每轮训练中，后续模型更关注前一轮中被错误分类的样本，给这些样本更高的权重，一边新的模型能纠正错误，所以他是一种**加权训练**，并且他是将所有若分类器合成一个强分类器。常见的算法有 **AdaBoost**、**Gradient Boosting** 和 **XGBoost**。

### 6 聚类算法

是一种无监督算法，将相似的样本归到一个类别中。使用不同的聚类准则，产生的结果不同。主要用作用户画像，系统推荐、恶意流量识别等。

##### KMeans

K表示初始中心点个数，means是中心点到其他数据点距离的平均值，流程：

1.   先随机找到我们设置的个数的**质心（分类中心点）**；
2.   遍历所有样本，每个样本都和这几个随机点求距离，找到距离最近的随机点n，暂时归到随机点n类
3.   计算每类的中心，如果中心和随机点不同，从第1步开始重新计算

KMeans原理简单实现容易，并且聚类效果还可以，但是他对噪声敏感，容易中心点偏移，可以保证局部最优，不能保证全局最优，demo：

```python
import matplotlib.pyplot as plt
from sklearn.datasets._samples_generator import make_blobs
from sklearn.cluster import KMeans
from sklearn.metrics import calinski_harabasz_score

# 创建数据集
# x是样本特征，y是样本类别，一共1000个样本
# 每个样本4个蔟，蔟的中心分别是{-1, -1}, {0, 0}, {1, 1}, {2, 2}
# 蔟的方差分别为0.4, 0.2, 0.2, 0.2
x, y = make_blobs(n_samples=1000, n_featrues=2, centers=[[-1, -1], [0, 0], [1, 1], [2, 2]], cluster_std=[0.4, 0.2, 0.2, 0.2], random_state=0)

# 数据集可视化
plt.scatter(x[:, 0], x[:, 1], marker='o')
plt.show()

# 训练并预测，将样本数据分成2类
y_pred = KMeans(n_clusters=2).fit_predict(x)
# 可视化
plt.scatter(x[:, 0], x[:, 1], c=y_pred)
plt.show()

# 使用ch_score查看效果，值越大效果越好
print(calinski_harabasz_score(x, y_pred))

```

###### 模型评估

1.   误差平方和
2.   肘方法
3.   轮廓系数法
4.   CH系数

###### KMeans优化

1.   canopy：优化了选择质心，防止质心选择时距离特别近，他是先随机一个质心，然后分别以t1、t2为半径画圆，然后在圆外随机选第二个质心再画圆，直到所有样本都在圆里。他的缺点时t1，t2不好设置。
2.   KMeans++：也是优化了质心的选择，通过这个公式可以让下次选择的质心距离较远$P(x_i) = \frac{D(x_i)^2}{\sum_{j} D(x_j)^2}$​
3.   k-medoids：优化了第二步，距离所有点最近的点当作中心点，对噪声鲁棒性好。

### 7 朴素贝叶斯

这也是一个分类算法，他和之前的KNN、决策树等不一样的是贝叶斯是结果按概率分布，比如n%概率属于类别a，m%概率属于类别b。

贝叶斯的公式是$P(c|w) = \dfrac {P(w|c)P(c)}{P(w)}$,w是文档的特征值，频数统计等，c是文档的类别。朴素贝叶斯中的朴素说的是特征之间相互独立。

因为征是相互独立的，所以计算P(w)的时候会被拆分成P(w1) * P(w2)……这种，当样本数过少的时候可能会出现P(w)等于0的情况，这个时候可以使用**拉普拉斯平滑系数**。

**举例：**比如学校的男女比例是3:2，男生穿裤子，女生有1半穿裤子，一半穿裙子，当你看到一个人穿裤子的时候判断是女生的概率。其实就是求事件B发生的条件下，A事件发生的概率：$ P(A|B) = \frac{P(B|A) \cdot P(A)}{P(B)} $。**可以做拼写检查、垃圾邮件过滤之类的事。**

demo:

```python
import gensim
import pandas as pd
import jieba
from wordcloud import WordCloud
import matplotlib.pyplot as plt
import matplotlib
from gensim import corpora
from sklearn.model_selection import train_test_split
from sklearn.featrue_extraction.text import CountVectorizer, TfidfVectorizer
from sklearn.naive_bayes import MultinomialNB

# 读取数据
df_news = pd.read_table('D:/BaiduNetdiskDownload/train.txt', names=['category', 'theme', 'URL', 'content'], encoding='utf-8')
df_news = df_news.dropna()  # 删除缺失值

# 分词
content = df_news.content.values.tolist()
content_s = []
for line in content:
    current_segment = list(jieba.cut(line))  # jieba.cut() 返回的是生成器对象，需要转为列表
    if len(current_segment) > 1 and current_segment != '\r\n':  # 排除换行符
        content_s.append(current_segment)

# 停用词
stopwords = pd.read_csv("D:/BaiduNetdiskDownload/stopwords.txt", index_col=False, sep="\t", quoting=3,
                        names=['stopword'], encoding='utf-8')


def drop_stopwords(contents):
    contents_clean = []
    all_words = []
    stopwords_set = set(stopwords.stopword.values.tolist())  # 使用集合加速查找
    for line in contents:
        line_clean = [word for word in line if word not in stopwords_set]  # 去除停用词
        contents_clean.append(line_clean)
        all_words.extend(line_clean)
    return contents_clean, all_words


contents_clean, all_words = drop_stopwords(content_s)
df_content = pd.DataFrame({'contents_clean': contents_clean})
df_all_words = pd.DataFrame({'all_words': all_words})

# 统计词频
words_count = df_all_words.groupby('all_words').size().reset_index(name='count').sort_values(by='count',
                                                                                             ascending=False)

# 词云
wordcloud = WordCloud(font_path="./simhei.ttf", background_color="white", max_font_size=80)
word_frequence = {x[0]: x[1] for x in words_count.head(100).values}  # 获取前100个高频词
wordcloud = wordcloud.fit_words(word_frequence)
matplotlib.use('TkAgg')
plt.imshow(wordcloud)
plt.show()

# LDA 主题建模
dictionary = corpora.Dictionary(contents_clean)  # 构建词典
corpus = [dictionary.doc2bow(sentence) for sentence in contents_clean]  # 转化为词袋
lda = gensim.models.LdaModel(corpus=corpus, id2word=dictionary, num_topics=20)

# 标签映射
label_mapping = {
    "汽车": 1, "财经": 2, "科技": 3, "健康": 4, "体育": 5, "教育": 6,
    "文化": 7, "军事": 8, "娱乐": 9, "时尚": 0
}
df_news['label'] = df_news['category'].map(label_mapping)

# 划分训练集和测试集
x_train, x_test, y_train, y_test = train_test_split(df_content['contents_clean'].values, df_news['label'].values, random_state=1)

# 数据预处理：将每个文档的词语连接成字符串
words = [' '.join(line) for line in x_train]

# 词袋模型
vec = CountVectorizer(analyzer='word', max_featrues=4000, lowercase=False)
vec.fit(words)

# 训练 Naive Bayes 分类器
classifier = MultinomialNB()
classifier.fit(vec.transform(words), y_train)

# 测试集预测
test_words = [' '.join(line) for line in x_test]
print(f"MultinomialNB accuracy: {classifier.score(vec.transform(test_words), y_test)}")

# 使用 TF-IDF 进行文本向量化
vectorizer = TfidfVectorizer(analyzer='word', max_featrues=4000, lowercase=False)
vectorizer.fit(words)

# 训练 Naive Bayes 分类器
classifier = MultinomialNB()
classifier.fit(vectorizer.transform(words), y_train)
print(f"Tfidf + MultinomialNB accuracy: {classifier.score(vectorizer.transform(test_words), y_test)}")
```

**特征值之间存在关联时效果会下降。**

### 8 支持向量机

SVM定义：寻找一个超平面，将样本分成2类，并且间隔最大。

当要求所有数据都正确分类叫硬间隔分类，只有当数据时线性可分离的时候才有效，并且对异常非常敏感；如果允许少部分数据分类错误，尽可能保持最大间隔和间隔违例找到平衡点叫软间隔分类。

### 9 HMM

##### 1 EM介绍

EM也叫期望最大化算法，E表示期望步，M表示极大步。主要是解决数据确实情况下的参数估计问题。他主要就2步：

1.   根据给出的结果估计出参数值（E步）；
2.   使用估计出的参数值估计缺失的数据，使用估计出的缺失数据和结果重新估计参数值（M步）；

反复迭代一直到最后收敛。

最大似然函数

##### 2 HMM

**马尔科夫模型**（Markov Model）是一种用于描述随机过程的数学模型，其基本假设是“马尔科夫性”，即系统的未来状态只与当前状态有关，与过去的历史状态无关。这种模型广泛应用于许多领域，如语音识别、自然语言处理、金融建模等。假设一个马尔科夫链的状态空间是 $S=\{s_1,s_2,…,s_N\}$，那么转移概率矩阵 P中的元素$P_{ij}$表示从状态$s_i$转移到状态$s_j$的概率，即：$P_{ij} = P(s_{t+1} = s_j | s_t = s_i)$，其中$s_t$表示时刻t的状态，$P_{ij}$表示从状态$s_i$转移到状态$s_j$的概率，满足以下条件：

$0 \leq P_{ij} \leq 1 \quad \text{且} \quad \sum_{j=1}^N P_{ij} = 1$

即每一行的概率和为 1，表示从当前状态出发，总有一个状态是可以到达的。

**隐马尔科夫模型**是对马尔科夫模型的一种扩展，特别用于处理那些观察到的现象是隐藏的、不可直接获取的情形。在 HMM 中，系统的状态是不可观察的（隐状态），而可以观察到的是与这些隐状态相关的观测值。比如现在有3中骰子，6面的、4面的、8面的，每次随机从3个骰子中取一个投掷得到一串点数，从结果上看一串点数属于显示状态链，但是不知道每次投掷时使用的是哪个骰子，这个是隐含状态链。

隐马尔科夫模型的目标是通过给定的观测序列 $O = (o_1, o_2, \dots, o_T)$，推断最可能的隐状态序列 $S = (s_1, s_2, \dots, s_T)$。

###### 2.1 HMM 包括以下几个重要组件：

-   **隐状态空间**：$S={s_1,s_2,…,s_N}$,系统可能的所有隐藏状态集合。隐状态本身不能直接观察到。
-   **观测空间**：$O={o_1,o_2,…,o_M}$,可以直接观察到的事件集合（例如，从某个状态产生的观察数据）。
-   **状态转移概率**：描述隐状态之间的转移概率，和马尔科夫模型类似。$A=\{a_{ij}\}, 其中 a_{ij} = P(s_{t+1} = s_j | s_t = s_i)$。
-   **观测概率**：描述每个隐状态下生成观测值的概率。$B={b_i(o_k)}$，其中 $b_i(o_k) = P(o_k | s_i)$ 表示在隐状态 $s_i$ 下观察到 $o_k$ 的概率。
-   **初始状态概率**：描述系统初始状态的概率分布。$π_i=P(s_1=s_i)$。

1.   知道骰子有几种(隐含状态数量)，每种骰子是什么(转换概率)，掷出的结果(可见状态链)，想知道每次掷出的是哪种骰子(隐含状态链)。主要用在语音识别的解码问题上。

     使用最大似然状态路径或者求每次掷出的骰子分别为某种骰子的概率取最大的。

2.   知道骰子有几种(隐含状态数量)，每种骰子是什么(转换概率)，掷出的结果(可见状态链)，想知道掷出这个结果的概率。这个直接算条件概率就行。

3.   知道骰子有几种(隐含状态数量)，不知道每种骰子是什么(转换概率)，观测到多次掷出的结果(可见状态链)，反推出每种骰子是什么。

###### 2.2 常用的算法：

-   **前向-后向算法**（用于评估问题）：

前向变量 $\alpha_t$ 表示在时刻 t 系统处于状态 $s_i$ 的概率：$\alpha_t(i) = P(o_1, o_2, \dots, o_t, s_t = s_i)$

后向变量 $\beta_t(i)$ 表示在时刻 t 之后，给定状态 $s_i$ 生成观测序列的概率：$\beta_t(i) = P(o_{t+1}, o_{t+2}, \dots, o_T | s_t = s_i)$

-   **维特比算法**（用于解码问题）：

维特比算法用于找到给定观测序列的最可能的隐状态序列 $S^*$。定义递推公式：$\delta_t(i) = \max_{s_1, s_2, \dots, s_{t-1}} \left( \delta_{t-1}(i') a_{i'i} b_i(o_t) \right)$，其中，$\delta_t(i)$ 表示在时刻 t 系统处于状态 $s_i$ 的最大概率。

###### 2.3 HMM示例

```python
import numpy as np
from hmmlearn import hmm


# 隐藏状态 3个盒子
states = ['box1', 'box2', 'box3']
n_states = len(states)
# 观测状态 2种球
observations = ['red', 'white']
n_observations = len(observations)
# 模型参数
start_prob = np.array([0.2, 0.4, 0.4])
transaction_prob = np.array([
    [0.5, 0.2, 0.3],
    [0.3, 0.5, 0.2],
    [0.2, 0.3, 0.5]])
emission_prob = np.array([[0.5, 0.5], [0.4, 0.6], [0.7, 0.3]])
# 离散观测状态
model = hmm.MultinomialHMM(n_components=n_states)
model.startprob_ = start_prob
model.transmat_ = transaction_prob
model.emissionprob_ = emission_prob

# 维特比算法
seen = np.array([[0, 1, 0]]).T
logprob, box = model.decode(seen, algorithm='viterbi')
print(np.array(states)[box])
```

