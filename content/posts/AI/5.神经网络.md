---
title: 5.神经网络
tags:
  - 深度学习
categories: 人工智能
copyright: true
---

所有的神经网络都是为了提取特征。

神经网络就是把多个线性回归和逻辑回归组合到一起。由一个输入层、一个输出层和n个隐藏层组成，第n层的每个神经元和第n-1层的所有神经元相连，第n-1层的输出就是第n层的输入。每个隐藏层有n个神经元，每个神经元都有一个非线性激活函数。

神经网络的精度高，效果好；但是训练时间长，小数据集上表现不好。他的本质是摆脱人为干预的特征提取(**黑盒**)，我们只负责输入，查看输出，这就是端对端模型(end-to-end)，深度学习中只有极小值没有极大值。

*   正向传播：从输入层-->隐藏层-->输出层的过程，是根据数据损失函数和激活函数**得到模型的输出结果和损失函数的值**。
*   反向传播：从损失函数开始，逐层向后传播误差(链式法则)，并计算每个参数的梯度的过程，然后用优化器更新权重和偏置，让损失主键减小。
*   计算图：描述张量之间运算关系的有向无环图，节点是变量（输入、权重、偏置、激活函数、输出），边是数学运算（加法、乘法、激活函数等）。为了高效计算梯度的。

### 一、损失函数

也叫代价函数、目标函数、误差函数。默认作用在监督学习的输出层，但是在多任务训练、对抗训练等，损失函数也可以作用在隐藏层或中间层。

损失函数 = 数据损失 + 正则化惩罚，数据损失就是预测值和真实值的差异。损失函数中一般会带着偏执(常量)，偏置跟输出挂钩，一般几分类就会有几个偏置。

log函数可以表示预测值为1的时候损失为0，同事预测值越不准损失越大，所以一般数据损失函数都用log表示。

GPT-4的损失函数中有1.8万亿个权重参数，涉及到生活的很多方面。

#### 1. 数据损失函数

##### 1.1 分类任务损失函数

###### 1.1.1 交叉熵损失函数

多分类的交叉熵：多分类的输出层使用softmax函数，损失公式：$ L = -\frac{1}{N} \sum_{i=1}^{N} \sum_{k=1}^{K} y_{i,k} \cdot \log(\hat{y}_{i,k})$，N是样本数量；K是类别数量；$y_{i,k}$ 是第 i 个样本在第 k 个类别上的真实标签（1 表示属于该类别，0 表示不属于）； $\hat{y}_{i,k}$ 是第 i 个样本在第 k 个类别上的预测概率，就是模型输出的预测结果。

二分类的交叉熵：二分类的输出层使用sigmoid函数，损失公式：$L = -\frac{1}{N} \sum_{i=1}^{N} \Big(y_i \cdot \log(\hat{y}_i) + (1 - y_i) \cdot \log(1 - \hat{y}_i)\Big)$，参数和多酚类一样。**sigmoid函数的趋势是近似平行x轴的，会导致梯度消失**。

##### 1.2 回归任务损失函数

###### 1.2.1 MAE损失

也叫L1 Loss，以绝对误差作为距离。具有稀疏性，也可以作为正则化添加到其他loss中作为约束。他的梯度在0点不平滑，容易跳过最小值。公式：$L = \frac{1}{N} \sum_{i=1}^{N} \left| y_i - \hat{y}_i \right|$

###### 1.2.2 MSE损失

求误差的平方和，就是欧式距离，也叫L2 Loss，也可以作为正则项。公式：$L = \frac{1}{N} \sum_{i=1}^{N} \left( y_i - \hat{y}_i \right)^2$。容易造成梯度爆炸。

###### 1.2.3 smooth L1

平滑L1损失函数，他是一个分段函数，为了解决L1的不平滑和L2的梯度爆炸问题。公式：
$$
L = \frac{1}{N} \sum_{i=1}^{N} \text{Smooth}_{L1}(y_i - \hat{y}_i)\\
\\
其中：\\
\\
\text{Smooth}_{L1}(x) =
\begin{cases}
0.5 x^2, & \text{if } |x| < 1 \\
|x| - 0.5, & \text{otherwise}
\end{cases}
$$

#### 2 正则化

##### 1. L1 L2正则化

通过在损失函数中增加正则项减少过拟合，L1让某些系数变成0，L2让某些系数趋于0.

##### 2. Dropout

每次迭代的时候随机选择神经元失活。这么做是为了解决特征过多导致的过拟合问题。属于七伤拳。

##### 3. 提前停止

将一部分训练集作为验证集，当训练的时候发现验证集的性能越来越差或者不在提升的时候停止训练。因为这个时候继续训练有可能过拟合。

### 二、优化方法

#### 1. 梯度下降

梯度下降是为了寻找损失函数最小化的系数的算法。分为3类：

| 算法                 | 描述                                   | 优点                 | 缺点                 |
| -------------------- | -------------------------------------- | -------------------- | -------------------- |
| BGD(批量梯度下降)    | 每次迭代计算每个样本上的梯度并求和     | 全剧最优             | 计算量大，速度慢     |
| SGD(随机梯度下降)    | 每次迭代只采集一个样本                 | 速度快，可以在线学习 | 准确度下降，存在噪音 |
| MBGD(小批量梯度下降) | 每次随机选一小部分样本的梯度并更新参数 | 同SGD                | 同SGD                |

梯度下降可能出现的问题：

1.   平坦区下降速度慢；
2.   鞍点：存在导数为0，但不是极值点；
3.   局部极小值；

动量梯度下降：计算梯度的指数加权平均数，利用这个值更新参数，可以缓解鞍点问题。

AdaGrad：使用一个小批量随机梯度g_t按元素平方累加st对学习率修正。

RmsProp：AdaGrad后期学习率较小，很难找到最优解，RmsProp是对AdaGrad的改进。

Adam：动量梯度下降和RmsProp的结合。

### 三、RNN模型

循环神经网络是最早应用到NLP的神经网络，训练时首先将文本进行分词，每个单词会分别输入到模型中，同时本次单词的输出会作为这条文本之后的单词的训练的特征。

#### 1 传统RNN

结构简单，**短句子的训练性能和效果不错**，句子过长时会出现特征消失。他是串联结构，不能叠太多层，性能很差，而且他单向训练只能记住历史，不能推理。

![RNN](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/RNN.png)

```python
import torch
import torch.nn as nn


# 实例化rnn对象，输入张量中特征维度是5，隐藏层张量中特征维度是6(隐藏层中神经元的个数)，隐藏层个数是1
# 默认的激活函数时tanh
rnn = nn.RNN(5, 6, 1)
# 设定输入的张量，输入序列的长度是1，批次的样本数是3，输入张量的维度是5
input = torch.randn(1, 3, 5)
# 1是隐藏层个数 * 网络方向(单向是1，双向是2),批次的样本数是3，隐藏层中神经元个数是6
h0 = torch.randn(1, 3, 6)
output, hidden = rnn(input, h0)
```

#### 2 LSTM

长短时记忆网络，由4部分组成，训练效率比RNN低，可以缓解长句子的梯度消失和梯度爆炸问题。

1.   遗忘门：决定当前时刻要丢弃多少上一时刻的记忆：$ f_t = σ(W_f⋅[h_{t−1},x_t]+b_f) $。
2.   输入门：决定当前时刻有多少新的信息需要存储到记忆单元中：$ i_t=σ(W_i⋅[h{t−1},x_t]+b_i) $。
3.   候选记忆单元：生成新的记忆内容：$ \tilde {C_t}=tanh(W_c⋅[h_{t−1},x_t]+b_c) $。
4.   输出门：决定当前时刻要输出多少记忆单元的内容：$ o_t=σ(W_o⋅[h{t−1},x_t]+b_o) $。
5.   记忆单元状态更新：结合遗忘门和输入门，对记忆单元进行更新：$ C_t=f_t⋅C_{t−1}+i_t⋅\tilde C_t~ $。
6.   隐藏状态：使用输出门控制，决定输出哪些信息:$ h_t=o_t⋅tanh(C_t) $。

```python
import torch
import torch.nn as nn

# 输入张量维度：5，隐藏层神经元数量：6，隐藏层数：2
lstm = nn.LSTM(5, 6, 2)
input1 = torch.randn(1, 3, 5)
h0 = torch.randn(2, 3, 6)
c0 = torch.randn(2, 3, 6)
output, (hn, cn) = lstm(input1, (h0, c0))
print(output.shape)
```

#### 3 GRU

门控循环单元，也可以缓解长句子的梯度消失和梯度爆炸问题，同时他的结构和计算要比LSTM简单。主要由两部分组成：

1.   更新门：
2.   重置门：

```python
import torch
import torch.nn as nn

# 输入张量维度：5，隐藏层神经元数量：6，隐藏层数：2
gru = nn.GRU(5, 6, 2)
input1 = torch.randn(1, 3, 5)
h0 = torch.randn(2, 3, 6)
output, hn = gru(input1, h0)
print(output.shape)
```

### 四、卷积神经网络(CNN)

CNN网络就是全连接神经网络前增加了2层：卷积层(提取图像特征)、池化层(降维，防止过拟合)。

跟图片、视频相关的都可以使用卷积网络实现，比如图片分类、图片分割、姿态估计、追踪任务、BEV等。

传统神经网络不适合处理图像，因为一个300 \* 300 \*3的图像就有27w的像素了，在扔到128个神经元的隐藏层中就有27w\*128的矩阵的输入参数，这还是1个隐藏层，更多的隐藏层，更多的神经元就会导致巨量的计算。

#### 1 卷积层

卷积运算是在**滤波器和输入数据的局部区域做内积**，内积是对应位置相乘再求和，卷积之后得到的是内积组成的特征图，内积越大就表示特征越大，越相关，内积为0表示不相关。英伟达对3*3的卷积核支持最好，1个通道的卷积运算示例：

![卷积运算](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/卷积运算.png)

左上角点位计算方位为(**内积**)：1 \* 1 + 1 \* 0 + 1 \* 1 + 0 \* 0 + 1 \* 1 + 1 \* 0 + 0 \* 1 + 0 \* 0 + 1 \* 1 + 偏置 = 4 + 偏置。

卷积运算对外圈是不公平的，因为外圈参与运算的次数最少，解决这个问题需要对原图进行padding，就是在原图外侧扩充，扩充出来的数据都是0。

上图中计算特征的步长是1，每次卷积核只移动1个格子，步长越大得到的特征越小，可以起到降低维度的作用，下面是步长为2的卷积云运算：

![卷积运算-步长为2](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/卷积运算-步长为2.png)

$ 卷积之后的宽 = \frac{原宽 - 卷积核宽 + 2padding} {步长} + 1 $，$ 卷积之后的长 = \frac{原长 - 卷积核长 + 2padding} {步长} + 1 $​。

可以看到卷积之后图像的像素变小，第一可以减少之后的全连接计算次数，第二卷积的过程中权重参数固定，都是卷积核的矩阵。所以卷积网络相比传统神经网络计算更少。

为什么需要做多次卷积？随着层数增加卷积核是越来越大的，层次越深观察的特征的范围越大。

#### 2 池化层(下采样)

池化层为了筛选出一个区域里最重要的特征，可以进一步减少特征数。比如特征图的尺寸是4 \* 4，池化之后的结果要求是2 \* 2，那么就要把特征图分成2 \* 2份，每份里面有很多小格：

![特征图](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/特征图.png)

池化层有2种，最大池化和平均池化。最大池化就是取最大值作为池化后的特征，平均池化就是计算平均值：
![特征图池化](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/特征图池化.png)

然后将特征图变成1维数据就可以发送到全连接的神经网络中了。

#### 3 demo

```python
import tensorflow as tf


# 加载数据
# mnist是基准数据集，包含了28x28像素的灰度图像，代表从0到9的手写数字
(train_images, train_labels), (test_images, test_labels) = tf.keras.datasets.mnist.load_data()

# 数据基础处理-将训练集变成：图像个数、宽、高、通道数
train_images = tf.reshape(train_images, [train_images.shape[0], train_images.shape[1], train_images.shape[2], 1])
test_images = tf.reshape(test_images, [test_images.shape[0], test_images.shape[1], test_images.shape[2], 1])

# 模型构建
net = tf.keras.models.Sequential([
    # 卷积层： 6个5 * 5的卷积核，激活函数是sigmoid
    tf.keras.layers.Conv2D(filters=6, kernel_size=5, activation='sigmoid', input_shape=(28, 28, 1)),
    # 最大池化
    tf.keras.layers.MaxPooling2D(pool_size=(2, 2)),
    # 卷积层： 16个5 * 5的卷积核，激活函数是sigmoid
    tf.keras.layers.Conv2D(filters=16, kernel_size=5, activation='sigmoid'),
    # 最大池化
    tf.keras.layers.MaxPooling2D(pool_size=(2, 2)),
    # 调整成1维数据
    tf.keras.layers.Flatten(),
    # 全连接神经网络-隐藏层1
    tf.keras.layers.Dense(120, activation="sigmoid"),
    # 全连接神经网络-隐藏层2
    tf.keras.layers.Dense(84, activation="sigmoid"),
    # 全连接神经网络-输出层
    tf.keras.layers.Dense(10, activation="softmax")
])

# 模型编译：定义优化器、损失函数、评价指标
net.compile(tf.keras.optimizers.SGD(learning_rate=0.9), loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# 模型训练
net.fit(train_images, train_labels, epochs=5, validation_split=0.1)

# 模型评估
score = net.evaluate(test_images, test_labels, verbose=1)
print("评估分数:", score[1])
```

### 四、Transformer

2017年出现了一篇论文叫attention is all your need，根据这篇论文的思想出现了Transformer，nlp才开始发展起来。Transformer的本质是更好的提取特征。**20年的BERT和VIT在nlp和计算机视觉的表现都非常好，这两个模型都是基于Transformer的。**

他可以利用分布式GPU进行训练，同时对长文本的效果比GRU和LSTM更好。基于seq2seq的transformer可以做文本生成、机器翻译等，又可以构建预训练语言模型用于不同任务的迁移学习。

#### 1 核心组成部分

1个输入层+n个编码器+n个解码器+1个输出层。

##### 1.1 编码器

编码器堆叠了多个相同的子层，每个子层包括：

*   **多头自注意力机制（Multi-Head Self-Attention）**：捕获序列中的关系。
*   **前馈神经网络（Feed-Forward Neural Network, FFN）**：对每个位置的表示独立进行非线性变换。
*   **跳跃连接（Residual Connection）和层归一化（Layer Normalization）**：帮助模型稳定和加速收敛。

##### 1.2 解码器

*   **掩码多头自注意力（Masked Multi-Head Self-Attention）**：在生成时屏蔽后续位置，防止信息泄漏。
*   **编码器-解码器注意力（Encoder-Decoder Attention，cross attention）**：将解码器的状态与编码器输出结合。
*   **前馈神经网络（FFN）** 和 **跳跃连接**。

#### 2 核心机制

##### 2.1 自注意力机制

**注意力机制可以解决相同的词在不同语境中得到的特征权重相同的问题。**

大脑能够快速的把注意力放到有辨识度的部分而做出判断，而不是从头到尾观察一遍之后再做出判断。注意力计算规则需要指定3个输入：query、key和value，query是自身问题，key是别人提问时的应答，value是本身特征，Q、K、V都是通过全连接训练的到的。比如现在有2个词x1和x2，如果想要算x1对于x2的权重，需要使用x1的query和x2的key做计算(内积)在和value计算得到结果，

$ \text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V $​

*   Q, K, V：分别是查询（Query）、键（Key）和值（Value），通过输入向量的线性变换得到。
*   $d_k$：是键向量的维度，$\sqrt{d_k}$​ 是缩放因子，用于防止内积值过大。
*   softmax：生成注意力权重。

##### 2.2 多头注意力机制

对注意力机制的扩充，**同时使用多个不同的注意力机制捕捉不同的特征，然后合并到一起**。

##### 2.3 位置编码

注意力机制有个问题，如果2个语义不同的句子的词完全相同(比如你打我 和 我打你)，相同词得到的特征权重是相同的，也就是说词出现的位置不会对结果产生影响，因为q、k、v没变。所以在Transformer计算特征权重时会让位置编码参与运算。

$\text{PE}(pos, 2i) = \sin\left(\frac{pos}{10000^{2i/d}}\right)$​

$\text{PE}(pos, 2i+1) = \cos\left(\frac{pos}{10000^{2i/d}}\right)$

pos是词的位置，d是嵌入向量的维度。

### 五、图神经网络(GNN)

可以解决样本数据之间非独立的情况。比如道路交通-动态流量预测，道路之间的关系就是图神经网络。
由点和边组成的叫做图，点和边都是已知特征。一个点有几个边叫做度数图神经网络的重点是边的构建。图在图神经网络中叫邻接矩阵。图神经网络的最大特点是让输入的特征长度可以不同，比如CNN中样本的图像必须都是n*n的，长宽超过了n就截取，transformer中输入的文本也长度也必须都是n，不够n的就补0，超过n的也截取，但是在图神经网络中可以实现不同格式的特征。
图神经网络也会有多层，每层的图结果是不变化的，但是随着训练的层数增加，点学到的东西是不同的，比如下面的图：
图卷积(GCN)
点或者边的种类不同叫异构图，
