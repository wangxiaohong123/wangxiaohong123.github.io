---
title: 4.Flutter高级使用
tags:
  - flutter
categories: 前端
copyright: true
---

### 1 动画

实现动画需要确定三件事：

1.   确定变化规律；
2.   根据规律设定周期，启动动画；
3.   定期获取动画的值，不断微调、重绘；

这三个在Flutter中分别对应Animation、AnimationController 与 Listener：

*   Animation：提供动画数据、状态(开始、停止、前进、后退)，只提供数据不负责渲染；
*   AnimationController：管理Animation，设置动画时长，启动动画等；
*   Listener：Animation的回调函数，监听动画进度，需要在回调函数中根据动画当前值重新渲染；

比如实现一个logo由小变大的动画：

```dart
class _AnimateAppState extends State<AnimateApp> with SingleTickerProviderStateMixin {
  AnimationController controller;
  Animation<double> animation;
  @override
  void initState() {
    super.initState();
    // 创建动画周期为1秒的AnimationController对象
    controller = AnimationController(
        vsync: this, duration: const Duration(milliseconds: 1000));
    // 创建从50到200线性变化的Animation对象
    animation = Tween(begin: 50.0, end: 200.0).animate(controller)
      ..addListener(() {
        setState(() {}); // 刷新界面
      });
    controller.forward(); // 启动动画
  }

    @override
    Widget build(BuildContext context) {
      return MaterialApp(
        home: Center(
          child: Container(
          width: animation.value, // 将动画的值赋给widget的宽高
          height: animation.value,
          child: FlutterLogo()
        )));
    }
}
```

创建AnimationController的时候传入了一个vsync对象，这个是为了节省资源的，当动画所在的Widget不显示时动画会停止。

上面的例子需要使用setState强制刷新才能看到动画效果，而且需要监听动画的进度，Flutter提供了AnimatedWidget和AnimatedBuilder用来简化这些步骤：

```dart
class AnimatedLogo extends AnimatedWidget {
  //AnimatedWidget需要在初始化时传入animation对象
  AnimatedLogo({Key key, Animation<double> animation})
      : super(key: key, listenable: animation);

  Widget build(BuildContext context) {
    //取出动画对象
    final Animation<double> animation = listenable;
    return Center(
      child: Container(
        height: animation.value,//根据动画对象的当前状态更新宽高
        width: animation.value,
        child: FlutterLogo(),
    ));
  }
}
```

使用的时候传入一个Animation对象就可以：

```dart
MaterialApp(
  home: Scaffold(
    body: AnimatedLogo(animation: animation)//初始化AnimatedWidget时传入animation对象
));
```

### 2 网络

在pubspec.yaml中添加网络插件

```yaml
dependencies:
  flutter:
    sdk: flutter
  http: ^1.5.0
```

使用方式：

```dart
import 'package:http/http.dart' as http;

void main() async {
  // GET
  var getResp = await http.get(
    Uri.parse('https://jsonplaceholder.typicode.com/posts/1'),
  );
  print("GET result:");
  print(getResp.body);

  // POST (表单格式)
  var postResp = await http.post(
    Uri.parse('https://jsonplaceholder.typicode.com/posts'),
    body: <String, String>{
      'title': 'foo',
      'body': 'bar',
      'userId': '1',
    },
  );
  print("POST result:");
  print(postResp.body);
}
```

http库不能定制拦截器、cookie管理等，推荐使用Dart社区人气较高的dio。

```dart
void getRequest() async {
  //创建网络调用示例
  Dio dio = new Dio();
  
  //设置URI及请求user-agent后发起请求
  var response = await dio.get("https://flutter.dev", options:Options(headers: {"user-agent" : "Custom-UA"}));
  
 //打印请求结果
  if(response.statusCode == HttpStatus.ok) {
    print(response.data.toString());
  } else {
    print("Error: ${response.statusCode}");
  }
}

//增加拦截器
dio.interceptors.add(InterceptorsWrapper(
    onRequest: (RequestOptions options){
      // 为每个请求头都增加user-agent
      options.headers["user-agent"] = "Custom-UA";
      // 检查是否有token，没有则直接报错
      if(options.headers['token'] == null) {
        return dio.reject("Error:请先登录");
      } 
      // 检查缓存是否有数据
      if(options.uri == Uri.parse('http://xxx.com/file1')) {
        return dio.resolve("返回缓存数据");
      }
      // 放行请求
      return options;
    }
));

// 增加try catch，防止请求报错
try {
  var response = await dio.get("https://xxx.com/xxx.zip");
  print(response.data.toString());
}catch(e) {
  print(e);
}
```

### 3 存储

存储有三种方式，文件、SharedPreferences和数据库

#### 3.1 文件

文件分为临时目录和文档目录，**适合大量的有序的数据持久化**

1.   临时目录：系统可以随时删除的目录，通常放一些不重要的混存数据。
2.   文档目录：只有删除应用程序的时候才会清除的目录。

```dart
//创建文件目录
Futrue<File> get _localFile async {
  final directory = await getApplicationDocumentsDirectory();
  final path = directory.path;
  return File('$path/content.txt');
}
//将字符串写入文件
Futrue<File> writeContent(String content) async {
  final file = await _localFile;
  return file.writeAsString(content);
}
//从文件读出字符串
Futrue<String> readContent() async {
  try {
    final file = await _localFile;
    String contents = await file.readAsString();
    return contents;
  } catch (e) {
    return "";
  }
}
```

#### 3.2 SharedPreferences

适合少量的键值对信息，比如青少年弹窗。只能存储基本类型的数据：int、double、bool 和 string

```dart
// 读取SharedPreferences中key为counter的值
Futrue<int>_loadCounter() async {
  SharedPreferences prefs = await SharedPreferences.getInstance();
  int  counter = (prefs.getInt('counter') ?? 0);
  return counter;
}

// 递增写入SharedPreferences中key为counter的值
// setter方法会先更新内存中的键值对，在写磁盘
Futrue<void>_incrementCounter() async {
  SharedPreferences prefs = await SharedPreferences.getInstance();
    int counter = (prefs.getInt('counter') ?? 0) + 1;
    prefs.setInt('counter', counter);
}
```

