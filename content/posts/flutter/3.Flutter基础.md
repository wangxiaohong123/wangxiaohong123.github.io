---
title: 3.Flutter基础
tags:
  - flutter
categories: 前端
copyright: true
---

**Flutter就是一个内嵌了多平台原生工程的父工程。**

最省事的跨平台方案是继浏览器控件的，比如uniApp，99%的需求都可以使用一套代码实现。但是这种基于手机内嵌的浏览器内核在性能上很差，比如web方式的跨平台一般使用css+js实现动画，原生可以使用GPU加速；浏览器内核需要解析HTML、CSS、JavaScript，和iOS的UIKit、Android的View没法比，其次WebView的内存管理不好，容易导致内存占用过高。

React Native虽然使用的是JavaScript+React方式，但是他使用原生渲染，性能可以但是复杂的交互和动画实现不了。**Flutter自己对Dart进行了封装，而且自己实现了渲染逻辑。**他使用SKia(2005年收购的产品)作为图像绘制引擎，SKia保证一套代码在不同平台渲染出相同效果。

### 1 架构和渲染

![flutter架构图](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/flutter架构图.png)

Flutter架构分为三层：

1.   Embedder ：操作系统适配层，实现了渲染 Surface 设置，线程设置，以及平台插件等平台相关特性的适配。Flutter 平台相关特性并不多，这就使得从框架层面保持跨端一致性的成本相对较低。
2.   Engine ：引擎层，主要包含 Skia、Dart 和 Text，实现了 Flutter 的渲染引擎、文字排版、事件处理和 Dart 运行时等功能。Skia 和 Text 为上层接口提供了调用底层渲染和排版的能力，Dart 则为 Flutter 提供了运行时调用 Dart 和渲染引擎的能力。而 Engine 层的作用，则是将它们组合起来，从它们生成的数据中实现视图渲染。
3.   Framework ：一个用 Dart 实现的 UI SDK，包含了动画、图形绘制和手势识别等功能。为了在绘制控件等固定样式的图形时提供更直观、更方便的接口，Flutter 还基于这些基础能力，根据 Material 和 Cupertino 两种视觉设计风格封装了一套 UI 组件库。我们在开发 Flutter 的时候，可以直接使用这些组件库。**其中Material是基于Google 的 Material Design 设计的组件库，Cupertino是基于Apple 的 iOS 设计规范设计的组件库**。

#### 1.1 渲染

渲染氛围4个阶段：布局、绘制、合成、渲染。Flutter中的元素以树的形式存在，采用深度优先的方式进行布局和绘制，然后进行一次合成，将所有涂层根据 大小、层级、透明度等规则计算出最终的显示效果，这么做是为了简化渲染树，提高渲染效率，合并完成之后交给SKia加工成二维的图像数据，最后交给GPU渲染。

### 2 线程模型

![Flutter线程模型](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/Flutter线程模型.png)

Dart是单线程的，但Flutter是多线程的，在Flutter中Dart的代码都运行在UI线程上，Dart的单线程模型中涉及到2个任务队列，微任务队列和事件队列，微任务队列的优先级比事件队列要高。所以微任务队列用来处理短小、优先级高的任务，flutter的回调、async的内部调度等；事件队列用来处理定时器、网络请求、用户输入、UI等任务。因为UI线程是主线程，是所有任务的入口，不过一些请求虽然会进到事件任务队列，但是UI线程会根据语法判断出这些任务不是自己处理的。

当出现不是UI线程处理的任务时会调用引擎API，让引擎判断应该是哪个线程处理后通过消息发送到对应线程的Task Runner，其他线程处理完任务也会通过引擎发送到UI线程的Task Runner，之后会将任务的处理结果封装成回调重新入队。

### 3 Widget

**Widget不可变设计：**为了简化开发，并发修改时是线程不安全的。

Flutter中Widget是数据映射，也是功能的抽象描述，也是试图的配置信息，他是组建实现的基本逻辑单位，一切皆是Widget。

大部分UI框架都会将试图数据封装成树结构，在将这些数据提供给渲染引擎，Flutter视图树进行了扩展，分成了Widget、Element和RenderObject三层。

1.   Widget：存储了视图渲染的配置，包括布局、属性、事件响应等。分为无状态（StatelessWidget）和有状态（StateFulWidget），有状态的Widget可以通过改变Widget的状态出发重布局（`state.setState`）达到改变Widget属性的效果。重布局就是找到状态改变的Widget进行rebuild操作(调用widget里的build方法)，所以有状态和无状态的Widget的区别就是能否自重建。以数据驱动UI构建的方式简单高效，但是这样会涉及到大量对象的销毁和重建，性能和垃圾回收都会受影响，不过**Widget不涉及实际渲染位图(屏幕上的像素)，只是轻量级的数据重构，所以重建造成的内存成本很低，至于重新渲染的成本是由其他组件优化的**。
2.   Element：是Widget的一个实例化对象，也是Widget到RenderObject的中间态，渲染时先通过Widget树构建Element树，然后创建对应的RenderObject关联到Element.RenderObject属性上，最后构建成RenderObject树。**为什么要增加一层Element？**因为Widget是不可变的，Element是可变的，Widget重构时Element通过diff算法比较Widget的变化，判断需不需要重新渲染，将变化同步到RenderObject中，降低性能损耗。
3.   RenderObject：完成渲染的布局、绘制阶段，将绘制完的RenderObject树交给SKia进行合成和渲染阶段。

#### 3.1 Widget状态的选择

Flutter中Widget采用深度优先的方式构建，也就是自顶向下，由父到子，那就可以理解为**符Widget如果可以通过初始化的参数完全控制子Widget的展示效果，子Widget就可以使用StatelessWidget。**比如弹窗，每次弹窗初始化Widget的时候只需要将样式和提示信息传给弹窗Widget即可。

即使StatefulWidget可以替代StatelessWidget也不能完全使用StatefulWidget，会影响渲染性能。

### 4 生命周期

#### 4.1 有状态Widget的生命周期

有状态的Widget也就是StatefulWidget的子类中都会有一个继承State的内部类，State中实现的build方法以及监听元素变化。

State的生命周期可以分为3个阶段：初始化、更新和销毁；

##### 4.1.1 初始化

初始化时会依次执行 ：构造方法 -> initState -> didChangeDependencies -> build，随后完成页面渲染。

*   构造方法中可以接受父Widget传递的UI配置，Flutter也会在构造方法中调用StatefulWidget.createState() 来创建一个 State。
*   initState() 会在State对象被插入试图树的时候调用，这个函数在整个生命周期只会被调用1次，一些状态的默认值是在这一步设置的。
*   didChangeDependencies()用来专门处理State对象依赖关系变化，initState()结束后被Flutter调用。
*   build()作用是构建视图，我们需要在这个函数中，根据父 Widget 传递过来的初始化配置数据，以及 State 的当前状态，创建一个 Widget 然后返回。

##### 4.1.2 更新

Widget 的状态更新，主要由 3 个方法触发：setState、didchangeDependencies 和 didUpdateWidget。

*   setState()：最常用的方法，当状态数据发生变化时，通过调用这个方法告诉Flutter使用更新后的数据重建UI。
*   didchangeDependencies()：State对象的依赖关系发生变化后，Flutter会调用这个方法，出发组件构建。比如系统语言或者主题发生改变时系统会通知 State 执行 didChangeDependencies 回调方法。
*   didUpdateWidget()：当 Widget 的配置发生变化时，比如，父 Widget 触发重建（即父 Widget 的状态发生变化时），热重载时，系统会调用这个函数。

##### 4.1.3 销毁

组件被移除或者页面销毁的时候，系统会调用 deactivate 和 dispose 这两个方法，来移除或销毁组件。

*   deactivate()：组件的可见状态发生变化，包括页面切换会调用这个方法。
*   dispose()：永久移除时调用，可以在这里进行最终的资源释放、移除监听、清理环境，等等。

#### 4.2 App的生命周期

App的生命周期类似于从后台进入前台、从前台退到后台，或是在 UI 绘制完成。原生中通过重写 Activity、ViewController 生命周期回调方法，或是注册应用程序的相关通知。Flutter中使用WidgetsBindingObserver实现。

```dart
abstract class WidgetsBindingObserver {
  // 页面pop
  Futrue<bool> didPopRoute() => Futrue<bool>.value(false);
  // 页面push
  Futrue<bool> didPushRoute(String route) => Futrue<bool>.value(false);
  // 系统窗口相关改变回调，如旋转
  void didChangeMetrics() { }
  // 文本缩放系数变化
  void didChangeTextScaleFactor() { }
  // 系统亮度变化
  void didChangePlatformBrightness() { }
  // 本地化语言变化
  void didChangeLocales(List<Locale> locale) { }
  // App生命周期变化
  void didChangeAppLifecycleState(AppLifecycleState state) { }
  // 内存警告回调
  void didHaveMemoryPressure() { }
  // Accessibility相关特性回调
  void didChangeAccessibilityFeatrues() {}
}
```

##### 4.2.1 didChangeAppLifecycleState

didChangeAppLifecycleState 回调函数中，有一个参数类型为 AppLifecycleState 的枚举类，这个枚举类是 Flutter 对 App 生命周期状态的封装。它的常用状态包括 resumed、inactive、paused 这三个。

*   resumed：可见的，并能响应用户的输入。
*   inactive：处在不活动状态，无法处理用户响应。
*   paused：不可见并不能响应用户的输入，但是在后台继续活动中。

从后台切入前台，控制台打印的 App 生命周期变化如下: AppLifecycleState.paused->AppLifecycleState.inactive->AppLifecycleState.resumed；从前台退回后台，控制台打印的 App 生命周期变化则变成了：AppLifecycleState.resumed->AppLifecycleState.inactive->AppLifecycleState.paused。

### 5 经典控件

#### 5.1 文本

单一样式文本：

```dart
Text(
  '文本是视图系统中的常见控件，用来显示一段特定样式的字符串，就比如Android里的TextView，或是iOS中的UILabel。',
  textAlign: TextAlign.center,// 居中显示
  style: TextStyle(fontWeight: FontWeight.bold, fontSize: 20, color: Colors.red),// 20号红色粗体展示
);
```

混合样式文本：

```dart
TextStyle blackStyle = TextStyle(fontWeight: FontWeight.normal, fontSize: 20, color: Colors.black); // 黑色样式

TextStyle redStyle = TextStyle(fontWeight: FontWeight.bold, fontSize: 20, color: Colors.red); // 红色样式

Text.rich(
    TextSpan(
        children: <TextSpan>[
          TextSpan(text:'文本是视图系统中常见的控件，它用来显示一段特定样式的字符串，类似', style: redStyle), // 第1个片段，红色样式 
          TextSpan(text:'Android', style: blackStyle), // 第1个片段，黑色样式 
          TextSpan(text:'中的', style:redStyle), // 第1个片段，红色样式 
          TextSpan(text:'TextView', style: blackStyle) // 第1个片段，黑色样式 
        ]),
  textAlign: TextAlign.center,
);
```

#### 5.2 图片

*   加载本地资源图片，如 Image.asset(‘images/logo.png’)；
*   加载本地（File 文件）图片，如 Image.file(new File(’/storage/xxx/xxx/test.jpg’))；
*   加载网络图片，如 Image.network('http://xxx/xxx/test.gif') 。

FadeInImage 控件比Flutter自带的Image多了很多功能，比如占位图、加载动画等：

```dart
FadeInImage.assetNetwork(
  placeholder: 'assets/loading.gif', // gif占位
  image: 'https://xxx/xxx/xxx.jpg',
  fit: BoxFit.cover, // 图片拉伸模式
  width: 200,
  height: 200,
)
```

图片的加载是异步的，由ImageProvider 触发。首先，ImageProvider 根据 _ImageState 中传递的图片配置生成对应的图片缓存 key；然后，去 ImageCache 中查找是否有对应的图片缓存，如果有，则通知 _ImageState 刷新 UI；如果没有，则启动 ImageStream 开始异步加载，加载完毕后，更新缓存；最后，通知 _ImageState 刷新 UI。

ImageCache使用LRU淘汰策略，保留最近做多使用的1000张图片，最大缓存时100MB，这种方式的缓存只在运行期间作用在内存中，如果想要支持缓存到文件系统，可以使用第三方的**CachedNetworkImage**控件。

#### 5.3 按钮

Flutter 提供了三个基本的按钮控件： FloatingActionButton、FlatButton 和 RaisedButton。

*   FloatingActionButton：圆形按钮，用来处理界面中最常用、最基础的操作。
*   FlatButton：凸起的按钮，带灰色背景，点击后背景加深。
*   RaisedButton：扁平的按钮，透明背景，点击后变灰色背景。

按钮有2个重要参数：

*   onPressed 参数用于设置点击回调，告诉 Flutter 在按钮被点击时通知我们。如果 onPressed 参数为空，则按钮会处于禁用状态，不响应用户点击。
*   child 参数用于设置按钮的内容，告诉 Flutter 控件应该长成什么样，也就是控制着按钮控件的基本样式。child 可以接收任意的 Widget，比如我们在上面的例子中传入的 Text，除此之外我们还可以传入 Image 等控件。

#### 5.4 列表

##### 5.4.1ListView

ListView可以沿一个方向排列所有子Widget，常用于各种列表。

ListView默认的构造函数可以通过设置Children将所有子Widget包含到ListView中，但是这种一次性将列表创建好的方式影响性能，可以用这种方式实现少量元素的ListView：

```dart
ListView(
  children: <Widget>[
    //设置ListTile组件的标题与图标 
    ListTile(leading: Icon(Icons.map),  title: Text('Map')),
    ListTile(leading: Icon(Icons.mail), title: Text('Mail')),
    ListTile(leading: Icon(Icons.message), title: Text('Message')),
  ]);
```

另一个构造函数ListView.builder和ListView.separated适用于Widget比较多的场景，这个构造函数有2个关键参数：

*   itemBuilder，是列表项的创建方法。当列表滚动到相应位置时，ListView 会调用该方法创建对应的子 Widget。
*   itemCount，表示列表项的数量，如果为空，则表示 ListView 为无限列表。

```dart
ListView.builder(
    itemCount: 100, //元素个数
    itemExtent: 50.0, //列表项高度
    itemBuilder: (BuildContext context, int index) => ListTile(title: Text("title $index"), subtitle: Text("body $index"))
);
```

ListView.separated比ListView.builder多了一个分割线的参数：

```dart
// 使用ListView.separated设置分割线
ListView.separated(
    itemCount: 100,
    separatorBuilder: (BuildContext context, int index) => index %2 ==0? Divider(color: Colors.green) : Divider(color: Colors.red),// index为偶数，创建绿色分割线；index为奇数，则创建红色分割线
    itemBuilder: (BuildContext context, int index) => ListTile(title: Text("title $index"), subtitle: Text("body $index"))// 创建子Widget
)
```

##### 5.4.2 CustomScrollView

对于一些功能比如效果联动、视图跟随手势、精细滑动等，就需要使用CustomScrollView来自定义滚动效果。在CustomScrollView中，彼此独立、可滚动的Widget统称为Sliver。

比如要实现一个滚动视差效果：让多层背景以不同速度移动，形成立体滚动效果。具体需求：一个有封面头图的列表，用户滚动列表时头图根据手势进行缩小或者展开。实现这个需求需要2个Sliver，头图的SliverAppBar，作为列表的SliverList：

```dart
CustomScrollView(
  slivers: <Widget>[
    SliverAppBar(// SliverAppBar作为头图控件
      title: Text('CustomScrollView Demo'),// 标题
      floating: true,// 设置悬浮样式
      flexibleSpace: Image.network("https://xx.jpg",fit:BoxFit.cover),// 设置悬浮头图背景
      expandedHeight: 300,// 头图控件高度
    ),
    SliverList(// SliverList作为列表控件
      delegate: SliverChildBuilderDelegate(
            (context, index) => ListTile(title: Text('Item #$index')),// 列表项创建方法
        childCount: 100,// 列表元素个数
      ),
    ),
  ]);
```

### 6 布局

Flutter提供了31种布局Widget，包括单子Widget、多子Widget、层叠Widget。

#### 6.1 常用的单子Widget

单子Widget就是说只有一个儿子，但是可以有很多孙子。

##### 6.1.1 Container

Container可以作为单独的控件，比如设置背景颜色、宽高，也可以作为其他空间的父级：定义子Widget如何摆放，不过他只能包含一个子Widget。如果用Container设置多个子Widget的布局需要先用一个根Widget包装所有子Widget，然后把根Widget放到Container中，由Container设置对齐(alignment)、边距(padding)等基础属性。

```dart
Container(
  child: Text('Container（容器）在UI框架中是一个很常见的概念，Flutter也不例外。'),
  padding: EdgeInsets.all(18.0), // 内边距
  margin: EdgeInsets.all(44.0), // 外边距
  width: 180.0,
  height:240,
  alignment: Alignment.center, // 子Widget居中对齐
  decoration: BoxDecoration( //Container样式
    color: Colors.red, // 背景色
    borderRadius: BorderRadius.circular(10.0), // 圆角边框
  ),
)
```

##### 6.1.2 Padding

如果子Widget只需要设定边距可以使用

```dart
Padding(
  padding: EdgeInsets.all(44.0),
  child: Text('Container（容器）在UI框架中是一个很常见的概念，Flutter也不例外。'),
);
```

##### 6.1.3 Center

讲子Widget居中排列

```dart
Scaffold(
  body: Center(child: Text("Hello")) // This trailing comma makes auto-formatting nicer for build methods.
);
```

一般Center会和Container一起使用

```dart
Container(
  child: Center(child: Text('Container（容器）在UI框架中是一个很常见的概念，Flutter也不例外。')),
  padding: EdgeInsets.all(18.0), // 内边距
  margin: EdgeInsets.all(44.0), // 外边距
  width: 180.0,
  height:240,
  decoration: BoxDecoration( //Container样式
    color: Colors.red, // 背景色
    borderRadius: BorderRadius.circular(10.0), // 圆角边框
  ),
);
```

#### 6.2 常用的多子Widget

多子Widget的布局就是2种规则的抽象：水平方向如何布局、垂直方向如何布局。

和前端的Flex一样，Flutter也有将子Widget按水平排列的Row和垂直排列的Column，以及负责这些子Widget在布局方向中剩余空间的Expanded。

Row和Column的使用就是将子Widget按序加入到children即可：

```dart
// Row的用法示范
Row(
  children: <Widget>[
    Container(color: Colors.yellow, width: 60, height: 80,),
    Container(color: Colors.red, width: 100, height: 180,),
    Container(color: Colors.black, width: 60, height: 80,),
    Container(color: Colors.green, width: 60, height: 80,),
  ],
);

// Column的用法示范
Column(
  children: <Widget>[
    Container(color: Colors.yellow, width: 60, height: 80,),
    Container(color: Colors.red, width: 100, height: 180,),
    Container(color: Colors.black, width: 60, height: 80,),
    Container(color: Colors.green, width: 60, height: 80,),
  ],
);
```

上面的Row和Column都不能占满屏幕，如果想要设置黄色和绿色均分剩下的空间，可以使用Expanded之后不指定宽度，再将弹性系数参数flex设置成1即可

```dart
Row(
  children: <Widget>[
    Expanded(flex: 1, child: Container(color: Colors.yellow, height: 60)), // 设置了flex=1，因此宽度由Expanded来分配
    Container(color: Colors.red, width: 100, height: 180,),
    Container(color: Colors.black, width: 60, height: 80,),
    Expanded(flex: 1, child: Container(color: Colors.green,height: 60),)// 设置了flex=1，因此宽度由Expanded来分配
  ],
);
```

对于Row和Column，Flutter提供了根据坐标轴的对齐方式，Row和Column的主轴、纵轴划分：

![flutter主轴、纵轴](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/flutter主轴、纵轴.png)

根据主轴与纵轴，设置子 Widget 在这两个方向上的对齐规则 mainAxisAlignment 与 crossAxisAlignment。比如，主轴方向 start 表示靠左对齐、center 表示横向居中对齐、end 表示靠右对齐、spaceEvenly 表示按固定间距对齐；而纵轴方向 start 则表示靠上对齐、center 表示纵向居中对齐、end 表示靠下对齐，Row中主轴和纵轴的对齐效果：

<img src="https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/flutter-row对齐.png" alt="flutter-row对齐" style="zoom:67%;" /><img src="https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/flutter-row纵轴.png" alt="flutter-row纵轴" style="zoom: 67%;" />

对于主轴而言，Flutter默认让父容器决定长度，即主轴方向的长度尽可能大；如果设置了`mainAxisSize: MainAxisSize.min`，主轴的宽度或者高度就由所有子Widget决定，即主轴方向的长度尽可能小。如果设置了`mainAxisSize: MainAxisSize.min`，Row的宽度和子Widget一样，因此设置助手的对齐方式就不起作用了。

#### 6.3 常用的层叠Widget布局

当需要让一个空间叠加到另一个控件的上面，比如图片上防文字，图片上加按钮。这个时候可以使用层叠容器Stack。

Stack提供了容器，Positioned提供设置Widget位置的能力：

```dart
Stack(
  children: <Widget>[
    Container(color: Colors.yellow, width: 300, height: 300),// 黄色容器
    Positioned(
      left: 18.0,
      top: 18.0,
      child: Container(color: Colors.green, width: 50, height: 50),// 叠加在黄色容器之上的绿色控件
    ),
    Positioned(
      left: 18.0,
      top:70.0,
      child: Text("Stack提供了层叠布局的容器"),// 叠加在黄色容器之上的文本
    )
  ],
)
```

**Positioned只能在Stack中使用**。

#### 6.4 组合与自绘

组合与自绘是用来自定义Widget的，使用基本Widget组装成一个高级的Widget。

组合：使用基础Widget布局摆放基础Widget，在控件内部设置基础Widget样式。这种方式对外暴露的接口比较少，减少上层使用成本，增强控件复用性。

自绘：对于现有Widget无法实现的视图，比如k线图，这个时候需要手动绘制。手动绘制使用CustomPaint，他是一个承接自绘控件的容器，容器中使用画布Canvas与画笔Paint绘制。

### 7 主题

主题一般由颜色、图片、字体、字号组成。视觉效果是易变的，将变化的部分抽离出来，把提供不同视觉效果的资源和配置按照主题进行归类，整合到统一的中间层进行管理，这样就能实现主题的管理和切换了。

在iOS中，主题的配置是预先写到plist文件中，通过单例控制app使用哪种配置，Android的配置则写入各个style属性值的xml中，通过activity的setTheme切换，前端也可以通过更换css实现多套主题；Flutter使用**ThemeData**统一管理主题的配置信息。

#### 7.1 全局统一的视觉风格

MaterialApp 的初始化方法提供了设置主题的能力：

```dart
MaterialApp(
  title: 'Flutter Demo',//标题
  theme: ThemeData(//设置主题
      brightness: Brightness.dark,//设置明暗模式为暗色
      accentColor: Colors.black,//(按钮）Widget前景色为黑色
      primaryColor: Colors.cyan,//主色调为青色
      iconTheme:IconThemeData(color: Colors.yellow),//设置icon主题色为黄色
      textTheme: TextTheme(body1: TextStyle(color: Colors.red))//设置文本颜色为红色
  ),
  home: MyHomePage(title: 'Flutter Demo Home Page'),
);
```

#### 7.2 局部独立的视觉风格

为某个页面或者某个区块设置不同的风格样式，比如选择不同主题时的预览窗口，可以使用Theme控件，他是一个单子Widget容器，在Theme中可以选择使用Theme.of继承app的主题+copyWith更新部分样式；或者使用ThemeData创建新主题。

```dart
// 新建主题
Theme(
    data: ThemeData(iconTheme: IconThemeData(color: Colors.red)),
    child: Icon(Icons.favorite)
);

// 继承主题
Theme(
    data: Theme.of(context).copyWith(iconTheme: IconThemeData(color: Colors.green)),
    child: Icon(Icons.feedback)
);
```

不同场景使用不同主题：

```dart
// iOS浅色主题
final ThemeData kIOSTheme = ThemeData(
    brightness: Brightness.light,// 亮色主题
    accentColor: Colors.white,// (按钮)Widget前景色为白色
    primaryColor: Colors.blue,// 主题色为蓝色
    iconTheme:IconThemeData(color: Colors.grey),// icon主题为灰色
    textTheme: TextTheme(body1: TextStyle(color: Colors.black))// 文本主题为黑色
);
// Android深色主题
final ThemeData kAndroidTheme = ThemeData(
    brightness: Brightness.dark,// 深色主题
    accentColor: Colors.black,// (按钮)Widget前景色为黑色
    primaryColor: Colors.cyan,// 主题色Wie青色
    iconTheme:IconThemeData(color: Colors.blue),// icon主题色为蓝色
    textTheme: TextTheme(body1: TextStyle(color: Colors.red))// 文本主题色为红色
);
// 应用初始化
MaterialApp(
  title: 'Flutter Demo',
  theme: defaultTargetPlatform == TargetPlatform.iOS ? kIOSTheme : kAndroidTheme,// 根据平台选择不同主题
  home: MyHomePage(title: 'Flutter Demo Home Page'),
);
```

### 8 依赖管理

#### 8.1 App内资源

图片、字符串、字体配置文件等叫做资源，代码与资源分离时现代UI框架的主流设计理念，这样可以对特定设备提供更准确的兼容性。

在iOS中图片和其他原始资源是区分开的，在Flutter里，assets可以放任意类型的文件：图片、JSON、字体等。对于资源的存放位置，Flutter没有像Android那样预先定义资源的目录结构，我们可以把资源放到任意目录下，**只需要根据pubspec.yaml对资源所在位置进行显示生命就可以**。

```yaml
flutter:
  assets:
    - assets/background.jpg   # 挨个指定资源路径
    - assets/loading.gif  # 挨个指定资源路径
    - assets/result.json  # 挨个指定资源路径
    - assets/icons/    # 子目录批量指定
    - assets/ # 根目录也是可以批量指定的
```

目录的批量指定不会递归，如果目录下还有子目录的话需要单独指定。

Flutter中图片可以使用`Image.asset`加载，其他资源通过Flutter的猪资源Bundle对象rootBundle直接访问。字符串资源使用`rootBundle.loadString`，二进制文件使用`rootBundle.load`方法。

Flutter也遵循了基于像素密度的管理方式，如1.0x，2.0x，3.0x，根据当前设备分辨率加载最接近设备像素比例的图片资源，想让Flutter适配不同分辨率需要将其他分辨率放到对应的分辨率子目录中，声明时仅声明1.0x的图片资源即可：

```yaml
# 目录结构
assets
├── background.jpg    //1.0x图
├── 2.0x
│   └── background.jpg  //2.0x图
└── 3.0x
    └── background.jpg  //3.0x图

# 声明
flutter:
  assets:
    - assets/background.jpg   # 1.0x图资源
```

**更换App图标、启动页都需要在原生中操作**。

#### 8.2 三方依赖

pubspec.yaml 更为重要的作用是管理 Flutter 工程代码的依赖，比如第三方库、Dart运行环境、Flutter版本等。

Dart提供了包管理工具Pub，和Maven、npm类似。和pubspec.yaml类似的还有.packages和pubspec.lock，.packages是表示包在本地目录缓存的地址，pubspec.lock是把依赖锁死的文件，.packages不需要版本管理，这是个人环境，pubspec.lock需要做版本管理，统一工程环境。

### 9 交互

#### 9.1 用户交互

##### 9.1.1 指针事件

指针事件表示用户交互的原始触摸数据，比如手指接触屏幕 PointerDownEvent、手指在屏幕上移动 PointerMoveEvent、手指抬起 PointerUpEvent，以及触摸取消 PointerCancelEvent等。当手指触摸屏幕，触摸事件发起时，Flutter咸确定手指与屏幕接触的位置上有哪些组件，将事件交给最内层的组件，从最内层开始向根节点分发事件。

Flutter中通过Listener Widget监听子Widget的指针事件：

```dart
Listener(
  child: Container(
    color: Colors.red,// 背景色红色
    width: 300,
    height: 300,
  ),
  onPointerDown: (event) => print("down $event"),// 手势按下回调
  onPointerMove:  (event) => print("move $event"),// 手势移动回调
  onPointerUp:  (event) => print("up $event"),// 手势抬起回调
);
```

##### 9.1.2 手势识别

指针事件比较原始，复杂功能很难处理，比如点击 onTap、双击 onDoubleTap、长按 onLongPress、拖拽 onPanUpdate、缩放 onScaleUpdate 等。响应用户交互使用的是Gestrue，Gestrue 可以支持同时分发多个手势交互行为，就是可以同时监听多个事件。

Gestrue是手势语义的抽象，如果想要在Widget中实现监听需要使用GestrueDetector：

```dart
// 红色container坐标
double _top = 0.0;
double _left = 0.0;
Stack(// 使用Stack组件去叠加视图，便于直接控制视图坐标
  children: <Widget>[
    Positioned(
      top: _top,
      left: _left,
      child: GestrueDetector(// 手势识别
        child: Container(color: Colors.red,width: 50,height: 50),// 红色子视图
        onTap: ()=>print("Tap"),// 点击回调
        onDoubleTap: ()=>print("Double Tap"),// 双击回调
        onLongPress: ()=>print("Long Press"),// 长按回调
        onPanUpdate: (e) {// 拖动回调
          setState(() {
            // 更新位置
            _left += e.delta.dx;
            _top += e.delta.dy;
          });
        },
      ),
    )
  ],
);
```

对于同时监听多个手势事件的情况，Flutter引入了手势竞技场的概念，手势竞技场根据触摸屏幕时长、位移、方向等决定有本次处理权的手势，就是说**虽然监听多个手势，但是只有一个手势会收到回调。**可以通过自定义手势识别器实现多事件响应。

#### 9.2 组件交互

组件的数据可以通过组件内变量获取，但是如果组件的层级很深每级都保存一份数据是浪费而且麻烦的。所以，对于数据的跨层传递，Flutter 还提供了三种方案：InheritedWidget、Notification 和 EventBus。

##### 9.2.1 InheritedWidget

Theme就是通过InheritedWidget实现的，使用InheritedWidget时需要自定义一个字类，然后字类提供of方法方便其他Widget在组件树中使用，最后重写updateShouldNotify方法，这个方法会在Flutter判断InheritedWidget需要重建时通知下层观察者组更新数据的：

```dart
class CountContainer extends InheritedWidget {
  //方便其子Widget在Widget树中找到它
  static CountContainer of(BuildContext context) => context.inheritFromWidgetOfExactType(CountContainer) as CountContainer;
  
  final int count;

  CountContainer({
    Key key,
    @required this.count,
    @required Widget child,
  }): super(key: key, child: child);

  // 判断是否需要更新
  @override
  bool updateShouldNotify(CountContainer oldWidget) => count != oldWidget.count;
}

// 使用
class _MyHomePageState extends State<MyHomePage> {
  @override
  Widget build(BuildContext context) {
   //将CountContainer作为根节点，并使用0作为初始化count
    return CountContainer(
      count: 0,
      child: Counter()
    );
  }
}

class Counter extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    //获取InheritedWidget节点
    CountContainer state = CountContainer.of(context);
    return Scaffold(
      appBar: AppBar(title: Text("InheritedWidget demo")),
      body: Text(
        'You have pushed the button this many times: ${state.count}',
      ),
    );
}
```

##### 9.2.2 Notification

Notification做子组件向上传递数据，比如子Widget状态变更，通知上报。

```dart
class CustomNotification extends Notification {
  CustomNotification(this.msg);
  final String msg;
}

//抽离出一个子Widget用来发通知
class CustomChild extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return RaisedButton(
      //按钮点击时分发通知
      onPressed: () => CustomNotification("Hi").dispatch(context),
      child: Text("Fire Notification"),
    );
  }
}
```

父Widget中监听这个通知做操作即可

```dart
class _MyHomePageState extends State<MyHomePage> {
  String _msg = "通知：";
  @override
  Widget build(BuildContext context) {
    //监听通知
    return NotificationListener<CustomNotification>(
        onNotification: (notification) {
          setState(() {_msg += notification.msg+"  ";});//收到子Widget通知，更新msg
        },
        child:Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[Text(_msg),CustomChild()],//将子Widget加入到视图树中
        )
    );
  }
}
```

##### 9.2.3 EventBus

适用于任何关系的Widget通信，遵循发布/订阅模式，需要依赖三方插件：

```dart
dependencies:  
  event_bus: 1.1.0
```

```dart
// 自定义事件类
class CustomEvent {
  String msg;
  CustomEvent(this.msg);
}

// 建立公共的event bus
EventBus eventBus = new EventBus();
// 第一个页面
class _FirstScreenState extends  State<FirstScreen>  {

  String msg = "通知：";
  StreamSubscription subscription;
  @override
  initState() {
   // 监听CustomEvent事件，刷新UI
    subscription = eventBus.on<CustomEvent>().listen((event) {
      setState(() {msg+= event.msg;});// 更新msg
    });
    super.initState();
  }
  dispose() {
    subscription.cancel();// State销毁时，清理注册
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return new Scaffold(
      body:Text(msg),
      ...
    );
  }
}
```

#### 9.3 页面交互

Flutter中页面之间的跳转使用Route和Navigator管理。

*   Route是页面的抽象，负责创建页面，接收参数，响应Navigator打开或关闭；
*   Navigator维护一个路由栈管理Route，Route打开就是入栈，关闭就是出栈，还可以替换栈内的Route。

Flutter中路由管理有2种方式，基本路由和命名路由

##### 9.3.1 基本路由

导航到一个新的页面需要创建一个MaterialPageRoute实例，调用Navigator.push方法将页面压倒栈的顶部。MaterialPageRoute是一种路由模板，定义过渡动画等相关配置，可以针对不同平台，实现与平台页面切换动画风格一致的路由切换动画。

返回上一个页面需要调用Navigator.pop方法从栈中删除这个页面。

```dart
class FirstScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return RaisedButton(
      //打开页面
      onPressed: ()=> Navigator.push(context, MaterialPageRoute(builder: (context) => SecondScreen()));
    );
  }
}

class SecondPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return RaisedButton(
      // 回退页面
      onPressed: ()=> Navigator.pop(context)
    );
  }
}
```

##### 9.3.2 命名路由

维护一个路由表，配置别名和页面的映射：

```dart
MaterialApp(
    ...
    // 注册路由
    routes:{
      "second_page":(context)=>SecondPage(),
    },
    //错误路由处理，统一返回UnknownPage 
    onUnknownRoute: (RouteSettings setting) => MaterialPageRoute(builder: (context) => UnknownPage()),
);
// 使用名字打开页面
Navigator.pushNamed(context,"second_page");
```

上面的onUnknownRoute用来处理不存在的路由标识的报错。

##### 9.3.3 路由参数

当需要打开路由传递参数时，使用RouteSettings获取：

```dart
// 打开页面时传递字符串参数
Navigator.of(context).pushNamed("second_page", arguments: "Hey");

class SecondPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // 取出路由参数
    String msg = ModalRoute.of(context).settings.arguments as String;
    return Text(msg);
  }
}
```

有时关闭页面也需要传递参数到上一个页面，比如打开某一个页面需要登录，上一个页面需要登录成功或者关闭作出处理：

```dart
class SecondPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: <Widget>[
          Text('Message from first screen: $msg'),
          RaisedButton(
            child: Text('back'),
            //页面关闭时传递参数
            onPressed: ()=> Navigator.pop(context,"Hi")
          )
        ]
      ));
  }
}

class _FirstPageState extends State<FirstPage> {
  String _msg='';
  @override
  Widget build(BuildContext context) {
    return new Scaffold(
      body: Column(children: <Widget>[
        RaisedButton(
            child: Text('命名路由（参数&回调）'),
            //打开页面，并监听页面关闭时传递的参数
            onPressed: ()=> Navigator.pushNamed(context, "third_page",arguments: "Hey").then((msg)=>setState(()=>_msg=msg)),
        ),
        Text('Message from Second screen: $_msg'),

      ],),
    );
  }
}
```



