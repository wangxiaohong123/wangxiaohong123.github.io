---
title: 1.分布式id-常见方案
date: 2021-01-19 06:27:35
tags:
  - 分布式id
categories: 框架
copyright: true
---

##### 分布式id生成器(发号器)使用场景

主要是用来做分库分表中数据的id。

##### 常见方案

###### 1.数据库主键自增

专门搞一个库和一个表，这个表只生成id，比如在插入真正数据之前，先往这个id生成表里插入，返回值就是主键。这种方案非常简单但是不能抗高并发，因为他是单标抗高并发写，肯定不现实。如果是低并发，低负载只是数据量大还勉强，关键是生产还需要保证这个表时高可用的，否则一个库挂了整个系统都死了，而且生成id的表还需要定期清理，其实也不简单。

###### 2.UUID

他应该是最简单的，直接本地生成，没有并发和可用问题，但是他生成的字符串，而且还很长，很长就会浪费空间，关键是他是字符串，而且不是自增，不是自增的主键会导致MySQL频繁的页分裂。如果有网卡的话UUID是基于Mac地址获得，容易暴露Mac地址。

###### 3.snowflake

雪花算范最终得到的是一个long类型数字，但是在计算的时候使用的是二进制，结构如下： 

| 0/1 | 41位二进制，当前时间 | n位二进制，n位机房id | 5位二进制，机器id | 12位二进制 |


* 第一位没有意义，是二进制标记位，0代表正数，1代表负数；

* 当前时间：使用当前时间毫秒时间戳转换为二进制，最高大约是69年；

* 10位的机房id和机器id：这两个可以随意传，比如服务器A、B、C，每台服务器部署了两个服务D、E，那么服务器A的机房id可以为1，服务器B的机房id为2，服务器C的机房id为3；服务D的机器id为1，服务E的id为2，或者这10位都是机器id，也就是发号器最多可以部署1024台服务；

* 12位二进制：当同一毫秒多个请求访问雪花算法工具类时，序号加1，意思是每台机器每毫秒最多生成4096个id，非常非常多了； 

他有很多问题，比如始终回拨：在多服务器上生成全局id，如果想保证id递增性，需要以一个机器作为基准，其他机器定时与这台机器时间校准，如果出现一台机器的时间快了，进行时间回调的之后，在生成的id可能就与之前的重复。
而且他需要独立部署，独立维护。 

###### 4.redis自增

比如5台redis机器，每台机器分别从1、2、3、4、5开始自增，自增的步长是5，这样也能抗住并发，但是需要每次生成id的时候定位机器，redis的数量也要写死，如果涉及到扩容是非常麻烦的，要改代码，还要清洗之前的id。如果想用在集群上还是单机合适一点，可是如果是单机需要主从保证高可用，如果发生主备切换就可能导致id重复，因为redis的主从同步是异步的。

###### 5.基于时间戳+业务id的组合

比如订单id基于时间戳+用户id这样可以保证唯一，除非他是用程序刷单或者系统bug。再比如打车软件是时间戳+地点id+手机号后4位之类的，这种冲突的概率就非常低了，但是理论上有可能会存在重复问题。他也只适合跟时间戳相关的业务。

第一优先级考虑这个。

###### 6.flicker(雅虎下的图片分享平台)

首先创建一张生成id的表：

```mysql
CREATE TABLE `id_generator` (  
  `id` bigint(20) unsigned NOT NULL auto_increment,  
  `stub` char(1) NOT NULL default '',  
  PRIMARY KEY  (`id`),  
  UNIQUE KEY `stub` (`stub`)  
) ENGINE=MyISAM;
```

注意这里的引擎使用的MyISAM，他的表现比InnoDB好，生成id的语法：

```mysql
REPLACE INTO id_generator(stub) VALUES ('a');  
SELECT LAST_INSERT_ID();
```

这样可以避免行数过大，一张表就一行数据。优化一下就是stub的值设置成每个服务的id，比如ip什么的，这样就会有多行，或者说stub设置成项目名，这样就支持多业务了，数据库只要双机主从高可用，在设置起始id和步长，类似redis自增的那种。但是他还是扛不住并发，但是生产可用，他和redis自增类似也会产生重复id问题。

###### 7.flicker变种

阿里的TDDL里的唯一ID用的就是这个，感觉leaf基于数据库也是用的这种方案。

就是说还是两台数据库，id的起始值不同，步长设置成很大，比如10000，然后底层还是replace+select，在单独写一个客户端，客户端里维护一个号段，每次执行1次REPLACE，和SELECT，然后把取到的id存到client中当做最大id，在维护一个AtomicLong，他的值是起始id，等到业务要使用id的时候就使用AtomicLong自增，如果AtomicLong增到最大值从数据库查一次，大概是这个意思。

号段自动更新：可以单独拿到一个线程定时检查号段是不是用完了，然后业务来取id发现超过号段最大值就睡眠一段时间再去查。
号段浪费问题：比如重启服务的时候号段没用完或者重启的时候又去获取了一个号段，但是用不上了，这个时候就要监听服务停止的生命周期，停止服务时不能在去获取新号段，还要把现在没用完的号段刷到本地，等到服务启动时从本都拿到没用完的号段继续使用。

缺点：还是不能扩容，超高并发比如双11用不了。

