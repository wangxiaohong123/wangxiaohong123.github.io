---
title: 2.shiro-realm
tags:
  - 安全认证
categories: 架构
copyright: true
---

#### 1.源码

MyRealm的类关系图：
![](https://tva1.sinaimg.cn/large/e6c9d24ely1h0h5eg9eqxj21gu0oc42s.jpg)
首先MyRealm继承了CachingRealm和一些接口，CachingRealm也实现了一些接口，先分析最上层的四个接口，⌘+↓跳到源码：

##### Realm接口：

```java
/**
 * 注释解释这个类是管理用户、角色、权限的
 * 一般和数据源一一对应
 */
public interface Realm {
    // 获取realm名称，同一个用户不同数据源使用不同Realm
    String getName();
	// 判断token是否支持，比如去ATM取钱，要先判断银行卡类型是否支持
    boolean supports(AuthenticationToken var1);
	// 根据token获取认证信息
    AuthenticationInfo getAuthenticationInfo(AuthenticationToken var1) throws AuthenticationException;
}
```

###### 1.上面两个方法都用到了AuthenticationToken类：

```java
/**
 * 在身份验证阶段尝的账户名和密码集合
 */
public interface AuthenticationToken extends Serializable {
    // 返回用户提交的账户名(能严格区分账号)
    Object getPrincipal();
	// 返回用户提交的密码
    Object getCredentials();
}
```

使用control+h查看子类关系：
![](https://tva1.sinaimg.cn/large/e6c9d24ely1h0h5w5alwcj20pc06ygnf.jpg)
可以看到他有两个子接口，但是这两个接口有一个共同的实现类UsernamePasswordToken，HostAuthenticationToken有一个自己的实现类BearerToken里面只有一个token和一个host属性，直接看UsernamePasswordToken的getPrincipal()和getCredentials()的方法实现：

```java
public class UsernamePasswordToken implements HostAuthenticationToken, RememberMeAuthenticationToken {
    private String username;
    private char[] password;
    private boolean rememberMe;
    private String host;
    
    // 可以看到他把username当成了账户名，所以我们传进来的username要保证唯一
    public Object getPrincipal() {
        return this.getUsername();
    }

    public Object getCredentials() {
        return this.getPassword();
    }
}
```

###### 2.getAuthenticationInfo()的返回值AuthenticationInfo

他和AuthenticationToken差不多，只不过getPrincipals()的返回值变成了一个集合。

```java
public interface AuthenticationInfo extends Serializable {
    PrincipalCollection getPrincipals();

    Object getCredentials();
}
```

##### CachingRealm

```java
public abstract class CachingRealm implements Realm, Nameable, CacheManagerAware, LogoutAware {
    private String name;
    private boolean cachingEnabled = true;
    private CacheManager cacheManager;
    
    /**
     * 获取账户的有效凭证
     */
    protected Object getAvailablePrincipal(PrincipalCollection principals) {
        Object primary = null;
        if (!isEmpty(principals)) {
            // 先根据realm名拿到凭证集合
            Collection thisPrincipals = principals.fromRealm(this.getName());
            if (!CollectionUtils.isEmpty(thisPrincipals)) {
                // 然后直接取第一个
                primary = thisPrincipals.iterator().next();
            } else {
                primary = principals.getPrimaryPrincipal();
            }
        }

        return primary;
    }
}
```

##### AuthenticatingRealm

在这个类的getSupports实现就可以解释supports是干什么的：

```java
public boolean supports(AuthenticationToken token) {
    // 只支持AuthenticationToken的子类
    return token != null && this.getAuthenticationTokenClass().isAssignableFrom(token.getClass());
}
```

再看getAuthenticationInfo方法：

```java
public final AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
    // 先从缓存中拿
    AuthenticationInfo info = this.getCachedAuthenticationInfo(token);
    if (info == null) {
        // 没有就去拿，这是个抽象方法，留给子类实现
        info = this.doGetAuthenticationInfo(token);
        if (token != null && info != null) {
            // 缓存认证信息
            this.cacheAuthenticationInfoIfPossible(token, info);
        }
    } else {
        log.debug("Using cached authentication info [{}] to perform credentials matching.", info);
    }

    if (info != null) {
        // 验证认证信息
        this.assertCredentialsMatch(token, info);
    } else {
        log.debug("No AuthenticationInfo found for submitted AuthenticationToken [{}].  Returning null.", token);
    }

    return info;
}
```

##### AuthorizingRealm

他是在AuthenticatingRealm的基础上增加的权限功能，同时他还实现了Authorizer接口，这个接口就是各种角色和权限检查。

#### 2.多realm demo

多realm就是多数据源，这样在登录的时候就要选择使用那种身份，realm自带的token类是没有身份标识的，所以需要我们自定义一个带标识的token类：

```java
package com.xiaohong.demo.ali.servicea.shiro.token;

import org.apache.shiro.authc.UsernamePasswordToken;

public class UsernamePasswordTypeToken extends UsernamePasswordToken {

    private String type;

    public UsernamePasswordTypeToken(final String username, final String password, final String type) {
        super(username, password);
        this.type = type;
    }

    public String getType() {
        return type;
    }
}
```

然后在添加一个自定义realm类，仿照MyRealm就可以，但是我没有，我尝试继承Realm接口：

```java
package com.xiaohong.demo.ali.servicea.shiro.realm;

import com.xiaohong.demo.ali.servicea.shiro.repository.bean.Admin;
import com.xiaohong.demo.ali.servicea.shiro.repository.bean.Users;
import com.xiaohong.demo.ali.servicea.shiro.service.AdminService;
import com.xiaohong.demo.ali.servicea.shiro.token.TokenType;
import com.xiaohong.demo.ali.servicea.shiro.token.UsernamePasswordTypeToken;
import org.apache.shiro.authc.*;
import org.apache.shiro.realm.Realm;
import org.apache.shiro.util.ByteSource;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;

@Component
public class AdminRealm implements Realm {

    // 这个是自己实现的admin表接口，和users一模一样
    @Resource
    private AdminService adminService;

    @Override
    public String getName() {
        return "adminRealm";
    }

    /**
     * 支持token是admin类型
     */
    @Override
    public boolean supports(AuthenticationToken token) {
        UsernamePasswordTypeToken typeToken = (UsernamePasswordTypeToken ) token;
        // TokenType是自定义的枚举类，判断这个realm是否支持当前token
        return TokenType.ADMIN.name().equals(typeToken.getType());
    }

    @Override
    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        String username = (String) token.getPrincipal();
        // 根据用户名从数据库查找用户
        Admin admin = adminService.queryByAdminName(username);
        if (null == admin) {
            throw new UnknownAccountException("用户不存在");
        }
        // 因为我们是直接继承的Realm，所以没有加密的方法，这里也就不需要盐
        return new SimpleAuthenticationInfo(username, admin.getPassword(), null, getName());
    }
}
```

把MyRealm也添加supports()方法：

```java
@Override
public boolean supports(AuthenticationToken token) {
    UsernamePasswordTypeToken typeToken = (UsernamePasswordTypeToken ) token;
    return TokenType.NORMAL.name().equals(typeToken.getType());
}
```

然后修改配置，把两个realm都加到SecurityManager中：

```java
/**
 * 创建SecurityManager
 */
@Bean
public SessionsSecurityManager securityManager(@Autowired List<Realm> realms) {
    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
    securityManager.setRealms(realms);
    return securityManager;
}
```

最后重新编写登录接口，增加身份标识变量：

```java
@PostMapping("/doLogin")
public String doLogin(String userName, String password, String type) {
    UsernamePasswordTypeToken token = new UsernamePasswordTypeToken(userName, password, type);
    try {
        SecurityUtils.getSubject().login(token);
    } catch (Exception e) {
        return "login";
    }
    return "manage";
}
```

##### 1.优化

每个realm的support()方法中都需要写死传过来的tokenType做比较这样不容易维护，我们把比较的方法放到一个tokenUtil里：

```java
package com.xiaohong.demo.ali.servicea.shiro.token;

import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.realm.Realm;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.Map;

@Component
public class TokenUtil {

    @Value("#{${realm.map}}")
    private Map<String, String> realmMap;

    public boolean supports(AuthenticationToken token, Realm realm) {
        return ((UsernamePasswordTypeToken) token).getType().equals(realmMap.get(realm.getName()));
    }
}
```

然后在配置文件中添加realm.map：

```yaml
realm:
  map: "{myRealm:'NORMAL',adminRealm:'ADMIN'}"
```

然后在两个realm中引入tokenUtil并修改supports()方法：

```java
private TokenUtil tokenUtil;
……
@Override
public boolean supports(AuthenticationToken token) {
    return tokenUtil.supports(token, this);
}
```

TokenUtil是被注入到spring的容器中了，但是我没有使用@Autowrite或者@Resource注解注入，而是使用aware方式注入，新建一个TokenUtilAware接口，里面只有一个方法，设置TokenUtil：

```java
package com.xiaohong.demo.ali.servicea.shiro.token;

import org.springframework.beans.factory.Aware;

public interface TokenUtilAware extends Aware {

    void setTokenUtil(TokenUtil tokenUtil);
}
```

因为他继承了Aware接口，所以会被spring扫描到，接着在新建一个postProcessor类，调用setTokenUtil方法：

```java
package com.xiaohong.demo.ali.servicea.shiro.token;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.core.Ordered;
import org.springframework.stereotype.Component;

@Component
public class TokenBeanPostProcessor implements BeanPostProcessor, Ordered {

    private ConfigurableApplicationContext ctx;

    public TokenBeanPostProcessor(ConfigurableApplicationContext ctx) {
        this.ctx = ctx;
    }

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        if (bean instanceof TokenUtilAware) {
            ((TokenUtilAware) bean).setTokenUtil(ctx.getBean(TokenUtil.class));
        }

        return bean;
    }

    @Override
    public int getOrder() {
        return Ordered.HIGHEST_PRECEDENCE;
    }
}
```

这个类实现了BeanPostProcessor和Ordered两个接口，这两个接口一个都不能少，因为现在我们的realm类中注入TokenUtil的流程是把TokenUtil放到spring容器中->扫描TokenUtilAware接口->执行postProcessor->把TokenUtil注入到realm类，执行postProcessor的postProcessBeforeInitialization()方法之前必须要完成TokenUtilAware、TokenUtil和realm类的扫描，如果不加order会导致realm放到容器中的时候TokenUtil没有被注入，如果把Ordered换成PriorityOrdered会导致执行postProcessBeforeInitialization()方法时TokenUtilAware没有放到容器中。

接下来只需要让realm类继承TokenUtilAware实现setTokenUtil()方法就可以了：

```java
@Override
public void setTokenUtil(TokenUtil tokenUtil) {
    this.tokenUtil = tokenUtil;
}
```