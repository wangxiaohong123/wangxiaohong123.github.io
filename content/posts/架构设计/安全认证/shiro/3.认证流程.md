---
title: 3.shiro-认证流程
tags:
  - 安全认证
categories: 架构
copyright: true
---

##### 单realm认证

在我们的登录接口中是先使用用户名、密码和账号的类型封装成了token，在使用`SecurityUtils.getSubject().login(token)`进行登录，断点跟到了DelegatingSubject的login()方法中，这个方法调用了securityManager的login方法并返回SubObject：

```java
Subject subject = securityManager.login(this, token);
```

然后进到DefaultSecurityManager的login()方法里，先调用了authenticate(token)方法，下面就是一些成功和失败的处理，点到authenticate()方法，还是只是调用其他方法:`return this.authenticator.authenticate(token);`,跟到了AbstractAuthenticator的authenticate方法，调用的是子类的doAuthenticate(token)方法，最后进到ModularRealmAuthenticator类中找到了核心代码：

```java
protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException {
    assertRealmsConfigured();
    Collection<Realm> realms = getRealms();
    if (realms.size() == 1) {
        return doSingleRealmAuthentication(realms.iterator().next(), authenticationToken);
    } else {
        return doMultiRealmAuthentication(realms, authenticationToken);
    }
}
```

首先进到单realm验证的方法：

```java
protected AuthenticationInfo doSingleRealmAuthentication(Realm realm, AuthenticationToken token) {
    // 调用supports()方法
    if (!realm.supports(token)) {
        throw new UnsupportedTokenException(msg);
    }
    // 获取验证信息
    AuthenticationInfo info = realm.getAuthenticationInfo(token);
    if (info == null) {
        throw new UnknownAccountException(msg);
    }
    return info;
}
```

获取验证信息调用的是AuthenticatingRealm的getAuthenticationInfo()方法：

```java
public final AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
    // 先从缓存拿
    AuthenticationInfo info = getCachedAuthenticationInfo(token);
    if (info == null) {
        // 这里调用的是我们自己实现的doGetAuthenticationInfo()方法
        info = doGetAuthenticationInfo(token);
        log.debug("Looked up AuthenticationInfo [{}] from doGetAuthenticationInfo", info);
        if (token != null && info != null) {
            cacheAuthenticationInfoIfPossible(token, info);
        }
    } else {
        log.debug("Using cached authentication info [{}] to perform credentials matching.", info);
    }
    if (info != null) {
        // 将获取到的信息和token中的信息比较
        assertCredentialsMatch(token, info);
    } else {
        log.debug("No AuthenticationInfo found for submitted AuthenticationToken [{}].  Returning null.", token);
    }
    return info;
}
```

查看信息比较方法：

```java
protected void assertCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) throws AuthenticationException {
    // 这个就是判断token和查询出来的用户信息是都一致
    CredentialsMatcher cm = getCredentialsMatcher();
    if (cm != null) {
        if (!cm.doCredentialsMatch(token, info)) {
            throw new IncorrectCredentialsException(……);
        }
    } else {
        throw new AuthenticationException(……);
    }
}
```

CredentialsMatcher有3个实现类：

*   AllowAllCredentialsMatcher：一直返回true，没有实际意义，测试使用
*   PasswordMatcher：
*   SimpleCredentialsMatcher：我们的realm里注入的就是这个类的子类：HashedCredentialsMatcher

有四个属性：

```java
// 算法名
private String hashAlgorithm;
// hash次数
private int hashIterations;
// 盐
private boolean hashSalted;
// 存储格式
private boolean storedCredentialsHexEncoded;
```

查看HashedCredentialsMatcher的doCredentialsMatch()方法实现：

```java
public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {
    // 计算加密密文
    Object tokenHashedCredentials = hashProvidedCredentials(token, info);
    Object accountCredentials = getCredentials(info);
    // 比较信息
    return equals(tokenHashedCredentials, accountCredentials);
}
```

###### AdminRealm认证问题

到这里就可以发现一个问题，AdminRealm直接继承Realm接口，并没有实现CredentialsMatcher的比较方法，所以在登录的时候输入什么都会返回成功，所以在AdminRealm中拿到SimpleAuthenticationInfo后进行比较操作，把比较信息的代码拿过来后的AdminRealm代码:

```java
package com.xiaohong.demo.ali.servicea.shiro.realm;

import com.xiaohong.demo.ali.servicea.shiro.repository.bean.Admin;
import com.xiaohong.demo.ali.servicea.shiro.service.AdminService;
import com.xiaohong.demo.ali.servicea.shiro.token.TokenUtil;
import com.xiaohong.demo.ali.servicea.shiro.token.TokenUtilAware;
import org.apache.shiro.authc.*;
import org.apache.shiro.authc.credential.AllowAllCredentialsMatcher;
import org.apache.shiro.authc.credential.CredentialsMatcher;
import org.apache.shiro.authc.credential.HashedCredentialsMatcher;
import org.apache.shiro.realm.Realm;
import org.apache.shiro.util.ByteSource;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;

@Component
public class AdminRealm implements Realm, TokenUtilAware {

    @Resource
    private AdminService adminService;

    private TokenUtil tokenUtil;

    private final CredentialsMatcher credentialsMatcher;

    public AdminRealm() {
        HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher();
        hashedCredentialsMatcher.setHashAlgorithmName("MD5");
        hashedCredentialsMatcher.setHashIterations(1024);
        hashedCredentialsMatcher.setStoredCredentialsHexEncoded(true);
        this.credentialsMatcher = hashedCredentialsMatcher;
    }

    @Override
    public String getName() {
        return "adminRealm";
    }

    /**
     * 支持token是admin类型
     */
    @Override
    public boolean supports(AuthenticationToken token) {
        return tokenUtil.supports(token, this);
    }

    @Override
    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        String username = (String) token.getPrincipal();
        // 根据用户名从数据库查找用户
        Admin admin = adminService.queryByAdminName(username);
        if (null == admin) {
            throw new UnknownAccountException("用户不存在");
        }
        // 算密码的盐
        ByteSource bytes = ByteSource.Util.bytes(username);
        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(username, admin.getPassword(), bytes, getName());
        assertCredentialsMatch(token, info);
        return info;
    }

    @Override
    public void setTokenUtil(TokenUtil tokenUtil) {
        this.tokenUtil = tokenUtil;
    }

    private void assertCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {
        CredentialsMatcher cm = getCredentialsMatcher();
        if (cm != null) {
            if (!cm.doCredentialsMatch(token, info)) {
                //not successful - throw an exception to indicate this:
                String msg = "Submitted credentials for token [" + token + "] did not match the expected credentials.";
                throw new IncorrectCredentialsException(msg);
            }
        } else {
            throw new AuthenticationException(……);
        }
    }

    public CredentialsMatcher getCredentialsMatcher() {
        return credentialsMatcher;
    }
}
```

##### 多域认证

回到ModularRealmAuthenticator类中的doAuthenticate()方法，进到多域认证的doMultiRealmAuthentication()方法中：

```java
protected AuthenticationInfo doMultiRealmAuthentication(Collection<Realm> realms, AuthenticationToken token) {
	// 获取认证策略
    AuthenticationStrategy strategy = getAuthenticationStrategy();
    AuthenticationInfo aggregate = strategy.beforeAllAttempts(realms, token);

    for (Realm realm : realms) {
        try {
            aggregate = strategy.beforeAttempt(realm, token, aggregate);
        } catch (ShortCircuitIterationException shortCircuitSignal) {
            // Break from continuing with subsequnet realms on receiving 
            // short circuit signal from strategy
            break;
        }

        if (realm.supports(token)) {
            AuthenticationInfo info = null;
            Throwable t = null;
            try {
                info = realm.getAuthenticationInfo(token);
            } catch (Throwable throwable) {
                t = throwable;
            }
            aggregate = strategy.afterAttempt(realm, token, info, aggregate, t);
        } else {
            log.debug("Realm [{}] does not support token {}.  Skipping realm.", realm, token);
        }
    }

    aggregate = strategy.afterAllAttempts(token, aggregate);
    return aggregate;
}
```

AuthenticationStrategy是认证策略，这个接口中有4个方法，在所有realm认证之前，在单个realm认证之前，在所有realm认证之后，在单个realm认证之后，他的每个实现类都是一个认证策略，shiro自己实现的有3个：至少1个realm认证成功，所有realm认证成功，第一个realm认证成功。

在for循环里的认证和单realm流程是一样的，完整的流程：
![](https://tva1.sinaimg.cn/large/e6c9d24ely1h0j2tjngbmj22180pu42m.jpg)

