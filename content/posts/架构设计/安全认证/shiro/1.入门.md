---
title: 1.shiro入门
tags:
  - 架构
categories: 安全认证
copyright: true
---

##### 功能

###### 1.主要功能

*   Authentication：身份认证/登录，验证用户是否是所声明的用户。
*   Authorization：授权验证，验证某个用户是否拥有某个权限。
*   Session Management：会话管理，用户信息也是保存在会话当中。
*   Cryptography：加密，保护数据的安全性。

###### 2.扩展功能

*   web support：很容易集成到web环境。
*   caching：缓存，避免每次查询数据库。
*   concurrency：多线程并发验证。
*   testing：很方便的测试验证。
*   run as：允许一个用户假装成另外一个用户身份。
*   remember me：记住我那个选中框。

##### 使用

使用流程：创建realm(安全数据源)->构建框架核心类SecurityManager->将realm绑定到SecurityManager->获取token凭证(用户名|密码)->调用Subject API完成登录校验。

创建好一个springboot的项目，引入MySQL，编辑好配置文件，增加shiro的配置：

```xml
<!-- 我这里使用的是1.8.0 -->
<dependency>
    <groupId>org.apache.shiro</groupId>
    <artifactId>shiro-spring-boot-web-starter</artifactId>
    <version>${shiro.version}</version>
</dependency>
```

###### 1.登录：

一）测试在代码里写死用户名和密码：

```java
@Test
public void login() {
    SimpleAccountRealm realm = new SimpleAccountRealm();
    realm.addAccount("xx", "123456");
    DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();
    defaultSecurityManager.setRealm(realm);
    // 全局设置安全管理器
    SecurityUtils.setSecurityManager(defaultSecurityManager);

    UsernamePasswordToken token = new UsernamePasswordToken("xx", "123456");
    // 创建Subject
    Subject subject = SecurityUtils.getSubject();
    // 登录
    subject.login(token);
    Assert.isTrue(subject.isAuthenticated());
	// 登出
    subject.logout();
    Assert.isTrue(!subject.isAuthenticated());
}
```

二）测试通过文件获取用户

在测试目录下创建resources文件夹，新建user.ini或者shiro-users.properties文件，添加如下内容：

```ini
# ini文件格式
[users]
xx=123456
# properties文件格式
user.xx=123456
```

然后编写测试方法：

```java
@Test
public void login2() {
    // properties写法，不需要指定资源路径，默认文件名就是shiro-users.properties
    PropertiesRealm realm = new PropertiesRealm();
    realm.onInit();
    // ini文件写法，需要制定资源路径
    // IniRealm realm = new IniRealm("classpath:user.ini");
    DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();
    defaultSecurityManager.setRealm(realm);
    SecurityUtils.setSecurityManager(defaultSecurityManager);

    UsernamePasswordToken token = new UsernamePasswordToken("xx", "123456");

    Subject subject = SecurityUtils.getSubject();
    subject.login(token);
    Assert.isTrue(subject.isAuthenticated());

    subject.logout();
    Assert.isTrue(!subject.isAuthenticated());
}
```

三）测试从数据库获取用户

新建一张表(users)，列为username和password，表名和列名都和shiro默认的一样，这样在demo中不需要自定义SQL语句了：

```java
@Test
public void login3() {
    DruidDataSource druidDataSource = new DruidDataSource();
    druidDataSource.setUrl("jdbc:mysql://8.142.71.78:3306/demo-shiro?useUnicode=true&useSSL=false&characterEncoding=utf8&serverTimezone=Asia/Shanghai");
    druidDataSource.setUsername("root");
    druidDataSource.setPassword("123456");
    druidDataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
    JdbcRealm realm = new JdbcRealm();
    realm.setDataSource(druidDataSource);
    DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();
    defaultSecurityManager.setRealm(realm);
    SecurityUtils.setSecurityManager(defaultSecurityManager);

    UsernamePasswordToken token = new UsernamePasswordToken("xx", "123456");

    Subject subject = SecurityUtils.getSubject();
    subject.login(token);
    Assert.isTrue(subject.isAuthenticated());

    subject.logout();
    Assert.isTrue(!subject.isAuthenticated());
}
```

###### 2.权限

一）从文件获取角色，在ini或者properties添加以下代码：

```ini
# ini文件格式
[users]
xx=123456,admin
[roles]
admin=user:del,user:add,user:edit
# properties文件格式
user.xx=123456,admin
role.admin=user:del,user:add,user:edit
```

然后从文件获取用户名和密码的登录测试不需要改，添加一行断言判断：

```java
Assert.isTrue(subject.hasRole("admin"));
Assert.isTrue(subject.isPermitted("user:add"));
Assert.isTrue(!subject.isPermitted("user:query"));
```

二）数据库获取角色权限，新建表user_roles，这个表包含两个字段，username和role_name，插入一条数据username(xx)，role_name(admin)，在新建角色权限表roles_permissions，这个表里也有两个字段，role_name和permission，在新增一条admin的user:*数据。修改从数据库获取用户名和密码的测试代码：

```java
@Test
public void permission3() {
    DruidDataSource druidDataSource = new DruidDataSource();
    druidDataSource.setUrl("jdbc:mysql://8.142.71.78:3306/demo-shiro?useUnicode=true&useSSL=false&characterEncoding=utf8&serverTimezone=Asia/Shanghai");
    druidDataSource.setUsername("root");
    druidDataSource.setPassword("qiyuan1502");
    druidDataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
    JdbcRealm realm = new JdbcRealm();
    realm.setDataSource(druidDataSource);
    realm.setPermissionsLookupEnabled(true);
    DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();
    defaultSecurityManager.setRealm(realm);
    SecurityUtils.setSecurityManager(defaultSecurityManager);

    UsernamePasswordToken token = new UsernamePasswordToken("xx", "123456");

    Subject subject = SecurityUtils.getSubject();
    subject.login(token);
    Assert.isTrue(subject.isAuthenticated());
    Assert.isTrue(subject.hasRole("admin"));
    Assert.isTrue(subject.isPermitted("user:add"));

    subject.logout();
    Assert.isTrue(!subject.isAuthenticated());
}
```

在JdbcRealm中定义了一些SQL，我们也可以自定义SQL，比如下面的代码是自定义查询用户SQL：

```
realm.setAuthenticationQuery("select password from users where username = ?");
```

###### 3.加密

shiro支持3中加密方式：可逆、不可逆、编码手段：

*   编码手段：只防君子不防小人，包括Hex(Base16)和Base64
*   可逆加密：AES、BlowFish(目前也没有破解方法)，这两个都是对称加密
*   不可逆加密：SHA(最广泛的hash算法)、MD5

修改登录测试代码，加入密码加密：

```java
@Test
public void login() {
    HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher();
    hashedCredentialsMatcher.setHashAlgorithmName("MD5");
    hashedCredentialsMatcher.setHashIterations(1024);
    hashedCredentialsMatcher.setStoredCredentialsHexEncoded(true);

    SimpleAccountRealm realm = new SimpleAccountRealm();
    realm.setCredentialsMatcher(hashedCredentialsMatcher);
    realm.addAccount("xx", "fc1709d0a95a6be30bc5926fdb7f22f4");
    DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();
    defaultSecurityManager.setRealm(realm);
    // 全局设置安全管理器
    SecurityUtils.setSecurityManager(defaultSecurityManager);

    UsernamePasswordToken token = new UsernamePasswordToken("xx", "123456");
    // 创建Subject
    Subject subject = SecurityUtils.getSubject();
    subject.login(token);
    Assert.isTrue(subject.isAuthenticated());

    subject.logout();
    Assert.isTrue(!subject.isAuthenticated());
}
```

##### 整合springboot

新建spring boot项目，引入shiro-spring-boot-web-starter、mybatis：

```xml
<dependency>
    <groupId>org.apache.shiro</groupId>
    <artifactId>shiro-spring-boot-web-starter</artifactId>
    <version>1.8.0</version>
</dependency>

<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.27</version>
</dependency>
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.2.2</version>
</dependency>
```

编写自定义realm(获取认证、获取授权信息、加密方式)：

```java
package com.xiaohong.demo.ali.servicea.shiro;

import com.xiaohong.demo.ali.servicea.shiro.repository.bean.Users;
import com.xiaohong.demo.ali.servicea.shiro.service.RolePermissionService;
import com.xiaohong.demo.ali.servicea.shiro.service.UserRoleService;
import com.xiaohong.demo.ali.servicea.shiro.service.UserService;
import org.apache.shiro.authc.*;
import org.apache.shiro.authc.credential.CredentialsMatcher;
import org.apache.shiro.authc.credential.HashedCredentialsMatcher;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.authz.SimpleAuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;
import org.apache.shiro.util.ByteSource;
import org.apache.shiro.util.CollectionUtils;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Component
public class MyRealm extends AuthorizingRealm {

    @Resource
    private UserService userService;

    @Resource
    private UserRoleService userRoleService;

    @Resource
    private RolePermissionService rolePermissionService;

    /**
     * 获取授权信息
     */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        Object userName = principalCollection.getPrimaryPrincipal();
        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
        // 先从数据库获取角色，在获取角色的权限
        info.setRoles(new HashSet<>(userRoleService.queryRolesByUserName((String) userName)));
        Set<String> permissions = new HashSet<>();
        for (String role : info.getRoles()) {
            List<String> strings = rolePermissionService.queryPermissionsByRole(role);
            if (!CollectionUtils.isEmpty(strings)) {
                permissions.addAll(new HashSet<>(strings));
            }
        }
        // 设置权限
        info.setStringPermissions(permissions);
        return info;
    }

    /**
     * 获取身份验证信息
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        String username = (String) token.getPrincipal();
        // 根据用户名从数据库查找用户
        Users user = userService.queryByUserName(username);
        if (null == user) {
            throw new UnknownAccountException("用户不存在");
        }
        // 算密码的盐
        ByteSource bytes = ByteSource.Util.bytes(username);
        return new SimpleAuthenticationInfo(username, user.getPassword(), bytes, getName());
    }

    /**
     * 设置加密
     */
    @Override
    public void setCredentialsMatcher(CredentialsMatcher credentialsMatcher) {
        HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher();
        hashedCredentialsMatcher.setHashAlgorithmName("MD5");
        hashedCredentialsMatcher.setHashIterations(1024);
        hashedCredentialsMatcher.setStoredCredentialsHexEncoded(true);
        super.setCredentialsMatcher(hashedCredentialsMatcher);
    }
}
```

编写shiroConfig配置类，初始化securityManager，设置realm，设置url访问权限，自定义错误返回方式:

```java
package com.xiaohong.demo.ali.servicea.shiro;

import org.apache.shiro.mgt.SessionsSecurityManager;
import org.apache.shiro.spring.web.config.DefaultShiroFilterChainDefinition;
import org.apache.shiro.spring.web.config.ShiroFilterChainDefinition;
import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.handler.SimpleMappingExceptionResolver;

import java.util.Properties;


@Configuration
public class MyShiroConfig {

    /**
     * 创建SecurityManager
     */
    @Bean
    public SessionsSecurityManager securityManager(@Autowired MyRealm myRealm) {
        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
        securityManager.setRealm(myRealm);
        return securityManager;
    }

    /**
     * 配置认证过滤
     */
    @Bean
    public ShiroFilterChainDefinition shiroFilterChainDefinition() {
        DefaultShiroFilterChainDefinition definition = new DefaultShiroFilterChainDefinition();
        // authc的意思是需要认证，anon的意思是不需要认证
        definition.addPathDefinition("/manage/**", "authc");
//        definition.addPathDefinition("/user/**", "roles[\"admin\"]");
        return definition;
    }

    /**
     * 解决使用@RequiresRoles或者@RequiresPermissions注解后接口404问题
     */
    @Bean
    public static DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() {
        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();
        defaultAdvisorAutoProxyCreator.setUsePrefix(true);
        return defaultAdvisorAutoProxyCreator;
    }

    /**
     * 自定义错误跳转到/unauthorized
     */
    @Bean
    public SimpleMappingExceptionResolver simpleMappingExceptionResolver() {
        SimpleMappingExceptionResolver resolver = new SimpleMappingExceptionResolver();
        Properties properties = new Properties();
        properties.setProperty("org.apache.shiro.authz.AuthorizationException", "/unauthorized");
        resolver.setExceptionMappings(properties);
        return resolver;
    }
}
```

项目配置文件：

```yaml
spring:
  application:
    name: service-a
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://8.142.71.78:3306/demo-shiro?useUnicode=true&useSSL=false&characterEncoding=utf8&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
    username: root
    password: qiyuan1502
  main:
    allow-bean-definition-overriding: true
server:
  port: 8001
mybatis:
  configuration:
    # 驼峰转下划线
    map-underscore-to-camel-case: true
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.xiaohong.demo.ali.servicea.shiro.repository.bean

shiro:
  loginUrl: /login
  unauthorizedUrl: /unauthorized
```

编写controller测试，登录登出的接口：

```java
@PostMapping("/doLogin")
public String doLogin(String userName, String password, String type) {
    UsernamePasswordTypeToken token = new UsernamePasswordTypeToken(userName, password, type);
    try {
        SecurityUtils.getSubject().login(token);
    } catch (Exception e) {
        return "login";
    }
    return "manage";
}

@GetMapping("/doLogout")
public String doLogout() {
    SecurityUtils.getSubject().logout();
    return "login";
}
```

剩下的就是正常写接口，然后配置权限，测试。