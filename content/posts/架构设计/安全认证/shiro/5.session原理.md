---
title: 5.shiro-session原理
tags:
  - 架构
categories: 安全认证
copyright: true
---

了解session原理需要先看Subject的源码，因为session由他管理，打开这个接口看到有个内部类叫Builder，它里面有两个变量：

```java
private final SubjectContext subjectContext;
private final SecurityManager securityManager;
```

##### SubjectContext

负责管理Subject上下文接口，他继承了Map类，里面是一些get、set方法，他有1个实现类(DefaultSubjectContext)和一个子接口(WebSubjectContext)，WebSubjectContext就是把request、response等变量存起来，实现类和子接口有一个共同的实现类(DefaultWebSubjectContext)。

Builder在实例化的时候会创建一个DefaultSubjectContext然后把SecurityManager放进去，Builder中还有一个buildSubject()方法，调用SecurityManager的createSubject()根据创建的SubjectContext创建一个Subject。

Subject也有一个实现类(DelegatingSubject)和一个子接口(WebSubject)，他俩有一个共同的实现类(WebDelegatingSubject)，当项目启动时，通过MEATA-INF扫描到shiro的一堆bean，spring.factories的配置：

```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration = \
  org.apache.shiro.spring.config.web.autoconfigure.ShiroWebAutoConfiguration,\
  org.apache.shiro.spring.config.web.autoconfigure.ShiroWebFilterConfiguration,\
  org.apache.shiro.spring.config.web.autoconfigure.ShiroWebMvcAutoConfiguration,\
  org.apache.shiro.spring.boot.autoconfigure.ShiroBeanAutoConfiguration,\
  org.apache.shiro.spring.boot.autoconfigure.ShiroAutoConfiguration,\
  org.apache.shiro.spring.boot.autoconfigure.ShiroAnnotationProcessorAutoConfiguration

org.springframework.boot.diagnostics.FailureAnalyzer = \
  org.apache.shiro.spring.boot.autoconfigure.ShiroNoRealmConfiguredFailureAnalyzer
```

其中有个bean就叫ShiroWebFilterConfiguration，在这个filterConfiguration中创建了ShiroFilterFactoryBean，而这个bean继承了BeanPostProcessor，这个bean的getObject()方法里创建了AbstractShiroFilter，这个filter创建并且调用了Subject：

```java
protected WebSubject createSubject(ServletRequest request, ServletResponse response) {
    return (new Builder(this.getSecurityManager(), request, response)).buildWebSubject();
}

protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse, final FilterChain chain) throws ServletException, IOException {
        Throwable t = null;
    try {
        final ServletRequest request = this.prepareServletRequest(servletRequest, servletResponse, chain);
        final ServletResponse response = this.prepareServletResponse(request, servletResponse, chain);
        // 构建WebSubject
        Subject subject = this.createSubject(request, response);
        subject.execute(new Callable() {
            public Object call() throws Exception {
                AbstractShiroFilter.this.updateSessionLastAccessTime(request, response);
                AbstractShiroFilter.this.executeChain(request, response, chain);
                return null;
            }
        });
    }
}
```

跟Subject不一样，SecurityManager在启动时就创建好了，而Subject是在请求处理之前构建。

##### Subject相关组件

SubjectDAO：保存的组件，只有一个实现DefaultSubjectDAO

SubjectFactory：创建Subject的组件，默认也只有一个实现DefaultSubjectFactory，DefaultSubjectFactory还有一个子类DefaultWebSubjectFactory

### session

session接口的方法有登录时间相关、主机、刷新时间、销毁session，设置属性。

他有1个子接口ValidatingSession，多了一个判断会话是否有效的方法。

ValidatingSession有一个实现类SimpleSession，SimpleSession中自己实现了一套完整的session实现，把属性保存到map中，这个是跟web环境无关的。

还有3个实现类ProxiedSession、HttpServletSession(基于httpSession保存session属性)、DelegatingSession。

其中ProxiedSession还有两个实现类ImmutableProxiedSession和StoppingAwareProxiedSession(DelegatingSubject的内部类)

DelegatingSession内部多了两个类，SessionKey和NativeSessionManager。NativeSessionManager继承了SessionManager，SessionManager中的方法只有start(SessionContext context)和getSession(SessionKey key)，NativeSessionManager是对SessionManager的方法进行补充SessionManager还有其他的实现类，再往里还有几个组件SessionFactory、SessionDAO(Cache和Memory)、SessionManager等。