---
title: DDD-2.入门
date: 2021-06-24 06:27:35
tags:
  - 研发效能
categories: DDD
copyright: true
---

DDD是一套软件/系统的设计思想，目前没有一套完整的方法论。他建议用现实的场景映射我们的代码设计，传统的MVC主要是快，但是代码会全部堆积在service层，在拿到需求后，开始建库表，然后所有的代码都是面向数据库的，这样service的代码会越来越多，并且在面对复杂业务会很无力，DDD就是为了解决复杂场景下的代码设计。但是目前使用DDD做代码设计的非常少，因为资料少，实践困难，如果是一个微型团队，每个人负责几个子系统，每个人都需要定义自己子系统的通用语言，这样沟通很容易产生误会，最好是一个二三十人的团队，负责十几个系统，每个小团队负责一个系统（一个系统里可能包含很多服务），这样小团队之间用自己的自定语言，项目leader先划分好领域，然后建模，每个团队的leader在把自己的系统建模，这样才可以。

##### 为什么要用DDD？

首先DDD的思想是面向对象的，更接近真实场景，其次在复杂系统的设计上DDD更优于传统三层架构，但如果三层架构把服务拆的足够微，我不觉得他比DDD弱，其实现在的DDD和十几年前的三层架构一样，当时三层架构刚刚开始流行，大部分公司没有接触过，就感觉很厉害，很难，几年之后，三层架构变成标配，在这种分层的思想已经固化的时候，出来了一个DDD，思想和三层架构有些差别，使用的少或者没使用就会感觉DDD很深奥，可能再过几年DDD普及之后就和现在的MVC一样了。DDD的价值是让开发和产品对业务有相同的理解，DDD的流程差不多是这样：

需求评审->和产品、运营、用户定义通用语言->业务建模->架构设计(业务架构+技术架构)->团队成员开始建模(实体、值对象、互动的流程)->搭建工程、定义接口、代码落地(根据通用语言)

可以看到和产品的沟通变多了，和产品一起定义的名词和业务挂钩，沟通无障碍，新人在看完需求文档，在看代码也很轻松。

其实传统的service+controller+dao+domain除了开发快，还有一个优点，就是门槛低，随便一个培训出来的人都能开发。但是DDD更适合大型的复杂的业务系统，而且他更贴合显示，业务模型和业务代码特别清晰，代码非常好看，如果一直维护面向数据库的代码肯定会越来乱。

如果一个大团队没搞DDD，小团队自己能不能搞？能，只要把只要把团队负责的几个系统定义一套通用语言就可以，小团队不搞，自己负责的几个服务能不能搞？能，自己负责的每个服务都是一个子域，使用一个通用语言也可以。

##### 基础概念

###### 1.限界上下文

他是一个独立的业务领域，可以是一个或多个子域，一般就是一个子域，也建议这么划分，建议每个限界上下文最好是一个独立的子系统，拥有独立的git仓库，独立的数据仓库，独立的测试环境，独立的团队。

###### 2.通用语言

针对同一限界上下文需要定义一套自己的名词，比如同样的orderNumber，在订单域里是充值、消费的订单号，在匹配域里，是发起一次群聊请求的订单号/房间号。

###### 3.子域（domain）

其实说的就是限界上下文，主要有3种子域，一般一个子域最好对应唯一一个限界上下文。

核心域：核心业务系统，比如订单、钱包、动态。

支撑子域：非核心系统，但是有了锦上添花或者是辅助性的系统，比如BI系统、爬虫系统、社会化治理系统。

通用子域：一般具有普适性，全公司都可以用的类似OA系统、权限系统这种。

一个子域可以拆分成多个module，一般一个子域也是一个独立运行的大系统。

###### 4.module

一般一个module就是一个服务。

###### 5.上下文映射

就是子域进行集成，就是不同系统之间的接口调用，因为不同的系统可能会有通用语言的冲突，就需要在接口调用的时候把冲突的单词映射成另一个。

上下文映射的种类，U-D就是调用链的上下游，下游调用，上游提供，箭头是由上游指向下游，表示数据的流向：

*   合作关系（Partnership）：两个上下文强耦合在一起，多个服务完成一整个业务，一般都是一起需求评审，一起开发，一起上线。这种关系需求变更对应的服务也要改动。
*   共享内核（Shared Kernel）：两个系统共同维护一些模型，比如A系统的API里的一些类是B系统认可的，或者一个单独的公共的模块，他们共用并且共同维护这些实体，很少见。
*   客户方-供应方（Customer-Supplier Development）：就是系统B根据系统A的需求定制接口，返回值还是系统A（客户方说的算），一般都是和合作关系配合用，你需要接口，人家没有就一起商量一下。
*   发布订阅（Publish-Subscribe）：比如那种发mq消息的。
*   尊奉着/没商量（Conformist）：系统A调用系统B，但是A说得不算，B只暴露一些接口，你要是用就调一下，你想要修改人家也不配合你，一般就是中间件部门写的接口，或者其他独立的系统。
*   开放主机服务OHS（Open Host Service）和发布语言PL（Published Language）：相当于是开放的API了，一般指三方或者公司自己的平台，比如云片短信，定义一种协议，一般都是http。基于消息机制也是发布语言的实现方式。
*   防腐层ACL（Anticorruption Layer）：为了防止系统B接口改动频繁，把调用系统B的代码抽离出来，以后系统B再次改动，这需要改防腐层的代码即可，一般和尊奉着/开放主机服务一起使用。
*   大泥球（Big Ball of Mud）：上下文没有关系，各行其道，混乱的组织在一起，一般说得就是本该拆成几个子域，结果混在了一个服务里。
*   独立路线/隔离模式（SeparateWay）：没关系。

###### 6.实体和值对象

*   实体：先理解成传统MVC的domain下的实体，但其实远不止，实体是有状态和行为的，也就是说实体的变量是可变的。
*   值对象：就是实体中包含的数据，比如订单中的值对象可以有订单详情，代表的是封装了一份数据，最经典的例子，前端返回的实体一般起名都以VO结尾，VO就是value object的缩写，翻译过来就是值对象，比如返回给前端的订单信息中有OrderInfo、OrderItem、Product、PurchaseCart。其实实体和值对象的区别可以理解成实体有id，值对象没有id。标准的DDD中规定值对象只能替换，不能修改。
*   聚合（Aggregate）：多个实体或者值对象的组合关系，一个订单实体中有多个订单明细实体，他们就是聚合关系，他可以看成是特殊的实体。
*   根实体：每个聚合关系里都有一个根实体，在订单里，大订单就是跟实体，也叫聚合根。
*   事务：说的是聚合实体的事务关系，比如说一起更新，要保证事务更新了这个聚合实体的整体或者部分的时候，实体内的数据是一致的。

聚合关系应尽量通过实体id引用，不要通过面向对象的引用，尽可能保证小型，主要就是通过事务规则，符合事务原则的实体，可以设计成聚合关系。

###### 7.资源库(repository)

负责对实体对象进行持久化。

###### 8.应用服务

负责对业务流程的编排，对应service接口。

###### 9.领域服务

实体/值对象/资源库/工厂/聚合不适合放在里面的复杂性为的补充。里面的行为就是指挥多个实体/值对象完成业务逻辑。 

###### 10.领域事件

系统交互的核心事件，比如支付订单事件，一般用过去式命名。

###### 11.业务组件

对领域事件的发布和处理。

###### 12.用户界面

对应controller接口。

###### 13.基础设施

MySQL、es、redis什么的，业务组件、领域服务、实体、资源库都可以用，根据业务决定。

###### 14.命令 command和查询query

用来驱动领域服务的业务逻辑核方法的执行，一般就是人通过web或者app这种UI界面发起的指令，是从CQRS架构里延伸出来的，牵扯到了下面的类DDD和泛DDD。

###### 15.战略设计/战略建模/领域对象建模

对子域划分、上下文映射、子域集成、实体、值对象和领域服务建模，完全没必要说得这么高大上，其实就是业务建模。一般一块业务就对应一个领域，一个领域又可以拆成多个子域，拆分域还是很容易的。

业务领域 -> 各个子域（module） -> 自己子域的通用语言（你应该跟子域里的其他人一起合作） -> 上下文映射（上下游关系）

###### 16.战术设计/战术建模

就是系统的详细设计。

### 贫血模型

我们现在的开发模式主要是快，代码全部堆积在service层，domain中的实体只有变量和get、set方法，这就叫贫血模型，DDD的精华就是反对贫血模型，让代码和真是业务对应起来，DDD呼吁采用真正的面向对象，通过业务系统建模还原真实世界，比如下订单，按照原来的逻辑，controller收到请求之后可能做一些校验就会把数据交给service，service去下单、扣库存，但是在真是场景中，订单是不能自己下单的，是人，用户才会有下单这个行为，正常应该是订单信息、优惠券、抵扣信息等封装到一个orderVO，controller校验完之后通过userEntity.submitOrder(orderVO)类似这样的操作去下单，准确的说userEntity也不是必要的，最起码应该是实体调用实体，controller和service还是可以存在的，只不过是做一写校验和返回值处理，dao层是对数据库的简单增删改查。

可以看出来DDD的精华就在实体建模上，抛弃面向过程，根据真实场景构建出实体的交互流程，这样只要别人理解业务，就一定能看懂代码，但是DDD的建模对业务理解要求非常严格，必须要深度理解业务。一定要贴合业务建模，面向流程开发。

##### 开发流程demo

在DDD里开发流程只有战略设计和战术设计，最后代码落地，战略设计又分为需求分析，场景分析，领域建模，子域划分（微服务拆分）；战术设计就是把领域对象确定实体、值对象、事件、实体方法，确定代码流程。

###### 1.战略设计

战略设计是根据用户旅程，提取领域对象和聚合根，然后划分限界上下文，建立领域模型，采用事件风暴的方法，把每个功能梳理一遍，提取领域对象。

*   产品愿景：就是需求分析，确定大概的需求，比如目标人群，功能列表。

*   场景分析：针对每一个功能列出事件和命令，比如请假功能：

    1）请假人登录系统：登录认证，获取用户信息和权限数据；

    2）创建请假单：打开请假页面，选择请假类型和时间，录入信息，提交请假单；

    3）修改请假单：查询请假单，打开请假单信息，修改，提交请假单；

    4）提交请假审批：获取审批规则，根据规则获取审批人，给请假单分配审批人；

*   领域建模：根据事件和命令反向推导出实体、值对象，确定聚合；划分限界上下文。怎么确定聚合？怎么定义实体和值对象？

    **实体和值对象**：大部分情况下可以简单的理解为实例有唯一id，并且这个id不会随着实体的状态改变儿改变，没有id就是值对象，但是不能这么分，因为值对象的定义是一个属性集合，只有数据初始化和不涉及修改数据的行为，因为值对象是一个整体，修改属性就要修改整个值对象，而实体是具有业务行为和业务逻辑的。比如根据会员、活动计算价格，虽然没有唯一id，但是涉及业务，她应该也是一个实体，用户信息有省份、城市、街道，这些统称地址信息，可以封装成一个值对象由用户实体引用，值对象的本质是把属性归类。

    **聚合**：聚合是由业务逻辑紧密关联的实体和值对象组合而成，是修改和持久化的基本单元，我理解的基本单元就是具有事务性，一般一个聚合对应一个仓储。聚合根的目的是要控制聚合的业务规则，他是一个实体，对于同一个聚合下的多个实体的交互可以放在聚合根中，如果过于复杂需要放在领域服务里，一个聚合对应一个领域服务。不同的聚合之间只能通过应用服务调用领域服务进行引用。

    **怎么找到聚合和聚合根**？

    在事件风暴之后可以找到所有的实体或者值对象，然后根据是否有独立的生命周期，是否有全局唯一ID，是否可以创建或者修改其他对象等来确定聚合根，然后根据单一职责和高内聚原则来确定聚合。同时聚合要尽可能的小。

    根据上面的步骤可以得到如图所示的聚合：

    由于审批规则没有生命周期，所以他是一个值对象，请假单是聚合根。

    最后根据业务把聚合划分到限界上下文中，确定微服务拆分。

###### 2.战术设计

命令一般都是和应用服务对应的，可以从命令->应用服务->领域服务->实体方法->实体属性自顶向下进行定义。

设计应用服务的时候需要定义出事件的大概流程，文字描述即可，比如提交审批流程：

1）根据人员类型、请假类型和请假天数，查询请假审批规则，获取下一步审批人的角色。

2）根据审批角色从人员组织关系查询下一个审批人。

3）为请假单分配审批人，请假单保存审批规则。

然后可以得到服务之间的依赖关系图：

上面的图可以梳理出来实体方法和部分值对象，然后根据业务细化实体的属性和值对象，比如请假单的时间、请假人、天数、审批状态、审批意见等，可以把聚合的依赖关系画到图中：

审批意见是实体，因为意见有自己的生命周期，并且意见可以修改。

代码目录结构：

> application（应用层，调用其他服务只能在应用服务中）
> + event（应用层和领域层都有event，建议统一放在应用层）
> > + publish
> > + subscribe
> + service
>
> + assembler（实现DTO和DO之间的相互转换）
>
> + dto（调用其他服务数据传输的载体）
>
> domain（领域层）
>
> + 聚合1
> > + entity（放聚合根、实体和值对象）
> > > + vo（值对象）
> > + event（放事件实体，实体中有简单的事件逻辑）
> > + service（领域服务）
> > + repository（仓储，一个聚合只能有一个仓储）
> > > + facade（接口）
> > > + persistence（实现类）
> > > + po（po对象）
> + 聚合2
>
> infrastructrue（基础层）
>
> + config
>
> + mapper
>
> + 自定义
>   
  interfaces（用户接口层）
>   
> + assembler（实现DTO和DO之间的相互转换）
>
> + dto（前端应用数据传输的载体）
>
> + facade（就是controller）

调用其他服务的参数和返回值如果是实体怎么处理，这个实体放在那？

验证DDD落地是否成功？
当代码能够贴合业务，还原业务流程，可以找产品来看看他能不能根据代码的英文单词的含义理解代码，和他设计的流程是否一致。
