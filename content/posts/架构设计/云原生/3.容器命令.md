---
title: 云原生-3.容器命令
date: 2023-05-22 06:27:35
tags:
  - 架构
categories: 云原生
copyright: true
---

### 一  Docker 命令

##### 1 Docker管理命令

Docker管理相关命令大部分都是针对组件增删改查，比如docker config命令

```shell
# 新增一个配置
docker config create
# 检查配置
docker config inspect
# 这是个集群管理命令，在单机上执行会提示is not a swarm manager
docker config ls
# 删除一个配置
docker config rm
```

```shell
# 管理docker配置
config
# 管理容器
container
# 管理上下文
context
# 管理镜像
image
# 管理网络
network
# 管理集群节点
node
# 管理插件
plugin
# 管理安全组件，比如密码
secret
# 管理swarm中编排的服务
service
# 管理docker部署
stack
# 管理集群
swarm
# 管理磁盘空间、系统事件等等
system
# 对一些内容的信任
trust
# 管理磁盘卷
volume
```

##### 2 镜像管理

###### 2.1 下载镜像

```shell
docker pull 镜像名:版本号

# 例子，安装最新版本的nginx
docker pull nginx:latest
# latest可以省略，也可以换成具体的版本号
```

###### 2.2 查看镜像列表

```shell
docker image ls
# 这个命令可以简写成下面的
docker images
```

###### 2.3 查看镜像详情

```shell
docker image inspect 镜像id
# 输出的东西很多，重点关注3个，ContainerConfig(容器配置)、GraphDiver(镜像的驱动信息)、RootFS(Docker的文件系统)

[{
        "Id": "sha256:448a08f1d2f94e8db6db9286fd77a3a4f3712786583720a12f1648abb8cace25",
        "RepoTags": [
            "nginx:latest"
        ],
        "RepoDigests": [
            "nginx@sha256:480868e8c8c797794257e2abd88d0f9a8809b2fe956cbfbc05dcc0bca1f7cd43"
        ],
        "Parent": "",
        "Comment": "",
        "Created": "2023-05-03T19:51:06.214253945Z",
        "Container": "a4589847511fc5545db6600740abeb1c991a29ecf9a4b1e3d9b74ae565d373a5",
        "ContainerConfig": {
            "Hostname": "a4589847511f",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            # 堆外提供服务的端口
            "ExposedPorts": {
                "80/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            # 环境变量
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "NGINX_VERSION=1.23.4",
                "NJS_VERSION=0.7.11",
                "PKG_RELEASE=1~bullseye"
            ],
            "Cmd": [
                "/bin/sh",
                "-c",
                "#(nop) ",
                "CMD [\"nginx\" \"-g\" \"daemon off;\"]"
            ],
            "Image": "sha256:3a939c4944ef49bcf282f201919718dc414fd79c7761fe46ed6cdad1ac2d6564",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": [
                "/docker-entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": {
                "maintainer": "NGINX Docker Maintainers <docker-maint@nginx.com>"
            },
            "StopSignal": "SIGQUIT"
        },
        "DockerVersion": "20.10.23",
        "Author": "",
        "Config": {
            "Hostname": "",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "ExposedPorts": {
                "80/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "NGINX_VERSION=1.23.4",
                "NJS_VERSION=0.7.11",
                "PKG_RELEASE=1~bullseye"
            ],
            "Cmd": [
                "nginx",
                "-g",
                "daemon off;"
            ],
            "Image": "sha256:3a939c4944ef49bcf282f201919718dc414fd79c7761fe46ed6cdad1ac2d6564",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": [
                "/docker-entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": {
                "maintainer": "NGINX Docker Maintainers <docker-maint@nginx.com>"
            },
            "StopSignal": "SIGQUIT"
        },
        "Architectrue": "amd64",
        "Os": "linux",
        "Size": 142145739,
        "VirtualSize": 142145739,
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/b2960f343512dccb38e75c436996f8b7f0a47117aa8dfc894f73751fcf3ff8ca/diff:/var/lib/docker/overlay2/6bd998edf03367283143c60c70f07288834e85f060116360376ffc9a97c50ea6/diff:/var/lib/docker/overlay2/b8f4d283b2079e0747991c2c494db19982a23a67330f72594de73b7c55e3f07e/diff:/var/lib/docker/overlay2/815ccce85a72931d7932e4376ea55e96368ed15e148f12ce776822a889a7755b/diff:/var/lib/docker/overlay2/829946bb9f068d5fa8421d456d7f5b450747f4a9902846b5ea83e3a6af910b0e/diff",
                "MergedDir": "/var/lib/docker/overlay2/69875c1f82c79054f8664b95fb87dba09105f8342899ccf87b248a7f63dddfaf/merged",
                "UpperDir": "/var/lib/docker/overlay2/69875c1f82c79054f8664b95fb87dba09105f8342899ccf87b248a7f63dddfaf/diff",
                "WorkDir": "/var/lib/docker/overlay2/69875c1f82c79054f8664b95fb87dba09105f8342899ccf87b248a7f63dddfaf/work"
            },
            "Name": "overlay2"
        },
        "RootFS": {
            "Type": "layers",
            "Layers": [
                "sha256:8553b91047dad45bedc292812586f1621e0a464a09a7a7c2ce6ac5f8ba2535d7",
                "sha256:a29cc9587af6488ae0cbb962ecbe023d347908cc62ca5d715af06e54ccaa9e36",
                "sha256:6bc8ae8fb3cf0909b3d9c2e74f6cabe16e6a2322c52cec76fbaecaef47006f1d",
                "sha256:5684be535bf11cb9ad1a57b51085f36d84ae8361eabc2b4c2ba9a83e8b084b20",
                "sha256:93ee76f39c974e4f819e632149c002d6f509aadc5995ec6523a96b337751c8ed",
                "sha256:1040838fe30e6f26d31bde96c514f47ee4bf727b3f1c3c7b045ea3891c1c2150"
            ]
        },
        "Metadata": {
            "LastTagTime": "0001-01-01T00:00:00Z"
        }
    }
]
```

###### 2.4 构建历史

```shell
docker image history 镜像id
```

###### 2.5 查看仓库镜像版本

到docker hub上搜索目标镜像，tags栏里有具体的信息。

###### 2.6 删除镜像

```shell
docker image rm 镜像id

# 上面的命令可以简写成下面这样
docker rmi 镜像id

# 删除所有镜像，正在运行或者被其他容器使用的删不掉
docker rmi $(docker images -q)

# 删除不在使用的镜像
docker image prune -a
```

###### 2.7 备份镜像

```shell
# -o表示输出到文件
docker save -o nginx.tar nginx:latest

# 和这个对应的是加载镜像
# -i表示从文件读取
docker image load -i nginx.tar
```

###### 2.8 导入镜像

```shell
# 这个命令可以加载本地文件，也可以加载url或者仓库的一个镜像
docker image import nginx.tar
```

###### 2.9 构建镜像

```shell
# -t是指定镜像名和镜像tag
# .的意思是DockerFile所在路径，相对和绝对路径都可以
docker build -t 镜像名/镜像tag .
```

###### 2.10 给镜像打tag

```shell
docker image tag 源镜像名:源tag 新镜像名:新tag
```

###### 2.11 推送镜像到远程仓库

```shell
docker push 镜像名:tag
```

##### 3 容器管理

###### 3.1 运行容器

```shell
# -i：交互式操作
# -t：终端
# -d：守护进程运行
# -p：设置宿主机和容器端口映射，有了这个才能在外部访问容器的进程
docker run [--name 名字] -itd -p 8080:80 nginx:latest

# 这个只能启动已经存在的容器
docker start 容器id

# 重启容器
docker restart 容器id
```

###### 3.2 创建容器

```shell
# 创建完容器是stop状态
docker create 镜像名:tag
```

###### 3.3 查看容器列表

```shell
docker container ls

# 上面可以缩写成这样
# 查看运行中的容器
# 查看所有容器是docker ps -a
docker ps
```

###### 3.4 停止容器

```shell
docker stop 容器id
```

###### 3.5 杀死容器

```shell
# 这个相当于kill -9，一般不用
docker kill 容器id
```

###### 3.6 挂起容器

```shell
# 挂起之后不会释放内存但是不会使用CPU
docker pause 容器id

# 解除挂起
docker unpause 容器id
```

###### 3.7 删除容器

```shell
# rm命令不能删除运行中容器，可以使用-f强制删除，一般不会这么勇
docker rm 容器id

# 删除没有使用的容器
# 有些容器没有运行，但是还会被其他运行的容器引用。这种是不会被删除的
docker prune
```

###### 3.8 查看容器日志

```shell
# 和tail命令差不多，-f就是常驻
# --tail=20显示最后20行
docker logs -f --tail=20 容器id
```

###### 3.9 进入容器

```shell
# -it表示交互方式
docker exec -it 容器id /bin/bash

# 退出
exit
```

###### 3.10 拷贝容器文件

```shell
# 把容器文件拷贝到宿主机
# 如果反过来写就是把宿主机文件拷贝到容器
docker cp 容器id:文件位置 目标位置
```

###### 3.11 重命名

```shell
docker rename 容器id 新name
```

###### 3.12 查看容器文件系统变化

```shell
docker diff 容器id

# 结果中C是修改，A是新增，D是删除
# C /var/cache/nginx
# A /var/cache/nginx/client_temp
```

###### 3.13 查看容器信息

```shell
# 查看容器占用的CPU、内存、网络等
docker stats 容器id

# 查看容器在宿主机的进程号
docker top 容器id

# 查看容器信息，和镜像一样的
docker inspect 容器id
```

##### 4 仓库管理命令

###### 4.1 登录docker hub

```shell
docker login
# 然后根据提示输入用户名密码就可以了

# 登出
docker logout
```

###### 4.2 搜索镜像

```shell
docker search 镜像名
```

###### 4.3 下载镜像

```shell
docker pull 镜像名:tag
```

###### 4.4 推送镜像

```shell
docker push 账号/镜像:tag
```

##### 5 网络命令



##### 6 存储命令

docker的数据持久化有3种方式：

###### 6.1 volumes

固定的文件路径，由docker管理，也可以指定volumes在宿主机上的路径。如果不指定docker会默认创建在宿主机上的/var/lib/docker/lolumes/容器id 目录里，这样有个不好的地方就是根据一个镜像启动的多个容器文件不共享，所以一般要给volume创建一个别名，在启动容器时指定volume的别名：

```shell
# 创建一个叫test_volume的volume
docker volume create test_volume

# 启动容器，把/usr/share/nginx/html目录挂载到刚刚创建的volume上
# -v和--volume是等效的
docker run -itd --name nginx_1 -p 8080:80 -v ruyuan_volume:/usr/share/nginx/html 镜像名:tag
```

使用-v时，如果宿主机目录不存在会自动创建。

volume的管理命令：

```shell
# 查看test_volume详情
docker inspect test_volume
# 查看volume列表
docker volume ls

# 删除volume相关
docker volume prune
docker volume rm
```

###### 6.2 bind mount

挂载到宿主机的其他目录使用方式也是-v或者--volume：

```shell
# /data/nginx/是宿主机中的路径，必须是绝对路径
# /usr/share/nginx/html表示容器中被挂载的路径
docker run -itd --name 容器别名 -v /data/nginx/:/usr/share/nginx/html 镜像名:tag
```

另一种挂载的方式是使用--mount：

```shell
# source表示宿主机中路径
# destination表示容器中被挂载的路径
docker run -itd --name 容器别名 --mount type=bind,source=/data/nginx,destination=/usr/share/nginx 镜像名:tag
```

*使用--mount时不指定type是使用volume方式存储*，当source路径不存在时会报错。

###### 6.3 tmpfs mounts

存放到宿主机内存中。

```shell
# /usr/share/nginx/html表示容器中被挂载的目录
docker run -itd --name 容器别名 --tmpfs /usr/share/nginx/html 镜像名:tag
```

这种方式因为读写是在内存，所以速度特别快。

### 二 Docker File

docker file是用来构建镜像的文件，使用`docker build`命令将docker file文件构建成镜像：

```shell
# .表示上下文路径，构建时会把这个路径里的文件打包给docker容器，所以这个里面不要有多余的文件
docker build -t 镜像名:tag --file file文件路径 .
```

##### 1 docker file 命令：

```dockerfile
# 必须以FROM开头
# FROM定义了这个镜像的构建是基于哪个基础镜像
# FROM命令可以多次使用
FROM nginx
# 指定镜像的作者
MAINTAINER xiaohong
# 执行shell或者exec的命令
# RUN可以有多个，但是每次执行RUN都会让镜像多加一层，可以使用&&拼接命令，这样只会打包一层
RUN echo ' nginx ' > /usr/share/nginx/html/index.html ADD Dockfile ContainerDockfile
# 和RUN一样，不过RUN是在build的时候运行，CMD在docker run命令执行时运行
# CMD只会执行一次，最后面的CMD会把前面的覆盖
CMD
# 类似CMD，可以接收启动镜像时的参数作为输入，也只能存在一个ENTRYPOINT命令
ENTRYPOINT
# 指定RUN、CMD、ENTRYPOINT的工作目录
WORKDIR
# 复制文件到镜像中
# source表示宿主机中的文件路径，destination是容器中的路径
ADD source destination
# 和ADD类似，ADD不能复制tar这种压缩文件，但是他自己会先解压，不过也会影响速度，推荐使用COPY
COPY
# 指定容器运行时监听的端口
EXPOSE 8080
# 定义环境变量，后续的指令都可以使用这个变量
ENV <key1>=<value1> <key2>=<value2>...
# 设置挂载的宿主机路径
VOLUME /usr/share/docker
# 指定执行后续命令的用户和用户组
USER 用户名[:用户组]
```

##### 2 查看镜像的构建记录：

```shell
docker history ae893c58d83f --no-trunc
```

##### 3 file例子

```dockerfile
FROM openjdk:8
COPY ./src /home/xiaohong/src 
WORKDIR /home/xiaohong/src 
RUN cd /home/xiaohong/src 
RUN ls
RUN javac Main.java
```

构建并上传：

```shell
docker build -t my-java-app .

# 先登录到远程仓库
docker login

# 打tag
docker tag my-java-app v1.0.0
# 推送到远程仓库
docker image push my-java-app:v1.0.0
```

### 三 Docker Compose

docker compose是用来定义和运行多容器的工具，可以在yml中配置所有需要的命令，然后执行一个命令运行所有容器。

##### 1 常用yml指令

1.   version：指定compose版本，比如1.2.x、3.x，目前主流的是3.x，他支持docker1.13及以上版本。
2.   services：定义所有的service信息，service下面的第一级的key就是service的名称。
3.   build：指定docker file所在的文件夹路径或者指定具体的docker file。
4.   image：指定服务使用的镜像。
5.   ports：定义宿主机和容器端口的映射。
6.   expose：指定容器用到的端口，并不对外暴露，而ports映射之后可以在外面访问。
7.   volumes：把宿主机的目录挂载到容器里，可以自定义volume的名称，也可以直接使用路径。
8.   depends_on：设置依赖关系，使用`docker-compose up`启动时会先启动依赖的服务。
9.   restart：默认no，可以设置成always，这样docker重启时容器也会重启。
10.   networks：指定容器的网络。
11.   environment：添加环境变量，需要注意boolean值要用单引号括起来，要不会被yml解析器解析成True或者False。
12.   command：替换容器启动的默认命令。
13.   container_name：指定容器名。
14.   healthcheck：检测docker服务是否在健康运行。
15.   extends：继承某个compose文件。

##### 2 docker-compose命令

使用docker-compose命令时不指定yml文件会在当前目录里查找docker-compose.yml文件。

###### 2.1 容器声明周期

```shell
# 创建或启动容器
# -d表示后台运行
docker-compose -f docker-compose文件路径 up -d

# 停止并删除容器
docker-compose -f docker-compose文件路径 down

# 停止容器
docker-compose -f docker-compose文件路径 stop
```

###### 2.2 查看进程信息

```shell
# 打印docker-compose文件中所有服务的进程信息
docker-compose -f docker-compose文件路径 top
```

###### 2.3 查看容器日志

```shell
# -f表示追加打印
docker-compose -f docker-compose文件路径 logs -f
```

##### 3 个人开发环境docker-compose.yml

```yaml
version: '3.9'

```

