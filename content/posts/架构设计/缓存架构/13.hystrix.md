Hystrix最主要的功能就是资源隔离，有两种实现方式：

1.  线程池的资源隔离：被隔离的资源被访问时，需要先经过tomcat等网络容器的线程池，如果访问资源的线程超过规定的数量会先进缓冲队列，队列满了之后就会走fallback降级处理，但是hystrix控制不了tomcat的线程，只是控制线程的执行，默认是10个；一个command group对应一个线程池；
2.  信号量的资源隔离：只是判断访问资源的线程数，接受请求和访问资源的请求是一个线程，通过计数实现的隔离，同一个服务内务需要隔离的时候信号量更合适；

这两个隔离技术的区别的是线程池使用自己的线程访问资源，所以信号量隔离技术无法做超时判断。除了资源隔离还有限流的作用。

一个command就是对一个服务的一个接口的请求，所以一般来说一个command对应一个接口，一个command group对应一个服务；

```java
// 使用线程池隔离技术
super(HystrixCommandGroupKey.Factory.asKey("GetProductInfoGroup"));
// 使用信号量隔离技术
super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("ExampleGroup"))
        .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
               .withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE)));
// 设置command名称：GetProductInfoCommand；
// 线程池名称：GetProductInfoPool；
// 线程池大小：15、缓冲队列大小：10；
super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("ProductInfoService"))
      .andCommandKey(HystrixCommandKey.Factory.asKey("GetProductInfoCommand"))
      .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey("GetProductInfoPool"))
      .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
                                       .withCoreSize(15)
                                       .withQueueSizeRejectionThreshold(10))
     );
// 设置超时时间是500ms
.andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
						.withExecutionTimeoutInMilliseconds(500))
```

还可以设置filter、request cache，command报错的fallback降级等等；

### 短路器 熔断

当经过短路器的流量达到阈值（默认是10s内超过20个请求）之后，使用下面代码配置：

```java
HystrixCommandProperties.circuitBreakerRequestVolumeThreshold(20)
```

短路器会统计异常访问（比如timeout、异常、reject）量占比（默认是50%），使用下面代码配置：

```java
HystrixCommandProperties.circuitBreakerErrorThresholdPercentage(50)
```

如果超过了设置的占比，短路器会由关闭编程开启状态，这个时候所有的请求都会被降级拒绝，经过一段时间之后（默认5s）,使用下面代码配置：

```java
HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds(5000)
```

短路器会编程半开启状态，让一条请求经过短路器，如果正常调用就自动恢复到关闭状态。

### 限流

限流一定要设置两个队列的大小：withQueueSizeRejectionThreshold和withMaxQueueSize，他俩谁的数小取谁的，withMaxQueueSize默认是-1，当大于0时会创建一个linkedBlockingQueue，设置withQueueSizeRejectionThreshold是为了动态控制流量。

### 请求合并

合并级别：

*   global context：tomcat所有调用线程对一个服务的任何一个command都可以合并在一起；
*   user request context：tomcat内的某一个调用线程，将某一个tomcat的调用线程对一个依赖服务的多个command调用合并到一起；
*   object modeling：基于对象的请求合并；

请求合并可以减少网络开销和提高吞吐量，但是会增加请求耗时，比如十个线程1s可以执行10次网络请求，请求合并之后相当于1个线程1s可以执行10个请求，10个线程1s就可以执行100次请求，100次请求只走了10次网络，但是每个请求响应的时间会变长，因为合并需要花费时间。

```java
super(Setter.withCollapserKey(HystrixCollapserKey.Factory.asKey("GetProductInfosCollapser"))
	.andCollapserPropertiesDefaults(HystrixCollapserProperties.Setter()
        // Batch中最多允许多少个request被合并
		.withMaxRequestsInBatch(100)
        // 控制一个batch创建之后，多长时间以后就自动触发batch的执行，默认10ms
        .withTimerDelayInMilliseconds(20))); 
```

### 容错模式

fail-fast：就是不给fallback降级逻辑，HystrixCommand.run()，直接报错，直接会把这个报错抛出来；

fail-silent：给一个fallback降级逻辑；

### 降级策略

第一级降级：command内嵌套command，最外层的command失败后执行内层command访问备用服务器，降级的command不能和外层的command使用一个线程池，因为很有可能走降级是因为线程池满了；

第二级降级：stubbed fallback降级，返回拼装的残缺数据；

### 线程池设置

公式：高峰访问次数 * TP99时间（s） + buffer，但是最多不要超过20；

超时时间设置满足TP95，防止新请求过来时没有线程空闲导致所有请求都被拒绝；

```java
// 线程池动态扩容缩容
.andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
    .withCoreSize(15)
    // 设置线程池最大大小
	.withMaximumSize(30)
    // 允许自动扩容
    .allowMaximumSizeToDivergeFromCoreSize(true)
    // 线程空闲1分钟就被销毁
    .withKeepAliveTimeMinutes(1)
```

使用hystrix-dashboard监控