### 低命中率问题

在nginx集群中，每个请求如果均匀被打到nginx集群中，同一条数据就会被多次加载到不同的nginx中，多次访问后台，并且nginx存储了很多的重复数据，低命中率的问题解决方案就是双层nginx架构，第一层是分发层，负责请求分发，用数据的某一个字段hash取模之类的，使同一条数据的请求打到同一台nginx；第二层叫应用层，是真正缓存数据的服务器。分发或者缓存的逻辑使用lua实现，nginx+lua的方案使用的是openresty，它里面还有redis、mysql什么的客户端等等。

### OpenResty部署

新建文件夹：

```shell
mkdir -p /usr/servers
cd /usr/servers/
```

安装readline库、编译器之类的东西：

```shell
yum install -y readline-devel pcre-devel openssl-devel gcc
```

下载openresty并解压：

```shell
wget https://openresty.org/download/openresty-1.13.6.2.tar.gz
tar -zxvf openresty-1.13.6.2.tar.gz
```

进入openresty-1.13.6.2/bundle/LuaJIT-2.1-20180420/下安装luajit

```shell
make clean && make && make install
# 安装完之后会提示我们建立软连接，复制执行一下
ln -sf luajit-2.1.0-beta3 /usr/local/bin/luajit
```

回到bundle目录安装一些模块

```shell
cd ../
# 第三方缓存模块
wget https://github.com/FRiCKLE/ngx_cache_purge/archive/2.3.tar.gz
tar -xvf 2.3.tar.gz
# 节点监测模块，监测某个节点负载或者运行情况
wget https://github.com/yaoweibin/nginx_upstream_check_module/archive/v0.3.0.tar.gz
tar -xvf v0.3.0.tar.gz
```

回到openresty主目录configure然后安装

```shell
cd ../

./configure --prefix=/usr/servers --with-http_realip_module  --with-pcre  --with-luajit --add-module=./bundle/ngx_cache_purge-2.3/ --add-module=./bundle/nginx_upstream_check_module-0.3.0/ -j2

make && make install
```

安装完了在/usr/servers/目录下会多出很多东西，就包括nginx，和正常安装的nginx是一样的，在nginx的sbin目录下执行./nginx -v查看下版本，./nginx启动。

### nginx+lua安装

目录结构：

```
nginx项目目录（文件夹）
	nginx配置文件
	lua（文件夹）
		lua脚本文件
	lualib（文件夹）
		*.lua
		*.so
```

在usr目录下创建目录hello_nginx，创建hello.conf文件：

```shell
server {
    listen       80;
    server_name  _;
    location /hello_nginx {
        default_type 'text/html';
        content_by_lua_file /usr/hello_nginx/lua/hello.lua;
    }
}
```

创建lua文件夹，cd进去创建hello.lua

```lua
ngx.say("hello world:nginx01");
```

修改nginx.conf文件，在http部分添加：

```shell
lua_package_path "/usr/hello_nginx/lualib/?.lua;;";
lua_package_cpath "/usr/hello_nginx/lualib/?.so;;";
include    /usr/hello_nginx/hello.conf;
```

把/use/servers下的lualib复制到/usr/hello_nginx中：

```shell
cp -r /usr/servers/lualib/ /usr/hello_nginx/
```

验证语法有没有错误：

```shell
/usr/servers/nginx/sbin/nginx -t
# 提示syntax is ok
```

重启nginx，在浏览器访问192.168.0.3/hello_nginx，浏览器显示hello world:nginx01说明成功。

***

使用01、02虚拟机当做应用层，03当做分发层，在03上修改：

```shell
cd /usr/hello_nginx/lualib/resty
# 安装http相关模块
wget https://raw.githubusercontent.com/pintsized/lua-resty-http/master/lib/resty/http_headers.lua
wget https://raw.githubusercontent.com/pintsized/lua-resty-http/master/lib/resty/http.lua
```

修改lua下的hello.lua

```lua
-- 获取uri的参数
local uri_args = ngx.req.get_uri_args()
local productId = uri_args["productId"]
-- 定义应用层ip
local host = {"192.168.0.3","192.168.0.5"}
-- 唯一标识计算hash值并取余，判断分发到那台虚拟机
local hash = ngx.crc32_long(productId)
local index = (hash % 2) + 1
-- 拼接url
backend = "http://"..host[index]

local requestpath = uri_args["requestpath"]
requestpath = "/"..requestpath.."?productId="..productId
-- 创建http客户端
local http = require("resty.http")  
local httpc = http.new()  
-- 发送请求获取结果
local resp, err = httpc:request_uri(backend, {  
    method = "GET",  
    path = requestpath
})

if not resp then  
    ngx.say("request error :", err)  
    return  
end
-- 返回结果
ngx.say(resp.body)  

httpc:close()
```

重启03的nginx，在服务器输入*http://192.168.0.6/hello_nginx?requestpath=hello_nginx&productId=1*，可以看到被分发到了02的虚拟机上。

***

***

在01、02虚拟机上安装html渲染模块：

```shell
cd /usr/hello_nginx/lualib/resty/
wget https://raw.githubusercontent.com/bungle/lua-resty-template/master/lib/resty/template.lua
mkdir /usr/hello_nginx/lualib/resty/html
cd /usr/hello_nginx/lualib/resty/html
wget https://raw.githubusercontent.com/bungle/lua-resty-template/master/lib/resty/template/html.lua
# 创建模板文件夹
mkdir /usr/hello_nginx/templates
# 在hello.conf中server下配置模板的位置
set $template_location "/templates";
set $template_root "/usr/hello_nginx/templates";
# nginx.conf配置缓存数据的名称和大小
lua_shared_dict my_cache 32m;
```

在templates文件夹下创建product.html模板：

```html
product id: {* productId *}<br/>
product name: {* productName *}<br/>
product pictrue list: {* productPictrueList *}<br/>
product specification: {* productSpecification *}<br/>
product service: {* productService *}<br/>
product color: {* productColor *}<br/>
product size: {* productSize *}<br/>
shop id: {* shopId *}<br/>
shop name: {* shopName *}<br/>
shop level: {* shopLevel *}<br/>
shop good cooment rate: {* shopGoodCommentRate *}<br/>
```

hello.conf中添加一个location

```shell
location /product {
    default_type 'text/html';
    content_by_lua_file /usr/hello_nginx/lua/product.lua;
}
```

在lua文件夹下创建product.lua

```lua
local uri_args = ngx.req.get_uri_args()
local productId = uri_args["productId"]
local shopId = uri_args["shopId"]

local cache_ngx = ngx.shared.my_cache

local productCacheKey = "product_info_"..productId
local shopCacheKey = "shop_info_"..shopId

local productCache = cache_ngx:get(productCacheKey)
local shopCache = cache_ngx:get(shopCacheKey)

if productCache == "" or productCache == nil then
	local http = require("resty.http")
	local httpc = http.new()

	local resp, err = httpc:request_uri("http://192.168.0.175:8082",{
  		method = "GET",
  		path = "/cache/getProductInfo?productId="..productId
	})

	productCache = resp.body
	cache_ngx:set(productCacheKey, productCache, 10 * 60)
end

if shopCache == "" or shopCache == nil then
	local http = require("resty.http")
	local httpc = http.new()

	local resp, err = httpc:request_uri("http://192.168.0.175:8082",{
  		method = "GET",
  		path = "/cache/getShopInfo?shopId="..shopId
	})

	shopCache = resp.body
	cache_ngx:set(shopCacheKey, shopCache, 10 * 60)
end

local cjson = require("cjson")
local productCacheJSON = cjson.decode(productCache)
local shopCacheJSON = cjson.decode(shopCache)

local context = {
	productId = productCacheJSON.id,
	productName = productCacheJSON.name,
	productPrice = productCacheJSON.price,
	productPictrueList = productCacheJSON.pictrueList,
	productSpecification = productCacheJSON.specification,
	productService = productCacheJSON.service,
	productColor = productCacheJSON.color,
	productSize = productCacheJSON.size,
	shopId = shopCacheJSON.id,
	shopName = shopCacheJSON.name,
	shopLevel = shopCacheJSON.level,
	shopGoodCommentRate = shopCacheJSON.goodCommentRate
}

local template = require("resty.template")
template.render("product.html", context)
```

