#### 数据库+缓存的读写模式（cache aside pattern）：

* 读的时候先去差redis，如果没有再去查数据库，将结果写到redis；
* 修改的时候先删除缓存，在更新数据库，不更新redis是为了比如更新100次才被读一次，不用缓存的时候没有必要频繁的计算，类似懒加载；

28法则：最重要的东西永远占用大约20%的部分，20%的数据是被频繁读取，所以80%的数据没有必要再更新数据库的时候更新缓存。

#### 数据库加缓存双写不一致问题

在高并发的情况下，如果一个请求在删除缓存之后修改数据库时，另一个请求来获取数据，此时缓存中没有就去读取数据库，数据库中的数据是还没修改完，比如事物是读已提交，那么此时读取到的就是旧数据，读取完放到缓存里的还是旧数据，这时候就会出现双写不一致问题，解决办法：创建多个队列并绑定线程消费，同一条数据路由到同一台服务下的同一个队列，实现同一条数据的操作异步串行。

##### 双写优化点：

同一条数据，当redis中没有的时候要去数据库中读取，这条请求会被放到队列等待消费，如果读请求很多的时候，队列中就会堆积大量的读操作，然后这些读操作在读取完数据库又会重新写入缓存，这些重复的操作即费资源又没必要，所以当redis中没有数据的时候要判断队列中是否已经有针对这条数据的毒操作，如果有的话就把这个请求hang一会，比如while(true)循环，在循环中判断循环的时间，然后再去读取redis，如果太长时间还是没有读到数据就自己去服务器中读；这样就会产生一个问题，如果读请求特别多，比如10000个读请求hang了200ms还没有在redis中读取到数据，这10000个请求会直接打到数据库上，就产生雪崩了，这种问题只能加服务器，加完服务器之后队列中的更新请求和读请求就少了，读的就快了。