---
title: 最终一致性框架
tags:
  - 自研框架
categories: 框架
copyright: true
---

##### RocketMQ事务消息缺点

首先使用RocketMQ的事务消息会增加额外的代码，比如提交half失败，要实现mq定时回查的接口，最关键的是如果mq短时间故障，在业务开始之前创建half消息失败的时候就要返回系统异常，但是业务明明没问题，不应该让mq拖垮业务。

因为mq问题导致数据库或者分布式事务全部回滚的强一致方案是没有容错性的，可以使用本地消息表代替事务消息，将发送失败的消息暂存，定时重试。

##### 框架的功能

有了软事务的框架后只要是非核心的动作(比如写redis、写MySQL、第三方接口调用等等)，如果不想让他们的失败拖垮核心链路都可以用本地消息表的方案解决，异常的非核心action操作一直重试就可以了。

但是一些操作比如调三方可能需要延迟或者降级的操作，比如发送短信一个三方发送失败就去调另一个三方执行降级逻辑，所以框架还要有延迟、降级功能。

如果重试到了最大次数还是失败怎么办？此时可能需要一个报警通知的功能。

整体流程如下：
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h116soskhoj20u01p0n24.jpg" style="zoom:100%;" />

##### 数据库结构：

```sql
CREATE TABLE `orderorigin_tend_consistency_task` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键自增',
  `task_id` varchar(300) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户自定义的任务名称，如果没有则使用方法签名',
  `task_status` tinyint NOT NULL DEFAULT '0' COMMENT '执行状态',
  `execute_times` int NOT NULL COMMENT '执行次数',
  `execute_time` bigint NOT NULL COMMENT '预计执行时间',
  `parameter_types` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '参数的类路径名',
  `method_name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '方法名',
  `method_sign_name` varchar(300) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '方法签名',
  `execute_interval_sec` int NOT NULL DEFAULT '60' COMMENT '执行间隔',
  `delay_time_sec` int NOT NULL DEFAULT '60' COMMENT '延迟时间',
  `task_parameter` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '方法参数',
  `performance_way` tinyint NOT NULL COMMENT '执行模式：1、立即执行 2、调度执行',
  `thread_way` tinyint NOT NULL COMMENT '线程模型 1、异步 2、同步',
  `ensure_idem` bit NOT NULL COMMENT '幂等性保证',
  `error_msg` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '执行的error信息',
  `alert_expression` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '告警表达式',
  `alert_action_bean_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '告警逻辑的的执行beanName',
  `fallback_class_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '降级逻辑的的类路径',
  `fallback_error_msg` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '降级失败时的错误信息',
  `created_time` datetime NOT NULL COMMENT '创建时间',
  `modified_time` datetime NOT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`),
  INDEX `nk_status_execute_time_key` (`task_status`,`execute_time`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
```

##### 执行任务逻辑

任务状态：0 初始化；1 执行失败；2 执行中；3 执行成功；

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1lyncovhvj20u01emadt.jpg)

流程中可能出现问题的地方：

*   初始化任务失败：这步会导致任务无法执行，并且没有重试、降级、报警操作，所以这步失败必须要把任务持久化到磁盘。
*   执行中次改任务状态为执行中失败，这里可以直接返回，下次扫描任务时还会拿到任务继续执行。
*   任务执行失败修改状态为fail失败，这里把改为fail状态失败的任务也写入磁盘。
*   任务执行成功但是修改状态为success失败，任务落盘。

不管任务执行成功还是失败，但是修改任务状态都是失败的，此时任务的状态还是2，当每个服务有多台实例时，定时扫描待执行的任务是并行的，所以多个服务可能会拿到一批相同的任务，所以没法根据本地磁盘中的修改状态失败的任务过滤，只能在扫描任务时过滤掉所有状态是2的任务，等到后台的线程把磁盘中的失败任务状态改成1或者3时才可以。

使用分布式锁控+任务状态制任务不被重复执行，如果是框架自带leader选举，进行任务分片的话这里是不需要分布式锁的。
