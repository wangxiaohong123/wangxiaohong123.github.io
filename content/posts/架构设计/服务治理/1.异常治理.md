---
title: 服务治理-1.异常治理
tags:
  - 异常治理
categories: 服务治理
copyright: true
---

治理就是说捕获和上抛异常、处理异常、封装和定义异常(规范化异常)。线上的而系统出现异常一般都是堆外提供的接口处，大概有4个地方：http接口：对应前端的一个功能。rpc接口：给其他系统调用的一个功能。mq消费。调度线程。

##### 错误码规范

code总长度为6位：

1.   前两位是微服务或者通用异常，比如客户端异常异常(缺少参数、请求类型错误)10，探索服务是11，动态服务是12。
2.   中间两位是每个服务对应的模块或者域。
3.   后两位递增表示具体异常。

通常来说每个系统要有自己的异常类，这样看日志就知道出现问题的系统是哪个。

##### 统一异常拦截

异常都会在出口处理，把异常封装成统一的实体返回，mq消费和调度线程可以包在try catch中，但是htto和rpc的接口太多，需要统一处理。

###### controller层

controller层的同一异常只需要在处理类上添加`@RestControllerAdvice`注解，然后定义多个方法处理不同异常，每个方法上添加`@ExceptionHandler(value=异常类)`就可以了：

```java
@Slf4j
@RestControllerAdvice
@Order
public class GlobalExceptionHandler {

    // =========== 系统级别未知异常 =========

    @ExceptionHandler(value = Exception.class)
    public JsonResponse<Object> handle(Exception e) {
        log.error("[ 系统未知错误 ]", e);
        return JsonResponse.createByError(SYSTEM_DEFAULT_ERROR);
    }

    // =========== 客户端异常 =========

    /**
     * 1001 HTTP请求方法类型错误
     */
    @ExceptionHandler(value = HttpRequestMethodNotSupportedException.class)
    public JsonResponse<Object> handle(HttpServletRequest request, HttpRequestMethodNotSupportedException e) {
        log.error("[客户端HTTP请求方法错误]uri->{}", request.getRequestURI(), e);
        return JsonResponse.createByError(CLIENT_HTTP_METHOD_ERROR);
    }
    
…………
    
    /**
     * 系统自定义业务异常
     */
    @ExceptionHandler(value = BaseBizException.class)
    public JsonResponse<Object> handle(BaseBizException e) {
        log.error("[业务异常:{},{}]", e.getErrorCode(), e.getErrorMsg());
        return JsonResponse.createByError(e.getErrorCode(), e.getErrorMsg(), e.getData());
    }
}
```

###### rpc层

rpc通过dubbo的SPI扩展机制自定义过滤器实现，创建两个过滤器，第一个过滤器负责处理自定义异常，不让dubbo封装成RuntimeException，第二个过滤器负责把自定义异常封装成JsonRponse。

DubboExceptionFilter：

```java
@Slf4j
@Activate(group = CommonConstants.PROVIDER)
public class DubboExceptionFilter implements Filter, Filter.Listener {

    @Override
    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
        return invoker.invoke(invocation);
    }

    /**
     * 这里主要把能直接返回的都返回了，要不然dubbo会把异常包装成RunTimeException返回给客户端
     */
    @Override
    public void onResponse(Result appResponse, Invoker<?> invoker, Invocation invocation) {
        if (appResponse.hasException() && GenericService.class != invoker.getInterface()) {
            try {
                Throwable exception = appResponse.getException();

                // 如果不是运行时异常直接返回
                if (!(exception instanceof RuntimeException) && (exception instanceof Exception)) {
                    return;
                }

                // 如果异常是consumer方法签名抛出类型也直接返回
                try {
                    Method method = invoker.getInterface().getMethod(invocation.getMethodName(),
                            invocation.getParameterTypes());
                    Class<?>[] exceptionClasses = method.getExceptionTypes();
                    for (Class<?> exceptionClass : exceptionClasses) {
                        if (exception.getClass().equals(exceptionClass)) {
                            return;
                        }
                    }
                } catch (NoSuchMethodException e) {
                    return;
                }

                log.error("Got unchecked and undeclared exception which called by {}.service:{},method:{},exception:" +
                                RpcContext.getContext().getRemoteHost(), invoker.getInterface().getName(),
                        invocation.getMethodName(), exception);

                // java异常直接返回
                String className = exception.getClass().getName();
                if (className.startsWith("java.") || className.startsWith("javax.")) {
                    return;
                }

                // 自定义异常直接返回
                if(exception instanceof BaseBizException) {
                    return;
                }

                // dubbo异常直接返回
                if (exception instanceof RpcException) {
                    return;
                }

                // 异常和服务提供方在同一个jar下直接返回
                String serviceFile = ReflectUtils.getCodeBase(invoker.getInterface());
                String exceptionFile = ReflectUtils.getCodeBase(exception.getClass());
                if (serviceFile == null || exceptionFile == null || serviceFile.equals(exceptionFile)) {
                    return;
                }

                // 包装成runtime exception返回
                appResponse.setException(new RuntimeException(StringUtils.toString(exception)));
            } catch (Throwable e) {
                log.warn("Fail to ExceptionFilter when called by {}.service:{},method:{},exception:",
                        RpcContext.getContext().getRemoteHost(), invoker.getInterface().getName(),
                        invocation.getMethodName(), e);
            }
        }
    }

    @Override
    public void onError(Throwable e, Invoker<?> invoker, Invocation invocation) {
        log.error("Got unchecked and undeclared exception which called by {}.service:{},method:{},exception:",
                RpcContext.getContext().getRemoteHost(), invoker.getInterface().getName(), invocation.getMethodName(), e);
    }
}
```

CustomerExceptionFilter：

```java
@Activate(group = CommonConstants.PROVIDER)
public class CustomerExceptionFilter implements Filter {

    @Override
    public Result invoke(Invoker<?> invoker, Invocation invocation) {

        Result result = null;
        String methodName = invocation.getMethodName();
        String className = invoker.getInterface().getName();
        Object[] args = invocation.getArguments();
        // 请求的方法参数名称
        StringBuilder params = new StringBuilder();
        if (null != args) {
            for (Object arg : args) {
                params.append("  ").append(arg);
            }
        }
        try {
            log.info("进入:[{}.{}]方法,参数:{}", className, methodName, params.toString());
            StopWatch stopWatch = new StopWatch();
            stopWatch.start();

            result = invoker.invoke(invocation);

            stopWatch.stop();
            // 执行时长(毫秒)
            long time = stopWatch.getTotalTimeMillis();
            Object resultValue = result.getValue();
            log.info("结束:[{}.{}]方法调用,时间:{},出参:{}", className, methodName, time,
                    resultValue == null ? null : resultValue.toString());

            if (result.hasException() && GenericService.class != invoker.getInterface()) {
                Throwable exception = result.getException();

                log.error("Error:{},service:{},method:{},exception:", RpcContext.getContext().getRemoteHost(),
                        className, methodName, exception);

                JsonResponse<?> jsonResponse;
                if (exception instanceof BaseBizException) {
                    BaseBizException bizException = (BaseBizException) exception;
                    jsonResponse = JsonResponse.createByError(bizException.getErrorCode(),
                            bizException.getErrorMsg());
                } else {
                    jsonResponse = JsonResponse.createByError(exception.getMessage());
                }
                result.setValue(jsonResponse);
                result.setException(null);
                return result;
            }
        } catch(RuntimeException e){
            log.error("Error:{},service:{},method:{},exception:", RpcContext.getContext().getRemoteHost(),
                    className, methodName, e);
        }
        return result;
    }
}
```

@Activate(group = CommonConstants.PROVIDER)表示过滤器在服务提供方还是消费方生效，然后在resources目录下新建META-INF/dubbo文件夹，在该文件夹下创建org.apache.dubbo.rpc.Filter文件，添加如下内容：

```properties
exception=com.orderorigin.stars.common.dubbo.DubboExceptionFilter
customerExceptionFilter=com.orderorigin.stars.common.dubbo.CustomerExceptionFilter
```

最后在服务配置文件中添加配置：

```yaml
dubbo:
  provider:
    filter: customerExceptionFilter
```

