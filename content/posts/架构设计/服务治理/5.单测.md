---
title: 服务治理-4.单测
tags:
  - 单测
categories: 服务治理
copyright: true
---

##### 合格的单元测试

一个优秀的单元测试应该满足5个条件：

*   可验证：当单侧代码运行完就可以验证业务代码是否有问题，而不是通过肉眼去看log，即使用assert来判断结果。
*   可重复：当单测写好后是可以不分环境不分时间的运行的，比如依赖MySQL，想MySQL中插入数据区测试，如果数据被删或者在测试环境都没有这个数据了，这个单测没法进行，就是说要避免对基础环境(redis、es、MySQL、mq等)和外部接口(rpc接口)的依赖。执行完单测后应该恢复现场， 把之前准备的数据和单测过程中产生的数据全部释放或者删掉。
*   独立性：单测方法之间独立，单测的方法不能依赖其他单测方法的结果。并且每个单测方法只测试一种情况。
*   彻底的：核心逻辑的所有分支都要覆盖，整体覆盖率不低于70%。
*   专业的：测试代码也要有可维护性，因为业务变更频繁，所以单测也会频繁修改和扩展，所以要保证单测的类的职责单一，方法命名清晰，降低方法的复杂度，保证可扩展性。

##### PowerMock框架使用

常见的框架一般就是Mockito 2.x：官网(https://mockito.org)及(https://github.com/mockito/mockito )和PowerMock 2.x：官网(https://github.com/powermock/powermock)。PowerMock 2.x扩展了了EasyMock和Mockito。Mockito基于Cglib模拟public访问权限类型的方法，PowerMock基于javassist和objenesis来修改类的字节码 + ⾃定义类加载器模拟public、private、static、final等访问权限修饰的⽅法。

使用PowerMock之前需要初始化：

```java
@Before
public void init() {
    MockitoAnnotations.initMocks(this);
}
```

然后使用@MockBean标注需要被mock的bean，这个注解会将⼀个spring bean的所有⽅法变成⼀个空⽅法，然后配合**PowerMockito.when().thenReturn()**或者**PowerMockito.doNothing().when()**来mock数据。

有一个和@MockBean类似的注解是@SpyBean，他的意思是说spring bean保持原样，只有调用了比如PowerMockito.doReturn().when()这种代码后这个方法才会被mock。当我们不想所有方法都mock的时候可以使用这个注解。

@Rule注解是配合JUnit4使用的，他用来断言抛出的异常是否是期望的异常，JUnit5使用过**Assert.assertThrows()**来验证异常。

>   这么写单测需要花费大量的时间，特别是造数据和清理数据。很有可能单测的代码要比业务逻辑的代码要多。所以一些外部系统，比如redis、es可以使用测试环境，这样会大幅度降低造数据和清理数据消耗的时间。

