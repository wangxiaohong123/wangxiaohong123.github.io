---
title: 链路追踪-1.原理
tags:
  - 链路追踪
categories: 服务治理
copyright: true
---

##### APM(Application Performance Monitor)

应用性能监控系统，他要监控到每个请求链路调用了那些环节，那些节点，每个节点的耗时，是否有异常，整个请求链路的TPS、性能延迟，出了问题能够快速便捷的看到某一次请求的日志。

##### SkyWalking模块

-   探针：在要监控的节点上通过注解的方式加上探针，这种无侵入的加探针的方式叫做插桩。
-   OAP平台：observability analysis platform，观察分析平台，需要独立部署。他会接收探针上报数据的请求。
-   存储模块：支持多种存储，es、mysql、hbase等等。
-   UI模块：统计数据查询和展现。

##### 增强原理

主要是依靠java agent技术实现class字节码增强，当jvm加载class的时候会触发ClassFileLoadHool事件，然后遍历所有的instrumentation并执行里面的ClassFileTransformer的transform()方法，instrumentation就相当于类信息，transform()方法的入参有ClassLoader、ClassName、byte[]等等类信息，在SkyWalking的java agent中，就是在他的premain()方法中把所有的ClassFileTransformer添加到instrumentation里。

##### 链路追踪模型

在sky walking中一次方法的调用成为span，span中有spanId和parent spanId，第一个span的parent id是null，第一个parent id为null的span会开启一个trace id，一个trace id对应一条链路。span有3中类型，entry、local、exit。

1.   entry是一般是http server收到的请求。
2.   local是相同进程内的方法的调用。
3.   exit表示trace segment出来，比如发起rpc请求或者调用数据库。

sky walking的trace segment是进程内所有span的集合，上报时会以segment为单位组装上报，提升效率，entry span就是trace segment的第一个span。

##### 内核轻量级队列模型

oap server收到上报数据之后会把数据放到内存队列中，在去进行消费、聚合、计算、持久化，oap server使用的内存队列是一个循环队列。

首先有个概念叫DataCarrier，他负责管理Channel，Channel负责管理buffer，每个Buffer表示一个数组，这个数组才是一个真正的队列。DataCarrier有两个参数，channel_size和buffer_size，channel_size表示Channel中有多少个buffer，buffer_size表示buffer中的数组长度。DataCarrier中还有一个组件IDataPartitoner，他负责处理数据应该路由到那个buffer。

buffer中持有一个index(此次数据应该写入的索引)和BufferStrategy strategy(队列策略)，因为buffer的数据是个循环数组，所以当往index上写入数据的时候发现这个数据没有被消费，需要对应的策略，他有三种实现，blocking阻塞等待+callbacks回调，override覆盖以及if_possible往后找空闲位置。

当buffer注册到DataCarrier上时会指定n个线程去消费，1个线程消费1个或者多个buffer，也有可能多个线程消费一个buffer，每个线程内部有一个consumeList，大小为1500，间隔consumCycle秒时开始扫描buffer，当发现存在不为null的数据后就放入自己的consumeList，扫描完后如果有数据就交给处理器中的处理函数。

