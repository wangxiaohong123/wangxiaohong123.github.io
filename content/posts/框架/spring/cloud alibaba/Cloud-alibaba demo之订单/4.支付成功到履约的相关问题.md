---
title: 4.支付成功到履约相关问题
tags:
  - cloud-alibaba
categories: 订单demo
copyright: true
---

**支付成功之前进行的预支付和取消订单的延迟消息处理需要用到分布式锁，防止在处理订单超时时，用户支付，不同业务可能还要加上在支付回调中检测订单取消后发起退款**

**同时为了防止发送延时消息失败需要有一个定时任务，定时扫描超过30分钟没有支付的订单，执行超时操作**

在支付成功后订单系统会受到一条回调，这个时候需要把订单状态更新成已支付，然后发送支付完成消息，发出去消息后再由订单系统自己来消费这个消息，为什么要发消息，第一履约执行很耗时间，通过mq解耦加快支付成功的响应时间，然后其他服务需要监听支付成功不需要通过api，直接消费消息就好了。

当收到支付成功事件后，先调用履约系统，调用履约系统成功后再把订单改成已履约，流程如下图，红线表示可能出现问题的步骤：

![](https://tva1.sinaimg.cn/large/008i3skNly1gxrl8dth1dj318h0u0ju7.jpg)

##### 发送支付成功消息失败

收到回调并且修改完订单状态，此时如果发送mq消息失败，需要回滚数据，这里用到的是rocket的事务消息，他的事务消息使用的是TransactionMQProducer，使用**TransactionSendResult result = transactionMQProducer.sendMessageInTransaction(mq, orderInfoDO);**发送消息，每次发送消息之前producer都需要设置监听，用来处理发送消息成功和失败的情况，例如：

```java
transactionMQProducer.setTransactionListener(new TransactionListener() {
    @Override
    public LocalTransactionState executeLocalTransaction(Message message, Object o) {
        try {
            // 正常的业务逻辑代码
            return LocalTransactionState.COMMIT_MESSAGE;
        } catch (BaseBizException e) {
            throw e;
        } catch (Exception e) {
            log.error("system error", e);
            return LocalTransactionState.ROLLBACK_MESSAGE;
        }

    }

    @Override
    public LocalTransactionState checkLocalTransaction(MessageExt messageExt) {
        // 这个回调只有mq检测到存在长时间没提交的half消息时调用
        // 逻辑就是判断之前的的正常业务代码有没有执行完
        // 执行完就返回COMMIT_MESSAGE，没执行完就返回ROLLBACK_MESSAGE
        if(true) {
            return LocalTransactionState.COMMIT_MESSAGE;
        }
        return LocalTransactionState.ROLLBACK_MESSAGE;
    }
});
```

#### 消费支付成功消息

##### 调用履约系统失败

调用履约失败只要消费者返回Action.RECONSUME_LATER就可以了，返回这个rocket就会把消息放到重试队列里，重试超过16次会把消息放到死信队列里，这个时候需要在起一个消费者负责消费私信队列。

##### 调用履约系统成功后修改订单状态失败

这里也是用到事务消息

##### 履约后订单状态消息乱序问题

首先RocketMQ的消息要存储在不同的consumerQueue里，那就有可能出库和发货在不同的queue中，可能造成先消费发货，又消费出库，或者Ian消费了签收，又消费发货，再或者消费状态消息的时候出错，导致重新消费，这个时候也可能造成状态不正确，不管怎么样订单的数据都不准了，解决的办法就是使用mq的顺序消息，在发送的时候把同一个订单的状态改变消息发送到同一个consumerQueue中，只要在发送消息的时候多传入两个参数，一个MessageQueueSelector并重写select方法，一个需要路由的key：

```java
SendResult sendResult = defaultMQProducer.send(message, new MessageQueueSelector() {
    @Override
    public MessageQueue select(List<MessageQueue> mqs, Message message, Object arg) {
        //根据订单id选择发送queue
        String orderId = (String) arg;
        long index = hash(orderId) % mqs.size();
        return mqs.get((int) index);
    }
}, orderId);
```

消费者应该是MessageListenerOrderly类型，然后消费失败导致时也不应该返回RECONSUME_LATER了，而是返回ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;这样的话整个队列都不会消费，被挂起，这样的话只需要在消费的时候加锁，不需要幂等校验，因为队列已经被挂起了。

##### seata 解决履约实务问题

履约的流程比较复杂这里选择使用saga事务，saga相对于AT来说没有全局锁，这是优点，也是缺点，并且不需要单独的表；相对于TCC来说不会对代码做那么多的侵入，不需要每个节点都实现3个方法；还还可以实现异步调用的事务机制。

使用seata实现saga首先需要定义状态基文件，在resources的statelang文件夹下创建order_fullfill.json：

```json
{
    // 事务状态名成
    "Name": "order_fulfill",
    // 备注
    "Comment": "订单履约流程",
    // 初始状态
    "StartState": "FulfillService",
    "Version": "1.0.0",
    // 里面定义了各种状态，每个状态里有流转的节点
    // 里面有两种节点，一种正常的任务节点，负责逻辑处理，还有一种判断节点根据上一个节点的结果判断流转方向
    "States": {
        "FulfillService": {
            "Type": "ServiceTask",
            "ServiceName": "fulfillSagaService",
            "ServiceMethod": "createFulfillOrder",
            "CompensateState": "CreateFulfillOrderCompensate",
            "Next": "ChoiceWmsState",
            "Input": [
                "$.[receiveFulfillRequest]"
            ],
            "Output": {
                "CreateFulfillOrderResult": "$.#root"
            },
            "Status": {
                "#root == true": "SU",
                "#root == false": "FA",
                "$Exception{java.lang.Throwable}": "UN"
            },
            "Catch": [
                {
                    "Exceptions": [
                        "java.lang.Throwable"
                    ],
                    "Next": "CompensationTrigger"
                }
            ]
        },
        "ChoiceWmsState":{
            "Type": "Choice",
            "Choices":[
                {
                    "Expression":"[CreateFulfillOrderResult] == true",
                    "Next":"WmsService"
                }
            ],
            "Default":"Fail"
        },
        "WmsService": {
            "Type": "ServiceTask",
            "ServiceName": "wmsSageService",
            "ServiceMethod": "pickGoods",
            "CompensateState": "WmsPickGoodsCompensate",
            "Next": "ChoiceTmsState",
            "Input": [
                "$.[receiveFulfillRequest]"
            ],
            "Output": {
                "WmsPickGoodsResult": "$.#root"
            },
            "Status": {
                "#root == true": "SU",
                "#root == false": "FA",
                "$Exception{java.lang.Throwable}": "UN"
            },
            "Catch": [
                {
                    "Exceptions": [
                        "java.lang.Throwable"
                    ],
                    "Next": "CompensationTrigger"
                }
            ]
        },
        "ChoiceTmsState":{
            "Type": "Choice",
            "Choices":[
                {
                    "Expression":"[WmsPickGoodsResult] == true",
                    "Next":"TmsService"
                }
            ],
            "Default":"Fail"
        },
        "TmsService": {
            "Type": "ServiceTask",
            "ServiceName": "tmsSagaService",
            "ServiceMethod": "sendOut",
            "CompensateState": "TmsSendOutCompensate",
            "Input": [
                "$.[receiveFulfillRequest]"
            ],
            "Output": {
                "TmsSendOutResult": "$.#root"
            },
            "Status": {
                "#root == true": "SU",
                "#root == false": "FA",
                "$Exception{java.lang.Throwable}": "UN"
            },
            "Catch": [
                {
                    "Exceptions": [
                        "java.lang.Throwable"
                    ],
                    "Next": "CompensationTrigger"
                }
            ],
            "Next": "Succeed"
        },
        "CreateFulfillOrderCompensate": {
            "Type": "ServiceTask",
            "ServiceName": "fulfillSagaService",
            "ServiceMethod": "createFulfillOrderCompensate",
            "Input": [
                "$.[receiveFulfillRequest]"
            ]
        },
        "WmsPickGoodsCompensate": {
            "Type": "ServiceTask",
            "ServiceName": "wmsSageService",
            "ServiceMethod": "pickGoodsCompensate",
            "Input": [
                "$.[receiveFulfillRequest]"
            ]
        },
        "TmsSendOutCompensate": {
            "Type": "ServiceTask",
            "ServiceName": "tmsSagaService",
            "ServiceMethod": "sendOutCompensate",
            "Input": [
                "$.[receiveFulfillRequest]"
            ]
        },
        "CompensationTrigger": {
            "Type": "CompensationTrigger",
            "Next": "Fail"
        },
        "Succeed": {
            "Type":"Succeed"
        },
        "Fail": {
            "Type":"Fail",
            "ErrorCode": "500",
            "Message": "订单履约异常！！"
        }
    }
}
```

然后为saga创建数据库配置和状态基配置：

DataSourceConfiguration：

```java
@Configuration
public class DataSourceConfiguration {

    @ConfigurationProperties(prefix = "spring.datasource")
    @Bean
    public DruidDataSource druidDataSource(){
        return new DruidDataSource();
    }

    @Bean(name = "transactionManager")
    @Primary
    public DataSourceTransactionManager transactionManager(@Qualifier("druidDataSource") DruidDataSource druidDataSource) {
        return new DataSourceTransactionManager(druidDataSource);
    }
}
```

StateMachineConfiguration：

```java
@Configuration
public class StateMachineConfiguration {

    @Bean
    public ThreadPoolExecutorFactoryBean threadExecutor(){
        ThreadPoolExecutorFactoryBean threadExecutor = new ThreadPoolExecutorFactoryBean();
        threadExecutor.setThreadNamePrefix("SAGA_ASYNC_EXE_");
        threadExecutor.setCorePoolSize(1);
        threadExecutor.setMaxPoolSize(20);
        return threadExecutor;
    }

    @Bean
    public DbStateMachineConfig dbStateMachineConfig(ThreadPoolExecutorFactoryBean threadExecutor
            , DruidDataSource druidDataSource) throws IOException {
        DbStateMachineConfig dbStateMachineConfig = new DbStateMachineConfig();
        dbStateMachineConfig.setDataSource(druidDataSource);
        dbStateMachineConfig.setThreadPoolExecutor((ThreadPoolExecutor) threadExecutor.getObject());
        dbStateMachineConfig.setResources(new PathMatchingResourcePatternResolver()
                .getResources("classpath*:statelang/*.json"));
        dbStateMachineConfig.setEnableAsync(true);
        dbStateMachineConfig.setTxServiceGroup("ruyuan-eshop-fulfill-group");
        return dbStateMachineConfig;
    }

    /**
     * saga状态机实例
     */
    @Bean
    public ProcessCtrlStateMachineEngine stateMachineEngine(DbStateMachineConfig dbStateMachineConfig){
        ProcessCtrlStateMachineEngine stateMachineEngine = new ProcessCtrlStateMachineEngine();
        stateMachineEngine.setStateMachineConfig(dbStateMachineConfig);
        return stateMachineEngine;
    }

    @Bean
    public StateMachineEngineHolder stateMachineEngineHolder(ProcessCtrlStateMachineEngine stateMachineEngine){
        StateMachineEngineHolder stateMachineEngineHolder = new StateMachineEngineHolder();
        stateMachineEngineHolder.setStateMachineEngine(stateMachineEngine);
        return stateMachineEngineHolder;
    }
}
```

然后根据定义的流程实现方法就可以了，同时需要注意saga也有幂等或者空回滚/空悬挂问题。