---
title: 6.限流熔断
tags:
  - cloud-alibaba
categories: 订单demo
copyright: true
---

限流、熔断降级使用alibaba的sentinel。

##### 基础概念

不管是那种规则，触发之后抛出的都是BlockException，BlockException的子类会区分各种，比如DegradeException。

流控、熔断这两个没啥好说的。

热点规则就是根据接口的参数来限制并发。

授权规则就是黑背名单。

系统规则就是说可以根据rt、线程数、CPU使用率这些来限制，一般都是根据CPU，比如说CPU达到了80%就会进行限流，使用这个实现自适应限流的效果，需要注意的是如果是系统规则要把资源做成EntryType.IN方式，默认是OUT的，可以在dubbo和MVC的拦截器里对所有请求处理。我觉得自适应限流加不加都可以，一般的厂子都是在上线前进行压测，然后根据每个接口的调用比例及服务的并发最大值做集群限流+网关的限流，集群限流需要单独一台机器充当token server，控制台可以配置集群流控服务的地址和端口，集群流控服务就搞一个springboot服务然后加两个依赖：

```xml
<dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-cluster-client-default</artifactId>
    <version>1.7.1</version>
</dependency>

<dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-cluster-server-default</artifactId>
    <version>1.7.1</version>
</dependency>
```

##### 使用

Sentinel是自带控制台的，但是控制台只把配置放到了内存里，每次重启数据就会丢失，官网推荐把配置持久化到nacos中，但是控制台又不支持？好在控制台的测试代码有持久化到nacos的例子，进行控制台的代码需要二次开发：

1.   首先修改依赖，在控制台的pom文件中找到**sentinel-datasource-nacos**依赖去掉nacos-client然后引入对应版本：

     ```xml
     <dependency>
         <groupId>com.alibaba.csp</groupId>
         <artifactId>sentinel-datasource-nacos</artifactId>
         <exclusions>
             <exclusion>
                 <groupId>com.alibaba.nacos</groupId>
                 <artifactId>nacos-client</artifactId>
             </exclusion>
         </exclusions>
     <!--            <scope>test</scope>-->
     </dependency>
     <!--- 我们项目搭建的nacos集群时1.4，所以这里改成1.4版本，现在用的最多的应该是2.0.x --->
     <dependency>
         <groupId>com.alibaba.nacos</groupId>
         <artifactId>nacos-client</artifactId>
         <version>1.4.0</version>
     </dependency>
     <dependency>
         <groupId>org.apache.commons</groupId>
         <artifactId>commons-lang3</artifactId>
         <version>3.5</version>
     </dependency>
     ```

2.    把src/test/java/com/alibaba/csp/sentinel/dashboard/rule/nacos 路径下的FlowRuleNacosProvider和FlowRuleNacosPublisher类拷⻉到src/main/java/com/alibaba/csp/sentinel/dashboard/rule下，NacosConfig和NacosConfigUtil拷贝到src/main/java/com/alibaba/csp/sentinel/dashboard/config目录下。

3.   连接nacos：配置文件中增加nacos的连接配置：

     ```properties
     nacos.serverAddr=127.0.0.1:8848
     nacos.namespace=test
     nacos.username=admin
     nacos.password=123456
     ```

     然后编辑刚才拷贝的NacosConfig类：

     ```java
     @Configuration
     public class NacosConfig {
     
         // 注入配置文件中的信息
         @Value("${nacos.serverAddr}")
         private String serverAddr;
     
         @Value("${nacos.namespace}")
         private String namespace;
     
         @Value("${nacos.username}")
         private String username;
     
         @Value("${nacos.password}")
         private String password;
     
         /**
          * 流控规则编码器
          */
         @Bean
         public Converter<List<FlowRuleEntity>, String> flowRuleEntityEncoder() {
             return JSON::toJSONString;
         }
     
         /**
          * 流控规则解码器
          */
         @Bean
         public Converter<String, List<FlowRuleEntity>> flowRuleEntityDecoder() {
             return s -> JSON.parseArray(s, FlowRuleEntity.class);
         }
     
         /**
          * 创建nacos配置服务
          */
         @Bean
         public ConfigService nacosConfigService() throws Exception {
             Properties properties = new Properties();
             properties.put(PropertyKeyConst.SERVER_ADDR, serverAddr);
             properties.put(PropertyKeyConst.NAMESPACE, namespace);
             properties.put(PropertyKeyConst.USERNAME, username);
             properties.put(PropertyKeyConst.PASSWORD, password);
             return ConfigFactory.createConfigService(properties);
         }
     }
     ```

4.   修改保存流控规则代码，找到在controller包下找到FlowControllerV1类，控制台在保存流控规则时会调用这个类里的接口，把注入的SentinelApiClient改成刚刚复制过来的两个类：

     ```java
     @Resource
     @Qualifier("flowRuleNacosProvider")
     private DynamicRuleProvider<List<FlowRuleEntity>> ruleProvider;
     
     @Resource
     @Qualifier("flowRuleNacosPublisher")
     private DynamicRulePublisher<List<FlowRuleEntity>> rulePublisher;
     
     //    @Autowired
     //    private SentinelApiClient sentinelApiClient;
     ```

     然后重写publishRules()方法：

     ```java
     /**
      * 推送到nacos的publishRules
      */
     private void publishRules(String app) throws Exception {
         List<FlowRuleEntity> rules = repository.findAllByApp(app);
         rulePublisher.publish(app, rules);
     }
     
     //    private CompletableFutrue<Void> publishRules(String app, String ip, Integer port) {
     //        List<FlowRuleEntity> rules = repository.findAllByMachine(MachineInfo.of(app, ip, port));
     //        return sentinelApiClient.setFlowRuleOfMachineAsync(app, ip, port, rules);
     //    }
     ```

     然后修改调用这个方法的代码，修改一下传入的参数，最后在获取规则列表的时候改成从nacos获取：

     ```java
     //            List<FlowRuleEntity> rules = sentinelApiClient.fetchFlowRuleOfMachine(app, ip, port);
     // 从nacos获取
     List<FlowRuleEntity> rules = ruleProvider.getRules(app);
     ```

6.   修改其他规则，需要先在NacosConfigUtil中创建POSTFIX变量：

     ```java
     public final class NacosConfigUtil {
     
         public static final String GROUP_ID = "SENTINEL_GROUP";
     
         /**
          * 限流规则
          */
         public static final String FLOW_DATA_ID_POSTFIX = "-flow-rules.json";
         /**
          * 新加一个熔断规则
          */
         public static final String DEGRADE_DATA_ID_POSTFIX = "-degrade-rules.json";
     
         private NacosConfigUtil() {}
     }
     ```

     然后创建降级的publisher类：

     ```java
     @Component("degradeFollowRuleNacosPublisher")
     public class DegradeFollowRuleNacosPublisher implements DynamicRulePublisher<List<DegradeRuleEntity>> {
     
         @Autowired
         private ConfigService configService;
         @Autowired
         private Converter<List<DegradeRuleEntity>, String> converter;
     
         @Override
         public void publish(String app, List<DegradeRuleEntity> rules) throws Exception {
             AssertUtil.notEmpty(app, "app name cannot be empty");
             if (rules == null) {
                 return;
             }
             configService.publishConfig(app + NacosConfigUtil.DEGRADE_FOLLOW_DATA_ID_POSTFIX,
                 NacosConfigUtil.GROUP_ID, converter.convert(rules));
         }
     }
     ```

     Provider同理：

     ```java
     @Component("degradeFollowRuleNacosProvider")
     public class DegradeFollowRuleNacosProvider implements DynamicRuleProvider<List<DegradeRuleEntity>> {
     
         @Autowired
         private ConfigService configService;
         @Autowired
         private Converter<String, List<DegradeRuleEntity>> converter;
     
         @Override
         public List<DegradeRuleEntity> getRules(String appName) throws Exception {
             String rules = configService.getConfig(appName + NacosConfigUtil.DEGRADE_FOLLOW_DATA_ID_POSTFIX,
                 NacosConfigUtil.GROUP_ID, 3000);
             if (StringUtil.isEmpty(rules)) {
                 return new ArrayList<>();
             }
             return converter.convert(rules);
         }
     }
     ```

     创建好provider和publisher后，还要在NacosConfig中配置编解码器：

     ```java
     /**
      * 熔断规则编码器
      */
     @Bean
     public Converter<List<DegradeRuleEntity>, String> degradeRuleEntityEncoder() {
         return JSON::toJSONString;
     }
     
     /**
      * 熔断规则解码器
      */
     @Bean
     public Converter<String, List<DegradeRuleEntity>> degradeRuleEntityDecoder() {
         return s -> JSON.parseArray(s, DegradeRuleEntity.class);
     }
     ```

     最后修改DegradeController，熔断的规则就可以持久化到nacos上了，热点规则、系统规则、授权规则也是⼀样的。

7.   打包部署：

     ```shell
     mvn clean package -Dmaven.test.skip=true
     ```

     启动：

     ```shell
     # -Dserver.port=8080表示sentinel-dashboard运⾏端⼝ 
     # -Dcsp.sentinel.dashboard.server=172.19.16.47:8080表示客户端向Sentinel接⼊端指定控制台的地址
     # -Dproject.name=sentinel-dashboard表示指定Sentinel控制台本身的应⽤名称
     # 剩下两个是nacos的配置
     nohup java -server -Xms1g -Xmx1g -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=47.92.4.30:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar --nacos.serverAddr=mse-a348bd14-p.nacos-ans.mse.aliyuncs.com:8848 --nacos.namespace=sentinel &
     ```

8.   业务服务接入sentinel：

     添加依赖：

     ```xml
     <!-- sentinel依赖 -->
     <dependency>
         <groupId>com.alibaba.cloud</groupId>
         <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
     </dependency>
     <!-- 如果需要基于nacos作为sentinel的数据源则需要添加如下的依赖 -->
     <dependency>
         <groupId>com.alibaba.csp</groupId>
         <artifactId>sentinel-datasource-nacos</artifactId>
         <version>1.8.2</version>
         <exclusions>
             <exclusion>
                 <groupId>com.alibaba.nacos</groupId>
                 <artifactId>nacos-client</artifactId>
             </exclusion>
         </exclusions>
     </dependency>
     <!-- 上面排除nacos客户端，这里引入自己的nacos集群版本 -->
     <dependency>
         <groupId>com.alibaba.nacos</groupId>
         <artifactId>nacos-client</artifactId>
         <version>1.4.0</version>
     </dependency>
     ```

     添加配置：

     ```yaml
     spring:
       cloud:
         sentinel:
           transport:
             # 控制台地址
             dashboard: localhost:8080
             # 和控制台通讯的端口
             port: 18001
           # 使⽤nacos做持久化
           datasource:
             # 流控配置
             flow:
               nacos:
                 server-addr: ${spring.cloud.nacos.discovery.server-addr}
                 namespace: test
                 groupId: SENTINEL_DEMO_GROUP
                 dataId: ${spring.application.name}-flow-rules.json
                 data-type: json
                 rule-type: flow
             # 熔断降级配置
             degrade:
               nacos:
                 server-addr: ${spring.cloud.nacos.discovery.server-addr}
                 namespace: test
                 groupId: SENTINEL_DEMO_GROUP
                 dataId: ${spring.application.name}-degrade-rules.json
                 data-type: json
                 rule-type: degrade
     ```

9.   异常处理：

     限流异常 FlowException 

     降级异常 DegradeException 

     参数限流异常 ParamFlowException 

     系统负载异常 SystemBlockException 

     授权异常 AuthorityException

     代码中创建一个BlockExceptionHandler 的实现类，重写的handle⽅法：

     ```java
     @Component
     public class CustomBlockExceptionHandler implements BlockExceptionHandler {
         @Override
         public void handle(HttpServletRequest request, HttpServletResponse response, BlockException e) throws Exception {
             String msg = "";
             if(e instanceof FlowException){
                 msg = "限流控制";
             }else if(e instanceof DegradeException){
                 msg = "降级控制";
             } else if(e instanceof AuthorityException){
                 msg = "授权控制";
             }
             response.setStatus(200);
             ObjectMapper objectMapper = new ObjectMapper();
             response.setContentType("application/json; charset=utf-8");
             PrintWriter writer = response.getWriter();
             writer.print(objectMapper.writeValueAsString(msg));
     
             response.flushBuffer();
         }
     }
     ```

     **注意，在使用sentinel把controller里的接口标记为资源时，可以写接口的url或者把接口定义为资源的value，比如@SentinelResource注解，当我们在控制台配置的资源名是接口的url时，自定义的全局sentinel异常处理可以生效，但是如果在控制台配置的资源名是@SentinelResource的value时，全局异常处理不生效，当触发规则控制后只会去找@SentinelResource注解中配置的blockHandler等**

