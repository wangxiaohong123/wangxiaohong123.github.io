---
title: nacos-3.核心源码
tags:
  - nacos
categories: 框架
copyright: true
---

##### 1.服务注册源码

服务注册、订阅什么的接口是NamingClientProxy，这个接口主要有两个实现类：NamingGrpcClientProxy和NamingHttpClientProxy，注册的方法是registerService，NamingGrpcClientProxy的流程：

```java
/**
 * Register a instance to service with specified instance properties.
 *
 * @param serviceName 服务名
 * @param groupName   服务分组
 * @param instance    实例信息，保存实例id、ip、端口、权重等信息
 */
public void registerService(String serviceName, String groupName, Instance instance) throws NacosException {
    // 先把实例存储到NamingGrpcRedoService的registeredInstances（ConcurrentMap）里
    redoService.cacheInstanceForRedo(serviceName, groupName, instance);
    // 注册服务
    doRegisterService(serviceName, groupName, instance);
}
```

注册服务的方法：

```java
public void doRegisterService(String serviceName, String groupName, Instance instance) throws NacosException {
    // 封装请求
    InstanceRequest request = new InstanceRequest(namespaceId, serviceName, groupName,
            NamingRemoteConstants.REGISTER_INSTANCE, instance);
    // 这步就是加个头，然后调用grpcClient发送请求
    requestToServer(request, Response.class);
    // 这个和上面一样，如果ConcurrentMap中没有这个服务就插入
    redoService.instanceRegistered(serviceName, groupName);
}
```

```java
private <T extends Response> T requestToServer(AbstractNamingRequest request, Class<T> responseClass)
        throws NacosException {
    try {
        // 设置安全认证的token、accessKey之类的
        request.putAllHeader(
                getSecurityHeaders(request.getNamespace(), request.getGroupName(), request.getServiceName()));
        // 通过rpcClient发起请求
        Response response =
                requestTimeout < 0 ? rpcClient.request(request) : rpcClient.request(request, requestTimeout);
        if (ResponseCode.SUCCESS.getCode() != response.getResultCode()) {
            throw new NacosException(response.getErrorCode(), response.getMessage());
        }
        if (responseClass.isAssignableFrom(response.getClass())) {
            return (T) response;
        }
        NAMING_LOGGER.error("Server return unexpected response '{}', expected response should be '{}'",
                response.getClass().getName(), responseClass.getName());
    } catch (NacosException e) {
        throw e;
    } catch (Exception e) {
        throw new NacosException(NacosException.SERVER_ERROR, "Request nacos server failed: ", e);
    }
    throw new NacosException(NacosException.SERVER_ERROR, "Server return invalid response");
}
```

```java
public Response request(Request request, long timeoutMills) throws NacosException {
    int retryTimes = 0;
    Response response;
    Exception exceptionThrow = null;
    long start = System.currentTimeMillis();
    // 没到重试次数并且没超时
    while (retryTimes < rpcClientConfig.retryTimes() && System.currentTimeMillis() < timeoutMills + start) {
        boolean waitReconnect = false;
        try {
            // currentConnection表示一个grpc的链接
            if (this.currentConnection == null || !isRunning()) {
                waitReconnect = true;
                throw new NacosException(NacosException.CLIENT_DISCONNECT,
                        "Client not connected, current status:" + rpcClientStatus.get());
            }
            // 发送请求
            response = this.currentConnection.request(request, timeoutMills);
            if (response == null) {
                throw new NacosException(SERVER_ERROR, "Unknown Exception.");
            }
            if (response instanceof ErrorResponse) {
                if (response.getErrorCode() == NacosException.UN_REGISTER) {
                    synchronized (this) {
                        waitReconnect = true;
                        if (rpcClientStatus.compareAndSet(RpcClientStatus.RUNNING, RpcClientStatus.UNHEALTHY)) {
                            LoggerUtils.printIfErrorEnabled(LOGGER,
                                    "Connection is unregistered, switch server, connectionId = {}, request = {}",
                                    currentConnection.getConnectionId(), request.getClass().getSimpleName());
                            switchServerAsync();
                        }
                    }
                    
                }
                throw new NacosException(response.getErrorCode(), response.getMessage());
            }
            // return response.
            lastActiveTimeStamp = System.currentTimeMillis();
            return response;
            
        } catch (Exception e) {
            if (waitReconnect) {
                try {
                    // wait client to reconnect.
                    Thread.sleep(Math.min(100, timeoutMills / 3));
                } catch (Exception exception) {
                    // Do nothing.
                }
            }
            
            LoggerUtils.printIfErrorEnabled(LOGGER,
                    "Send request fail, request = {}, retryTimes = {}, errorMessage = {}", request, retryTimes,
                    e.getMessage());
            
            exceptionThrow = e;
            
        }
        retryTimes++;
        
    }
    // 处理失败的情况
    if (rpcClientStatus.compareAndSet(RpcClientStatus.RUNNING, RpcClientStatus.UNHEALTHY)) {
        switchServerAsyncOnRequestFail();
    }
    
    if (exceptionThrow != null) {
        throw (exceptionThrow instanceof NacosException) ? (NacosException) exceptionThrow
                : new NacosException(SERVER_ERROR, exceptionThrow);
    } else {
        throw new NacosException(SERVER_ERROR, "Request fail, unknown Error");
    }
}
```

http请求会被InstanceController接收，进到他的register()方法中：

```java
@CanDistro
@PostMapping
@Secured(action = ActionTypes.WRITE)
public String register(HttpServletRequest request) throws Exception {
    // 命名空间
    final String namespaceId = WebUtils
            .optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);
    // 服务名称
    final String serviceName = WebUtils.required(request, CommonParams.SERVICE_NAME);
    NamingUtils.checkServiceNameFormat(serviceName);
    // 封装实例信息
    final Instance instance = HttpRequestInstanceBuilder.newBuilder()
            .setDefaultInstanceEphemeral(switchDomain.isDefaultInstanceEphemeral()).setRequest(request).build();
    // 注册服务
    getInstanceOperator().registerInstance(namespaceId, serviceName, instance);
    NotifyCenter.publishEvent(new RegisterInstanceTraceEvent(System.currentTimeMillis(), "",
            false, namespaceId, NamingUtils.getGroupName(serviceName), NamingUtils.getServiceName(serviceName),
            instance.getIp(), instance.getPort()));
    return "ok";
}
```

注册服务也分两个，一个是服务端，一个是客户端，只看服务端的吧，跟进到InstanceOperatorServiceImpl的registerInstance()方法，这个方法先把Instance参数转换成naming.core.Instance然后调用serviceManager的registerInstance()方法：

```java
public void registerInstance(String namespaceId, String serviceName, Instance instance) throws NacosException {
    // 实体转换
    com.alibaba.nacos.naming.core.Instance coreInstance = parseInstance(instance);
    serviceManager.registerInstance(namespaceId, serviceName, coreInstance);
}
```

继续走到serviceManager里：

```java
public void registerInstance(String namespaceId, String serviceName, Instance instance) throws NacosException {
    NamingUtils.checkInstanceIsLegal(instance);
    // 如果服务不存在，创建一个空服务放到一个map(serviceMap)里，然后初始化这个服务
    // 心跳检查就是在里调用的（service.init()）
    createEmptyService(namespaceId, serviceName, instance.isEphemeral());
    // 从serviceMap获取服务
    Service service = getService(namespaceId, serviceName);
    
    checkServiceIsNull(service, namespaceId, serviceName);
    // 补充实例数据，instance.isEphemeral()表示是否是临时节点
    // 添加实例信息
    addInstance(namespaceId, serviceName, instance.isEphemeral(), instance);
}
```

关键的代码就在addInstance()这个方法里：

```java
public void addInstance(String namespaceId, String serviceName, boolean ephemeral, Instance... ips)
        throws NacosException {
    String key = KeyBuilder.buildInstanceListKey(namespaceId, serviceName, ephemeral);
    Service service = getService(namespaceId, serviceName);
    synchronized (service) {
        // 这个很关键
        List<Instance> instanceList = addIpAddresses(service, ephemeral, ips);
        
        Instances instances = new Instances();
        instances.setInstanceList(instanceList);
        // 这里会走distro协议的put
        consistencyService.put(key, instances);
    }
}
```

addIpAddresses()方法中处理实例的集群信息、心跳时间什么的：

```java
public List<Instance> updateIpAddresses(Service service, String action, boolean ephemeral, Instance... ips)
        throws NacosException {
    // 这个相当于服务实例的map
    Datum datum = consistencyService
            .get(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), ephemeral));
    
    List<Instance> currentIPs = service.allIPs(ephemeral);
    Map<String, Instance> currentInstances = new HashMap<>(currentIPs.size());
    Set<String> currentInstanceIds = CollectionUtils.set();
    
    for (Instance instance : currentIPs) {
        currentInstances.put(instance.toIpAddr(), instance);
        currentInstanceIds.add(instance.getInstanceId());
    }
    
    Map<String, Instance> instanceMap;
    if (datum != null && null != datum.value) {
        // 如果有服务实例的信息，就更新，包括地址、心跳时间什么的
        instanceMap = setValid(((Instances) datum.value).getInstanceList(), currentInstances);
    } else {
        // 如果没有服务实例的信息就初始化一个新map
        instanceMap = new HashMap<>(ips.length);
    }
    
    for (Instance instance : ips) {
        // 处理实例、集群
        if (!service.getClusterMap().containsKey(instance.getClusterName())) {
            Cluster cluster = new Cluster(instance.getClusterName(), service);
            cluster.init();
            service.getClusterMap().put(instance.getClusterName(), cluster);
            Loggers.SRV_LOG
                    .warn("cluster: {} not found, ip: {}, will create new cluster with default configuration.",
                            instance.getClusterName(), instance.toJson());
        }
        
        if (UtilsAndCommons.UPDATE_INSTANCE_ACTION_REMOVE.equals(action)) {
            instanceMap.remove(instance.getDatumKey());
        } else {
            Instance oldInstance = instanceMap.get(instance.getDatumKey());
            if (oldInstance != null) {
                instance.setInstanceId(oldInstance.getInstanceId());
            } else {
                // 雪花算法生成id
                instance.setInstanceId(instance.generateInstanceId(currentInstanceIds));
            }
            instanceMap.put(instance.getDatumKey(), instance);
        }
        
    }
    if (instanceMap.size() <= 0 && UtilsAndCommons.UPDATE_INSTANCE_ACTION_ADD.equals(action)) {
        throw new IllegalArgumentException(
                "ip list can not be empty, service: " + service.getName() + ", ip list: " + JacksonUtils
                        .toJson(instanceMap.values()));
    }
    
    return new ArrayList<>(instanceMap.values());
}
```

addIpAddresses()方法走完了就会走到consistencyService()方法，不同的协议会走到不同的实现类，默认是distro，所以进到DistroConsistencyServiceImpl类中：

```java
public void put(String key, Record value) throws NacosException {
    // 这里有个发送变更通知还不知道干啥的
    onPut(key, value);
    // If upgrade to 2.0.X, do not sync for v1.
    if (ApplicationUtils.getBean(UpgradeJudgement.class).isUseGrpcFeatrues()) {
        return;
    }
    // 开启延迟任务，nacos服务端配置的，默认1s
    distroProtocol.sync(new DistroKey(key, KeyBuilder.INSTANCE_LIST_KEY_PREFIX), DataOperation.CHANGE,
            DistroConfig.getInstance().getSyncDelayMillis());
}
```

onPut()方法是用来处理临时节点和发送数据变更通知的，开启延迟任务会走到DistroProtocol的syncToTarget()方法里：

```java
public void syncToTarget(DistroKey distroKey, DataOperation action, String targetServer, long delay) {
    // 先初始化一个DistroKey
    DistroKey distroKeyWithTarget = new DistroKey(distroKey.getResourceKey(), distroKey.getResourceType(),
            targetServer);
    // 然后创建延迟任务，添加到distroTaskEngineHolder里
    // 这个是定时调度线程池实现的，同一个服务的多次任务会进行merge处理
    DistroDelayTask distroDelayTask = new DistroDelayTask(distroKeyWithTarget, action, delay);
    distroTaskEngineHolder.getDelayTaskExecuteEngine().addTask(distroKeyWithTarget, distroDelayTask);
    if (Loggers.DISTRO.isDebugEnabled()) {
        Loggers.DISTRO.debug("[DISTRO-SCHEDULE] {} to {}", distroKey, targetServer);
    }
}
```

getDelayTaskExecuteEngine()拿到的是NacosDelayTaskExecuteEngine，这个类里有个定时调度线程负责执行提交进来的任务，执行线程的run()方法里调用了NacosTaskProcessor的process()方法：

```java
public boolean process(NacosTask task) {
    if (!(task instanceof DistroDelayTask)) {
        return true;
    }
    DistroDelayTask distroDelayTask = (DistroDelayTask) task;
    DistroKey distroKey = distroDelayTask.getDistroKey();
    switch (distroDelayTask.getAction()) {
        case DELETE:
            DistroSyncDeleteTask syncDeleteTask = new DistroSyncDeleteTask(distroKey, distroComponentHolder);
            distroTaskEngineHolder.getExecuteWorkersManager().addTask(distroKey, syncDeleteTask);
            return true;
        case CHANGE:
        case ADD:
            DistroSyncChangeTask syncChangeTask = new DistroSyncChangeTask(distroKey, distroComponentHolder);
            distroTaskEngineHolder.getExecuteWorkersManager().addTask(distroKey, syncChangeTask);
            return true;
        default:
            return false;
    }
}
```

可以看到执行方法时又获取了ExecuteWorkersManager对象，然后会调用TaskExecuteWorker的process()方法，其实就是执行task的run：

```java
public boolean process(NacosTask task) {
    if (task instanceof AbstractExecuteTask) {
        putTask((Runnable) task);
    }
    return true;
}
```

具体的任务对应不同的task，比如数据变更对应的是DistroSyncChangeTask:

```java
@Override
protected boolean doExecute() {
    String type = getDistroKey().getResourceType();
    DistroData distroData = getDistroData(type);
    if (null == distroData) {
        Loggers.DISTRO.warn("[DISTRO] {} with null data to sync, skip", toString());
        return true;
    }
    // 同步数据
    return getDistroComponentHolder().findTransportAgent(type)
            .syncData(distroData, getDistroKey().getTargetServer());
}
```

TransportAgent也有两种，一个是rpc的，另一个是http，都是封装个request，然后发请求：

```java
public boolean syncData(DistroData data, String targetServer) {
    if (isNoExistTarget(targetServer)) {
        return true;
    }
    DistroDataRequest request = new DistroDataRequest(data, data.getType());
    Member member = memberManager.find(targetServer);
    if (checkTargetServerStatusUnhealthy(member)) {
        Loggers.DISTRO
                .warn("[DISTRO] Cancel distro sync caused by target server {} unhealthy, key: {}", targetServer,
                        data.getDistroKey());
        return false;
    }
    try {
        Response response = clusterRpcClientProxy.sendRequest(member, request);
        return checkResponse(response);
    } catch (NacosException e) {
        Loggers.DISTRO.error("[DISTRO-FAILED] Sync distro data failed! key: {}", data.getDistroKey(), e);
    }
    return false;
}
```

其他nacos实例会通过controller或者rpc的服务端接收到这个请求，然后交给distroProtocol的onReceive()方法：

```java
public boolean onReceive(DistroData distroData) {
    Loggers.DISTRO.info("[DISTRO] Receive distro data type: {}, key: {}", distroData.getType(),
            distroData.getDistroKey());
    String resourceType = distroData.getDistroKey().getResourceType();
    DistroDataProcessor dataProcessor = distroComponentHolder.findDataProcessor(resourceType);
    if (null == dataProcessor) {
        Loggers.DISTRO.warn("[DISTRO] Can't find data process for received data {}", resourceType);
        return false;
    }
    return dataProcessor.processData(distroData);
}
```

dataProcessor也有两个，一个客户端一个服务端的，服务端主要还是调用了onPut()方法。

onPut()方法的数据变更通知调用的是notifier.addTask()，这个notifier是内部的一个线程，他的run()方法里调用了handle()方法，handle()方法里又更具事件类型调用RecordListener的对应方法，RecordListener有一个实现类时Service，以服务实例信息变更为入口，进到Service的onChange()方法中：

```java
public void onChange(String key, Instances value) throws Exception {
    
    Loggers.SRV_LOG.info("[NACOS-RAFT] datum is changed, key: {}, value: {}", key, value);
    
    for (Instance instance : value.getInstanceList()) {
        if (instance == null) {
            // Reject this abnormal instance list:
            throw new RuntimeException("got null instance " + key);
        }
        if (instance.getWeight() > 10000.0D) {
            instance.setWeight(10000.0D);
        }
        if (instance.getWeight() < 0.01D && instance.getWeight() > 0.0D) {
            instance.setWeight(0.01D);
        }
    }
    // 这个很关键
    updateIPs(value.getInstanceList(), KeyBuilder.matchEphemeralInstanceListKey(key));
    
    recalculateChecksum();
}
```

updateIPs()方法先是处理了集群信息，最关键的是下面一行代码：

```java
getPushService().serviceChanged(this);
```

这个代码是反向通知订阅这个实例的服务。