---
title: 10.dubbo-总结
tags:
  - 源码
categories: Dubbo
copyright: true
---

##### 1.门面模式思想在dubbo的使用

model体系中封装了一堆组件，这些组件比如SPI、Repository等公共组件在dubbo框架运行过程中会经常被用到，如果没有Model，每个使用到的地方要自己维护，开源框架的公共部分开发是一个难点，因为是多人协作开发，如果每个人都根据自己的习惯处理公共组件会很混乱，比如有些人喜欢单例，有些人喜欢缓存。尤其是dubbo的大部分组件都是使用SPI支持扩展，如果有的人就不用SPI获取组件就很麻烦，放到Model中让公共组件有一个统一的使用标准和方法。

比如SPI的使用，通过注解配置让我们只关心接口有哪些方法就可以，而不去关心具体的实现。

##### 2.为什么要区分provider和consumer？

首先根据单一职责原则就应该分开，如果不区分Service和Reference，比如果只有一个Service，这个时候一个Service耦合了暴露服务和调用服务两种不同的功能场景，这样代码耦合性高而且不好维护。

##### 3.注册中心、元数据中心、配置中心为什么要分开

最开始dubbo只有一个注册中心，这3个数据都是放到配置中心上的，如果是小项目集群我觉得是够用的，但是如果是大项目，比如服务就有几百个，集群实例几千几万个，这个时候想要扩容是比较困难的，而且如果只是注册中心要扩容，其他两个是没必要一起扩容的，第二如果注册中心挂了，不应该影响其他两个。

##### 4.为什么要有exchanger这一层

官方的解释是为了同步转异步，在发送请求的时候默认实现是HeaderExchangeChannel，这个实现把我们的业务对象封装成了网络通信里的请求/响应对象，也是在这一层把调用channel的send然后把结果封装成了DefaultFutrue返回，把发送转成了异步。

##### 5.为什么要有transporter层

现在底层的服务通信使用的是netty，如果要换成其他的就需要修改大量的exchanger的代码，有了transportet层还以定义一套标准，以后换网络框架可以先新增在修改transporter的实现类，不需要修改Exchanger。

##### 6.全链路异步思想

客户端看网络请求模型，借助exchanger同步转异步。服务端借助AllDispatcher将请求提交到线程池。

##### 7.dubbo协议标准

2个字节的魔数，主要用来标记消息开始；1个字节标识(可以区分请求类型、two way这种)；1个字节的空位置；8个字节的请求id；4个字节的body长度。一共16个字节。

##### 8.dubbo3.0之后的优化

*   3.0之前注册的节点是方法级粒度的，这样在服务变化的时候消费端会收到大量的反向推送并且计算，这对消费者的内存、带宽的压力都大，同时注册中心的内存消耗也很大。
*   将公共组件放到Model中。
*   增加对nacos、consul等注册中心的支持。
*   新增triple协议，feign用的http1.1，grpc用的http2.0。基于http2.序列化除了protobuf还支持hessian2等，老协议无缝升级。

##### 9.注册中心类结构

注册中心最底层是具体实现，比如ZookeeperRegistry、NacosRegistry，他们的父类是CacheableFailbackRegistry负责缓存，父类的父类是FailbackRegistry，负责故障重试，最顶层的类是AbstractRegistry实现通用的公共能力(基于本地磁盘的缓存写入和重启恢复和注册、取消注册、订阅、取消订阅、节点变更通知)，这种分层的思想非常好。

##### 10.zk网络抖动导致节点丢失问题

在Curator5ZookeeperClient创建临时节点时，如果捕获到了NodeExistsException异常，需要先删除节点，再创建。

