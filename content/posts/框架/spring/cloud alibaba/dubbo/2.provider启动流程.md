---
title: 2.dubbo-provider启动源码
tags:
  - 源码
categories: Dubbo
copyright: true
---

#### 启动

进到ServiceConfig的export()方法中，看到3.0的代码把服务启动的代码都放到了ModuleDeployer中，猜测是在start方法中做的启动准备工作，有的版本调用的不是start()方法，而是prepare()方法。

然后在下面加了一个锁再去判断服务的export状态，**首先不明白这里为什么要加锁，然后下面有初始化也有发布，但是还有个刷新，这里在刷新什么？**

```java
/**
 *ServiceConfig的export()
 */
public void export() {
    // 如果这个服务已经启动了，就直接返回
    // exported被volatile修饰
    if (this.exported) {
        return;
    }
    // 3.0新引入的ScopeModel，管理各种组件的，这里的getScopeModel()拿到的是ScopeModel的子类ModuleModel
    // getDeployer()拿到的是DefaultModuleDeployer
    // 判断DefaultModuleDeployer就是对服务启动做初始化的组件
    getScopeModel().getDeployer().start();

    synchronized (this) {
        if (this.exported) {
            return;
        }
        // 执行刷新
        if (!this.isRefreshed()) {
            this.refresh();
        }
        // 服务实例的初始化
        if (this.shouldExport()) {
            this.init();
            // 延迟发布
            if (shouldDelay()) {
                doDelayExport();
            } else {
                doExport();
            }
        }
    }
}
```

DefaultModuleDeployer的start()方法：

```java
public synchronized Futrue start() throws IllegalStateException {
    // 检查state变量的状态
    if (isStopping() || isStopped() || isFailed()) {
        throw new IllegalStateException(getIdentifier() + " is stopping or stopped, can not start again");
    }
	// 也是state变量
    if (isStarting() || isStarted()) {
        // 这个startFutrue是一个全局的CompletableFutrue类型变量
        return startFutrue;
    }
    // 这里就是把状态设置成starting
    // 然后出发starting状态的监听
    // 然后把全局变量startFutrue赋初始值CompletableFutrue
    onModuleStarting();
    // 服务初始化
    applicationDeployer.initialize();
    // 这里只是设置了一个initialized状态
    // 他是全局的AtomicBoolean类型变量
    initialize();
    // refresh服务
    exportServices();
    // prepare application instance
    // exclude internal module to avoid wait itself
    // 如果不是内部模块就准备实例，防止自我等待
    if (moduleModel != moduleModel.getApplicationModel().getInternalModule()) {
        applicationDeployer.prepareApplicationInstance();
    }
    // 描述服务，大概看了一眼，没看懂是干什么的
    referServices();
    executorRepository.getSharedExecutor().submit(() -> {
        // 这里调用featrue.get()等待拿到结果
        try {
            // wait for export finish
            waitExportFinish();
            // wait for refer finish
            waitReferFinish();
        } catch (Throwable e) {
            logger.warn("wait for export/refer services occurred an exception", e);
        } finally {
            // 设置启动完成，applicationDeployer也需要修改一下状态
            onModuleStarted();
        }
    });

    return startFutrue;
}
```

整体的启动就是这些，看完了start方法又多了几个疑问，**refresh服务有做了什么操作，为什么这么多刷新，有什么用，描述服务是干什么的**

继续点进applicationDeployer.initialize();里看一下，可以看到DefaultApplicationDeployer是ApplicationDeployer的实现类：

```java
/**
 * DefaultApplicationDeployer
 */
public void initialize() {
    if (initialized.get()) {
        return;
    }
    // 这个startLock只是一个全局的对象
    // 我觉得这里加锁不是因为启动的时候有多线程并发访问dubbo服务的启动
    // 是有多个线程访问不同的方法
    synchronized (startLock) {
        if (initialized.get()) {
            return;
        }
        // 注册jvm销毁钩子
        // 销毁一些资源
        // 1.先创建一个DubboShutdownHook，他是个线程
        // 2.然后通过调用Runtime.getRuntime().addShutdownHook(this);注册销毁钩子
        registerShutdownHook();
        // 启动配置中心
        // 要先判断有没有必要把注册中心当成配置中心，然后在创建一个配置中心（ConfigCenterConfig）
        startConfigCenter();
        // 通过ConfigManager加载配置,比如ProtocolConfig，MetadataReportConfig等等
        // ProtocolConfig就是dubbo.protocols.xxx
        // 如果没配置就是空，此时还没有默认值
        loadApplicationConfigs();
        // 初始化moduleModel
        // 拿到所有的ModuleModel
        // 遍历ModuleModel，执行ModuleModel的Deployer的initialize()方法
        initModuleDeployers();
        // 2.7.8之后引入的启动元数据中心
        // 创建一个MetadataReportInstance，调用他的的init方法。
        startMetadataCenter();
        // 初始化一些类
        initMetadataService();
        // 设置initialized状态
        initialized.set(true);
    }
}
```

初始化moduleModel，初始化之前已经拿到了moduleModels，**生么时候设置的moduleModels没看到**：

```java
private void initModuleDeployers() {
    // 这个是把models放到全局变量defaultModule中
    applicationModel.getDefaultModule();
    // 把moduleModels复制一份在操作，避免遍历的时候其他线程插入ModuleModel导致ConcurrentModificationException
    List<ModuleModel> moduleModels = new ArrayList<>(applicationModel.getModuleModels());
    for (ModuleModel moduleModel : moduleModels) {
        // 初始化moduleModel，ModuleModel只有DefaultModuleDeployer一个实现类
        // 这里只会走到DefaultModuleDeployer的initialize()方法
        moduleModel.getDeployer().initialize();
    }
}
```

初始化结束后回到ModuleDeployer的start方法，继续走initialize()方法，因为这个方法在DefaultApplicationDeployer的initialize()方法中初始化初始化moduleModel使已经被调用过了，所以initialized已经被设置成了true，这个时候会直接返回：

```java
public void initialize() throws IllegalStateException {
    if (initialized.get()) {
        return;
    }
    // Ensure that the initialization is completed when concurrent calls
    synchronized (this) {
        if (initialized.get()) {
            return;
        }
        // 这里又加载了一次配置，和DefaultApplicationDeployer加载的不一样
        // 这里加载了dubbo.providers.xxx、load dubbo.consumers.xxx和load dubbo.modules.xxx
        loadConfigs();

        // 设置exportAsync、referAsync和background
        ModuleConfig moduleConfig = moduleModel.getConfigManager().getModule().orElseThrow(() -> new IllegalStateException("Default module config is not initialized"));
        exportAsync = Boolean.TRUE.equals(moduleConfig.getExportAsync());
        referAsync = Boolean.TRUE.equals(moduleConfig.getReferAsync());

        // start in background
        background = moduleConfig.getBackground();
        if (background == null) {
            // compatible with old usages
            background = isExportBackground() || isReferBackground();
        }

        initialized.set(true);
    }
}
```

到exportServices()进行刷新服务：

```java
private void exportServices() {
    // 拿到所有服务
    for (ServiceConfigBase sc : configManager.getServices()) {
        // 可以把每个ServiceConfig看成一个服务
        // exportServiceInternal的代码就是调用了sc.refresh();这个方法在父类AbstractConfig中
        // 如果是异步export还会执行sc.export()方法，但是我们就是从这个方法进来的啊
        // 断点发现这个代码根本就不会走，configManager.getServices()拿到的size是0
        exportServiceInternal(sc);
    }
}
```

然后回到ServiceConfig的export()，在调用完DefaultApplicationDeployer的start()方法后继续走到refresh()方法：

```java
public void refresh() {
    // 设置一下状态
    refreshed.set(true);
    try {
        // 这个就是一个检查，检查什么没看
        preProcessRefresh();
		// 拿到环境
        Environment environment = getScopeModel().getModelEnvironment();
        List<Map<String, String>> configurationMaps = environment.getConfigurationMaps();
        // 下面是获取前缀的
        String preferredPrefix = null;
        for (String prefix : getPrefixes()) {
            if (ConfigurationUtils.hasSubProperties(configurationMaps, prefix)) {
                preferredPrefix = prefix;
                break;
            }
        }
        // 如果没有配置前缀，调用getPrefixes()，这个是子类实现的自定义前缀方法
        if (preferredPrefix == null) {
            preferredPrefix = getPrefixes().get(0);
        }
        // 到此为止就拿到了一个preferredPrefix，这个路径现在是dubbo.service.org.apache.dubbo.demo.DemoService
        // dubbo.service是他自己拼的前缀，中间一部分是服务接口的包名，最后跟上接口的名称
        // Extract sub props (which key was starts with preferredPrefix)
        Collection<Map<String, String>> instanceConfigMaps = environment.getConfigurationMaps(this, preferredPrefix);
        Map<String, String> subProperties = ConfigurationUtils.getSubProperties(instanceConfigMaps, preferredPrefix);
        InmemoryConfiguration subPropsConfiguration = new InmemoryConfiguration(subProperties);
        // 这就是日志处理了
        if (logger.isDebugEnabled()) {
            String idOrName = "";
            if (StringUtils.hasText(this.getId())) {
                idOrName = "[id=" + this.getId() + "]";
            } else {
                String name = ReflectUtils.getProperty(this, "getName");
                if (StringUtils.hasText(name)) {
                    idOrName = "[name=" + name + "]";
                }
            }
        }
        assignProperties(this, environment, subProperties, subPropsConfiguration);
        // 这里处理服务接口里提供方法
        processExtraRefresh(preferredPrefix, subPropsConfiguration);
    } catch (Exception e) {
        logger.error("Failed to override field value of config bean: " + this, e);
        throw new IllegalStateException("Failed to override field value of config bean: " + this, e);
    }
    // 刷新之后的一些检查
    postProcessRefresh();
}
```

处理服务接口里提供方法就是通过反射，拿到接口和里面对应的方法：

```java
/**
 * AbstractInterfaceConfig
 */
protected void processExtraRefresh(String preferredPrefix, InmemoryConfiguration subPropsConfiguration) {
    if (StringUtils.hasText(interfaceName)) {
        Class<?> interfaceClass = null;
        try {
            // 反射拿到类，这个interfaceName是用set方法设置的，在哪设置还没看
            interfaceClass = ClassUtils.forName(interfaceName);
        } catch (ClassNotFoundException e) {
            return;
        }

        // 获取到配置
        Map<String, String> configProperties = subPropsConfiguration.getProperties();
        // 拿到所有方法，遍历
        Method[] methods = interfaceClass.getMethods();
        for (Method method : methods) {
            // 判断方法名是configProperties的元素，什么时候设置成map的key也没看到
            if (ConfigurationUtils.hasSubProperties(configProperties, method.getName())) {
                // 每个方法就是一个MethodConfig，把方法名和参数设置进去
                MethodConfig methodConfig = getMethodByName(method.getName());
                if (methodConfig == null) {
                    methodConfig = new MethodConfig();
                    methodConfig.setName(method.getName());
                    this.addMethod(methodConfig);
                }
                java.lang.reflect.Parameter[] arguments = method.getParameters();
                for (int i = 0; i < arguments.length; i++) {
                    if (getArgumentByIndex(methodConfig, i) == null &&
                        hasArgumentConfigProps(configProperties, methodConfig.getName(), i)) {

                        ArgumentConfig argumentConfig = new ArgumentConfig();
                        argumentConfig.setIndex(i);
                        methodConfig.addArgument(argumentConfig);
                    }
                }
            }
        }

        // 有把方法刷新了
        List<MethodConfig> methodConfigs = this.getMethods();
        if (methodConfigs != null && methodConfigs.size() > 0) {
            // whether ignore invalid method config
            Object ignoreInvalidMethodConfigVal = getEnvironment().getConfiguration()
                .getProperty(ConfigKeys.DUBBO_CONFIG_IGNORE_INVALID_METHOD_CONFIG, "false");
            boolean ignoreInvalidMethodConfig = Boolean.parseBoolean(ignoreInvalidMethodConfigVal.toString());

            Class<?> finalInterfaceClass = interfaceClass;
            List<MethodConfig> validMethodConfigs = methodConfigs.stream().filter(methodConfig -> {
                methodConfig.setParentPrefix(preferredPrefix);
                methodConfig.setScopeModel(getScopeModel());
                // 猜测这个刷新就是生成了代理，因为我看到里面先把方法名拼到了刚才得到的接口名后面
                // 然后调用了invoke方法
                methodConfig.refresh();
                // 又验证了一下配置
                return verifyMethodConfig(methodConfig, finalInterfaceClass, ignoreInvalidMethodConfig);
            }).collect(Collectors.toList());
            this.setMethods(validMethodConfigs);
        }
    }

}
```

回到ServiceConfig的export()里继续走到init()方法：

```java
public void init() {
    // 这里是乐观锁设置initialized属性为true
    if (this.initialized.compareAndSet(false, true)) {
        // load ServiceListeners from extension
        ExtensionLoader<ServiceListener> extensionLoader = this.getExtensionLoader(ServiceListener.class);
        this.serviceListeners.addAll(extensionLoader.getSupportedExtensionInstances());
    }
    // 这里很关键，初始化service的元数据
    // 应该是和元数据中心配合使用的
    initServiceMetadata(provider);
    // 接口类型
    serviceMetadata.setServiceType(getInterfaceClass());
    // target是实现的类
    serviceMetadata.setTarget(getRef());
    // 这个就是接口的路径
    serviceMetadata.generateServiceKey();
}
```

initServiceMetadata里设置了版本、group、接口名等等，但是设置完了除了接口名，其他还是null。

```java
protected void initServiceMetadata(AbstractInterfaceConfig interfaceConfig) {
    serviceMetadata.setVersion(getVersion(interfaceConfig));
    serviceMetadata.setGroup(getGroup(interfaceConfig));
    serviceMetadata.setDefaultGroup(getGroup(interfaceConfig));
    serviceMetadata.setServiceInterfaceName(getInterface());
}
```

到这为止，启动的准备工作就完事儿了，接下来就要执行发布的代码，继续往下看doExport()方法，doExport方法中就是调用了两个方法：

```java
doExportUrls();
exported();
```

exported()一看就是发布结束后的收尾工作，核心应该都在doExportUrls()里面，在这个方法中又出现了getScopeModel()，之前的deployer就是用这个方法获取的，所以我先进去看了下这个方法的返回值是干什么的。进去之后就是一堆组件，各种model，model中还有model，他通过这个model组件体系保存了所有插件，在别的地方需要使用的时候直接获取。

```java
private void doExportUrls() {
    // 这个getScopeModel()已经出现不止一次了，他的返回值是ScopeModel的子类ModuleModel
    // 通过ModuleModel可以拿到ModuleServiceRepository
    // 之前还获取过其他的组件，这里就猜测dubbo把各个组件都集中在了ModuleModel中
    // ModuleModel相当于门面模式，需要那个组件就去获取
    // ModuleServiceRepository他的本质是dubbo服务数据的存储组件,里面有服务对应的map、consumer的map、provider的map等
    ModuleServiceRepository repository = getScopeModel().getServiceRepository();
    // 把要发布的服务注册到repository中，就是把这个服务的数据存到repository的services里面
    ServiceDescriptor serviceDescriptor = repository.registerService(getInterfaceClass());
    // 创建一个服务的提供者，有接口名、具体的类、还有ModuleModel，必须有这个，要不然获取不到其他组件了
    // 还有刚才初始化的元数据
    providerModel = new ProviderModel(getUniqueServiceName(), ref, serviceDescriptor, this,
                                      getScopeModel(), serviceMetadata);
	// 在把封装好的providerModel放到repository的providers里
    repository.registerProvider(providerModel);
	// 生成注册的url，registry://127.0.0.1:2181/……和service-discovery-registry://127.0.0.1:2181/……
    List<URL> registryURLs = ConfigValidationUtils.loadRegistries(this, true);
	// protocols是通信的协议，默认是dubbo
    for (ProtocolConfig protocolConfig : protocols) {
        // 在protocolConfig中如果配置了contextPath就会把在path前面拼接contextPath/
        // 但是我们没配置，所以治理拿到的pathKey还是org.apache.dubbo.demo.DemoService
        String pathKey = URL.buildKey(getContextPath(protocolConfig)
                                      .map(p -> p + "/" + path)
                                      .orElse(path), group, version);
        // 又保存了一遍服务信息，这次把path和接口关联
        // 因为path没变，所以这不不会有什么操作
        repository.registerService(pathKey, interfaceClass);
        // 核心发布的流程
        doExportUrlsFor1Protocol(protocolConfig, registryURLs);
    }
}
```

然后进到关键的发布流程的代码里：

```java
private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> registryURLs) {
    // 先把配置转成map然后删掉空值
    Map<String, String> map = buildAttributes(protocolConfig);
    map.keySet().removeIf(key -> key == null || map.get(key) == null);
    // 设置元数据
    serviceMetadata.getAttachments().putAll(map);
	// 在这里构建了一个url
    // 里面有协议、地址、接口的path、还有一些元数据
    // 类似这样：dubbo://102.168.31.153:21880/org.apache.dubbo.demo.DemoService?anyhost=true……
    // 也是在这步设置了默认值
    URL url = buildUrl(protocolConfig, registryURLs, map);
    exportUrl(url, registryURLs);
}
```

上面创建了一个URL对象，然后走到了exportUrl方法，在这个方法里有本地发布和非本地发布，根据url里的scope参数判断是本地还是非本地，我觉得正常的服务启动之后会本地和远程都需要发布，也就说这个方法会走两次，一次本地，一次远程。

```java
private void exportUrl(URL url, List<URL> registryURLs) {
    String scope = url.getParameter(SCOPE_KEY);
    // 如果scope不是none就发布
    if (!SCOPE_NONE.equalsIgnoreCase(scope)) {
        // 不是远程就发本地
        if (!SCOPE_REMOTE.equalsIgnoreCase(scope)) {
            exportLocal(url);
        }
        // 不是本地就发远程
        if (!SCOPE_LOCAL.equalsIgnoreCase(scope)) {
            url = exportRemote(url, registryURLs);
            MetadataUtils.publishServiceDefinition(url);
        }
    }
    this.urls.add(url);
}
```

**为什么他的判断条件是!远程，就本地发布和!本地就远程发布？**因为这里的scope传进来的是null，这样判断本地和远程都可以发布。

先进到到本地发布exportLocal(url)里去：

```java
private void exportLocal(URL url) {
    // 这里在原来的URL基础上覆盖了几个属性
    URL local = URLBuilder.from(url)
        .setProtocol(LOCAL_PROTOCOL)
        .setHost(LOCALHOST_VALUE)
        .setPort(0)
        .build();
    local = local.setScopeModel(getScopeModel()).setServiceModel(providerModel);
    // 注意这里的false，表示是否带元数据
    doExportUrl(local, false);
}
```

这个时候url变成了injvm://102.168.31.153……，injvm表示的是本地发布替换了原来的dubbo协议头dubbo://，进到doExportUrl中：

```java
private void doExportUrl(URL url, boolean withMetaData) {
    // ref是实现类DemoServiceImpl，interfaceClass是接口DemoService，url是暴露出去的信息
    // 通过proxyFactory生成一个invoker，这个invoker就是基于DemoService接口生成的动态代理
    // 当netty server收到请求的时候，肯定会根据url调用这个invoker，底层肯定会回调自己的实现类
    // ProxyFactory$Adaptive
    // proxyFactory instanceof JavassistProxyFactory
    Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);
    // 本地创建的withMetaData是false
    if (withMetaData) {
        invoker = new DelegateProviderMetaDataInvoker(invoker, this);
    }
    // protocolSPI是Protocol类型
    // 通过protocol把invoker封装成Exporter发布出去
    Exporter<?> exporter = protocolSPI.export(invoker);
    exporters.add(exporter);
}
```

Protocol$Adaptive是一个native类，断点进不去，大概的意思就是构建一个org.apache.dubbo.rpc.Protocol类型的protocol。

虽然方法里不能打断点，但是这步走完后的返回值可以看到，返回值是一个ListenerExporterWrapper，里面有过一个Exporter<T> exporter对象，这个对象在本地发布的时候返回的是InjvmExporter，所以Protocol$Adaptive的export方法里调用的应该是InjvmProtocol，看一下InjvmProtocol的expoer：

```java
@Override
public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
    // 只有一句话，就是实例化InjvmExporter
    return new InjvmExporter<T>(invoker, invoker.getUrl().getServiceKey(), exporterMap);
}
```

到这里本地发布就完事了，回到之前的exportRul()方法里，往下走到了exportRemote()远程发布的代码，这个方法有两个参数，一个url，一个是个数组，数组里有两个元素：

1.   service-discovery-registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&dubbo=2.0.2&pid=44489&registry=zookeeper&timestamp=1637053498954
2.   registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&dubbo=2.0.2&pid=44489&registry=zookeeper&timestamp=1637053498954。

这两个元素除了头，其他的都一样，每个元素都会调用一遍doExportUrl()方法，但是protocolSPI已经变成了RegistryProtocol，RegistryProtocol类里有个内置对象protected Protocol protocol;这个protocol的类型是DubboProtocol，先看RegistryProtocol的export方法：

```java
public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {
    // 拿到对应的url，设置一些属性
    URL registryUrl = getRegistryUrl(originInvoker);
    URL providerUrl = getProviderUrl(originInvoker);
    final URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);
    final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);
    Map<URL, NotifyListener> overrideListeners = getProviderConfigurationListener(providerUrl).getOverrideListeners();
    overrideListeners.put(registryUrl, overrideSubscribeListener);
    providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);
    // 虽然叫doLocalExport，但是他是远程发布核心代码
    final ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker, providerUrl);
    ……
    return new DestroyableExporter<>(exporter);
}
```

在doLocalExport()方法中调用了DubboProtocol的export方法，只要是远程发布，不管那个url都会调用DubboProtocol，dubboProtocol的export()方法中也没啥代码，就是又调用了一个openServer(url);方法，所以直接进到openServer方法里看：

```java
private void openServer(URL url) {
    checkDestroyed();
    String key = url.getAddress();
    boolean isServer = url.getParameter(IS_SERVER_KEY, true);
    if (isServer) {
        ProtocolServer server = serverMap.get(key);
        // 第一次发布server是null
        if (server == null) {
            synchronized (this) {
                server = serverMap.get(key);
                if (server == null) {
                    // 双重检查server还是null，所有又走到了createServer()
                    serverMap.put(key, createServer(url));
                }else {
                    server.reset(url);
                }
            }
        } else {
            // server supports reset, use together with override
            server.reset(url);
        }
    }
}
```

这里又调用了createServer()，这个代码就会非常非常关键了：

```java
private ProtocolServer createServer(URL url) {
    // 又是一顿处理url
    url = URLBuilder.from(url)
        // send readonly event when server closes, it's enabled by default
        .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())
        // enable heartbeat by default
        .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT))
        .addParameter(CODEC_KEY, DubboCodec.NAME)
        .build();
    String str = url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER);

    if (StringUtils.isNotEmpty(str) && !url.getOrDefaultFrameworkModel().getExtensionLoader(Transporter.class).hasExtension(str)) {
        throw new RpcException("Unsupported server type: " + str + ", url: " + url);
    }

    ExchangeServer server;
    try {
        // 应该是核心了
        server = Exchangers.bind(url, requestHandler);
    } catch (RemotingException e) {
        throw new RpcException("Fail to start server(url: " + url + ") " + e.getMessage(), e);
    }

    str = url.getParameter(CLIENT_KEY);
    if (StringUtils.isNotEmpty(str)) {
        Set<String> supportedTypes = url.getOrDefaultFrameworkModel().getExtensionLoader(Transporter.class).getSupportedExtensions();
        if (!supportedTypes.contains(str)) {
            throw new RpcException("Unsupported client type: " + str);
        }
    }

    DubboProtocolServer protocolServer = new DubboProtocolServer(server);
    loadServerProperties(protocolServer);
    return protocolServer;
}
```

刚开始以为上面的bind方法应该很关键，但是进去之后又没啥东西：

```java
public static ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {
    if (url == null) {
        throw new IllegalArgumentException("url == null");
    }
    if (handler == null) {
        throw new IllegalArgumentException("handler == null");
    }
    url = url.addParameterIfAbsent(Constants.CODEC_KEY, "exchange");
    return getExchanger(url).bind(url, handler);
}
```

继续往下跟getExchanger(url).bind(url, handler)，getExchanger返回了HeaderExchanger，继续：

```java
@Override
public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {
    return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));
}
```

这里就是一直封装成ExchangeServer，调用了Transporters.bind：

```java
public static RemotingServer bind(URL url, ChannelHandler... handlers) throws RemotingException {
    if (url == null) {
        throw new IllegalArgumentException("url == null");
    }
    if (handlers == null || handlers.length == 0) {
        throw new IllegalArgumentException("handlers == null");
    }
    ChannelHandler handler;
    if (handlers.length == 1) {
        handler = handlers[0];
    } else {
        handler = new ChannelHandlerDispatcher(handlers);
    }
    // 这个getTransporter是Transporter$Adaptive类型，又不能进断点了
    // 但是Transporter$Adaptive对我们有用的实现类只有一个：NettyTransporter，netty4包下的
    // 在这里构造一个NettyServer
    return getTransporter(url).bind(url, handler);
}
```

bind里就是return new NettyServer(……)，点进去看也是调用父类的构造函数，所以直接进到父类AbstractServer中看构造方法：

```java
public AbstractServer(URL url, ChannelHandler handler) throws RemotingException {
    // 这个super就是一个赋值操作，没啥东西
    super(url, handler);
    // 下面也是一些简单赋值
    executorRepository = url.getOrDefaultApplicationModel().getExtensionLoader(ExecutorRepository.class).getDefaultExtension();
    localAddress = getUrl().toInetSocketAddress();

    String bindIp = getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());
    int bindPort = getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());
    if (url.getParameter(ANYHOST_KEY, false) || NetUtils.isInvalidLocalHost(bindIp)) {
        bindIp = ANYHOST_VALUE;
    }
    bindAddress = new InetSocketAddress(bindIp, bindPort);
    this.accepts = url.getParameter(ACCEPTS_KEY, DEFAULT_ACCEPTS);
    try {
        // 关键就是这个
        doOpen();
        if (logger.isInfoEnabled()) {
            logger.info("Start " + getClass().getSimpleName() + " bind " + getBindAddress() + ", export " + getLocalAddress());
        }
    } catch (Throwable t) {
        throw new RemotingException(url.toInetSocketAddress(), null, "Failed to bind " + getClass().getSimpleName()
                                    + " on " + getLocalAddress() + ", cause: " + t.getMessage(), t);
    }
    executor = executorRepository.createExecutorIfAbsent(url);
}
```

找到了启动netty的代码doOpen()，这是个抽象方法，要回到netty4的NettyServer看实现：

```java
protected void doOpen() throws Throwable {
    // ServerBootstrap相当于一个server服务器
    bootstrap = new ServerBootstrap();
    // 轮询监听端口连接事件的线程池
    // 使用netty的成熟框架都会根据操作系统来选择是EpollEventLoopGroup还是NioEventLoopGroup来提高性能
    bossGroup = NettyEventLoopFactory.eventLoopGroup(1, EVENT_LOOP_BOSS_POOL_NAME);
    // 处理监听到的事件的线程池
    workerGroup = NettyEventLoopFactory.eventLoopGroup(
        getUrl().getPositiveParameter(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),
        EVENT_LOOP_WORKER_POOL_NAME);
    // 创建handler
    final NettyServerHandler nettyServerHandler = new NettyServerHandler(getUrl(), this);
    channels = nettyServerHandler.getChannels();
    // 获取keepalive配置
    boolean keepalive = getUrl().getParameter(KEEP_ALIVE_KEY, Boolean.FALSE);

    bootstrap.group(bossGroup, workerGroup)
        // 这里也是根据操作系统判断使用EpollServerSocketChannel还是NioServerSocketChannel
        .channel(NettyEventLoopFactory.serverSocketChannelClass())
        // reuseAddr是true
        // 这个是防止重启时四次挥手出错导致的重启报错Address already in use
        .option(ChannelOption.SO_REUSEADDR, Boolean.TRUE)
        // tcp no delay整合多个请求一起发送虽然吞吐量会变高，但是延迟也会变高
        // 所以tcp no delay的意思是不把多个请求合并发送
        .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)
        .childOption(ChannelOption.SO_KEEPALIVE, keepalive)
        .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
        .childHandler(new ChannelInitializer<SocketChannel>() {
            @Override
            // 建立连接的操作
            protected void initChannel(SocketChannel ch) throws Exception {
                // FIXME: should we use getTimeout()?
                int idleTimeout = UrlUtils.getIdleTimeout(getUrl());
                NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);
                if (getUrl().getParameter(SSL_ENABLED_KEY, false)) {
                    // 加密通信
                    ch.pipeline().addLast("negotiation", new SslServerTlsHandler(getUrl()));
                }
                ch.pipeline()
                    // 编解码
                    .addLast("decoder", adapter.getDecoder())
                    .addLast("encoder", adapter.getEncoder())
                    // 这个应该是机器空闲的处理
                    .addLast("server-idle-handler", new IdleStateHandler(0, 0, idleTimeout, MILLISECONDS))
                    // 业务处理代码，这里用的是NettyServerHandler
                    .addLast("handler", nettyServerHandler);
            }
        });
    // bind之后就可以监听网络了
    ChannelFutrue channelFutrue = bootstrap.bind(getBindAddress());
    channelFutrue.syncUninterruptibly();
    channel = channelFutrue.channel();

}
```

启动了nettyServer之后就可以把他注册到zk上去了，需要回到RegistryProtocol的export()方法中，执行完了doLocalExport(originInvoker, providerUrl)要继续往下走

```java
// 这里拿到的是ListenerRegistryWrapper
final Registry registry = getRegistry(registryUrl);
final URL registeredProviderUrl = getUrlToRegistry(providerUrl, registryUrl);

// decide if we need to delay publish
boolean register = providerUrl.getParameter(REGISTER_KEY, true);
if (register) {
    // 注册的逻辑
    register(registry, registeredProviderUrl);
}

// 把url添加到ProviderModel
registerStatedUrl(registryUrl, registeredProviderUrl, register);

// 设置两个url
// registerUrl
exporter.setRegisterUrl(registeredProviderUrl);
// subscribeUrl
exporter.setSubscribeUrl(overrideSubscribeUrl);

if (!registry.isServiceDiscovery()) {
    // Deprecated! Subscribe to override rules in 2.6.x or before.
    // 这个弃用了，为了兼容2.6或之前版本？
    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);
}
// 这个是执行监听的
notifyExport(exporter);
//Ensure that a new exporter instance is returned every time export
return new DestroyableExporter<>(exporter);
```

注册的逻辑就是registry.register(registeredProviderUrl);这个registry是之前生成的ListenerRegistryWrapper，ListenerRegistryWrapper的register()又调用了registry.register(url)，这个registry是Registry类型的全局对象，拿到的是ServiceDiscoveryRegistry类型，ServiceDiscoveryRegistry的register()又调用了同类的doRegister()方法：

```java
public void doRegister(URL url) {
    url = addRegistryClusterKey(url);
    // 这句很关键，核心了
    if (writableMetadataService.exportURL(url)) {
        if (logger.isInfoEnabled()) {
            logger.info(format("The URL[%s] registered successfully.", url.toString()));
        }
    } else {
        if (logger.isWarnEnabled()) {
            logger.warn(format("The URL[%s] has been registered.", url.toString()));
        }
    }
}
```

writableMetadataService是WritableMetadataService类型的接口，他的实现类是InMemoryWritableMetadataService，看这名就知道是本地发布，直接跳过，看远程发布，回到ListenerRegistryWrapper，远程发布的时候registry变成了ZookeeperRegistry，但是ZookeeperRegistry并不是Registry的实现类，直接断点跟进去发现调用的是FailbackRegistry的register()方法，FailbackRegistry是Registry的实现类，FailbackRegistry还是一个抽象类，在register()方法中调用了抽象方法doRegister()，由子类实现，而ZookeeperRegistry就是他的子类，这样就回到了ZookeeperRegistry的doRegister方法：

```java
public void doRegister(URL url) {
    try {
        // 这个就是检查zkClient有没有被初始化
        checkDestroyed();
        // 自己封装的zkClient创建节点、添加监听什么的
        zkClient.create(toUrlPath(url), url.getParameter(DYNAMIC_KEY, true));
    } catch (Throwable e) {
        throw new RpcException("Failed to register " + url + " to zookeeper " + getUrl() + ", cause: " + e.getMessage(), e);
    }
}
```

注册成功，启动结束。

![](https://tva1.sinaimg.cn/large/008vxvgGly1h7tz463yp2j31lf0u0dkl.jpg)