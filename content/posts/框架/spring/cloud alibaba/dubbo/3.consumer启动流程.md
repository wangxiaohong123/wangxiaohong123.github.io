---
title: 3.dubbo-consumer启动源码
tags:
  - 源码
categories: Dubbo
copyright: true
---

进到consumer的api的启动demo，首先创建的是一个ReferenceConfig。provider创建的是ServiceConfig。

```java
private static void runWithRefer() {
    // reference是要调用的实例
    // 为每个实例创建一个reference
    ReferenceConfig<DemoService> reference = new ReferenceConfig<>();
    // 配置注册地址、元数据地址和引用的服务接口
    reference.setApplication(new ApplicationConfig("dubbo-demo-api-consumer"));
    reference.setRegistry(new RegistryConfig("zookeeper://127.0.0.1:2181"));
    reference.setMetadataReportConfig(new MetadataReportConfig("zookeeper://127.0.0.1:2181"));
    reference.setInterface(DemoService.class);
    // 通过reference的get，拿到的推断是DemoService的动态代理
    // get结束后，consumer应该就启动完成了
    DemoService service = reference.get();
    // 调用代理的方法，就会实现和目标接口的建立连接、序列化、发送请求等等
    String message = service.sayHello("dubbo");
    System.out.println(message);
}
```

直接进到get()方法里：

```java
public T get() {
    if (destroyed) {
        throw new IllegalStateException("The invoker of ReferenceConfig("+url+") has already destroyed!");
    }
	// 这个ref是一个全局对象，类型就是之前声明ReferenceConfig<DemoService>传进来的泛型
    // 也就是要访问的五福
    if (ref == null) {
        // 初始化ScopeModel，这个和之前provider的代码是一样的
        getScopeModel().getDeployer().start();
        synchronized (this) {
            if (ref == null) {
                init();
            }
        }
    }
    return ref;
}
```

继续走到init()方法：

```java
protected synchronized void init() {
    if (initialized) {
        return;
    }
    initialized = true;
	// 这里的refresh()包括下面的元数据中心、加载配置、注册repository的处理都和我们之前看的一样
    if (!this.isRefreshed()) {
        this.refresh();
    }
    initServiceMetadata(consumer);
    serviceMetadata.setServiceType(getServiceInterfaceClass());
    serviceMetadata.setServiceKey(URL.buildKey(interfaceName, group, version));
    Map<String, String> referenceParameters = appendConfig();

    ModuleServiceRepository repository = getScopeModel().getServiceRepository();
    ServiceDescriptor serviceDescriptor = repository.registerService(interfaceClass);
    consumerModel = new ConsumerModel(serviceMetadata.getServiceKey(), proxy, serviceDescriptor, this,
                                      getScopeModel(), serviceMetadata, createAsyncMethodInfo());
    repository.registerConsumer(consumerModel);
    serviceMetadata.getAttachments().putAll(referenceParameters);
    // 这里就不一样了，也是核心，创建代理
    ref = createProxy(referenceParameters);

    serviceMetadata.setTarget(ref);
    serviceMetadata.addAttribute(PROXY_CLASS_REF, ref);
    consumerModel.setProxyObject(ref);
    consumerModel.initMethodModels();
    checkInvokerAvailable();
}
```

createProxy()：

```java
private T createProxy(Map<String, String> referenceParameters) {
    // 是否是本地的服务
    if (shouldJvmRefer(referenceParameters)) {
        createInvokerForLocal(referenceParameters);
    } else {
        urls.clear();
        if (url != null && url.length() > 0) {
            // user specified URL, could be peer-to-peer address, or register center's address.
            parseUrl(referenceParameters);
        } else {
            // if protocols not in jvm checkRegistry
            // 协议不在jvm的注册表
            if (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())) {
                // 这个里就设置一些属性
                aggregateUrlFromRegistry(referenceParameters);
            }
        }
        // 关键：为远程服务创建invoker
        createInvokerForRemote();
    }
    URL consumerUrl = new ServiceConfigURL(CONSUMER_PROTOCOL, referenceParameters.get(REGISTER_IP_KEY), 0,
                                           referenceParameters.get(INTERFACE_KEY), referenceParameters);
    consumerUrl = consumerUrl.setScopeModel(getScopeModel());
    consumerUrl = consumerUrl.setServiceModel(consumerModel);
    MetadataUtils.publishServiceDefinition(consumerUrl);

    // 关键：创建代理
    return (T) proxyFactory.getProxy(invoker, ProtocolUtils.isGeneric(generic));
}
```

这个方法最开始就是一些判断处理什么的，如果是远程的话一定会走这个方法createInvokerForRemote();这里创建了一个invoker，是全局的，然后下面就是一些设置属性什么的先不管，最下面是根据刚才创建的invoker创建代理，这两步是最关键的，先看创建invoker的代码:

```java
private void createInvokerForRemote() {
    if (urls.size() == 1) {
        URL curUrl = urls.get(0);
        // 又使用了protocolSPI，但是这里调用的是refer方法
        // 拿到的involer的类型是MigrationInvoker
        // 内部有很多组件，其中有一个就是ClusterInvoker类型的invoker
        // 只能把protocol的实现类都看一遍，推测还是使用RegistryProtocol创建的invoker
        invoker = protocolSPI.refer(interfaceClass,curUrl);
        if (!UrlUtils.isRegistry(curUrl)){
            List<Invoker<?>> invokers = new ArrayList<>();
            invokers.add(invoker);
            invoker = Cluster.getCluster(scopeModel, Cluster.DEFAULT).join(new StaticDirectory(curUrl, invokers), true);
        }
    } else {
        List<Invoker<?>> invokers = new ArrayList<>();
        URL registryUrl = null;
        for (URL url : urls) {
            // For multi-registry scenarios, it is not checked whether each referInvoker is available.
            // Because this invoker may become available later.
            invokers.add(protocolSPI.refer(interfaceClass, url));
            if (UrlUtils.isRegistry(url)) {
                // use last registry url
                registryUrl = url;
            }
        }
        if (registryUrl != null) {
            // registry url is available
            // for multi-subscription scenario, use 'zone-aware' policy by default
            String cluster = registryUrl.getParameter(CLUSTER_KEY, ZoneAwareCluster.NAME);
            // The invoker wrap sequence would be: ZoneAwareClusterInvoker(StaticDirectory) -> FailoverClusterInvoker
            // (RegistryDirectory, routing happens here) -> Invoker
            invoker = Cluster.getCluster(registryUrl.getScopeModel(), cluster, false).join(new StaticDirectory(registryUrl, invokers), false);
        } else {
            // not a registry url, must be direct invoke.
            if (CollectionUtils.isEmpty(invokers)) {
                throw new IllegalArgumentException("invokers == null");
            }
            URL curUrl = invokers.get(0).getUrl();
            String cluster = curUrl.getParameter(CLUSTER_KEY, Cluster.DEFAULT);
            invoker = Cluster.getCluster(scopeModel, cluster).join(new StaticDirectory(curUrl, invokers), true);
        }
    }
}
```

断点进来走的是第一个if分支，也就是urls的size是1，先按照1看，这里生成的invoker是MigrationInvoker，里面有一个很重要的成员是MockClusterInvoker，通过RegistryProtocol生成的invoker：

```java
public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
    url = getRegistryUrl(url);
    // 推测是注册zk组件
    Registry registry = getRegistry(url);
    if (RegistryService.class.equals(type)) {
        return proxyFactory.getInvoker((T) registry, type, url);
    }

    // group="a,b" or group="*"
    Map<String, String> qs = (Map<String, String>) url.getAttribute(REFER_KEY);
    String group = qs.get(GROUP_KEY);
    if (group != null && group.length() > 0) {
        if ((COMMA_SPLIT_PATTERN.split(group)).length > 1 || "*".equals(group)) {
            return doRefer(Cluster.getCluster(url.getScopeModel(), MergeableCluster.NAME), registry, type, url, qs);
        }
    }
    // 拿到的是failoverCLuster，集群故障转移组件
    Cluster cluster = Cluster.getCluster(url.getScopeModel(), qs.get(CLUSTER_KEY));
    return doRefer(cluster, registry, type, url, qs);
}
```

doRefer()方法：

```java
protected <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type, URL url, Map<String, String> parameters) {
    Map<String, Object> consumerAttribute = new HashMap<>(url.getAttributes());
    consumerAttribute.remove(REFER_KEY);
    URL consumerUrl = new ServiceConfigURL(parameters.get(PROTOCOL_KEY) == null ? DUBBO : parameters.get(PROTOCOL_KEY),
                                           null,
                                           null,
                                           parameters.get(REGISTER_IP_KEY),
                                           0, getPath(parameters, type),
                                           parameters,
                                           consumerAttribute);
    url = url.putAttribute(CONSUMER_URL_KEY, consumerUrl);
    // getMigrationInvoker()方法就在下面
    // 用刚才创建的failoverCLuster实例化一个ServiceDiscoveryMigrationInvoker
    ClusterInvoker<T> migrationInvoker = getMigrationInvoker(this, cluster, registry, type, url, consumerUrl);
    return interceptInvoker(migrationInvoker, url, consumerUrl, url);
}

protected <T> ClusterInvoker<T> getMigrationInvoker(RegistryProtocol registryProtocol, Cluster cluster, Registry registry, Class<T> type, URL url, URL consumerUrl) {
    return new ServiceDiscoveryMigrationInvoker<T>(registryProtocol, cluster, registry, type, url, consumerUrl);
}
```

interceptInvoker()方法里拿到了监听器，然后调用监听器的onRefer()方法，这里拿到的监听器就是MigrationRuleListener，MigrationRuleListener里的onRefer()方法先根据传进来的invoker拿到MigrationRuleHandler实例，然后调用实例的doMigrate()方法，这个方法里有一行代码很关键：

```java
if (refreshInvoker(step, threshold, rule)) {
    // 刷新成功之后更新规则
    setMigrationRule(rule);
}
```

进到refreshInvoker()方法中里面是一个switch case分支，根据传进来的step（MigrationStep）直接走到APPLICATION_FIRST分支，这个分支执行migrationInvoker.migrateToApplicationFirstInvoker(newRule)方法，而migrationInvoker是我们在上面的getMigrationInvoker中直接实例化的ServiceDiscoveryMigrationInvoker：

```java
public void migrateToApplicationFirstInvoker(MigrationRule newRule) {
    CountDownLatch latch = new CountDownLatch(0);
    // 这个方法生成MockClusterInvoker
    refreshInterfaceInvoker(latch);
    refreshServiceDiscoveryInvoker(latch);

    // 上面创建了两个invoker，这里就是判断那个invoker是最优的，然后就会把另一个放到备用里
    // 根据什么判断的呢，以后再看
    calcPreferredInvoker(newRule);
}
```

先看refreshInterfaceInvoker()方法，这个方法里又调回了RegistryProtocol的getInvoker()方法：

```java
invoker = registryProtocol.getInvoker(cluster, registry, type, url);
```

在getInvoker()方法中先是用url创建一个DynamicDirectory实例（RegistryDirectory类型），然后调用doCreateInvoker()方法：

```java
protected <T> ClusterInvoker<T> doCreateInvoker(DynamicDirectory<T> directory, Cluster cluster, Registry registry, Class<T> type) {
    // 设置注册中心、protocol
    directory.setRegistry(registry);
    directory.setProtocol(protocol);
    // 这个parameters里面是ip、端口、协议之类的
    Map<String, String> parameters = new HashMap<>(directory.getConsumerUrl().getParameters());
    // 构造一个新的URL
    URL urlToRegistry = new ServiceConfigURL(
        parameters.get(PROTOCOL_KEY) == null ? DUBBO : parameters.get(PROTOCOL_KEY),
        parameters.remove(REGISTER_IP_KEY), 0, getPath(parameters, type), parameters);
    urlToRegistry = urlToRegistry.setScopeModel(directory.getConsumerUrl().getScopeModel());
    urlToRegistry = urlToRegistry.setServiceModel(directory.getConsumerUrl().getServiceModel());
    if (directory.isShouldRegister()) {
        directory.setRegisteredConsumerUrl(urlToRegistry);
        // 这里就是往zk上注册
        registry.register(directory.getRegisteredConsumerUrl());
    }
    directory.buildRouterChain(urlToRegistry);
    // 这里非常重要，这里面有获取服务实例信息的代码
    directory.subscribe(toSubscribeUrl(urlToRegistry));
	// 这里会调用MockClusterWrapper的join方法，把directory封装到MockClusterInvoker里返回
    return (ClusterInvoker<T>) cluster.join(directory, true);
}
```

registry.subscribe(url, this);方法经过ListenerRegistryWrapper->FailbackRegistry->ZookeeperRegistry，最终走到了注册zk的方法ZookeeperRegistry的doSubscribe()：

```java
// 创建节点
zkClient.create(path, false);
// 对子节点监听
List<String> children = zkClient.addChildListener(path, zkListener);
if (children != null) {
    urls.addAll(toUrlsWithEmpty(url, path, children));
}
// 这里应该就是对每个实例的客户端建立netty连接
notify(url, listener, urls);
```

跟着notify走到了RegistryDirectory的notify()方法，然后最后一行有一个refreshOverrideAndInvoker()方法，refreshOverrideAndInvoker()方法里又调用了refreshInvoker()方法，refreshInvoker()方法里有一行很关键：

```java
// Translate url list to Invoker map
Map<URL, Invoker<T>> newUrlInvokerMap = toInvokers(oldUrlInvokerMap, invokerUrls);
```

在toInvokers中调用了**protocol.refer(serviceType, url);**方法，进到DubboProtocol的refer()方法里，方法里又调用了protocolBindingRefer()方法，在这个方法里构造了一个invoker：

```java
DubboInvoker<T> invoker = new DubboInvoker<T>(serviceType, url, getClients(url), invokers);
```

构造DubboInvoker之前先调用了getClient()方法，断点进到DubboInvoker的构造方法里发现连接已经建立完了，所以建立连接的代码就应该在getClients(url)方法里，这个方法里创建了一个关键的元素：List\<ReferenceCountExchangeClient\> shareClients，他是通过getSharedClient(url, connections)方法创建的，然后一直跟，跟到了buildReferenceCountExchangeClientList()方法，又跟到了buildReferenceCountExchangeClient()方法，在这个方法里看到了像核心代码的东西：initClient(url)

```java
// 发起请求
client = Exchangers.connect(url, requestHandler);
```

代码里的核心就是这个，Exchangers一看就是网络通信的组件，然后继续往下跟，跟到了HeaderExchanger，又跟到了Transporters又跟到了netty4的NettyTransporter，找到了一行代码：

```java
return new NettyClient(url, handler);
```

点击去又跟到了父类AbstractClient中，在父类的构造方法里主要就是干了两件事，doOpen();和connect();doOpen和connect都是在NettyClient中实现的，先看doOpen：

```java
protected void doOpen() throws Throwable {
    // 处理网络请求的handler
    final NettyClientHandler nettyClientHandler = new NettyClientHandler(getUrl(), this);
    bootstrap = new Bootstrap();
    // 设置group以及一些参数
    bootstrap.group(EVENT_LOOP_GROUP.get())
        .option(ChannelOption.SO_KEEPALIVE, true)
        .option(ChannelOption.TCP_NODELAY, true)
        .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
        //.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getTimeout())
        .channel(socketChannelClass());

    bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, Math.max(DEFAULT_CONNECT_TIMEOUT, getConnectTimeout()));
    // 处理逻辑、编解码啥的
    bootstrap.handler(new ChannelInitializer<SocketChannel>() {

        @Override
        protected void initChannel(SocketChannel ch) throws Exception {
            int heartbeatInterval = UrlUtils.getHeartbeat(getUrl());

            if (getUrl().getParameter(SSL_ENABLED_KEY, false)) {
                ch.pipeline().addLast("negotiation", new SslClientTlsHandler(getUrl()));
            }

            NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyClient.this);
            ch.pipeline()//.addLast("logging",new LoggingHandler(LogLevel.INFO))//for debug
                .addLast("decoder", adapter.getDecoder())
                .addLast("encoder", adapter.getEncoder())
                .addLast("client-idle-handler", new IdleStateHandler(heartbeatInterval, 0, 0, MILLISECONDS))
                .addLast("handler", nettyClientHandler);

            String socksProxyHost = ConfigurationUtils.getProperty(getUrl().getOrDefaultApplicationModel(), SOCKS_PROXY_HOST);
            if(socksProxyHost != null && !isFilteredAddress(getUrl().getHost())) {
                int socksProxyPort = Integer.parseInt(ConfigurationUtils.getProperty(getUrl().getOrDefaultApplicationModel(), SOCKS_PROXY_PORT, DEFAULT_SOCKS_PROXY_PORT));
                Socks5ProxyHandler socks5ProxyHandler = new Socks5ProxyHandler(new InetSocketAddress(socksProxyHost, socksProxyPort));
                ch.pipeline().addFirst(socks5ProxyHandler);
            }
        }
    });
}
```

connect()走的是子类的doConnect()方法：

```java
protected void doConnect() throws Throwable {
    long start = System.currentTimeMillis();
    // 发起了连接，但是连接并不是同步建立的
    // 需要拿到一个futrue
    // 在下面需要判断连接建立的状态
    ChannelFutrue futrue = bootstrap.connect(getConnectAddress());
    try {
        boolean ret = futrue.awaitUninterruptibly(getConnectTimeout(), MILLISECONDS);

        if (ret && futrue.isSuccess()) {
            Channel newChannel = futrue.channel();
            try {
                // Close old channel
                // copy reference
                Channel oldChannel = NettyClient.this.channel;
                if (oldChannel != null) {
                    try {
                        oldChannel.close();
                    } finally {
                        NettyChannel.removeChannelIfDisconnected(oldChannel);
                    }
                }
            } finally {
                if (NettyClient.this.isClosed()) {
                    try {
                        newChannel.close();
                    } finally {
                        NettyClient.this.channel = null;
                        NettyChannel.removeChannelIfDisconnected(newChannel);
                    }
                } else {
                    NettyClient.this.channel = newChannel;
                }
            }
        } else if (futrue.cause() != null) {
            throw new RemotingException(this, "client(url: " + getUrl() + ") failed to connect to server "
                                        + getRemoteAddress() + ", error message is:" + futrue.cause().getMessage(), futrue.cause());
        } else {
            throw new RemotingException(this, "client(url: " + getUrl() + ") failed to connect to server "
                                        + getRemoteAddress() + " client-side timeout "
                                        + getConnectTimeout() + "ms (elapsed: " + (System.currentTimeMillis() - start) + "ms) from netty client "
                                        + NetUtils.getLocalHost() + " using dubbo version " + Version.getVersion());
        }
    } finally {
        // just add new valid channel to NettyChannel's cache
        if (!isConnected()) {
            //futrue.cancel(true);
        }
    }
}
```

然后netty就建立完了。

cluster.join(directory, true)调用的是

```java
new MockClusterInvoker<T>(directory, this.cluster.join(directory, buildFilterChain))
```

除了directory还需要一个invoker，使用cluster.join()根据directory成成invoker，cluster.join()走到了AbstractCluster里，接着又调用了dojoin()方法生成FailoverClusterInvoker实例，所以这个时候MockClusterInvoker实例中有两个属性，一个是DynamicDirectory，一个是FailoverClusterInvoker。

回到migrateToApplicationFirstInvoker()方法，继续走到refreshServiceDiscoveryInvoker(latch);方法，和上面一样，只不过创建的DynamicDirectory是ServiceDiscoveryRegistryDirectory类型，然后也没有走注册分支。

到这里ReferenceConfig的createProxy()方法中的createInvokerForRemote()就执行完了，继续往下看根据invoker创建动态代理的代码：

```java
proxyFactory.getProxy(invoker, ProtocolUtils.isGeneric(generic));
```

这个代码走到了StubProxyFactoryWrapper方法中，进到这个方法里的第一行又是一个proxyFactory.getProxy()，这里的proxyFactory变成了AbstractProxyFactory：

```java
/**
 * StubProxyFactoryWrapper
 */
public <T> T getProxy(Invoker<T> invoker, boolean generic) throws RpcException {
    // 这里的proxyFactory是AbstractProxyFactory
    T proxy = proxyFactory.getProxy(invoker, generic);
    // 剩下的是对GenericService的处理，先不看
}
```

AbstractProxyFactory的getProxy首先拿到了url里的所有接口对应的class，然后调用子类的getProxy()方法生成代理:

```java
public <T> T getProxy(Invoker<T> invoker, boolean generic) throws RpcException {
    // when compiling with native image, ensure that the order of the interfaces remains unchanged
    LinkedHashSet<Class<?>> interfaces = new LinkedHashSet<>();
    String config = invoker.getUrl().getParameter(INTERFACES);
    if (StringUtils.isNotEmpty(config)) {
        // 逗号分割
        String[] types = COMMA_SPLIT_PATTERN.split(config);
        for (String type : types) {
            try {
                ClassLoader classLoader = getClassLoader(invoker);
                // 这个就是对基础类/包装类的处理
                interfaces.add(ReflectUtils.forName(classLoader, type));
            } catch (Throwable e) {
                // ignore
            }
        }
    }
    if (generic) {
        try {
            // 通过反射拿到真正要代理的class
            String realInterface = invoker.getUrl().getParameter(Constants.INTERFACE);
            ClassLoader classLoader = getClassLoader(invoker);
            interfaces.add(ReflectUtils.forName(classLoader, realInterface));
        } catch (Throwable e) {
            // ignore
        }
        if (GenericService.class.equals(invoker.getInterface()) || !GenericService.class.isAssignableFrom(invoker.getInterface())) {
            interfaces.add(com.alibaba.dubbo.rpc.service.GenericService.class);
        }
    }
    interfaces.add(invoker.getInterface());
    interfaces.addAll(Arrays.asList(INTERNAL_INTERFACES));
    // 这个就很关键了
    // 走到了JavassistProxyFactory
    return getProxy(invoker, interfaces.toArray(new Class<?>[0]));
}
```

JavassistProxyFactory里面就一句话：

```java
public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {
    // Proxy是dubbo自己实现的
    return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));
}
```

到这里动态代理就创建完了，然后回到ReferenceConfig的init()方法，继续往下走，走到了checkInvokerAvailable()方法，这个方法是检查刚才创建的代理有没有效，就是调用involer的isAvailable方法，不写了，到这里创建动态代理的方法就结束了，回到demo里，这时候调用了一下provider的demo的方法，一定会走到invokerInvocationHandler的invoker里去

![](https://tva1.sinaimg.cn/large/008vxvgGly1h7ucja9iryj324a0u00xz.jpg)

