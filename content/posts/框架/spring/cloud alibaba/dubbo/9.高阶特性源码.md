---
title: 9.dubbo-高阶特性源码
tags:
  - 源码
categories: Dubbo
copyright: true
---

### 一、triple协议

使用triple协议时DubboProtocol会被替换成TripleProtocol。TripleProtocol的export()方法和DubboProtocol的区别就是调用的是PortUnificationExchanger的bind()方法：

```java
/**
 * PortUnificationExchanger
 */
public static void bind(URL url) {
    servers.computeIfAbsent(url.getAddress(), addr -> {
        // 构建server
        final PortUnificationServer server = new PortUnificationServer(url);
        // 启动server，这里还是使用netty
        server.bind();
        return server;
    });
}
```

server.bind();方法就是启动netty服务，但是使用的handler和Dubbo协议不一样，triple使用的handler是PortUnificationServerHandler。

消费端也是一样的，会走到TripleProtocol的refer()方法。

但是看源码的时候好像没看到triple协议使用了Exchanger和Transporter。

### 二、三大中心源码

##### 1.注册中心

注册中心分成5层：

1.   第一层接口层（Registry、RegistryService等），订阅、取消订阅、注册、下线等方法；
2.   第二层抽象层（AbstractRegistry），公共方法的默认实现，数据的磁盘缓存处理；
3.   第三层重试层（FailbackRegistry），负责订阅、取消订阅、注册、下线等任务的失败重试；
4.   第四层缓存层（CacheableFailbackRegistry），基于内存缓存节点信息；
5.   第五层实现层（ZookeeperRegistry、NacosRegistry等），主要负责和注册中心的交互；

###### 1）ZookeeperRegistry源码

```java
public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) {
    // 传进来的url是zk的注册地址
    // 初始化缓存、构建缓存清理定时任务、构造重试时间轮、创建磁盘缓存文件，如果文件已经存在还会读取磁盘缓存
    super(url);
    if (url.isAnyHost()) {
        throw new IllegalStateException("registry address == null");
    }
    String group = url.getGroup(DEFAULT_ROOT);
    if (!group.startsWith(PATH_SEPARATOR)) {
        group = PATH_SEPARATOR + group;
    }
    this.root = group;
    // 基于zookeeperTransporter构建zk客户端
    // zookeeperTransporter是在ZookeeperRegistryFactory中通过SPI获取的
    // 这里需要注意创建Curator5ZookeeperClient的时候添加的监听里解决了zk网络抖动导致节点消失的bug
    zkClient = zookeeperTransporter.connect(url);
    zkClient.addStateListener((state) -> {
        if (state == StateListener.RECONNECTED) {
            // 重连之后尝试拉取provider最新的集群地址
            // 这里不会重新注册，因为短暂的网络断开不会删除临时节点
            logger.warn("Trying to fetch the latest urls, in case there're provider changes during connection loss.\n" +
                " Since ephemeral ZNode will not get deleted for a connection lose, " +
                "there's no need to re-register url of this instance.");
            ZookeeperRegistry.this.fetchLatestAddresses();
        } else if (state == StateListener.NEW_SESSION_CREATED) {
            // 经历SESSION_LOST并且重新连接之后
            // 需要重新注册和监听
            // 因为zk可能因为网络抖动+延迟删除节点，导致我们在注册时提示节点已存在
            // 但是过一会zk把节点删除，这样就会导致节点丢失
            // 这个recover()就是调用FailbackRegistry把注册和定于添加定时任务，到时候会执行这个类的doRegister方法
            logger.warn("Trying to re-register urls and re-subscribe listeners of this instance to registry...");
            try {
                ZookeeperRegistry.this.recover();
            } catch (Exception e) {
                logger.error(e.getMessage(), e);
            }
        } else if (state == StateListener.SESSION_LOST) {
            // 连接断开的时间超过了阈值，此时会话过期，zk端会把当前客户端创建的临时节点删除
            // 客户端户收到一个SESSION_LOST的监听回调
            logger.warn("Url of this instance will be deleted from registry soon. " +
                "Dubbo client will try to re-register once a new session is created.");
        } else if (state == StateListener.SUSPENDED) {

        } else if (state == StateListener.CONNECTED) {

        }
    });
}
```

ZookeeperRegistry的构造方法中会调用CacheableFailbackRegistry的构造方法：

```java
public CacheableFailbackRegistry(URL url) {
    // 初始化重试时间轮
    super(url);
    extraParameters = new HashMap<>(8);
    extraParameters.put(CHECK_KEY, String.valueOf(false));
    // 定时缓存清理使用单线程线程池
    cacheRemovalScheduler = url.getOrDefaultApplicationModel().getExtensionLoader(ExecutorRepository.class).getDefaultExtension().nextScheduledExecutor();
    cacheRemovalTaskIntervalInMillis = getIntConfig(url.getScopeModel(), CACHE_CLEAR_TASK_INTERVAL, 2 * 60 * 1000);
    cacheClearWaitingThresholdInMillis = getIntConfig(url.getScopeModel(), CACHE_CLEAR_WAITING_THRESHOLD, 5 * 60 * 1000);
}
```

CacheableFailbackRegistry的构造方法会调用FailbackRegistry的构造方法：

```java
public FailbackRegistry(URL url) {
    // 拿到这个url先去创建磁盘缓存文件，如果文件已经存在还会读取磁盘缓存
    super(url);
    // 设置重试间隔，默认5s
    this.retryPeriod = url.getParameter(REGISTRY_RETRY_PERIOD_KEY, DEFAULT_REGISTRY_RETRY_PERIOD);

    // 初始化时间轮
    retryTimer = new HashedWheelTimer(new NamedThreadFactory("DubboRegistryRetryTimer", true), retryPeriod, TimeUnit.MILLISECONDS, 128);
}
```

FailbackRegistry的构造方法最后会调AbstractRegistry的构造方法：

```java
public AbstractRegistry(URL url) {
    setUrl(url);
    // 从Model组件里获取Bean工厂，在获取RegistryManager
    registryManager = url.getOrDefaultApplicationModel().getBeanFactory().getBean(RegistryManager.class);
    // 是否开启本地磁盘缓存
    localCacheEnabled = url.getParameter(REGISTRY_LOCAL_FILE_CACHE_ENABLED, true);
    // 获取共享线程池
    registryCacheExecutor = url.getOrDefaultApplicationModel().getDefaultExtension(ExecutorRepository.class).getSharedExecutor();
    if (localCacheEnabled) {
        // 开启刷盘定时任务
        // 同步刷盘，默认是false
        syncSaveFile = url.getParameter(REGISTRY_FILESAVE_SYNC_KEY, false);
        // 获取缓存文件的目录和文件名
        String defaultFilename = System.getProperty(USER_HOME) + DUBBO_REGISTRY +
            url.getApplication() + "-" + url.getAddress().replaceAll(":", "-") + CACHE;
        String filename = url.getParameter(FILE_KEY, defaultFilename);
        // 获取file对象和创建目录
        File file = null;
        if (ConfigUtils.isNotEmpty(filename)) {
            file = new File(filename);
            if (!file.exists() && file.getParentFile() != null && !file.getParentFile().exists()) {
                if (!file.getParentFile().mkdirs()) {
                    throw new IllegalArgumentException("Invalid registry cache file " + file + ", cause: Failed to create directory " + file.getParentFile() + "!");
                }
            }
        }
        this.file = file;
        // 先把磁盘缓存读取出来
        // 为了远程订阅失败的容错
        loadProperties();
        // 先拿到备用的url，备用的url里最少也要有一个当前url自己
        // 启动的时候这步什么都没干
        notify(url.getBackupUrls());
    }
}
```

父类的构造方法调用完了之后就开始建立zk的链接并且添加状态监听，调用Curator5ZookeeperTransporter的connect()方法，通过双重检查建立一个curator的客户端，初始化curator客户端的源码：

```java
public Curator5ZookeeperClient(URL url) {
    super(url);
    try {
        // 连接超时时间和会话过期时间
        int timeout = url.getParameter(TIMEOUT_KEY, DEFAULT_CONNECTION_TIMEOUT_MS);
        int sessionExpireMs = url.getParameter(ZK_SESSION_EXPIRE_KEY, DEFAULT_SESSION_TIMEOUT_MS);
        CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()
                .connectString(url.getBackupAddress())
                .retryPolicy(new RetryNTimes(1, 1000)) // 连接失败过1s再重试1次
                .connectionTimeoutMs(timeout)
                .sessionTimeoutMs(sessionExpireMs);
        String authority = url.getAuthority();
        if (authority != null && authority.length() > 0) {
            builder = builder.authorization("digest", authority.getBytes());
        }
        client = builder.build();
        // 添加状态监听
        client.getConnectionStateListenable().addListener(new CuratorConnectionStateListener(url));
        client.start();
        // 阻塞等待结果
        boolean connected = client.blockUntilConnected(timeout, TimeUnit.MILLISECONDS);
        if (!connected) {
            throw new IllegalStateException("zookeeper not connected");
        }
    } catch (Exception e) {
        throw new IllegalStateException(e.getMessage(), e);
    }
}
```

**注册**的方法并没有重写父类的，所以注册会先进到FailbackRegistry的register()方法：

```java
public void register(URL url) {
    if (!acceptable(url)) {
        return;
    }
    super.register(url);
    // 把这个url相关的失败注册、下线任务清理
    removeFailedRegistered(url);
    removeFailedUnregistered(url);
    try {
        // 这里调用具体子类的逻辑
        doRegister(url);
    } catch (Exception e) {
        Throwable t = e;

        // 配置check参数是false才会重试
        boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)
                && url.getParameter(Constants.CHECK_KEY, true)
                && !(url.getPort() == 0);
        boolean skipFailback = t instanceof SkipFailbackWrapperException;
        if (check || skipFailback) {
            if (skipFailback) {
                t = t.getCause();
            }
            throw new IllegalStateException("Failed to register " + url + " to registry " + getUrl().getAddress() + ", cause: " + t.getMessage(), t);
        } else {
            logger.error("Failed to register " + url + ", waiting for retry, cause: " + t.getMessage(), t);
        }
        // 注册失败向时间轮中添加失败任务
        addFailedRegistered(url);
    }
}
```

doRegister()就是用zkClient创建临时节点：

```java
@Override
public void doRegister(URL url) {
    try {
        // 这个就是检查zkClient有没有被初始化
        checkDestroyed();
        // 把URL转成目录，创建临时节点
        // 目录类似于/dubbo/接口路径/categoryPath[provider,consumer]/ip……
        zkClient.create(toUrlPath(url), url.getParameter(DYNAMIC_KEY, true));
    } catch (Throwable e) {
        throw new RpcException("Failed to register " + url + " to zookeeper " + getUrl() + ", cause: " + e.getMessage(), e);
    }
}
```

创建临时节点就是调用curator的api：

```java
public void createEphemeral(String path) {
    try {
        client.create().withMode(CreateMode.EPHEMERAL).forPath(path);
    } catch (NodeExistsException e) {
        logger.warn("ZNode " + path + " already exists, since we will only try to recreate a node on a session expiration, this duplication might be caused by a delete delay from the zk server, which means the old expired session may still holds this ZNode and the server just hasn't got time to do the deletion. In this case, we can just try to delete and create again.", e);
        // 如果重复创建，要先删掉这个节点，在重新注册
        // 这个就是解决zk因为网络抖动节点丢失的问题
        deletePath(path);
        createEphemeral(path);
    } catch (Exception e) {
        throw new IllegalStateException(e.getMessage(), e);
    }
}
```

下线的操作和注册差不多。

**订阅**也是走到了FailbackRegistry的subscribe()方法:

```java
public void subscribe(URL url, NotifyListener listener) {
    // 调用父类的订阅方法
    // 把传进来的监听器放到set里
    super.subscribe(url, listener);
    // 移除失败的订阅任务
    removeFailedSubscribed(url, listener);
    try {
        // Sending a subscription request to the server side
        // 这里就是执行订阅的代码，直接走到了zkRegistry中
        doSubscribe(url, listener);
    } catch (Exception e) {
        Throwable t = e;
        // 如果失败的话尝试拿到之前从磁盘缓存读取出来的url信息容错处理
        List<URL> urls = getCacheUrls(url);
        if (CollectionUtils.isNotEmpty(urls)) {
            notify(url, listener, urls);
        } else {
            // 没有缓存并且配置check参数是false才会重试
            boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)
                    && url.getParameter(Constants.CHECK_KEY, true);
            boolean skipFailback = t instanceof SkipFailbackWrapperException;
            if (check || skipFailback) {
                if (skipFailback) {
                    t = t.getCause();
                }
                throw new IllegalStateException("Failed to subscribe " + url + ", cause: " + t.getMessage(), t);
            }
        }
        // Record a failed registration request to a failed list, retry regularly
        addFailedSubscribed(url, listener);
    }
}
```

doSubscribe()又会调到ZookeeperRegistry里：

```java
public void doSubscribe(final URL url, final NotifyListener listener) {
    try {
        checkDestroyed();
        if (ANY_VALUE.equals(url.getServiceInterface())) {
            String root = toRootPath();
            boolean check = url.getParameter(CHECK_KEY, false);
            ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.computeIfAbsent(url, k -> new ConcurrentHashMap<>());
            ChildListener zkListener = listeners.computeIfAbsent(listener, k -> (parentPath, currentChilds) -> {
                for (String child : currentChilds) {
                    child = URL.decode(child);
                    if (!anyServices.contains(child)) {
                        anyServices.add(child);
                        subscribe(url.setPath(child).addParameters(INTERFACE_KEY, child,
                            Constants.CHECK_KEY, String.valueOf(check)), k);
                    }
                }
            });
            zkClient.create(root, false);
            List<String> services = zkClient.addChildListener(root, zkListener);
            if (CollectionUtils.isNotEmpty(services)) {
                for (String service : services) {
                    service = URL.decode(service);
                    anyServices.add(service);
                    subscribe(url.setPath(service).addParameters(INTERFACE_KEY, service,
                        Constants.CHECK_KEY, String.valueOf(check)), listener);
                }
            }
        } else {
            // 正常来说都是针对指定的接口进行监听
            CountDownLatch latch = new CountDownLatch(1);
            try {
                List<URL> urls = new ArrayList<>();
                // toCategoriesPath()拿到的是/dubbo/接口路径/provider
                // 拿到这个节点之后就可以监听这个节点下的子节点了
                for (String path : toCategoriesPath(url)) {
                    ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.computeIfAbsent(url, k -> new ConcurrentHashMap<>());
                    // ChildListener是zk的子节点监听
                    ChildListener zkListener = listeners.computeIfAbsent(listener, k -> new RegistryChildListenerImpl(url, path, k, latch));
                    if (zkListener instanceof RegistryChildListenerImpl) {
                        ((RegistryChildListenerImpl) zkListener).setLatch(latch);
                    }
                    // 创建持久节点
                    // 其实是对/dubbo/接口路径/provider路径的检查
                    zkClient.create(path, false);
                    // 对子节点监听
                    List<String> children = zkClient.addChildListener(path, zkListener);
                    if (children != null) {
                        // 每个children都是一个子节点字符串，把他们转成具体的服务URL
                        // 而且toUrlsWithEmpty调用的是CacheableFailbackRegistry父类
                        urls.addAll(toUrlsWithEmpty(url, path, children));
                    }
                }
                // 这里是对每个实例的客户端建立netty连接
                // 这个类里的notify()就是调用父类的notify()
                notify(url, listener, urls);
            } finally {
                // tells the listener to run only after the sync notification of main thread finishes.
                latch.countDown();
            }
        }
    } catch (Throwable e) {
        throw new RpcException("Failed to subscribe " + url + " to zookeeper " + getUrl() + ", cause: " + e.getMessage(), e);
    }
}
```

调用toUrlsWithEmpty()进行raw url -> URL的时候，使用父类进行缓存优化。

notify()方法会去调用抽象父类AbstractRegistry里：

```java
protected void notify(URL url, NotifyListener listener, List<URL> urls) {
    // 上面是一堆校验
    // keep every provider's category.
    Map<String, List<URL>> result = new HashMap<>();
    for (URL u : urls) {
        if (UrlUtils.isMatch(url, u)) {
            String category = u.getCategory(DEFAULT_CATEGORY);
            List<URL> categoryList = result.computeIfAbsent(category, k -> new ArrayList<>());
            categoryList.add(u);
        }
    }
    if (result.size() == 0) {
        return;
    }
    Map<String, List<URL>> categoryNotified = notified.computeIfAbsent(url, u -> new ConcurrentHashMap<>());
    // 遍历 回调listener的notify()
    for (Map.Entry<String, List<URL>> entry : result.entrySet()) {
        String category = entry.getKey();
        List<URL> categoryList = entry.getValue();
        categoryNotified.put(category, categoryList);
        listener.notify(categoryList);
        if (localCacheEnabled) {
            // 缓存数据刷盘
            saveProperties(url);
        }
    }
}
```

listener.notify()，这个listener是NotifyListener类型，这里的notify()走到了RegistryDirectory里，因为RegistryDirectory继承了DynamicDirectory，而DynamicDirectory是实现了NotifyListener接口的。就是在RegistryDirectory里进行了netty连接+DubboInvoker封装。

###### 2）NacosRegistry源码

NacosRegistry是直接注册FailbackRegistry的，没有row url -> URL的转换。和zk的registry思路一样，只不多他使用的是nacos提供的api。

###### 3）DNSRegistry

使用dns当注册中心，那么dns保存的就不是域名和ip的映射了，保存的应该是接口名称和ip的映射。

dubbo中没有实现DNSRegistry，里面都是空方法。但是他有个DNSServiceDiscovery。

##### 2.配置中心

获取具体的配置中心是根据配置中心的url中的protocol属性，protocol可以是nacos、zookeeper、appllo。

配置中心没有什么代码，都是别人声明一个监听，然后来调用配置中心添加监听器，这样配置发生变化的时候，对应的关注这个配置的类就会收到监听。

###### 1）ZookeeperDynamicConfiguration

看下构造方法：

```java
ZookeeperDynamicConfiguration(URL url, ZookeeperTransporter zookeeperTransporter) {
    // 这个url就是zk的链接地址
    // super(url)里也没干啥，就是创建了个线程池
    super(url);
    this.url = url;
    rootPath = getRootPath(url);
	// 这个就是缓存每个节点对应的所有监听器的
    this.cacheListener = new CacheListener(rootPath);

    final String threadName = this.getClass().getSimpleName();
    // 又搞了个线程池
    this.executor = new ThreadPoolExecutor(DEFAULT_ZK_EXECUTOR_THREADS_NUM, DEFAULT_ZK_EXECUTOR_THREADS_NUM,
            THREAD_KEEP_ALIVE_TIME, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<Runnable>(DEFAULT_QUEUE),
            new NamedThreadFactory(threadName, true),
            new AbortPolicyWithReport(threadName, url));

    // 基于ZookeeperTransporter创建zk客户端
    zkClient = zookeeperTransporter.connect(url);
    boolean isConnected = zkClient.isConnected();
    if (!isConnected) {
        throw new IllegalStateException("Failed to connect with zookeeper, pls check if url " + url + " is correct.");
    }
}
```

添加监听：

```java
/**
 * 这个方法在MeshRuleManager和MigrationRuleListener初始化的时候会调用CompositeDynamicConfiguration的addListener()
 * 然后调到这个方法添加监听
 * 当监听到节点有变化时就会反过来调用监听
 */
@Override
protected void doAddListener(String pathKey, ConfigurationListener listener) {
    cacheListener.addListener(pathKey, listener);
    zkClient.addDataListener(pathKey, cacheListener, executor);
}
```

###### 2）nacos和apollo配置中心

他俩和zk的思路一样，都是维护一堆监听，收到对应配置中心回调的时候再去回调维护的监听，而且都有现成的api。

###### 3）元数据中心

以provider启动来说，在ServiceConfig的init()方法中会获取ModelDeployer，然后调用他的start()方法，然后调用ApplicationDeployer的initialize()方法，这个方法里会初始化配置中心和元数据中心。就是把接口的属性、版本号什么赋值，然后在发布的时候，判断需要远程发布的下面有一行代码是上报元数据的：

```java
MetadataUtils.publishServiceDefinition(url);
```

最终会调用到AbstractMetadataReport的storeProviderMetadataTask()：

```java
private void storeProviderMetadataTask(MetadataIdentifier providerMetadataIdentifier, ServiceDefinition serviceDefinition) {
    try {
        if (logger.isInfoEnabled()) {
            logger.info("store provider metadata. Identifier : " + providerMetadataIdentifier + "; definition: " + serviceDefinition);
        }
        allMetadataReports.put(providerMetadataIdentifier, serviceDefinition);
        failedReports.remove(providerMetadataIdentifier);
        // 把元数据转成json
        Gson gson = new Gson();
        String data = gson.toJson(serviceDefinition);
        // 调用对应的元数据上报实现，上报元数据
        // 比如zookeeper就是ZookeeperMetadataReport
        doStoreProviderMetadata(providerMetadataIdentifier, data);
        saveProperties(providerMetadataIdentifier, data, true, !syncReport);
    } catch (Exception e) {
        // retry again. If failed again, throw exception.
        failedReports.put(providerMetadataIdentifier, serviceDefinition);
        metadataReportRetry.startRetryTask();
        logger.error("Failed to put provider metadata " + providerMetadataIdentifier + " in  " + serviceDefinition + ", cause: " + e.getMessage(), e);
    }
}
```

### 三、启动时检查

启动时检查的配置有3个

```properties
# 关闭具体服务的启动时检查，没有提供者时不报错
dubbo.reference.具体的接口路径.check=false
# 关闭所有服务的启动时检查
dubbo.consumer.check=false
# 关闭注册中心的启动时检查，关闭这个如果注册订阅失败也允许启动，会在后台定时重试
dubbo.registry.check=false
```

前两个都是针对consumer的，对应的代码在ReferenceConfig的checkInvokerAvailable()里：

```java
private void checkInvokerAvailable() throws IllegalStateException {
    // shouldCheck()就是上面的参数，具体的还没看
    // invoker.isAvailable()就是通过netty判断是否连接
    if (shouldCheck() && !invoker.isAvailable()) {
        invoker.destroy();
        throw new IllegalStateException("Should has at least one way to know which services this interface belongs to," + " subscription url: " + invoker.getUrl());
    }
}
```

### 四、多注册中心

多注册中心的源码对应MultipleRegistry，代码都差不多，就是用for循环注册、订阅什么的。

