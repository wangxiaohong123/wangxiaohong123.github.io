---
title: 7.cluster模块源码
tags:
  - 源码
categories: Dubbo
copyright: true
---

cluster模块里主要的组件有Directory(管理集群信息)、Cluster+ClusterInvoker(集群容错)、LoadBalance(负载均衡)、Router(筛选可以访问的invokers)。

### 1.Directory

在源码中关于这个接口主要用到的实现类就是RegistryDirectory，RegistryDirectory是DynamicDirectory的子类，这两个实现类都是在dubbo_registry模块里的。先看DynamicDirectory的代码。

DynamicDirectory的类注释上写的RegistryDirectory，因为在2.6.x、2.7.x的版本这个类就是叫RegistryDirectory，3.0之后改名为DynamicDirectory，他是用来做目标服务发现和集群信息维护的最核心的组件，Dynamic的意思是维护目标实例集群地址不光要主动拉取，一般第一次的时候会主动拉取，还需要在注册中心注册监听，动态维护目标实例集群。注意这里只是目标实例，每个目标实例都有自己的DynamicDirectory，看构造方法，没啥东西，都是一些变量的初始化，url设置什么的，之前看到在实例化这个类之后调用了subscribe()方法，在进到这个方法里：

##### subscribe()源码

```java
public void subscribe(URL url) {
    // 这个就是设置了一下url，set方法，没啥看的
    setSubscribeUrl(url);
    // 这个方法就很关键，用来在最开始的时候拿到目标服务实例集群地址
    // 订阅！用zk相关的registry进行订阅
    registry.subscribe(url, this);
}
```

这个时候的registry是ListenerRegistryWrapper，这个ListenerRegistryWrapper不是重点，因为他里面就是一个try finally，继续调用registry.subscribe(url, listener);这个时候的registry是ServiceDiscoveryRegistry……，最后会走到ZookeeperRegistry的doSubscribe()方法里。这个方法里会为节点添加监听：

```java
zkClient.addChildListener(path, zkListener);
```

zk节点监听器中重写了childChanged()方法：

```java
public void childChanged(String path, List<String> children) {
    try {
        latch.await();
    } catch (InterruptedException e) {
        logger.warn("Zookeeper children listener thread was interrupted unexpectedly, may cause race condition with the main thread.");
    }
    // notifier是在构造方法里创建的RegistryNotifier
    notifier.notify(children);
}
```

最后会一层一层调用到RegistryDirectory的refreshInvoker()方法，在这里会建立netty连接，构建DubboInvoker。

##### doList()源码

doList()方法就会获取可用的目标实例集群信息：

```java
public List<Invoker<T>> doList(Invocation invocation) {
    if (forbidden) {
        // 1. No service provider 2. Service providers are disabled
        throw new RpcException(RpcException.FORBIDDEN_EXCEPTION, "No provider available from registry " +
                               getUrl().getAddress() + " for service " + getConsumerUrl().getServiceKey() + " on consumer " +
                               NetUtils.getLocalHost() + " use dubbo version " + Version.getVersion() +
                               ", please check status of providers(disabled, not registered or in blacklist).");
    }

    if (multiGroup) {
        return this.invokers == null ? Collections.emptyList() : this.invokers;
    }

    List<Invoker<T>> invokers = null;
    try {
        // 这里可以筛选出来可以访问的特定的provider实例
        // 比如灰度发布，按照版本
        invokers = routerChain.route(getConsumerUrl(), invocation);
    } catch (Throwable t) {
        logger.error("Failed to execute router: " + getUrl() + ", cause: " + t.getMessage(), t);
    }

    return invokers == null ? Collections.emptyList() : invokers;
}
```

### 2.Cluster+ClusterInvoker

有6种集群容错策略：

1.   故障转移集群模式(failover)：呼叫失败的时候将自动切换到其他节点，也叫重试机制，如果接口支持幂等，允许重复调用可以使用这个模式。
2.   快速失败模式(failfast)：只调用一次，如果失败就抛出异常，如果接口不支持幂等，就要用这个模式保证只掉1次，比如下单，如果失败就失败，让用户重新下单。
3.   失败安全模式(failsafe)：如果调用失败，不抛出异常，只打印日志，如果接口的数据可有可无，使用这个模式。
4.   失败自动恢复(failback)：调用失败会记录，然后定时重试。
5.   并行多路调用模式(forking)：并行调用多个provider，返回第一个结果，他是并行调用，比较消耗CPU。
6.   广播模式(broadcast)：广播所有provider，有一个失败就算失败。

除了并行模式和广播模式，其他的模式选择节点的代码都在AbstractClusterInvoker中，这个是他们的父类，选择节点的方法是select():

```java
protected Invoker<T> select(LoadBalance loadbalance, Invocation invocation,
                            List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException {

    if (CollectionUtils.isEmpty(invokers)) {
        return null;
    }
    // invocation差不多就表示一次调用，如果invocation是空，方法名会被定义成空字符串，否则就是invocation里的方法名
    String methodName = invocation == null ? StringUtils.EMPTY_STRING : invocation.getMethodName();

    // sticky默认是false
    // 这个是dubbo的粘滞链接
    // 粘滞链接是尽可能保证多次调用到同一个provider
    // 什么时候会用到粘滞链接？比如调用一个provider，provider可能把结果缓存到jvm，我们就可以使用粘滞链接，避免其他provider再次缓存
    boolean sticky = invokers.get(0).getUrl()
            .getMethodParameter(methodName, CLUSTER_STICKY_KEY, DEFAULT_CLUSTER_STICKY);

    // 经过一系列条件
    // 如果!invokers.contains(stickyInvoker)说明provider挂了
    // 此时应该重新选择一个粘滞链接
    if (stickyInvoker != null && !invokers.contains(stickyInvoker)) {
        stickyInvoker = null;
    }
    //ignore concurrency problem
    if (sticky && stickyInvoker != null && (selected == null || !selected.contains(stickyInvoker))) {
        if (availablecheck && stickyInvoker.isAvailable()) {
            return stickyInvoker;
        }
    }

    // 走到这说明尽管设置了粘滞链接，但是没有生效
    // 可能是因为第一次调用，也可能是provider挂了
    // 此时需要根据负载均衡策略选择一个invoker
    Invoker<T> invoker = doSelect(loadbalance, invocation, invokers, selected);

    // 如果是粘滞链接就把stickyInvoker赋值
    if (sticky) {
        stickyInvoker = invoker;
    }

    return invoker;
}
```

这个方法只是进行校验和处理粘滞链接，真正的选择节点方法在doSelect()里：

```java
/**
 * 大概思路就是优先选择没有调用过的
 * 如果没有满足条件的，在调用过的并且可用的节点中选择
 * 如果调用过的节点中没有满足条件就使用下一个invoker，反正也是失败
 */
private Invoker<T> doSelect(LoadBalance loadbalance, Invocation invocation,
                            List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException {

    if (CollectionUtils.isEmpty(invokers)) {
        return null;
    }
    // 如果只有1个invoker，不需要复杂均衡直接返回这个invoker
    if (invokers.size() == 1) {
        return invokers.get(0);
    }
    // 负载均衡策略选择一个invoker
    Invoker<T> invoker = loadbalance.select(invokers, getUrl(), invocation);

    // 如果选择的invoker是已经选择过了，或者选择的invoker是不可用的就要重新选择一个invoker
    if ((selected != null && selected.contains(invoker))
            || (!invoker.isAvailable() && getUrl() != null && availablecheck)) {
        try {
            // 重新选择
            Invoker<T> rInvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);
            if (rInvoker != null) {
                invoker = rInvoker;
            } else {
                // 如果选来选去都是空直接拿到下一个invoker
                // 需要看一下什么时候会返回空
                // invokers里的invoker都不可用会返回空
                // loadbalance.select()也可能会返回空
                int index = invokers.indexOf(invoker);
                try {
                    //Avoid collision
                    invoker = invokers.get((index + 1) % invokers.size());
                } catch (Exception e) {
                    logger.warn(e.getMessage() + " may because invokers list dynamic change, ignore.", e);
                }
            }
        } catch (Throwable t) {
            logger.error("cluster reselect fail reason is :" + t.getMessage() + " if can not solve, you can set cluster.availablecheck=false in url", t);
        }
    }

    return invoker;
}

/**
 * 重新选择节点
 */
private Invoker<T> reselect(LoadBalance loadbalance, Invocation invocation,
                            List<Invoker<T>> invokers, List<Invoker<T>> selected, boolean availablecheck) throws RpcException {

    //Allocating one in advance, this list is certain to be used.
    List<Invoker<T>> reselectInvokers = new ArrayList<>(
            invokers.size() > 1 ? (invokers.size() - 1) : invokers.size());

    // 把可用的invoker和没选择过的invoker挑出来
    for (Invoker<T> invoker : invokers) {
        if (availablecheck && !invoker.isAvailable()) {
            continue;
        }

        if (selected == null || !selected.contains(invoker)) {
            reselectInvokers.add(invoker);
        }
    }

    // 如果有没选择过的可用的invoker，重新根据负载均衡策略选择一次invoker
    if (!reselectInvokers.isEmpty()) {
        return loadbalance.select(reselectInvokers, getUrl(), invocation);
    }

    // 如果invokers里都是不可用的或者选择过的，就在可用的invoker里重新根据负载均衡策略选择一次invoker
    if (selected != null) {
        for (Invoker<T> invoker : selected) {
            if ((invoker.isAvailable()) // available first
                    && !reselectInvokers.contains(invoker)) {
                reselectInvokers.add(invoker);
            }
        }
    }
    if (!reselectInvokers.isEmpty()) {
        return loadbalance.select(reselectInvokers, getUrl(), invocation);
    }

    return null;
}
```

###### 1)重试模式

重试模式对应FailoverClusterInvoker，发起rpc调用时会走到这个类的doInvoke()方法：

```java
public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
    List<Invoker<T>> copyInvokers = invokers;
    // 检查invokers是否是空
    checkInvokers(copyInvokers, invocation);
    String methodName = RpcUtils.getMethodName(invocation);
    // 计算invoke的次数，猜测这个跟重试相关的
    // 根据的配置是retries + 1，但是默认值，一写用到相同配置的地方的默认值可能不一样
    int len = calculateInvokeTimes(methodName);
    // retry loop.
    RpcException le = null; // last exception.
    List<Invoker<T>> invoked = new ArrayList<Invoker<T>>(copyInvokers.size()); // invoked invokers.
    // 这里放的是invoker的address，size还是len
    // 但是这个不是控制调用次数的，这个就是为了输出日志的
    Set<String> providers = new HashSet<String>(len);
    for (int i = 0; i < len; i++) {
        //Reselect before retry to avoid a change of candidate `invokers`.
        //NOTE: if `invokers` changed, then `invoked` also lose accuracy.
        if (i > 0) {
            // 检查invoker是否被销毁
            checkWhetherDestroyed();
            // 重新拿到invokers
            copyInvokers = list(invocation);
            // 在检查一下目标肌群中是否有节点
            checkInvokers(copyInvokers, invocation);
        }
        // 选择一个invoker
        Invoker<T> invoker = select(loadbalance, invocation, copyInvokers, invoked);
        // 尽量不重试已经请求过的invoker
        invoked.add(invoker);
        RpcContext.getServiceContext().setInvokers((List) invoked);
        try {
            // 这里就是执行rpc的代码了
            Result result = invokeWithContext(invoker, invocation);
            if (le != null && logger.isWarnEnabled()) {
                // 虽然这次成功了，但是之前调用存在失败的情况
                // 把失败的信息打印出来
                logger.warn("Although retry the method " + methodName
                        + " in the service " + getInterface().getName()
                        + " was successful by the provider " + invoker.getUrl().getAddress()
                        + ", but there have been failed providers " + providers
                        + " (" + providers.size() + "/" + copyInvokers.size()
                        + ") from the registry " + directory.getUrl().getAddress()
                        + " on the consumer " + NetUtils.getLocalHost()
                        + " using the dubbo version " + Version.getVersion() + ". Last error is: "
                        + le.getMessage(), le);
            }
            return result;
        } catch (RpcException e) {
            if (e.isBiz()) { // biz exception.
                throw e;
            }
            le = e;
        } catch (Throwable e) {
            le = new RpcException(e.getMessage(), e);
        } finally {
            providers.add(invoker.getUrl().getAddress());
        }
    }
    // 超过最大调用次数还是失败就抛出异常
    throw new RpcException(le.getCode(), "Failed to invoke the method "
            + methodName + " in the service " + getInterface().getName()
            + ". Tried " + len + " times of the providers " + providers
            + " (" + providers.size() + "/" + copyInvokers.size()
            + ") from the registry " + directory.getUrl().getAddress()
            + " on the consumer " + NetUtils.getLocalHost() + " using the dubbo version "
            + Version.getVersion() + ". Last error is: "
            + le.getMessage(), le.getCause() != null ? le.getCause() : le);
}
```

###### 2)快速失败模式

快速失败对应FailfastClusterInvoker，他和

```java
public Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
    // 检查节点是否为空
    checkInvokers(invokers, invocation);
    Invoker<T> invoker = select(loadbalance, invocation, invokers, null);
    try {
        return invokeWithContext(invoker, invocation);
    } catch (Throwable e) {
        if (e instanceof RpcException && ((RpcException) e).isBiz()) { // biz exception.
            throw (RpcException) e;
        }
        throw new RpcException(e instanceof RpcException ? ((RpcException) e).getCode() : 0,
            "Failfast invoke providers " + invoker.getUrl() + " " + loadbalance.getClass().getSimpleName()
                + " for service " + getInterface().getName()
                + " method " + invocation.getMethodName() + " on consumer " + NetUtils.getLocalHost()
                + " use dubbo version " + Version.getVersion()
                + ", but no luck to perform the invocation. Last error is: " + e.getMessage(),
            e.getCause() != null ? e.getCause() : e);
    }
}
```

###### 3)安全失败模式

failsafe模式对应FailsafeClusterInvoker

```java
public Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
    try {
        checkInvokers(invokers, invocation);
        Invoker<T> invoker = select(loadbalance, invocation, invokers, null);
        return invokeWithContext(invoker, invocation);
    } catch (Throwable e) {
        logger.error("Failsafe ignore exception: " + e.getMessage(), e);
        return AsyncRpcResult.newDefaultAsyncResult(null, null, invocation); // ignore
    }
}
```

###### 4)失败自动恢复模式

这个模式基于自己的时间轮实现的重试，对应FailbackClusterInvoker

```java
protected Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
    Invoker<T> invoker = null;
    URL consumerUrl = RpcContext.getServiceContext().getConsumerUrl();
    try {
        checkInvokers(invokers, invocation);
        invoker = select(loadbalance, invocation, invokers, null);
        // Asynchronous call method must be used here, because failback will retry in the background.
        // Then the serviceContext will be cleared after the call is completed.
        // 这个是异步调用，但是方法体和invokeWithContext()一样
        return invokeWithContextAsync(invoker, invocation, consumerUrl);
    } catch (Throwable e) {
        logger.error("Failback to invoke method " + invocation.getMethodName() + ", wait for retry in background. Ignored exception: "
            + e.getMessage() + ", ", e);
        if (retries > 0) {
            // 如果配置了重试，提交到TimerTask
            addFailed(loadbalance, invocation, invokers, invoker, consumerUrl);
        }
        return AsyncRpcResult.newDefaultAsyncResult(null, null, invocation); // ignore
    }
}
```

提交重试任务就是先初始化时间轮，然后通过时间轮定时重试任务：

```java
private void addFailed(LoadBalance loadbalance, Invocation invocation, List<Invoker<T>> invokers, Invoker<T> lastInvoker, URL consumerUrl) {
    // double check，保证多线程并发安全问题
    // 初始化Hash时间轮
    if (failTimer == null) {
        synchronized (this) {
            if (failTimer == null) {
                failTimer = new HashedWheelTimer(
                    new NamedThreadFactory("failback-cluster-timer", true),
                    1,
                    TimeUnit.SECONDS, 32, failbackTasks);
            }
        }
    }
    // 创建重试任务
    RetryTimerTask retryTimerTask = new RetryTimerTask(loadbalance, invocation, invokers, lastInvoker, retries, RETRY_FAILED_PERIOD, consumerUrl);
    try {
        failTimer.newTimeout(retryTimerTask, RETRY_FAILED_PERIOD, TimeUnit.SECONDS);
    } catch (Throwable e) {
        logger.error("Failback background works error, invocation->" + invocation + ", exception: " + e.getMessage());
    }
}
```

**TODO 时间轮源码：**

###### 5)广播模式

广播模式对应BroadcastClusterInvoker

```java
public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
    checkInvokers(invokers, invocation);
    // 把所有目标节点放到RPC上下文里
    RpcContext.getServiceContext().setInvokers((List) invokers);
    RpcException exception = null;
    Result result = null;
    URL url = getUrl();
    // 这个是广播失败的比例容忍度，最小0，最大100，默认是100
    // 这个参数不能决定调用结果，而是控制什么时候调用结束的，只要有一个失败，还是会返回异常
    // 比如配置了30，意思是当调用失败比例达到30%将不再继续调用
    int broadcastFailPercent = url.getParameter(BROADCAST_FAIL_PERCENT_KEY, MAX_BROADCAST_FAIL_PERCENT);

    if (broadcastFailPercent < MIN_BROADCAST_FAIL_PERCENT || broadcastFailPercent > MAX_BROADCAST_FAIL_PERCENT) {
        logger.info(String.format("The value corresponding to the broadcast.fail.percent parameter must be between 0 and 100. " +
                "The current setting is %s, which is reset to 100.", broadcastFailPercent));
        broadcastFailPercent = MAX_BROADCAST_FAIL_PERCENT;
    }

    // 根据比例计算允许失败的机器数
    int failThresholdIndex = invokers.size() * broadcastFailPercent / MAX_BROADCAST_FAIL_PERCENT;
    int failIndex = 0;
    // 开始顺序遍历
    // 只要失败的节点数没达到failThresholdIndex就一直遍历
    for (Invoker<T> invoker : invokers) {
        try {
            result = invokeWithContext(invoker, invocation);
            if (null != result && result.hasException()) {
                Throwable resultException = result.getException();
                if (null != resultException) {
                    exception = getRpcException(result.getException());
                    logger.warn(exception.getMessage(), exception);
                    failIndex++;
                    if (failIndex == failThresholdIndex) {
                        break;
                    }
                }
            }
        } catch (Throwable e) {
            exception = getRpcException(e);
            logger.warn(exception.getMessage(), exception);
            failIndex++;
            if (failIndex == failThresholdIndex) {
                break;
            }
        }
    }

    // 有一个调用失败就是失败
    if (exception != null) {
        if (failIndex == failThresholdIndex) {
            logger.debug(
                    String.format("The number of BroadcastCluster call failures has reached the threshold %s", failThresholdIndex));
        } else {
            logger.debug(String.format("The number of BroadcastCluster call failures has not reached the threshold %s, fail size is %s",
                    failThresholdIndex, failIndex));
        }
        throw exception;
    }

    return result;
}
```

###### 6)并行调用模式

forking模式对应ForkingClusterInvoker

```java
public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
    try {
        checkInvokers(invokers, invocation);
        final List<Invoker<T>> selected;
        // 默认并行度是2
        final int forks = getUrl().getParameter(FORKS_KEY, DEFAULT_FORKS);
        // 默认超时时间是1s
        final int timeout = getUrl().getParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);
        if (forks <= 0 || forks >= invokers.size()) {
            // 如果配置的并行度小于0或者大于目标集群节点数量就把目标节点赋值成所有集群节点
            selected = invokers;
        } else {
            // 否则就使用负载均衡一直选择节点，直到满足并行度
            selected = new ArrayList<>(forks);
            while (selected.size() < forks) {
                Invoker<T> invoker = select(loadbalance, invocation, invokers, selected);
                if (!selected.contains(invoker)) {
                    //Avoid add the same invoker several times.
                    selected.add(invoker);
                }
            }
        }
        RpcContext.getServiceContext().setInvokers((List) selected);
        final AtomicInteger count = new AtomicInteger();
        final BlockingQueue<Object> ref = new LinkedBlockingQueue<>();
        // 遍历invoker，把结果放到队列里
        for (final Invoker<T> invoker : selected) {
            URL consumerUrl = RpcContext.getServiceContext().getConsumerUrl();
            executor.execute(() -> {
                try {
                    Result result = invokeWithContextAsync(invoker, invocation, consumerUrl);
                    ref.offer(result);
                } catch (Throwable e) {
                    // 只要失败计数加1，如果计数==selected.size，就把这个结果放到队里里
                    // 这个是尽可能保证有成功的结果进到队列里
                    // 如果都失败也会有一个失败的结果进到队列里
                    int value = count.incrementAndGet();
                    if (value >= selected.size()) {
                        ref.offer(e);
                    }
                }
            });
        }
        try {
            // 拿到第一个结果，有结果就返回结果，是异常就抛出异常
            Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS);
            if (ret instanceof Throwable) {
                Throwable e = (Throwable) ret;
                throw new RpcException(e instanceof RpcException ? ((RpcException) e).getCode() : RpcException.UNKNOWN_EXCEPTION,
                    "Failed to forking invoke provider " + selected + ", but no luck to perform the invocation. " +
                        "Last error is: " + e.getMessage(), e.getCause() != null ? e.getCause() : e);
            }
            return (Result) ret;
        } catch (InterruptedException e) {
            throw new RpcException("Failed to forking invoke provider " + selected + ", " +
                "but no luck to perform the invocation. Last error is: " + e.getMessage(), e);
        }
    } finally {
        // clear attachments which is binding to current thread.
        RpcContext.getClientAttachment().clearAttachments();
    }
}
```

### 3.LoadBalance

dubbo自己实现了5中负载均衡算法：

1.   带权重的随机
2.   带权重的轮询
3.   最小活跃
4.   一致性哈希
5.   最短响应时间

负载均衡的父类是AbstractLoadBalance，这个里面有一个计算权重的方法：

```java
protected int getWeight(Invoker<?> invoker, Invocation invocation) {
    int weight;
    URL url = invoker.getUrl();
    // 处理多注册中心场景
    if (REGISTRY_SERVICE_REFERENCE_PATH.equals(url.getServiceInterface())) {
        weight = url.getParameter(REGISTRY_KEY + "." + WEIGHT_KEY, DEFAULT_WEIGHT);
    } else {
        // 获取方法的weight属性，默认是100
        weight = url.getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);
        if (weight > 0) {
            // 获取timestamp配置
            long timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, 0L);
            if (timestamp > 0L) {
                long uptime = System.currentTimeMillis() - timestamp;
                if (uptime < 0) {
                    return 1;
                }
                // 获取warmup配置，默认10 * 60 * 1000
                int warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);
                if (uptime > 0 && uptime < warmup) {
                    // 计算权重
                    weight = calculateWarmupWeight((int)uptime, warmup, weight);
                }
            }
        }
    }
    return Math.max(weight, 0);
}
```

###### 1）随机负载均衡

带权重的随机对应RandomLoadBalance，他在选择的时候回先判断是否需要权重：

```java
private <T> boolean needWeightLoadBalance(List<Invoker<T>> invokers, Invocation invocation) {

    Invoker invoker = invokers.get(0);
    URL invokerUrl = invoker.getUrl();
    // 这个是处理RegistryService接口的
    // 这个是多注册中心场景的负载均衡
    if (REGISTRY_SERVICE_REFERENCE_PATH.equals(invokerUrl.getServiceInterface())) {
        String weight = invokerUrl.getParameter(REGISTRY_KEY + "." + WEIGHT_KEY);
        if (StringUtils.isNotEmpty(weight)) {
            return true;
        }
    } else {
        // 从方法的配置里获取weight的值，如果没有就从全局配置中获取
        String weight = invokerUrl.getMethodParameter(invocation.getMethodName(), WEIGHT_KEY);
        if (StringUtils.isNotEmpty(weight)) {
            return true;
        }else {
            // 获取timestamp配置
            String timeStamp = invoker.getUrl().getParameter(TIMESTAMP_KEY);
            if (StringUtils.isNotEmpty(timeStamp)) {
                return true;
            }
        }
    }
    return false;
}
```

然后进行选择：

```java
protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
    // 拿到invokers的数量
    int length = invokers.size();
    // 判断是否使用权重
    if (!needWeightLoadBalance(invokers,invocation)){
        // 如果不需要权重，直接生成一个随机数
        return invokers.get(ThreadLocalRandom.current().nextInt(length));
    }

    // Every invoker has the same weight?
    boolean sameWeight = true;
    // the maxWeight of every invokers, the minWeight = 0 or the maxWeight of the last invoker
    int[] weights = new int[length];
    // The sum of weights
    int totalWeight = 0;
    // 计算每个invoker的权重，他存的累加值。判断是否哦权重都相同
    for (int i = 0; i < length; i++) {
        // 获取权重
        int weight = getWeight(invokers.get(i), invocation);
        // Sum
        totalWeight += weight;
        // save for later use
        weights[i] = totalWeight;
        if (sameWeight && totalWeight != weight * (i + 1)) {
            sameWeight = false;
        }
    }
    if (totalWeight > 0 && !sameWeight) {
        // If (not every invoker has the same weight & at least one invoker's weight>0), select randomly based on totalWeight.
        // 根据总权重生成一个随机值，然后根据这个随机值拿到一个invoker
        int offset = ThreadLocalRandom.current().nextInt(totalWeight);
        // Return a invoker based on the random value.
        for (int i = 0; i < length; i++) {
            if (offset < weights[i]) {
                return invokers.get(i);
            }
        }
    }
    // 如果权重相同或者权重都是0就随机选一个
    return invokers.get(ThreadLocalRandom.current().nextInt(length));
}
```

###### 2）轮询负载均衡

轮询对应RoundRobinLoadBalance：

```java
protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
    String key = invokers.get(0).getUrl().getServiceKey() + "." + invocation.getMethodName();
    ConcurrentMap<String, WeightedRoundRobin> map = methodWeightMap.computeIfAbsent(key, k -> new ConcurrentHashMap<>());
    int totalWeight = 0;
    long maxCurrent = Long.MIN_VALUE;
    long now = System.currentTimeMillis();
    Invoker<T> selectedInvoker = null;
    WeightedRoundRobin selectedWRR = null;
    for (Invoker<T> invoker : invokers) {
        String identifyString = invoker.getUrl().toIdentityString();
        int weight = getWeight(invoker, invocation);
        WeightedRoundRobin weightedRoundRobin = map.computeIfAbsent(identifyString, k -> {
            WeightedRoundRobin wrr = new WeightedRoundRobin();
            wrr.setWeight(weight);
            return wrr;
        });

        // 权重发生改变
        if (weight != weightedRoundRobin.getWeight()) {
            //weight changed
            weightedRoundRobin.setWeight(weight);
        }
        long cur = weightedRoundRobin.increaseCurrent();
        weightedRoundRobin.setLastUpdate(now);
        if (cur > maxCurrent) {
            maxCurrent = cur;
            selectedInvoker = invoker;
            selectedWRR = weightedRoundRobin;
        }
        totalWeight += weight;
    }
    if (invokers.size() != map.size()) {
        map.entrySet().removeIf(item -> now - item.getValue().getLastUpdate() > RECYCLE_PERIOD);
    }
    if (selectedInvoker != null) {
        // 选中的invoker的权重要减去总权重
        // 这样就能保证下次选择其他的invoker
        selectedWRR.sel(totalWeight);
        return selectedInvoker;
    }
    // should not happen here
    return invokers.get(0);
}
```

WeightedRoundRobin是他的内部类：

```java
protected static class WeightedRoundRobin {
    private int weight;
    private AtomicLong current = new AtomicLong(0);
    private long lastUpdate;

    public int getWeight() {
        return weight;
    }

    public void setWeight(int weight) {
        this.weight = weight;
        current.set(0);
    }

    public long increaseCurrent() {
        return current.addAndGet(weight);
    }

    public void sel(int total) {
        current.addAndGet(-1 * total);
    }

    public long getLastUpdate() {
        return lastUpdate;
    }

    public void setLastUpdate(long lastUpdate) {
        this.lastUpdate = lastUpdate;
    }
}
```

###### 3）最小活跃负载均衡

最小活跃对应LeastActiveLoadBalance

```java
protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
    // Number of invokers
    int length = invokers.size();
    // The least active value of all invokers
    int leastActive = -1;
    // The number of invokers having the same least active value (leastActive)
    int leastCount = 0;
    // The index of invokers having the same least active value (leastActive)
    int[] leastIndexes = new int[length];
    // the weight of every invokers
    int[] weights = new int[length];
    // The sum of the warmup weights of all the least active invokers
    int totalWeight = 0;
    // The weight of the first least active invoker
    int firstWeight = 0;
    // Every least active invoker has the same weight value?
    boolean sameWeight = true;


    // Filter out all the least active invokers
    for (int i = 0; i < length; i++) {
        Invoker<T> invoker = invokers.get(i);
        // 获取invoker的调用次数
        int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();
        // Get the weight of the invoker's configuration. The default value is 100.
        int afterWarmup = getWeight(invoker, invocation);
        // save for later use
        weights[i] = afterWarmup;
        // 如果是第一个invoker或者当前invoker的调用次数比上一个小
        if (leastActive == -1 || active < leastActive) {
            // Reset the active number of the current invoker to the least active number
            leastActive = active;
            // Reset the number of least active invokers
            leastCount = 1;
            // Put the first least active invoker first in leastIndexes
            leastIndexes[0] = i;
            // Reset totalWeight
            totalWeight = afterWarmup;
            // Record the weight the first least active invoker
            firstWeight = afterWarmup;
            // Each invoke has the same weight (only one invoker here)
            sameWeight = true;
            // If current invoker's active value equals with leaseActive, then accumulating.
        } else if (active == leastActive) {
            // Record the index of the least active invoker in leastIndexes order
            leastIndexes[leastCount++] = i;
            // Accumulate the total weight of the least active invoker
            totalWeight += afterWarmup;
            // If every invoker has the same weight?
            if (sameWeight && afterWarmup != firstWeight) {
                sameWeight = false;
            }
        }
    }
    // Choose an invoker from all the least active invokers
    if (leastCount == 1) {
        // If we got exactly one invoker having the least active value, return this invoker directly.
        return invokers.get(leastIndexes[0]);
    }
    if (!sameWeight && totalWeight > 0) {
        // If (not every invoker has the same weight & at least one invoker's weight>0), select randomly based on 
        // totalWeight.
        int offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);
        // Return a invoker based on the random value.
        for (int i = 0; i < leastCount; i++) {
            int leastIndex = leastIndexes[i];
            offsetWeight -= weights[leastIndex];
            if (offsetWeight < 0) {
                return invokers.get(leastIndex);
            }
        }
    }
    // If all invokers have the same weight value or totalWeight=0, return evenly.
    return invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]);
}
```

###### 4）一致性hash负载均衡

一致性hash对应ConsistentHashLoadBalance：

```java
protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
    String methodName = RpcUtils.getMethodName(invocation);
    String key = invokers.get(0).getUrl().getServiceKey() + "." + methodName;
    // using the hashcode of list to compute the hash only pay attention to the elements in the list
    // 根据invokers的list计算hash值
    int invokersHashCode = getCorrespondingHashCode(invokers);
    ConsistentHashSelector<T> selector = (ConsistentHashSelector<T>) selectors.get(key);
    // 根据接口+方法名初始化一个ConsistentHashSelector
    if (selector == null || selector.identityHashCode != invokersHashCode) {
        selectors.put(key, new ConsistentHashSelector<T>(invokers, methodName, invokersHashCode));
        selector = (ConsistentHashSelector<T>) selectors.get(key);
    }
    // 调用一致性hash的select方法
    return selector.select(invocation);
}
```

ConsistentHashSelector是他的内部类：

```java
private static final class ConsistentHashSelector<T> {

    private final TreeMap<Long, Invoker<T>> virtualInvokers;
    private final int replicaNumber;
    private final int identityHashCode;

    private final int[] argumentIndex;

    /**
     * key: server(invoker) address
     * value: count of requests accept by certain server
     */
    private Map<String, AtomicLong> serverRequestCountMap = new ConcurrentHashMap<>();

    /**
     * count of total requests accept by all servers
     */
    private AtomicLong totalRequestCount;

    /**
     * count of current servers(invokers)
     */
    private int serverCount;

    /**
     * the ratio which allow count of requests accept by each server
     * overrate average (totalRequestCount/serverCount).
     * 1.5 is recommended, in the futrue we can make this param configurable
     */
    private static final double OVERLOAD_RATIO_THREAD = 1.5F;

    ConsistentHashSelector(List<Invoker<T>> invokers, String methodName, int identityHashCode) {
        // virtualInvokers就是虚拟节点
        this.virtualInvokers = new TreeMap<Long, Invoker<T>>();
        this.identityHashCode = identityHashCode;
        URL url = invokers.get(0).getUrl();
        this.replicaNumber = url.getMethodParameter(methodName, HASH_NODES, 160);
        String[] index = COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, HASH_ARGUMENTS, "0"));
        argumentIndex = new int[index.length];
        for (int i = 0; i < index.length; i++) {
            argumentIndex[i] = Integer.parseInt(index[i]);
        }
        // 每个invoker对应几个虚拟节点
        for (Invoker<T> invoker : invokers) {
            String address = invoker.getUrl().getAddress();
            for (int i = 0; i < replicaNumber / 4; i++) {
                byte[] digest = Bytes.getMD5(address + i);
                for (int h = 0; h < 4; h++) {
                    long m = hash(digest, h);
                    virtualInvokers.put(m, invoker);
                }
            }
        }

        totalRequestCount = new AtomicLong(0);
        serverCount = invokers.size();
        serverRequestCountMap.clear();
    }

    public Invoker<T> select(Invocation invocation) {
        String key = toKey(invocation.getArguments());
        byte[] digest = Bytes.getMD5(key);
        return selectForKey(hash(digest, 0));
    }
    private String toKey(Object[] args) {
        StringBuilder buf = new StringBuilder();
        for (int i : argumentIndex) {
            if (i >= 0 && i < args.length) {
                buf.append(args[i]);
            }
        }
        return buf.toString();
    }
    private Invoker<T> selectForKey(long hash) {
        Map.Entry<Long, Invoker<T>> entry = virtualInvokers.ceilingEntry(hash);
        if (entry == null) {
            entry = virtualInvokers.firstEntry();
        }

        String serverAddress = entry.getValue().getUrl().getAddress();

        /**
         * The following part of codes aims to select suitable invoker.
         * This part is not complete thread safety.
         * However, in the scene of consumer-side load balance,
         * thread race for this part of codes
         * (execution time cost for this part of codes without any IO or
         * network operation is very low) will rarely occur. And even in
         * extreme case, a few requests are assigned to an invoker which
         * is above OVERLOAD_RATIO_THREAD will not make a significant impact
         * on the effect of this new algorithm.
         * And make this part of codes synchronized will reduce efficiency of
         * every request. In my opinion, this is not worth. So it is not a
         * problem for this part is not complete thread safety.
         */
        double overloadThread = ((double) totalRequestCount.get() / (double) serverCount) * OVERLOAD_RATIO_THREAD;
        /**
         * Find a valid server node:
         * 1. Not have accept request yet
         * or
         * 2. Not have overloaded (request count already accept < thread (average request count * overloadRatioAllowed ))
         */
        while (serverRequestCountMap.containsKey(serverAddress)
            && serverRequestCountMap.get(serverAddress).get() >= overloadThread) {
            /**
             * If server node is not valid, get next node
             */
            entry = getNextInvokerNode(virtualInvokers, entry);
            serverAddress = entry.getValue().getUrl().getAddress();
        }
        if (!serverRequestCountMap.containsKey(serverAddress)) {
            serverRequestCountMap.put(serverAddress, new AtomicLong(1));
        } else {
            serverRequestCountMap.get(serverAddress).incrementAndGet();
        }
        totalRequestCount.incrementAndGet();

        return entry.getValue();
    }

    private Map.Entry<Long, Invoker<T>> getNextInvokerNode(TreeMap<Long, Invoker<T>> virtualInvokers, Map.Entry<Long, Invoker<T>> entry){
        Map.Entry<Long, Invoker<T>> nextEntry = virtualInvokers.higherEntry(entry.getKey());
        if(nextEntry == null){
            return virtualInvokers.firstEntry();
        }
        return nextEntry;
    }

    private long hash(byte[] digest, int number) {
        return (((long) (digest[3 + number * 4] & 0xFF) << 24)
                | ((long) (digest[2 + number * 4] & 0xFF) << 16)
                | ((long) (digest[1 + number * 4] & 0xFF) << 8)
                | (digest[number * 4] & 0xFF))
                & 0xFFFFFFFFL;
    }
}
```

##### 3.自动降级机制

在调用容错策略对应的Invoker之前会经过MockCLusterInvoker，他的Invoker组成了严格的责任链模式，这个Invoker是负责处理mock配置的，有两种选择，force开头的潜质mock和普通mock，强制mock就是不发起远程调用，直接本地模拟，普通mock会在远程调用失败的时候才进行模拟调用：

```java
public Result invoke(Invocation invocation) throws RpcException {
    // 模拟调用的意思就是如果目标provider故障了，这个时候consumer可以降级调用
    // 降级使用的就是mock模拟，不发起远程调用
    Result result;
    // 获取mock配置
    String value = getUrl().getMethodParameter(invocation.getMethodName(), MOCK_KEY, Boolean.FALSE.toString()).trim();
    if (value.length() == 0 || "false".equalsIgnoreCase(value)) {
        // 处理no mock的情况
        // 发起正常的情况
        // 这个时候invoker是AbstractCluster的内部类ClusterFilterInvoker
        result = this.invoker.invoke(invocation);
    } else if (value.startsWith(FORCE_KEY)) {
        // 如果mock的配置是force开头就说明是强制mock
        // 这个时候是不会走远程调用的
        if (logger.isWarnEnabled()) {
            logger.warn("force-mock: " + invocation.getMethodName() + " force-mock enabled , url : " + getUrl());
        }
        //force:direct mock
        result = doMockInvoke(invocation, null);
    } else {
        // 这个就是正常的mock
        // 先远程调用，如果失败了就走模拟调用
        try {
            result = this.invoker.invoke(invocation);

            //fix:#4585
            if(result.getException() != null && result.getException() instanceof RpcException){
                RpcException rpcException= (RpcException)result.getException();
                if(rpcException.isBiz()){
                    throw  rpcException;
                }else {
                    result = doMockInvoke(invocation, rpcException);
                }
            }

        } catch (RpcException e) {
            if (e.isBiz()) {
                throw e;
            }

            if (logger.isWarnEnabled()) {
                logger.warn("fail-mock: " + invocation.getMethodName() + " fail-mock enabled , url : " + getUrl(), e);
            }
            result = doMockInvoke(invocation, e);
        }
    }
    return result;
}
```

模拟调用的源码：

```java
private Result doMockInvoke(Invocation invocation, RpcException e) {
    Result result;
    Invoker<T> mockInvoker;

    // 选择模拟的invoker
    // 他这个里面就是给invocation设置了一个invocation.need.mock参数
    // 然后把DynamicDirectory的invokers返回了
    List<Invoker<T>> mockInvokers = selectMockInvoker(invocation);
    // 如果DynamicDirectory里的invokers不是空就拿第一个，否则新建一个MockInvoker
    if (CollectionUtils.isEmpty(mockInvokers)) {
        mockInvoker = (Invoker<T>) new MockInvoker(getUrl(), directory.getInterface());
    } else {
        // TODO 这里看一下还是会走正常调用，但是invocation多了一个invocation.need.mock参数
        // 估计后面会判断这个参数不执行远程调用
        mockInvoker = mockInvokers.get(0);
    }
    try {
        result = mockInvoker.invoke(invocation);
    } catch (RpcException mockException) {
        if (mockException.isBiz()) {
            result = AsyncRpcResult.newDefaultAsyncResult(mockException.getCause(), invocation);
        } else {
            throw new RpcException(mockException.getCode(), getMockExceptionMessage(e, mockException), mockException.getCause());
        }
    } catch (Throwable me) {
        throw new RpcException(getMockExceptionMessage(e, me), me.getCause());
    }
    return result;
}
```

执行远程调用的方式有两种，一种是invokers全部下线使用MockInvoker模拟，另外一种还是正常的Invoker执行，但是invocation多了一个invocation.need.mock参数。

###### 使用MockInvoker模拟调用：

```java
public Result invoke(Invocation invocation) throws RpcException {
    if (invocation instanceof RpcInvocation) {
        ((RpcInvocation) invocation).setInvoker(this);
    }
    String mock = getUrl().getMethodParameter(invocation.getMethodName(), MOCK_KEY);

    if (StringUtils.isBlank(mock)) {
        throw new RpcException(new IllegalAccessException("mock can not be null. url :" + url));
    }
    // 根据mock参数的前缀设置mock变量
    mock = normalizeMock(URL.decode(mock));
    if (mock.startsWith(RETURN_PREFIX)) {
        mock = mock.substring(RETURN_PREFIX.length()).trim();
        try {
            Type[] returnTypes = RpcUtils.getReturnTypes(invocation);
            // 根据returnType拿到返回的默认值
            Object value = parseMockValue(mock, returnTypes);
            return AsyncRpcResult.newDefaultAsyncResult(value, invocation);
        } catch (Exception ew) {
            throw new RpcException("mock return invoke error. method :" + invocation.getMethodName()
                    + ", mock:" + mock + ", url: " + url, ew);
        }
    } else if (mock.startsWith(THROW_PREFIX)) {
        // 配置的mock是抛出异常就直接抛出异常
        mock = mock.substring(THROW_PREFIX.length()).trim();
        if (StringUtils.isBlank(mock)) {
            throw new RpcException("mocked exception for service degradation.");
        } else { // user customized class
            Throwable t = getThrowable(mock);
            throw new RpcException(RpcException.BIZ_EXCEPTION, t);
        }
    } else { //impl mock
        // 执行自己实现的mock类
        try {
            Invoker<T> invoker = getInvoker(mock);
            return invoker.invoke(invocation);
        } catch (Throwable t) {
            throw new RpcException("Failed to create mock implementation class " + mock, t);
        }
    }
}
```

###### 通过invocation配置invocation.need.mock参数实现mock

这种方式的视线在MockInvokersSelector的route()方法中，这种情况会根据invokers中有没有配置成mock的provider返回，没有会返回空集合。

```java
public <T> List<Invoker<T>> route(final List<Invoker<T>> invokers,
                                  URL url, final Invocation invocation) throws RpcException {
    if (CollectionUtils.isEmpty(invokers)) {
        return invokers;
    }

    if (invocation.getObjectAttachments() == null) {
        return getNormalInvokers(invokers);
    } else {
        String value = (String) invocation.getObjectAttachments().get(INVOCATION_NEED_MOCK);
        if (value == null) {
            return getNormalInvokers(invokers);
        } else if (Boolean.TRUE.toString().equalsIgnoreCase(value)) {
            return getMockedInvokers(invokers);
        }
    }
    return invokers;
}

private <T> List<Invoker<T>> getMockedInvokers(final List<Invoker<T>> invokers) {
    if (!hasMockProviders(invokers)) {
        return null;
    }
    List<Invoker<T>> sInvokers = new ArrayList<Invoker<T>>(1);
    for (Invoker<T> invoker : invokers) {
        if (invoker.getUrl().getProtocol().equals(MOCK_PROTOCOL)) {
            sInvokers.add(invoker);
        }
    }
    return sInvokers;
}
```

### 4.Router

dubbo的条件路由

Router的实现类在RouterChain类中使用，他是在DynamicDirectory中调用的RouterChain的构造方法构建Route链条：

```java
private RouterChain(URL url) {
    // 获取线程池组件
    executorRepository = url.getOrDefaultApplicationModel().getExtensionLoader(ExecutorRepository.class)
        .getDefaultExtension();
    // 创建一个新的线程池
    loopPool = executorRepository.nextExecutorExecutor();
    // 获取自动激活的RouterFactory
    List<RouterFactory> extensionFactories = url.getOrDefaultApplicationModel().getExtensionLoader(RouterFactory.class)
        .getActivateExtension(url, ROUTER_KEY);
    // 获取Router list
    List<Router> routers = extensionFactories.stream()
        .map(factory -> factory.getRouter(url))
        .sorted(Router::compareTo)
        .collect(Collectors.toList());
    // 这里没什么东西
    initWithRouters(routers);

    // 这里应该能拿到3种RouterFactory
    // CacheableStateRouterFactory(可缓存的Router)
    // TagDynamicStateRouterFactory(动态标签Router)
    // TagStaticStateRouterFactory(静态标签Router)
    // 基于TagRouter可以实现灰度发布、蓝绿发布
    List<StateRouterFactory> extensionStateRouterFactories = url.getOrDefaultApplicationModel()
        .getExtensionLoader(StateRouterFactory.class)
        .getActivateExtension(url, STATE_ROUTER_KEY);

    List<StateRouter> stateRouters = extensionStateRouterFactories.stream()
        .map(factory -> factory.getRouter(url, this))
        .sorted(StateRouter::compareTo)
        .collect(Collectors.toList());

    // init state routers
    initWithStateRouters(stateRouters);
}
```

当invoker发生改变时一定会调用RouterChain的setInvokers()方法，这个方法会遍历stateRouters更新invokers。

随便看几个主要的Router：

##### 1）ConditionRouter

```java
public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation)
        throws RpcException {
    if (!enabled) {
        return invokers;
    }

    if (CollectionUtils.isEmpty(invokers)) {
        return invokers;
    }
    try {
        // 如果invokers都不符合条件，就返回原来的
        // 就是根据参数和值进行匹配
        if (!matchWhen(url, invocation)) {
            return invokers;
        }
        List<Invoker<T>> result = new ArrayList<Invoker<T>>();
        if (thenCondition == null) {
            logger.warn("The current consumer in the service blacklist. consumer: " + NetUtils.getLocalHost() + ", service: " + url.getServiceKey());
            return result;
        }
        for (Invoker<T> invoker : invokers) {
            // 再次匹配
            if (matchThen(invoker.getUrl(), url)) {
                result.add(invoker);
            }
        }
        if (!result.isEmpty()) {
            return result;
        } else if (this.isForce()) {
            logger.warn("The route result is empty and force execute. consumer: " + NetUtils.getLocalHost() + ", service: " + url.getServiceKey() + ", router: " + url.getParameterAndDecoded(RULE_KEY));
            return result;
        }
    } catch (Throwable t) {
        logger.error("Failed to execute condition router rule: " + getUrl() + ", invokers: " + invokers + ", cause: " + t.getMessage(), t);
    }
    return invokers;
}
```

##### 2）AppRouter

AppRouter是ListenableRouter的子类，当配置规则改变的时候会回调process()方法，这里维护了List\<ConditionRouter\> conditionRouters列表，route()方法也是拿到所有的ConditionRouter进行过滤：

```java
public synchronized void process(ConfigChangedEvent event) {
    if (logger.isDebugEnabled()) {
        logger.debug("Notification of condition rule, change type is: " + event.getChangeType() +
                ", raw rule is:\n " + event.getContent());
    }

    if (event.getChangeType().equals(ConfigChangeType.DELETED)) {
        routerRule = null;
        conditionRouters = Collections.emptyList();
    } else {
        try {
            // 这个routerRule就是List<String> conditions
            routerRule = ConditionRuleParser.parse(event.getContent());
            generateConditions(routerRule);
        } catch (Exception e) {
            logger.error("Failed to parse the raw condition rule and it will not take effect, please check " +
                    "if the condition rule matches with the template, the raw rule is:\n " + event.getContent(), e);
        }
    }
}
```

##### 2）ScriptRouter

```java
public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {
    if (engine == null || function == null) {
        return invokers;
    }
    Bindings bindings = createBindings(invokers, invocation);
    return getRoutedInvokers(AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
        try {
            // 动态运行脚本
            return function.eval(bindings);
        } catch (ScriptException e) {
            logger.error("route error, rule has been ignored. rule: " + rule + ", method:" +
                    invocation.getMethodName() + ", url: " + RpcContext.getContext().getUrl(), e);
            return invokers;
        }
    }, accessControlContext));
}
```

##### 3）TagRouter

```java
public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {
    if (CollectionUtils.isEmpty(invokers)) {
        return invokers;
    }

    // since the rule can be changed by config center, we should copy one to use.
    final TagRouterRule tagRouterRuleCopy = tagRouterRule;
    if (tagRouterRuleCopy == null || !tagRouterRuleCopy.isValid() || !tagRouterRuleCopy.isEnabled()) {
        return filterUsingStaticTag(invokers, url, invocation);
    }

    List<Invoker<T>> result = invokers;
    // 主要是根据tag属性匹配
    String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :
            invocation.getAttachment(TAG_KEY);

    // if we are requesting for a Provider with a specific tag
    if (StringUtils.isNotEmpty(tag)) {
        List<String> addresses = tagRouterRuleCopy.getTagnameToAddresses().get(tag);
        // filter by dynamic tag group first
        if (CollectionUtils.isNotEmpty(addresses)) {
            result = filterInvoker(invokers, invoker -> addressMatches(invoker.getUrl(), addresses));
            // if result is not null OR it's null but force=true, return result directly
            if (CollectionUtils.isNotEmpty(result) || tagRouterRuleCopy.isForce()) {
                return result;
            }
        } else {
            // dynamic tag group doesn't have any item about the requested app OR it's null after filtered by
            // dynamic tag group but force=false. check static tag
            result = filterInvoker(invokers, invoker -> tag.equals(invoker.getUrl().getParameter(TAG_KEY)));
        }
        // If there's no tagged providers that can match the current tagged request. force.tag is set by default
        // to false, which means it will invoke any providers without a tag unless it's explicitly disallowed.
        if (CollectionUtils.isNotEmpty(result) || isForceUseTag(invocation)) {
            return result;
        }
        // FAILOVER: return all Providers without any tags.
        else {
            List<Invoker<T>> tmp = filterInvoker(invokers, invoker -> addressNotMatches(invoker.getUrl(),
                    tagRouterRuleCopy.getAddresses()));
            return filterInvoker(tmp, invoker -> StringUtils.isEmpty(invoker.getUrl().getParameter(TAG_KEY)));
        }
    } else {
        // List<String> addresses = tagRouterRule.filter(providerApp);
        // return all addresses in dynamic tag group.
        List<String> addresses = tagRouterRuleCopy.getAddresses();
        if (CollectionUtils.isNotEmpty(addresses)) {
            result = filterInvoker(invokers, invoker -> addressNotMatches(invoker.getUrl(), addresses));
            // 1. all addresses are in dynamic tag group, return empty list.
            if (CollectionUtils.isEmpty(result)) {
                return result;
            }
            // 2. if there are some addresses that are not in any dynamic tag group, continue to filter using the
            // static tag group.
        }
        return filterInvoker(result, invoker -> {
            String localTag = invoker.getUrl().getParameter(TAG_KEY);
            return StringUtils.isEmpty(localTag) || !tagRouterRuleCopy.getTagNames().contains(localTag);
        });
    }
}
```

##### 4）MeshRuleRouter

流量管理路由策略，主要分为两块，VirtualService和DestinationRule。

当consumer调用服务的时候会根据DubboRoute和DubboRouteDetail匹配到DubboDestination中对应的subset。

-   [VirtualService](https://dubbo.apache.org/zh/docs3-v2/java-sdk/advanced-featrues-and-usage/traffic/mesh-style/virtualservice/) 主要处理入站流量分流的规则，支持服务级别和方法级别的分流。
-   [DubboRoute](https://dubbo.apache.org/zh/docs3-v2/java-sdk/advanced-featrues-and-usage/traffic/mesh-style/virtualservice/#dubboroute) 主要解决服务级别的分流问题。同时，还提供的重试机制、超时、故障注入、镜像流量等能力。
-   [DubboRouteDetail](https://dubbo.apache.org/zh/docs3-v2/java-sdk/advanced-featrues-and-usage/traffic/mesh-style/virtualservice/#dubboroutedetail) 主要解决某个服务中方法级别的分流问题。支持方法名、方法参数、参数个数、参数类型、header 等各种维度的分流能力。同时也支持方法级的重试机制、超时、故障注入、镜像流量等能力。
-   [DubboDestination](https://dubbo.apache.org/zh/docs3-v2/java-sdk/advanced-featrues-and-usage/traffic/mesh-style/virtualservice/#dubbodestination) 用来描述路由流量的目标地址，支持 host、port、subnet 等方式。
-   [DestinationRule](https://dubbo.apache.org/zh/docs3-v2/java-sdk/advanced-featrues-and-usage/traffic/mesh-style/destination-rule/) 主要处理目标地址规则，可以通过 hosts、subnet 等方式关联到 Provider 集群。同时可以通过 [trafficPolicy](https://dubbo.apache.org/zh/docs3-v2/java-sdk/advanced-featrues-and-usage/traffic/mesh-style/destination-rule/#trafficpolicy) 来实现负载均衡。

