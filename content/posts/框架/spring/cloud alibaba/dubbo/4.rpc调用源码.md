---
title: 4.dubbo-rpc调用源码
tags:
  - 源码
categories: Dubbo
copyright: true
---

直接进InvokerInvocationHandler的invoke()方法

```java
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    // 动态生成了实现类之后调用时其实这个代理并不直到你调用这个方法时要怎么处理
    // 所以动态代理都会封装一个InvocationHandler，这个是dubbo自己实现的，通过代理调用的方法都会走到这里
    // 在这里可以拿到代理的对象是谁，那个方法，什么参数
    if (method.getDeclaringClass() == Object.class) {
        return method.invoke(invoker, args);
    }
    String methodName = method.getName();
    Class<?>[] parameterTypes = method.getParameterTypes();
    // 基础方法比如tostring、equals啥的的处理
    if (parameterTypes.length == 0) {
        if ("toString".equals(methodName)) {
            return invoker.toString();
        } else if ("$destroy".equals(methodName)) {
            invoker.destroy();
            return null;
        } else if ("hashCode".equals(methodName)) {
            return invoker.hashCode();
        }
    } else if (parameterTypes.length == 1 && "equals".equals(methodName)) {
        return invoker.equals(args[0]);
    }
    // 封装rpc信息，serviceModel是目标服务信息
    RpcInvocation rpcInvocation = new RpcInvocation(serviceModel, method, invoker.getInterface().getName(), protocolServiceKey, args);
    String serviceKey = url.getServiceKey();
    rpcInvocation.setTargetServiceUniqueName(serviceKey);
    // invoker.getUrl() returns consumer url.
    RpcServiceContext.setRpcContext(url);
    if (serviceModel instanceof ConsumerModel) {
        rpcInvocation.put(Constants.CONSUMER_MODEL, serviceModel);
        rpcInvocation.put(Constants.METHOD_MODEL, ((ConsumerModel) serviceModel).getMethodModel(method));
    }
	// 这里是发起服务调用的入口
    // invoker就是MigrationInvoker
    // recreate()是拿到相应根据对应协议转成我们接口返回的对象
    return invoker.invoke(rpcInvocation).recreate();
}
```

代码进到了MigrationInvoker的involer中，**为什么叫MigrationInvoker？他里面其实还有一个invoker叫CurrentAvailableInvoker，每次获取currentAvailableInvoker的时候会在MockClusterInvoker和ServiceDiscoveryInvoker中选择一个，他可能吧这个切换的过程叫迁移**。

MockClusterInvoker的代码：

```java
public Result invoke(Invocation invocation) throws RpcException {
    if (currentAvailableInvoker != null) {
        // 这里是做什么的没看懂
        if (step == APPLICATION_FIRST) {
            // call ratio calculation based on random value
            if (ThreadLocalRandom.current().nextDouble(100) > promotion) {
                return invoker.invoke(invocation);
            }
        }
        return currentAvailableInvoker.invoke(invocation);
    }
	// 根据下面的名称猜测当需要 强制mock降级的时候currentAvailableInvoker会被替换成ServiceDiscoveryInvoker
    switch (step) {
        case APPLICATION_FIRST:
            if (checkInvokerAvailable(serviceDiscoveryInvoker)) {
                currentAvailableInvoker = serviceDiscoveryInvoker;
            } else if (checkInvokerAvailable(invoker)) {
                currentAvailableInvoker = invoker;
            } else {
                currentAvailableInvoker = serviceDiscoveryInvoker;
            }
            break;
        case FORCE_APPLICATION:
            currentAvailableInvoker = serviceDiscoveryInvoker;
            break;
        case FORCE_INTERFACE:
        default:
            currentAvailableInvoker = invoker;
    }

    return currentAvailableInvoker.invoke(invocation);
}
```

还要继续走到currentAvailableInvoker的invoker，此时这个currentAvailableInvoker是MockClusterInvoker：

```java
public Result invoke(Invocation invocation) throws RpcException {
    Result result;
    // 先去了一个mock的参数，如果没有或者是false就走第一个分支
    String value = getUrl().getMethodParameter(invocation.getMethodName(), MOCK_KEY, Boolean.FALSE.toString()).trim();
    if (value.length() == 0 || "false".equalsIgnoreCase(value)) {
        // no mock
        // 发起正常的情况
        // 这个时候invoker是AbstractCluster的内部类ClusterFilterInvoker
        result = this.invoker.invoke(invocation);
    } else if (value.startsWith(FORCE_KEY)) {
        // 如果mock的配置是force开头就说明是强制mock
        // 这个时候是不会走远程调用的
        result = doMockInvoke(invocation, null);
    } else {
        //fail-mock
        try {
            // 这个就是正常的mock
            // 先远程调用，如果失败了就走模拟调用
            result = this.invoker.invoke(invocation);
            //fix:#4585
            if(result.getException() != null && result.getException() instanceof RpcException){
                RpcException rpcException= (RpcException)result.getException();
                if(rpcException.isBiz()){
                    throw  rpcException;
                }else {
                    result = doMockInvoke(invocation, rpcException);
                }
            }
        } catch (RpcException e) {
            if (e.isBiz()) {
                throw e;
            }
            result = doMockInvoke(invocation, e);
        }
    }
    return result;
}
```

继续往里走到incoker.invoke()方法，这里的invoker是FilterChainNode，他是Invoker的子类，而且还是FilterChainBuilder的内部类：

```java
public Result invoke(Invocation invocation) throws RpcException {
    Result asyncResult;
    try {
        // 这个filter用的是ConsumerContextFilter
        asyncResult = filter.invoke(nextNode, invocation);
    } catch (Exception e) {
        // 异常先不看
        if (filter instanceof ListenableFilter) {
            ListenableFilter listenableFilter = ((ListenableFilter) filter);
            try {
                Filter.Listener listener = listenableFilter.listener(invocation);
                if (listener != null) {
                    listener.onError(e, originalInvoker, invocation);
                }
            } finally {
                listenableFilter.removeListener(invocation);
            }
        } else if (filter instanceof FILTER.Listener) {
            FILTER.Listener listener = (FILTER.Listener) filter;
            listener.onError(e, originalInvoker, invocation);
        }
        throw e;
    } finally {

    }
    // 返回值还有一些过滤处理
    return asyncResult.whenCompleteWithContext((r, t) -> {
        if (filter instanceof ListenableFilter) {
            ListenableFilter listenableFilter = ((ListenableFilter) filter);
            Filter.Listener listener = listenableFilter.listener(invocation);
            try {
                if (listener != null) {
                    if (t == null) {
                        listener.onResponse(r, originalInvoker, invocation);
                    } else {
                        listener.onError(t, originalInvoker, invocation);
                    }
                }
            } finally {
                listenableFilter.removeListener(invocation);
            }
        } else if (filter instanceof FILTER.Listener) {
            FILTER.Listener listener = (FILTER.Listener) filter;
            if (t == null) {
                listener.onResponse(r, originalInvoker, invocation);
            } else {
                listener.onError(t, originalInvoker, invocation);
            }
        }
    });
}
```

上面其实关键的就一句话：**filter.invoke(nextNode, invocation);**这里会走到ConsumerContextFilter的invoker，其实在这里只是拿到一个RpcContext，然后设置一些属性，最后还是会调用一个invoker.invoke()，然后又回到了FilterChainNode中，只不过这个时候filter变成了MonitorFilter，然后又是一个invoker.invoke()，就走到了AbstractClusterInvoker中，其实这步就是走一堆filterChain，但是还没开始真正调用，进到AbstractClusterInvoker的invoke()里看一下：

```java
public Result invoke(final Invocation invocation) throws RpcException {
    checkWhetherDestroyed();
	// 下面就是重点了
    // 先把实例的所有invoker拿出来
    // 这个list以后要好好看一下，可以看成是服务发现的方法
    // 通过上面看到的DynamicDirectory的list方法
    List<Invoker<T>> invokers = list(invocation);
    // 负载均衡组件
    LoadBalance loadbalance = initLoadBalance(invokers, invocation);
    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
    // 服务调用
    return doInvoke(invocation, invokers, loadbalance);
}
```

所以终于看到了服务调用的代码，先看看怎么后去服务实例的invokers，list()方法只有一行**return getDirectory().list(invocation);**其实就是调用了directory的list，这里的getDirectory()返回的是AbstractDirectory，在AbstractDirectory的list()方法中又调用了doList()方法，doList是一个抽象方法，断点跟到了RegistryDirectory类中，在RegistryDirectory的doList()方法中调用了**routerChain.route(getConsumerUrl(), invocation);**方法，所以又走到了RouterChain类中，但是看注释上写的东西，说是route()方法是从缓存中获取的服务实例信息，这里就不进去看了。缓存的服务实例在RegistryProtocol的doCreateInvoker()方法中调用的directory.subscribe(toSubscribeUrl(urlToRegistry));。

因为是吧netty的客户端封装到了invoker中， 所以可以直接通过invoker和服务端通信，继续看初始化负载均衡组件的代码：

```java
LoadBalance loadbalance = initLoadBalance(invokers, invocation);
```

上面已经看到了，initLoadBalance方法传进去的invokers就是DubboInvoker数组，它里面有NettyClient

```java
protected LoadBalance initLoadBalance(List<Invoker<T>> invokers, Invocation invocation) {
    ApplicationModel applicationModel = ScopeModelUtil.getApplicationModel(invocation.getModuleModel());
    if (CollectionUtils.isNotEmpty(invokers)) {
        return applicationModel.getExtensionLoader(LoadBalance.class).getExtension(
            // 他构建负载均衡实例是要从url中拿到loadbalance参数，默认是random
            invokers.get(0).getUrl().getMethodParameter(
                RpcUtils.getMethodName(invocation), LOADBALANCE_KEY, DEFAULT_LOADBALANCE
            )
        );
    } else {
        return applicationModel.getExtensionLoader(LoadBalance.class).getExtension(DEFAULT_LOADBALANCE);
    }
}
```

从上面可以看到，默认的负载均衡就是RandomLoadBalance，纯随机，然后继续走doInvoke()方法，进到FailoverClusterInvoker类中：

```java
public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
    List<Invoker<T>> copyInvokers = invokers;
    checkInvokers(copyInvokers, invocation);
    String methodName = RpcUtils.getMethodName(invocation);
    // 计算invoke的次数，猜测这个跟重试相关的
    int len = calculateInvokeTimes(methodName);
    // retry loop.
    RpcException le = null; // last exception.
    List<Invoker<T>> invoked = new ArrayList<Invoker<T>>(copyInvokers.size()); // invoked invokers.
    Set<String> providers = new HashSet<String>(len);
    for (int i = 0; i < len; i++) {
        //Reselect before retry to avoid a change of candidate `invokers`.
        //NOTE: if `invokers` changed, then `invoked` also lose accuracy.
        if (i > 0) {
            checkWhetherDestroyed();
            copyInvokers = list(invocation);
            // check again
            checkInvokers(copyInvokers, invocation);
        }
        // 选择一个invoker
        Invoker<T> invoker = select(loadbalance, invocation, copyInvokers, invoked);
        // 保证不重试已经请求过的invoker
        invoked.add(invoker);
        RpcContext.getServiceContext().setInvokers((List) invoked);
        try {
            // 这里就是执行rpc的代码了
            Result result = invokeWithContext(invoker, invocation);
            if (le != null && logger.isWarnEnabled()) {
                logger.warn("Although retry the method " + methodName
                            + " in the service " + getInterface().getName()
                            + " was successful by the provider " + invoker.getUrl().getAddress()
                            + ", but there have been failed providers " + providers
                            + " (" + providers.size() + "/" + copyInvokers.size()
                            + ") from the registry " + directory.getUrl().getAddress()
                            + " on the consumer " + NetUtils.getLocalHost()
                            + " using the dubbo version " + Version.getVersion() + ". Last error is: "
                            + le.getMessage(), le);
            }
            return result;
        } catch (RpcException e) {
            if (e.isBiz()) { // biz exception.
                throw e;
            }
            le = e;
        } catch (Throwable e) {
            le = new RpcException(e.getMessage(), e);
        } finally {
            providers.add(invoker.getUrl().getAddress());
        }
    }
    throw new RpcException(le.getCode(), "Failed to invoke the method "
                           + methodName + " in the service " + getInterface().getName()
                           + ". Tried " + len + " times of the providers " + providers
                           + " (" + providers.size() + "/" + copyInvokers.size()
                           + ") from the registry " + directory.getUrl().getAddress()
                           + " on the consumer " + NetUtils.getLocalHost() + " using the dubbo version "
                           + Version.getVersion() + ". Last error is: "
                           + le.getMessage(), le.getCause() != null ? le.getCause() : le);
}
```

执行rpc调用的代码就是通过**invoker.invoke(invocation)**，都在AbstractInvoker类中：

```java
public Result invoke(Invocation inv) throws RpcException {
    // if invoker is destroyed due to address refresh from registry, let's allow the current invoke to proceed
    RpcInvocation invocation = (RpcInvocation) inv;
    // prepare rpc invocation
    prepareInvocation(invocation);
    // do invoke rpc invocation and return async result
    // 可以看出来rpc返回的结果是异步的
    AsyncRpcResult asyncResult = doInvokeAndReturn(invocation);
    // wait rpc result if sync
    // 等待请求结果
    // 同步等待返回结果
    waitForResultIfSync(asyncResult, invocation);
    return asyncResult;
}
```

doInvokeAndReturn()方法的核心代码应该就两行：

```java
// 调用，此时的invoker是DubboInvoker
asyncResult = (AsyncRpcResult) doInvoke(invocation);
// 然后把拿到result封装到FutrueAdapter中，在放到rpc上下文里
RpcContext.getServiceContext().setFutrue(new FutrueAdapter<>(asyncResult.getResponseFutrue()));
```

接着就进到DubboInvoker的doInvoke()方法：

```java
protected Result doInvoke(final Invocation invocation) throws Throwable {
    RpcInvocation inv = (RpcInvocation) invocation;
    final String methodName = RpcUtils.getMethodName(invocation);
    inv.setAttachment(PATH_KEY, getUrl().getPath());
    inv.setAttachment(VERSION_KEY, version);
    // 这个就是NettyClient
    ExchangeClient currentClient;
    if (clients.length == 1) {
        currentClient = clients[0];
    } else {
        currentClient = clients[index.getAndIncrement() % clients.length];
    }
    try {
        // invocation里有个return参数，如果是false就表示单向
        // 这里拿到的isOneway是false
        boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);
        // 计算超时时间
        int timeout = calculateTimeout(invocation, methodName);
        invocation.put(TIMEOUT_KEY, timeout);
        if (isOneway) {
            // 不要结果就直接发送了
            boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false);
            currentClient.send(inv, isSent);
            return AsyncRpcResult.newDefaultAsyncResult(invocation);
        } else {
            // 拿到一个线程池
            ExecutorService executor = getCallbackExecutor(getUrl(), inv);
            // 发送请求
            // 此时的client是ReferenceCountExchangeClient
            CompletableFutrue<AppResponse> appResponseFutrue =
                currentClient.request(inv, timeout, executor).thenApply(obj -> (AppResponse) obj);
            // save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutrueAdapter
            FutrueContext.getContext().setCompatibleFutrue(appResponseFutrue);
            AsyncRpcResult result = new AsyncRpcResult(appResponseFutrue, inv);
            result.setExecutor(executor);
            return result;
        }
    } catch (TimeoutException e) {
        ……
    }
}
```

doInvoke()里发送请求之前先获取了一个线程池，然后不管是发送请求还是返回结果里都有这个线程池，发送请求的代码就是currentClient.request()了，这个request()显示调用了ReferenceCountExchangeClient的request，在ReferenceCountExchangeClient的request()中又调用了HeaderExchangeClient的request，HeaderExchangeClient的request()里调用了HeaderExchangeChannel的request:

```java
public CompletableFutrue<Object> request(Object request, int timeout, ExecutorService executor) throws RemotingException {
    if (closed) {
        throw new RemotingException(this.getLocalAddress(), null, "Failed to send request " + request + ", cause: The channel " + this + " is closed!");
    }
    // 创建请求
    Request req = new Request();
    req.setVersion(Version.getProtocolVersion());
    req.setTwoWay(true);
    req.setData(request);
    // 用一堆东西封装成了featrue，这个纯返回用
    DefaultFutrue futrue = DefaultFutrue.newFutrue(channel, req, timeout, executor);
    try {
        // 发送请求，channel是AbstractPeer
        channel.send(req);
    } catch (RemotingException e) {
        futrue.cancel();
        throw e;
    }
    return futrue;
}
```

在这里channel就是NettyCLient，NettyCLient继承了AbstractClient，AbstractClient又继承了AbstractPeer，这里的channel.send(req)先走到了AbstractPeer的send()，他的send()里又调用了send()这个时候走到的是AbstractClient，然后在AbstractClient的send()里执行getChannel()，这个方法调用的是NettyCLient，所以最终在AbstractClient的send()方法里调用的其实是NettyChannel的send：

```java
public void send(Object message, boolean sent) throws RemotingException {
    if (needReconnect && !isConnected()) {
        connect();
    }
    Channel channel = getChannel();
    // 省略校验……
    channel.send(message, sent);
}
```

```java
protected org.apache.dubbo.remoting.Channel getChannel() {
    Channel c = channel;
    if (c == null) {
        return null;
    }
    return NettyChannel.getOrAddChannel(c, getUrl(), this);
}
```

最后最后的发送逻辑在NettyCHannel的send：

```java
public void send(Object message, boolean sent) throws RemotingException {
    // 父类的send里没有代码，只是校验连接是否关闭
    super.send(message, sent);
    boolean success = true;
    int timeout = 0;
    try {
        // 调用netty的writeAndFlush
        ChannelFutrue futrue = channel.writeAndFlush(message);
        if (sent) {
            // 获取配置的超时时间
            timeout = getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);
            // 等待发送结果
            success = futrue.await(timeout);
        }
        Throwable cause = futrue.cause();
        if (cause != null) {
            throw cause;
        }
    } catch (Throwable e) {
        removeChannelIfDisconnected(channel);
        throw new RemotingException(this, "Failed to send message " + PayloadDropper.getRequestWithoutData(message) + " to " + getRemoteAddress() + ", cause: " + e.getMessage(), e);
    }
    if (!success) {
        throw new RemotingException(this, "Failed to send message " + PayloadDropper.getRequestWithoutData(message) + " to " + getRemoteAddress() + "in timeout(" + timeout + "ms) limit");
    }
}
```

请求发送完之后回到AbstractInvoker的waitForResultIfSync()方法等待请求结果，里面就是一个try catch：

```java
// 拿到超时时间
Object timeout = invocation.get(TIMEOUT_KEY);
if (timeout instanceof Integer) {
    asyncResult.get((Integer) timeout, TimeUnit.MILLISECONDS);
} else {
    // 没有超时时间就是int的最大值
    asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
}
```

AsyncResult的get方法先拿到一个线程池，然后调用ThreadlessExecutor.waitAndDrain()方法：

```java
public void waitAndDrain() throws InterruptedException {
    if (finished) {
        return;
    }
    Runnable runnable;
    try {
        runnable = queue.take();
    }catch (InterruptedException e){
        waiting = false;
        throw e;
    }
    synchronized (lock) {
        waiting = false;
        runnable.run();
    }
    runnable = queue.poll();
    while (runnable != null) {
        runnable.run();
        runnable = queue.poll();
    }
    // mark the status of ThreadlessExecutor as finished.
    finished = true;
}
```

到这里consumer发送请求就结束了

#### provider处理请求

不管是provider还是consumer启动的时候都是用nettyServer启动了netty服务，启动netty的bootstrap的时候添加了一个handlerChild（NettyServerHandler），这个就是处理请求的入口。这个类继承了ChannelDuplexHandler类，ChannelDuplexHandler也是ChannelInboundHandlerAdapter的子类，里面必然会有一些channelActive()、channelRead()、write()这些方法，收到消息的入口肯定是channelRead()了：

```java
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
    // 这里的NettyChannel是dubbo的netty4包下的
    // 里面有个CHANNEL_MAP变量存的是channel信息，这个类是一个工具类，里面大部分方法都是静态的
    // 但是没有在类加载的时候实例化，而是每次获取或者添加channel的时候实例化一个放到CHANNEL_MAP里
    NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
    // 这个handler是AbstractPeer
    handler.received(channel, msg);
}
```

AbstractPeer内部还有个handler，是MultiMessageHandler类型，所以receive()调用的是MultiMessageHandler里的receive()：

```java
public void received(Channel channel, Object message) throws RemotingException {
    // 批量消息？
    if (message instanceof MultiMessage) {
        MultiMessage list = (MultiMessage) message;
        for (Object obj : list) {
            try {
                // 又是一个handler
                handler.received(channel, obj);
            } catch (Throwable t) {
                logger.error("MultiMessageHandler received fail.", t);
                try {
                    handler.caught(channel, t);
                } catch (Throwable t1) {
                    logger.error("MultiMessageHandler caught fail.", t1);
                }
            }
        }
    } else {
        // 不是就走到下一个handler，下一个是HeartbeatHandler
        handler.received(channel, message);
    }
}
```

他有一个handler的处理链路，如果不是MultiMessageHandler下一个就是HeartbeatHandler，不是heartbeat下一个就是AllChannelHandler，然后就没了，AllChannelHandler的receive()就两行代码：

```java
// 拿到一个线程池，然后提交一个异步任务
ExecutorService executor = getPreferredExecutorService(message);
executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));
```

在往下跟就又是一堆handler，先看一下去掉日志后的ChannelEventRunnable的run()方法：

```java
public void run() {
    // 我们刚才传进来一个ChannelState.RECEIVED，接收消息就走这个
    if (state == ChannelState.RECEIVED) {
        try {
            // 这里又是一个handler，这个handler是DecodeHandler
            handler.received(channel, message);
        } catch (Exception e) {}
    } else {
        // 下面就是处理建立连接、断开连接、发送消息之类的逻辑
        switch (state) {
            case CONNECTED:
                try {
                    handler.connected(channel);
                } catch (Exception e) {}
                break;
            case DISCONNECTED:
                try {
                    handler.disconnected(channel);
                } catch (Exception e) {}
                break;
            case SENT:
                try {
                    handler.sent(channel, message);
                } catch (Exception e) {}
                break;
            case CAUGHT:
                try {
                    handler.caught(channel, exception);
                } catch (Exception e) {}
                break;
            default:
        }
    }

}
```

继续看DecodeHandler里的代码，这里就是先decode解码，然后交给下一个handler处理，走到了HeaderExchangeHandler，然后又调用了自己的handleRequest()方法，核心代码：

```java
// 这个是处理请求的，然后把结果封装到CompletionStage里
CompletionStage<Object> futrue = handler.reply(channel, msg);
futrue.whenComplete((appResult, t) -> {
    try {
        if (t == null) {
            res.setStatus(Response.OK);
            res.setResult(appResult);
        } else {
            res.setStatus(Response.SERVICE_ERROR);
            res.setErrorMessage(StringUtils.toString(t));
        }
        // 拿到结果之后封装响应，然后发送出去
        channel.send(res);
    } catch (RemotingException e) {
        logger.warn("Send result to consumer failed, channel is " + channel + ", msg is " + e);
    }
});
```

进到真正处理请求的方法handler.reply()，这个handler是DubboProtocol内部的一个变量requestHandler，这个变量是ExchangeHandlerAdapter类型，并且重写了reply()方法，这个方法里就是拿到了一个Invoker，然后通过invoker.invoke()方法一层一层调用到我们实现的接口实现类，大概的流程就看完了。

![](https://tva1.sinaimg.cn/large/008vxvgGly1h7v544so4hj337q0qy0yu.jpg)