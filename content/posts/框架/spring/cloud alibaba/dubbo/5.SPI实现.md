---
title: 5.SPI实现源码
tags:
  - 源码
categories: Dubbo
copyright: true
---

SPI的全称就是Service Provider Interface，是一种动态替换的机制，用来动态替换接口的实现类，需要在工作目录下的META-INF/services目录中创建一个文件，这个文件名是要被动态替换实现类的接口的全限定名，文件的内容是接口实现类的全限定名。java中通过Service.providers(接口.class)或者ServiceLoader.load(接口.class)拿到所有实现类，之后就可以遍历调用了。

Dubbo自己实现了一套SPI机制，关键组件类都是通过自己的SPI动态实例化的，让我们只需要修改一些配置就可以替换默认的组件。

java的SPI会把所有的实现类都拿出来，而Dubbo的SPI会根据需要拿到实现类，而且Dubbo的SPI还提供了IOC、AOP的功能。

除了SPI这种扩展，还可以使用配置文件的方式，当发现配置了某个配置，就加载用户自己的实现类，但是这种方式只适合少量的组件扩展，dubbo使用SPI机制让大量的核心组件都是可以替换的。

SPI的实现在ExtensionLoader中，这个类主要有3种获取extension方式getExtension()根据name获取、getAdaptiveExtension()获取url中配置的extension、getActivateExtension()根据@Adaptive注解实现一个接口自动激活多个实现类。

##### getExtension()

```java
public T getExtension(String name, boolean wrap) {
    // 检查的代码没看
    checkDestroyed();
    if (StringUtils.isEmpty(name)) {
        throw new IllegalArgumentException("Extension name == null");
    }
    if ("true".equals(name)) {
        return getDefaultExtension();
    }
    // 一个缓存key
    String cacheKey = name;
    if (!wrap) {
        cacheKey += "_origin";
    }
    // 根据缓存key获取实例对应的holder
    // 如果没有就创建一个空的holder
    final Holder<Object> holder = getOrCreateHolder(cacheKey);
    Object instance = holder.get();
    // 双重检查
    if (instance == null) {
        synchronized (holder) {
            instance = holder.get();
            if (instance == null) {
                // 创建对象
                instance = createExtension(name, wrap);
                holder.set(instance);
            }
        }
    }
    return (T) instance;
}
```

创建对象方法就包括读取SPI配置文件、创建class和初始化实例：

```java
private T createExtension(String name, boolean wrap) {
    // 加载SPI配置里对应的实现类
    Class<?> clazz = getExtensionClasses().get(name);
    if (clazz == null || unacceptableExceptions.contains(name)) {
        throw findException(name);
    }
    // 开始注入给接口
    try {
        // extensionInstances就是实现类和接口的缓存
        T instance = (T) extensionInstances.get(clazz);
        if (instance == null) {
            // 构造实现类，创建实现类和接口的缓存
            // 使用构造方法反射创建对象
            extensionInstances.putIfAbsent(clazz, createExtensionInstance(clazz));
            instance = (T) extensionInstances.get(clazz);
            // 对象实例化之前的处理，就是遍历extensionPostProcessors
            instance = postProcessBeforeInitialization(instance, name);
            // 通过setter方法依赖注入
            injectExtension(instance);
            // 对象实例化之后的处理，还是遍历extensionPostProcessors
            instance = postProcessAfterInitialization(instance, name);
        }

        // 如果wrapper就根据@wrapper注解进行包装
        if (wrap) {
            List<Class<?>> wrapperClassesList = new ArrayList<>();
            if (cachedWrapperClasses != null) {
                wrapperClassesList.addAll(cachedWrapperClasses);
                wrapperClassesList.sort(WrapperComparator.COMPARATOR);
                Collections.reverse(wrapperClassesList);
            }

            if (CollectionUtils.isNotEmpty(wrapperClassesList)) {
                for (Class<?> wrapperClass : wrapperClassesList) {
                    Wrapper wrapper = wrapperClass.getAnnotation(Wrapper.class);
                    if (wrapper == null
                        || (ArrayUtils.contains(wrapper.matches(), name) && !ArrayUtils.contains(wrapper.mismatches(), name))) {
                        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
                        instance = postProcessAfterInitialization(instance, name);
                    }
                }
            }
        }

        // Warning: After an instance of Lifecycle is wrapped by cachedWrapperClasses, it may not still be Lifecycle instance, this application may not invoke the lifecycle.initialize hook.
        initExtension(instance);
        return instance;
    } catch (Throwable t) {
        throw new IllegalStateException("Extension instance (name: " + name + ", class: " +
            type + ") couldn't be instantiated: " + t.getMessage(), t);
    }
}
```

关键就是方法第一行的getExtensionClasses()方法，dubbo把能缓存的都缓存了，扩展类的对象放在cachedClasses变量中，getExtensionClasses()方法中进行一个双重检查，如果没有加载过就调用loadExtensionClasses()方法加载：

```java
private Map<String, Class<?>> loadExtensionClasses() {
    checkDestroyed();
    // 缓存默认的实现类名称
    cacheDefaultExtensionName();
    // 扩展类的集合
    Map<String, Class<?>> extensionClasses = new HashMap<>();

    for (LoadingStrategy strategy : strategies) {
        // 加载开始
        loadDirectory(extensionClasses, strategy, type.getName());

        // compatible with old ExtensionFactory
        if (this.type == ExtensionInjector.class) {
            loadDirectory(extensionClasses, strategy, ExtensionFactory.class.getName());
        }
    }

    return extensionClasses;
}
```

loadDirectory()方法中又调用了重载的loadDirectory()：

```java
private void loadDirectory(Map<String, Class<?>> extensionClasses, String dir, String type,
                           boolean extensionLoaderClassLoaderFirst, boolean overridden,
                           String[] excludedPackages, String[] onlyExtensionClassLoaderPackages) {
    // 目录 + 接口名
    // 这样就能在对应的spi配置文件夹下找到对应的配置文件
    String fileName = dir + type;
    try {
        // 先拿到一些ClassLoader
        List<ClassLoader> classLoadersToLoad = new LinkedList<>();
        // try to load from ExtensionLoader's ClassLoader first
        if (extensionLoaderClassLoaderFirst) {
            ClassLoader extensionLoaderClassLoader = ExtensionLoader.class.getClassLoader();
            if (ClassLoader.getSystemClassLoader() != extensionLoaderClassLoader) {
                classLoadersToLoad.add(extensionLoaderClassLoader);
            }
        }

        // 这个是从scopeModel中获取ClassLoader
        Set<ClassLoader> classLoaders = scopeModel.getClassLoaders();
        if (CollectionUtils.isEmpty(classLoaders)) {
            // 读取SPI配置文件
            // 把里面的内容转成Enumeration<URL>对象
            Enumeration<java.net.URL> resources = ClassLoader.getSystemResources(fileName);
            if (resources != null) {
                // 遍历读取出来的URL，加载类
                // 加载的时候也要根据@Adaptive或者wrapper分别处理
                while (resources.hasMoreElements()) {
                    loadResource(extensionClasses, null, resources.nextElement(), overridden, excludedPackages, onlyExtensionClassLoaderPackages);
                }
            }
        } else {
            classLoadersToLoad.addAll(classLoaders);
        }

        Map<ClassLoader, Set<java.net.URL>> resources = ClassLoaderResourceLoader.loadResources(fileName, classLoadersToLoad);
        resources.forEach(((classLoader, urls) -> {
            // 这个和上面的loadResource()是一样的
            loadFromClass(extensionClasses, overridden, urls, classLoader, excludedPackages, onlyExtensionClassLoaderPackages);
        }));
    } catch (Throwable t) {
        logger.error("Exception occurred when loading extension class (interface: " +
            type + ", description file: " + fileName + ").", t);
    }
}
```

##### getAdaptiveExtension()

```java
/**
 * 这个方法针对的是@Adaptive注解的实现类
 * 如果有多个实现类，根据url里的参数匹配对应的实现类
 * 他通过动态加载code然后编译创建出来一个对象，并不是要直接使用的
 * 而是根据这个对象去匹配真正的实现类
 */
@SuppressWarnings("unchecked")
public T getAdaptiveExtension() {
    checkDestroyed();
    Object instance = cachedAdaptiveInstance.get();
    // 双重检查
    if (instance == null) {
        if (createAdaptiveInstanceError != null) {
            throw new IllegalStateException("Failed to create adaptive instance: " +
                createAdaptiveInstanceError.toString(),
                createAdaptiveInstanceError);
        }

        synchronized (cachedAdaptiveInstance) {
            instance = cachedAdaptiveInstance.get();
            if (instance == null) {
                try {
                    instance = createAdaptiveExtension();
                    // 设置缓存
                    cachedAdaptiveInstance.set(instance);
                } catch (Throwable t) {
                    createAdaptiveInstanceError = t;
                    throw new IllegalStateException("Failed to create adaptive instance: " + t.toString(), t);
                }
            }
        }
    }

    return (T) instance;
}
```

这个方法的调用链路关键就是createAdaptiveExtensionClass()方法：

```java
private Class<?> createAdaptiveExtensionClass() {
    // Adaptive Classes' ClassLoader should be the same with Real SPI interface classes' ClassLoader
    ClassLoader classLoader = type.getClassLoader();
    try {
        // 处理native类
        if (NativeUtils.isNative()) {
            return classLoader.loadClass(type.getName() + "$Adaptive");
        }
    } catch (Throwable ignore) {

    }
    // Adaptive是用class code generator做类代码生成
    // 就是说他的代码是动态生成的
    String code = new AdaptiveClassCodeGenerator(type, cachedDefaultName).generate();
    // 针对生成的代码做动态编译
    org.apache.dubbo.common.compiler.Compiler compiler = extensionDirector.getExtensionLoader(
        org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();
    return compiler.compile(code, classLoader);
}
```

### ExtensionDirector

他是用来管理ExtensionLoader的，其中最主要的就是extensionLoadersMap。

```java
/**
 * 维护Class对象和ExtensionLoader的关系
 */
private final ConcurrentMap<Class<?>, ExtensionLoader<?>> extensionLoadersMap = new ConcurrentHashMap<>(64);
/**
 * 可能是个树？
 */
private ExtensionDirector parent;
/**
 * 作用范围
 */
private final ExtensionScope scope;
/**
 * Extension扩展势力的后处理
 */
private List<ExtensionPostProcessor> extensionPostProcessors = new ArrayList<>();
/**
 * 每个Model都会关联一个ExtensionDirector
 * 每个ExtensionDirector又回关联一个Model
 */
private ScopeModel scopeModel;
private AtomicBoolean destroyed = new AtomicBoolean();
```

