---
title: 8.model组件源码
tags:
  - 源码
categories: Dubbo
copyright: true
---

Model的相关组件在我们初始化provider之前就已经创建好了，先进到总父类ScopeModel中，看到他继承了ExtensionAccessor接口，看这个名就和SPI有关系，猜测只要实现了ExtensionAccessor接口就具备了使用SPI机制获取指定接口扩展实现的能力。

##### ScopeModel

看一下类中的变量：

```java
/**
 * 这个是他内部的id，用来定位model在model树中的位置
 * <ol>
 *     <li>1</li>
 *     FrameworkModel (index=1)
 *     <li>1.2</li>
 *     FrameworkModel (index=1) -> ApplicationModel (index=2)
 *     <li>1.2.0</li>
 *     FrameworkModel (index=1) -> ApplicationModel (index=2) -> ModuleModel (index=0, internal module)
 *     <li>1.2.1</li>
 *     FrameworkModel (index=1) -> ApplicationModel (index=2) -> ModuleModel (index=1, first user module)
 * </ol>
 */
private String internalId;

/**
 * Public Model Name, can be set from user
 */
private String modelName;

private String desc;

/**
 * 一批要使用的类加载器
 */
private Set<ClassLoader> classLoaders;

/**
 * 这个是父类，也就是通过这个属性构成的model树
 */
private final ScopeModel parent;
/**
 * 这个是枚举类，用来表示Extension实例对象的范围
 * 因为有很多的Model组件，这个属性就决定了当前Model创建出的Extension实例在那个范围可以使用
 * 是当前框架都能用还是当前模块都能用
 */
private final ExtensionScope scope;

/**
 * 他是一个Extension loader的管理组件
 * 如果想针对某个接口加载SPI的实现类，就要用这个变量获取到接口对应的ExtensionLoader组件，再去获取对应的实现类
 */
private ExtensionDirector extensionDirector;

/**
 * 这个就和Spring类似的
 * dubbo自己实现的，负责管理在dubbo框架内部共享的bean
 */
private ScopeBeanFactory beanFactory;
/**
 * model组件的生命周期事件监听
 */
private List<ScopeModelDestroyListener> destroyListeners;
/**
 * 这个应该放的是当前Model的属性
 */
private Map<String, Object> attributes;
/**
 * 当前组件是否被销毁
 */
private final AtomicBoolean destroyed = new AtomicBoolean(false);
```

这个父类的构造方法就是设置parent和ExtensionScope，还有一些属性实在initialize()方法中设置的：

```java
protected void initialize() {
    // 创建ExtensionDirector，ExtensionDirector里也有parent属性的
    this.extensionDirector = new ExtensionDirector(parent != null ? parent.getExtensionDirector() : null, scope, this);
    // 创建Extension之后的处理操作
    // 其实就是只要Extension继承了ScopeModelAware接口，就把当前的Model设置进去
    this.extensionDirector.addExtensionPostProcessor(new ScopeModelAwareExtensionProcessor(this));
    this.beanFactory = new ScopeBeanFactory(parent != null ? parent.getBeanFactory() : null, extensionDirector);
    this.destroyListeners = new LinkedList<>();
    this.attributes = new ConcurrentHashMap<>();
    this.classLoaders = new ConcurrentHashSet<>();

    // Add Framework's ClassLoader by default
    ClassLoader dubboClassLoader = ScopeModel.class.getClassLoader();
    if (dubboClassLoader != null) {
        this.addClassLoader(dubboClassLoader);
    }
}
```

ScopeModel一共有3个子类ModuleModel、ApplicationModel、FrameworkModel。

##### ModuleModel

ModuleModel中多了一些和服务相关的属性，还依赖了ApplicationModel。

```java
public static final String NAME = "ModuleModel";

// 他和ApplicationModel是引用关系,ConfigManager在这里
private final ApplicationModel applicationModel;
// 这个就是一些配置
private ModuleEnvironment moduleEnvironment;
// 服务仓储,存储的都是服务数据，里面有服务对应的map,consumer的map、provider的map等
private ModuleServiceRepository serviceRepository;
// 这个里面有服务的元数据相关、配置中心、上报中心
private ModuleConfigManager moduleConfigManager;
// 管理其他模块和组件的生命周期
private ModuleDeployer deployer;
```

在看看他的构造方法

```java
public ModuleModel(ApplicationModel applicationModel, boolean isInternal) {
    // 这里就能看到他把传进来的ApplicationModel当成自己的父组件了
    // 同时作用范围是ExtensionScope.MODULE，就是说不同的Model创建的Extension是不一样的
    super(applicationModel, ExtensionScope.MODULE);
    Assert.notNull(applicationModel, "ApplicationModel can not be null");
    // 又把传进来的ApplicationModel赋值到一个成员变量
    this.applicationModel = applicationModel;
    // 这个的意思应该就是ApplicationModel中维护了一堆ModuleModel类型的子节点
    // 通过这个方法把ModuleModel加到子节点中并设置internalId
    applicationModel.addModule(this, isInternal);
    if (LOGGER.isInfoEnabled()) {
        LOGGER.info(getDesc() + " is created");
    }
	// 初始化
    initialize();
    Assert.notNull(serviceRepository, "ModuleServiceRepository can not be null");
    Assert.notNull(moduleConfigManager, "ModuleConfigManager can not be null");
    Assert.assertTrue(moduleConfigManager.isInitialized(), "ModuleConfigManager can not be initialized");

    // notify application check state
    ApplicationDeployer applicationDeployer = applicationModel.getDeployer();
    if (applicationDeployer != null) {
        applicationDeployer.notifyModuleChanged(this, DeployState.PENDING);
    }
}
```

可以把初始化的代码是一个扩展，我们可以实现ScopeModelInitializer的实现类放到SPI配置中，这样就会在initialize()方法中被执行

```java
protected void initialize() {
    super.initialize();
    this.serviceRepository = new ModuleServiceRepository(this);
    this.moduleConfigManager = new ModuleConfigManager(this);
    this.moduleConfigManager.initialize();

    initModuleExt();

    // 通过SPI获取一堆ScopeModelInitializer的实现类
    ExtensionLoader<ScopeModelInitializer> initializerExtensionLoader = this.getExtensionLoader(ScopeModelInitializer.class);
    Set<ScopeModelInitializer> initializers = initializerExtensionLoader.getSupportedExtensionInstances();
    for (ScopeModelInitializer initializer : initializers) {
        initializer.initializeModuleModel(this);
    }
}
```

##### ApplicatioonModel

他主要是用来管理ModuleModel的，看一下变量：

```java
// 子ModuleModel节点
private final List<ModuleModel> moduleModels = Collections.synchronizedList(new ArrayList<>());
private final List<ModuleModel> pubModuleModels = Collections.synchronizedList(new ArrayList<>());
// 环境变量
private Environment environment;
// 服务配置
private ConfigManager configManager;
// 这个也是服务数据相关的
private ServiceRepository serviceRepository;
// ApplicationModel级组件的声明周期的管理组件
private ApplicationDeployer deployer;

private final FrameworkModel frameworkModel;

private ModuleModel internalModule;
// 默认的ModuleModel
private volatile ModuleModel defaultModule;

// internal module index is 0, default module index is 1
// 这个应该是用来生成internalId的
private AtomicInteger moduleIndex = new AtomicInteger(0);
private Object moduleLock = new Object();
```

他有一个static的方法用来获取defaultModel，所以应该是有一个单例的ApplicatioonModel在上一层树种，然后还可以通过构造方法创建ApplicationModel实例：

```java
public ApplicationModel(FrameworkModel frameworkModel, boolean isInternal) {
    // ApplicationModel的parent是FrameworkModel
    // 通过ApplicationModel创建的Model的作用范围是ExtensionScope.APPLICATION
    // 意思是说ApplicationModel创建的Model可以在子Model中使用
    super(frameworkModel, ExtensionScope.APPLICATION);
    Assert.notNull(frameworkModel, "FrameworkModel can not be null");
    this.isInternal = isInternal;
    this.frameworkModel = frameworkModel;
    frameworkModel.addApplication(this);
    if (LOGGER.isInfoEnabled()) {
        LOGGER.info(getDesc() + " is created");
    }
    initialize();
}
```

他的initialize()和ModuleModel差不多。

##### FrameworkModel

每个Model都有服务信息的组件，它里面的变量也很少:

```java
public static final String NAME = "FrameworkModel";
/**
 * 这个是自己的internalId
 * 因为没有父级了，所以是静态通用的
 */
private static final AtomicLong index = new AtomicLong(1);
// 这个是用来成成ApplicationModel的internalId
private final AtomicLong appIndex = new AtomicLong(0);

private static Object globalLock = new Object();

/**
 * 这个是他自己的单例默认实例
 */
private volatile static FrameworkModel defaultInstance;

private volatile ApplicationModel defaultAppModel;
/**
 * 他没有父级了
 * 所以要通过一个list保存所有的FrameworkModel
 */
private static List<FrameworkModel> allInstances = Collections.synchronizedList(new ArrayList<>());

/**
 * 子ApplicationModel节点
 */
private List<ApplicationModel> applicationModels = Collections.synchronizedList(new ArrayList<>());

private List<ApplicationModel> pubApplicationModels = Collections.synchronizedList(new ArrayList<>());

/**
 * 服务数据
 */
private FrameworkServiceRepository serviceRepository;

private ApplicationModel internalApplicationModel;
```

构造方法也很简单：

```java
public FrameworkModel() {
    super(null, ExtensionScope.FRAMEWORK);
    this.setInternalId(index.getAndIncrement()+"");
    synchronized (globalLock) {
        allInstances.add(this);
        // 设置默认的FrameworkModel
        resetDefaultFrameworkModel();
    }
    if (LOGGER.isInfoEnabled()) {
        LOGGER.info(getDesc() + " is created");
    }
    initialize();
}
```

##### ScopeBeanFactory

ScopeBeanFactory是ScopeModel中的变量，他就是存储框架里用到的bean实例，先看变量：

```java
/**
 * 他也有父级
 */
private final ScopeBeanFactory parent;
/**
 * ExtensionAccessor的实现类
 */
private ExtensionAccessor extensionAccessor;
private List<ExtensionPostProcessor> extensionPostProcessors;
/**
 * 每个class都有AtomicInteger的计数器
 */
private Map<Class, AtomicInteger> beanNameIdCounterMap = new ConcurrentHashMap<>();
/**
 * 注册过的Bean实例的注册信息
 * BeanInfo里就是名称和具体事例
 */
private List<BeanInfo> registeredBeanInfos = Collections.synchronizedList(new ArrayList<>());
/**
 * 初始化策略
 */
private InstantiationStrategy instantiationStrategy;
private AtomicBoolean destroyed = new AtomicBoolean();
```

构造方法里也没有什么东西，获取后处理逻辑，然后再构建一个初始化的策略。

获取bean的方法：

```java
public <T> T getOrRegisterBean(String name, Class<T> type) {
    T bean = getBean(name, type);
    if (bean == null) {
        // lock by type
        synchronized (type) {
            bean = getBean(name, type);
            if (bean == null) {
                // 如果没找到就创建
                bean = createAndRegisterBean(name, type);
            }
        }
    }
    return bean;
}
```

getBean()就是现在自己这找，没有就去父类，父类没有就反null，创建bean的源码：

```java
private <T> T createAndRegisterBean(String name, Class<T> clazz) {
    checkDestroyed();
    T instance = getBean(name, clazz);
    if (instance != null) {
        throw new ScopeBeanException("already exists bean with same name and type, name=" + name + ", type=" + clazz.getName());
    }
    try {
        // 使用创建策略初始化bean
        instance = instantiationStrategy.instantiate(clazz);
    } catch (Throwable e) {
        throw new ScopeBeanException("create bean instance failed, type=" + clazz.getName(), e);
    }
    // 注册bean
    registerBean(name, instance);
    return instance;
}
```

##### ModuleDeployer

ModuleDeployer是ModuleModel中管理其他组件生命周期的，他的实现是DefaultModuleDeployer，他是和Model对应的，就是说还有ApplicationDeployer这些，初始化的方法已经在provider启动的时候看过了。