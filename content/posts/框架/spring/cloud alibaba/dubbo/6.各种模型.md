---
title: 6.各种模型源码
tags:
  - 源码
categories: Dubbo
copyright: true
---

##### 1.filter模型

这是一责任链模式。在DefaultFilterChainBuilder的buildInvokerChain()方法中拿到所有Filter，然后遍历添加到过滤链FilterChainNode里：

```java
public <T> Invoker<T> buildInvokerChain(final Invoker<T> originalInvoker, String key, String group) {
    Invoker<T> last = originalInvoker;
    URL url = originalInvoker.getUrl();
    // 这个就是读取SPI动态扩展配置里的实现类
    // 他默认的应该就两个ZoneAwareFilter和ConsumerContextFilter
    List<Filter> filters = ScopeModelUtil.getExtensionLoader(Filter.class, url.getScopeModel()).getActivateExtension(url, key, group);

    if (!filters.isEmpty()) {
        for (int i = filters.size() - 1; i >= 0; i--) {
            final Filter filter = filters.get(i);
            final Invoker<T> next = last;
            last = new FilterChainNode<>(originalInvoker, next, filter);
        }
    }

    return last;
}
```

AccessLogFilter：创建一步任务把日志写到磁盘文件

ExecuteLimitFilter：provider端根据配置，针对类和方法限制调用的并发量，配置值：executes，超过上线会直接抛出异常

ActiveLimitFilter：consumer端根据配置，对接口的并发量控制，配置值：actives，超过上限会等待"timeout"时间，然后再抛出异常

##### 2.业务分发线程模型

###### 1）AllDispatcher

AllDispatcher是默认的分发模型，他的dispatch()方法创建了AllChannelHandler。这个handler的建立连接、断开连接、收到请求、发生异常都会走线程池，获取线程池的方法在父类WrappedChannelHandler中。

```java
public class AllChannelHandler extends WrappedChannelHandler {

    @Override
    public void connected(Channel channel) throws RemotingException {
        // 完成连接建立事件
        // 拿到线程池
        ExecutorService executor = getSharedExecutorService();
        try {
            executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.CONNECTED));
        } catch (Throwable t) {
            throw new ExecutionException("connect event", channel, getClass() + " error when process connected event .", t);
        }
    }

    @Override
    public void disconnected(Channel channel) throws RemotingException {
        // 断开连接
        ExecutorService executor = getSharedExecutorService();
        try {
            executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED));
        } catch (Throwable t) {
            throw new ExecutionException("disconnect event", channel, getClass() + " error when process disconnected event .", t);
        }
    }

    @Override
    public void received(Channel channel, Object message) throws RemotingException {
        // 收到请求
        ExecutorService executor = getPreferredExecutorService(message);
        try {
            executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));
        } catch (Throwable t) {
            if(message instanceof Request && t instanceof RejectedExecutionException){
                sendFeedback(channel, (Request) message, t);
                return;
            }
            throw new ExecutionException(message, channel, getClass() + " error when process received event .", t);
        }
    }

    @Override
    public void caught(Channel channel, Throwable exception) throws RemotingException {
        // 出现异常
        ExecutorService executor = getSharedExecutorService();
        try {
            executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.CAUGHT, exception));
        } catch (Throwable t) {
            throw new ExecutionException("caught event", channel, getClass() + " error when process caught event .", t);
        }
    }
}
```

除了处理请求是使用getPreferredExecutorService()，其他情况拿到的都是共享线程池getSharedExecutorService();

###### 2）DirectDispatcher

DirectDispatcher创建的是DirectChannelHandler，这个handler只有在收到请求并且根据消息拿到的线程池是ThreadlessExecutor类型的的时候才会提交到线程池，否则或者其他的事件比如建立连接就同步调用handler处理了。

```java
public class DirectChannelHandler extends WrappedChannelHandler {

    @Override
    public void received(Channel channel, Object message) throws RemotingException {
        ExecutorService executor = getPreferredExecutorService(message);
        if (executor instanceof ThreadlessExecutor) {
            try {
                executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));
            } catch (Throwable t) {
                throw new ExecutionException(message, channel, getClass() + " error when process received event .", t);
            }
        } else {
            handler.received(channel, message);
        }
    }
}
```

###### 3）MessageOnlyDispatcher

MessageOnlyDispatcher创建的是MessageOnlyChannelHandler，他跟DirectChannelHandler不一样的地方是，只要是received事件都会走线程池：

```java
public class MessageOnlyChannelHandler extends WrappedChannelHandler {

    @Override
    public void received(Channel channel, Object message) throws RemotingException {
        ExecutorService executor = getPreferredExecutorService(message);
        try {
            executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));
        } catch (Throwable t) {
            if(message instanceof Request && t instanceof RejectedExecutionException){
                sendFeedback(channel, (Request) message, t);
                return;
            }
            throw new ExecutionException(message, channel, getClass() + " error when process received event .", t);
        }
    }
}
```

###### 4）ExecutionDispatcher

ExecutionDispatcher创建的是ExecutionChannelHandler，这个handler只把请求类型放进线程池，如果是响应就同步调用：

```java
public class ExecutionChannelHandler extends WrappedChannelHandler {

    @Override
    public void received(Channel channel, Object message) throws RemotingException {
        ExecutorService executor = getPreferredExecutorService(message);

        if (message instanceof Request) {
            try {
                executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));
            } catch (Throwable t) {
                // FIXME: when the thread pool is full, SERVER_THREADPOOL_EXHAUSTED_ERROR cannot return properly,
                // therefore the consumer side has to wait until gets timeout. This is a temporary solution to prevent
                // this scenario from happening, but a better solution should be considered later.
                if (t instanceof RejectedExecutionException) {
                    sendFeedback(channel, (Request) message, t);
                }
                throw new ExecutionException(message, channel, getClass() + " error when process received event.", t);
            }
        } else if (executor instanceof ThreadlessExecutor) {
            executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));
        } else {
            handler.received(channel, message);
        }
    }
}
```

##### 5）ConnectionOrderedDispatcher

ConnectionOrderedDispatcher创建的是ConnectionOrderedChannelHandler，这个handler自己内部有一个线程池，建立和断开连接会提交到自己的线程池中执行，其他的情况还是通过WrappedChannelHandler中的方法获取。

##### 3.线程池模型

处理请求的所有handler都是继承WrappedChannelHandler的，这个里面封装了建立连接、断开连接、收到请求、发生异常的默认处理都是同步的，获取两个线程池的方法也在这里。

其实只有处理响应的操作才会使用其他的线程池，剩下的情况走的都是getSharedExecutorService()：

```java
public ExecutorService getPreferredExecutorService(Object msg) {
    if (msg instanceof Response) {
        // 响应的话就根据response拿到对应的DefaultFutrue
        // 使用DefaultFutrue中的线程池返回
        Response response = (Response) msg;
        DefaultFutrue responseFutrue = DefaultFutrue.getFutrue(response.getId());
        // a typical scenario is the response returned after timeout, the timeout response may have completed the futrue
        // responseFutrue == null或者executor.isShutdown()都可能是因为请求超时，这个时候还是用getSharedExecutorService()
        if (responseFutrue == null) {
            return getSharedExecutorService();
        } else {

            ExecutorService executor = responseFutrue.getExecutor();
            if (executor == null || executor.isShutdown()) {
                executor = getSharedExecutorService();
            }
            return executor;
        }
    } else {
        return getSharedExecutorService();
    }
}
```

再看getSharedExecutorService()方法：

```java
public ExecutorService getSharedExecutorService() {
    // Application可能会在channel创建前先销毁，这里是解决这个bug
    // see https://github.com/apache/dubbo/issues/9127
    if (url.getApplicationModel() == null || url.getApplicationModel().isDestroyed()) {
        return GlobalResourcesRepository.getGlobalExecutorService();
    }

    // note: url.getOrDefaultApplicationModel() may create new application model
    ApplicationModel applicationModel = url.getOrDefaultApplicationModel();
    // 还是从SPI获取ExecutorRepository的实现类
    // ExecutorRepository是管理线程池的组件
    ExecutorRepository executorRepository =
            applicationModel.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();
    ExecutorService executor = executorRepository.getExecutor(url);
    if (executor == null) {
        executor = executorRepository.createExecutorIfAbsent(url);
    }
    return executor;
}
```

创建线程池的方法都在**DefaultExecutorRepository**的createExecutor()中：

```java
private ExecutorService createExecutor(URL url) {
    // 通过SPI扩展配置拿到实现类，创建线程池
    // 里面配置了4个实现类，getAdaptiveExtension()就是获取默认的实现类，默认的是fixed，在ThreadPool接口的SPI注解中配置的
    return (ExecutorService) extensionAccessor.getExtensionLoader(ThreadPool.class).getAdaptiveExtension().getExecutor(url);
}
```

剩下3种线程池说明：

*   LimitedThreadPool根据忙碌情况创建线程，但是不会超过最大值。
*   EagerThreadPool最大线程数是Integer.MAX_VALUE并且不会回收，这个就要慎用。
*   CachedThreadPool，他的最大线程数也是Integer.MAX_VALUE，但是他会回收空闲线程。

##### 4.网络服务模型

启动服务的代码在DubboProtocol的createServer()方法里，这个方法里会调用**Exchangers.bind(url, requestHandler);**，requestHandler是DubboProtocol自己创建的，通过Exchangers.bind把handler一顿封装，然后再实例化一个nettyServer。

NettyServer把包装好的ChannelHandlerDispatcher和AllDispatcher关联，这样在收到请求的时候就可以通过ChannelHandlerDispatcher把请求转发给AllDispatcher了。

![](https://tva1.sinaimg.cn/large/008vxvgGly1h814n0e0bpj31jn0u0tc9.jpg)

