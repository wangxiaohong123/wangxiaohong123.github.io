---
title: spring-boot-2.源码
date: 2021-01-19 06:27:35
tags:
  - spring-boot
categories: 框架
copyright: true
---

Spring boot的源码和spring的代码耦合的很多，所以看的时候不能看细节，一细就会进到spring的源码里，所以查看主要功能的思路就可以，比如自动装配。

源码都在spring-boot-project模块里，直接进到SpringApplication的run(Class<?>[] primarySources, String[] args)方法里，这个也是我们启动服务的入口：

```java
public static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {
    // 先用我们自己的Application类初始化一个SpringApplication，然后调用他的run()方法
   return new SpringApplication(primarySources).run(args);
}
```

#### 一、初始化SpringApplication源码：

```java
public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
   this.resourceLoader = resourceLoader;
   Assert.notNull(primarySources, "PrimarySources must not be null");
   // 这个就是我们传进来的类
   this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));
   // 根据classpath推断工程类型,拿到的是SERVLET
   this.webApplicationType = WebApplicationType.deduceFromClasspath();
    // ApplicationContextInitializer是个接口，我们自己或者第三方框架可能自定义他的实现类
	// 在spring容器初始化的时候会被调用
   setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
    // ApplicationListener他也是个接口，他是在发生事件的时候会被回调
   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
   this.mainApplicationClass = deduceMainApplicationClass();
}
```

##### 1.推断工程类型就是看项目里有没有和对应类型匹配的类：

```java
static WebApplicationType deduceFromClasspath() {
   // 他写死了一些类，然后再classpath里扫描jar包和我们自己开发的类，如果和写死的类匹配上了就返回对应的类型
   if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) && !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)
         && !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) {
      return WebApplicationType.REACTIVE;
   }
   for (String className : SERVLET_INDICATOR_CLASSES) {
      if (!ClassUtils.isPresent(className, null)) {
         return WebApplicationType.NONE;
      }
   }
   return WebApplicationType.SERVLET;
}
```

##### 2.设置ApplicationContextInitializer和ApplicationListener调用的是Spring的SpringFactoriesLoader里的方法，他会扫描各个META-INF/spring.factories文件里的配置类。

##### 3.找到项目主类：

```java
private Class<?> deduceMainApplicationClass() {
   try {
      // new RuntimeException().getStackTrace()可以获取方法的调用栈
      StackTraceElement[] stackTrace = new RuntimeException().getStackTrace();
      // 找到调用栈里第一个main方法所在的类
      for (StackTraceElement stackTraceElement : stackTrace) {
         if ("main".equals(stackTraceElement.getMethodName())) {
            return Class.forName(stackTraceElement.getClassName());
         }
      }
   }
   catch (ClassNotFoundException ex) {
      // Swallow and continue
   }
   return null;
}
```

#### 二、SpringApplication.run()方法源码

```java
public ConfigurableApplicationContext run(String... args) {
   StopWatch stopWatch = new StopWatch();
   stopWatch.start();
   ConfigurableApplicationContext context = null;
   Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();
   configureHeadlessProperty();
   // 拿到SpringApplicationRunListeners，里面放到是SpringApplicationRunListener的实现类
   // 就是说我们可以自己实现SpringApplicationRunListener，在这个方法里就会调用对应的方法
   SpringApplicationRunListeners listeners = getRunListeners(args);
   // 拿到所有的listener然后遍历调用starting()，就是广播了一下启动事件
   listeners.starting();
   try {
      ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
      // 准备环境
      // 在这里也会回调listener的一个方法
      ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);
      configureIgnoreBeanInfo(environment);
      Banner printedBanner = printBanner(environment);
      // 这个非常关键，创建AnnotationConfigServletWebServerApplicationContext
      context = createApplicationContext();
      exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,
            new Class[] { ConfigurableApplicationContext.class }, context);
      prepareContext(context, environment, listeners, applicationArguments, printedBanner);
      // 这个很关键，刷新刚才加载进去的postProcessor
      // 这里可能会执行核心代码逻辑，比如spring bean的初始化、spring mvc、tomcat等等
      refreshContext(context);
      afterRefresh(context, applicationArguments);
      stopWatch.stop();
      if (this.logStartupInfo) {
         new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
      }
       // 第一个spring容器启动之后会通过监听回调触发正式的spring容器初始化和后面的系统启动工作
      listeners.started(context);
      callRunners(context, applicationArguments);
   }
   catch (Throwable ex) {
      handleRunFailure(context, ex, exceptionReporters, listeners);
      throw new IllegalStateException(ex);
   }

   try {
      listeners.running(context);
   }
   catch (Throwable ex) {
      handleRunFailure(context, ex, exceptionReporters, null);
      throw new IllegalStateException(ex);
   }
   return context;
}
```

refreshContext(context);时已知这个context是AnnotationConfigServletWebServerApplicationContext，refresh()方法会走到他的父类**ServletWebServerApplicationContext**的refresh()方法。

refresh()首先会调用到**AbstractApplicationContext**里，AbstractApplicationContext的refresh()方法里有几个调用非常关键：

```java
public void refresh() throws BeansException, IllegalStateException {
    synchronized(this.startupShutdownMonitor) {
        // 创建spring容器
        this.prepareRefresh();
        ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
        this.prepareBeanFactory(beanFactory);

        try {
            this.postProcessBeanFactory(beanFactory);
            this.invokeBeanFactoryPostProcessors(beanFactory);
            // 注册bean的后处理器
            // 比如AutowriteAnnotationBeanPostProcessor
            this.registerBeanPostProcessors(beanFactory);
            this.initMessageSource();
            this.initApplicationEventMulticaster();
            // 启动tomcat
            this.onRefresh();
            this.registerListeners();
            // 这里通过spring的getBean()来初始化各种bean，比如数据库相关、dubbo相关
            this.finishBeanFactoryInitialization(beanFactory);
            // 
            this.finishRefresh();
        } catch (BeansException var9) {
            if (this.logger.isWarnEnabled()) {
                this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var9);
            }
            this.destroyBeans();
            this.cancelRefresh(var9);
            throw var9;
        } finally {
            this.resetCommonCaches();
        }

    }
}
```

##### 1.启动tomcat源码

onRefresh()方法会调回AnnotationConfigServletWebServerApplicationContext的onRefresh()，onRefresh()中又会调用createWebServer():

```java
private void createWebServer() {
   WebServer webServer = this.webServer;
   ServletContext servletContext = getServletContext();
   if (webServer == null && servletContext == null) {
      // 从beanFactory中获取webServerFactory
      // 默认拿到的是TomcatServletWebServerFactory，可以改成JettyServletWebServerFactory
      ServletWebServerFactory factory = getWebServerFactory();
      // 获取网络容器
      this.webServer = factory.getWebServer(getSelfInitializer());
   } else if (servletContext != null) {
      try {
         getSelfInitializer().onStartup(servletContext);
      }
      catch (ServletException ex) {
         throw new ApplicationContextException("Cannot initialize servlet context", ex);
      }
   }
   initPropertySources();
}
```

进到TomcatServletWebServerFactory的getWebServer中查看创建tomcat的代码：

```java
public WebServer getWebServer(ServletContextInitializer... initializers) {
   Tomcat tomcat = new Tomcat();
   File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir("tomcat");
   tomcat.setBaseDir(baseDir.getAbsolutePath());
   Connector connector = new Connector(this.protocol);
   tomcat.getService().addConnector(connector);
   customizeConnector(connector);
   tomcat.setConnector(connector);
   tomcat.getHost().setAutoDeploy(false);
   configureEngine(tomcat.getEngine());
   for (Connector additionalConnector : this.additionalTomcatConnectors) {
      tomcat.getService().addConnector(additionalConnector);
   }
   prepareContext(tomcat.getHost(), initializers);
   return getTomcatWebServer(tomcat);
}
```

创建完Tomcat之后需要组装成WebServer，在调用WebServer构造方法时会调用WebServer的initialize()方法，在这个方法里启动了tomcat：

```java
private void initialize() throws WebServerException {
		logger.info("Tomcat initialized with port(s): " + getPortsDescription(false));
		synchronized (this.monitor) {
			try {
				……
				// 启动tomcat
                // 这里还会创建一个WebApplicationContext
				this.tomcat.start();
				rethrowDeferredStartupExceptions();

				try {
					ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());
				}
				// Unlike Jetty, all Tomcat threads are daemon threads. We create a
				// blocking non-daemon to stop immediate shutdown
				startDaemonAwaitThread();
			}
			catch (Exception ex) {
				stopSilently();
				destroySilently();
				throw new WebServerException("Unable to start embedded Tomcat", ex);
			}
		}
	}
```

#### 三、@EnableAutoConfiguration源码

这个是启用自动装配的注解，这个注解里有个@Import注解，很关键，引入的类是AutoConfigurationImportSelector，断点跟进发现这个类的内部类AutoConfigurationGroup的selectImports()方法会被引用，这里就是根据autoConfigurationEntries过滤，然后返回符合条件的自动装配的配置类，这些配置类都是在spring.factories文件中配置的，web，redis，jdbc等是spring boot自带的，其他的三方可以自己创建并配置spring.factories。

这些配置类什么时候被扫描到了autoConfigurationEntries对象中？

##### 1.web server的自动装配

autoConfigurationEntries中有一个自动装配的类是ServletWebServerFactoryAutoConfiguration，他是负责注入网络容器的：

```java
/**
 * 自动注入网络容器
 * 这个类创建了两个bean，ServletWebServerFactoryCustomizer和TomcatServletWebServerFactoryCustomizer
 * 其中TomcatServletWebServerFactoryCustomizer的创建条件是需要有Tomcat这个bean
 *
 * @Import注解引入的第一个类是这个类的内部类，BeanPostProcessorsRegistrar注册了两个PostProcessor
 * EmbeddedTomcat就是创建一个TomcatServletWebServerFactory，在启动tomcat的时候会用到这个类
 * EmbeddedJetty就是创建一个JettyServletWebServerFactory
 * EmbeddedUndertow也是一个web容器，但是用的不多，红冒公司的
 */
@Configuration
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@ConditionalOnClass(ServletRequest.class)
@ConditionalOnWebApplication(type = Type.SERVLET)
@EnableConfigurationProperties(ServerProperties.class)
@Import({ ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,
      ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,
      ServletWebServerFactoryConfiguration.EmbeddedJetty.class,
      ServletWebServerFactoryConfiguration.EmbeddedUndertow.class })
public class ServletWebServerFactoryAutoConfiguration {

   @Bean
   public ServletWebServerFactoryCustomizer servletWebServerFactoryCustomizer(ServerProperties serverProperties) {
      return new ServletWebServerFactoryCustomizer(serverProperties);
   }

   @Bean
   @ConditionalOnClass(name = "org.apache.catalina.startup.Tomcat")
   public TomcatServletWebServerFactoryCustomizer tomcatServletWebServerFactoryCustomizer(
         ServerProperties serverProperties) {
      return new TomcatServletWebServerFactoryCustomizer(serverProperties);
   }

   /**
    * 这个类是在上面的@Import注解引入的，这个类里注册了两个PostProcessor
    */
   public static class BeanPostProcessorsRegistrar implements ImportBeanDefinitionRegistrar, BeanFactoryAware {

      private ConfigurableListableBeanFactory beanFactory;

      @Override
      public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
         if (beanFactory instanceof ConfigurableListableBeanFactory) {
            this.beanFactory = (ConfigurableListableBeanFactory) beanFactory;
         }
      }

      @Override
      public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
            BeanDefinitionRegistry registry) {
         if (this.beanFactory == null) {
            return;
         }
         registerSyntheticBeanIfMissing(registry, "webServerFactoryCustomizerBeanPostProcessor",
               WebServerFactoryCustomizerBeanPostProcessor.class);
         registerSyntheticBeanIfMissing(registry, "errorPageRegistrarBeanPostProcessor",
               ErrorPageRegistrarBeanPostProcessor.class);
      }

      private void registerSyntheticBeanIfMissing(BeanDefinitionRegistry registry, String name, Class<?> beanClass) {
         if (ObjectUtils.isEmpty(this.beanFactory.getBeanNamesForType(beanClass, true, false))) {
            RootBeanDefinition beanDefinition = new RootBeanDefinition(beanClass);
            beanDefinition.setSynthetic(true);
            registry.registerBeanDefinition(name, beanDefinition);
         }
      }
   }
}
```

##### 2.spring mvc的自动装配

mvc的自动装配分成两个类，DispatcherServletAutoConfiguration和WebMvcAutoConfiguration，DispatcherServletAutoConfiguration里主要创建了DispatcherServlet，然后拿着DispatcherServlet创建DispatcherServletRegistrationBean。DispatcherServletRegistrationBean设置了关注的url是/*，也就是说所有的请求都会交给DispatcherServlet来处理，然后网络容器一定会回调addRegistration()方法，通过这个方法把DispatcherServlet动态加到网络容器的ServletContext中。

