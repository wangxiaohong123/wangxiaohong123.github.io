---
title: 4.扫描
tags:
  - spring-framework
categories: 框架
copyright: true
---

启动容器时会执行一堆BeanFactoryPostProcessor接口和子接口的方法，ConfigurationClassPostProcessor实现了BeanDefinitionRegistryPostProcessor，所以这个类有父接口和子接口的方法，扫描的代码入口就在子接口的方法实现里。

@inherited注解标记的类上的注解会被子类继承，接口无效。

###### 半配置和全配置

全配置会被代理，为了确保@Bean对应的Bean的作用域的正确，在全被配置类里可以保证@Bean配置的Bean的作用域是单例的，而半配置类没法保证。

除了@Bean注解产生的类或者ImportBeanDefinitionRegistrar的实现类，其他的Bean都是配置类！

###### 1.Spring中存在多个扫描器

容器启动的时候会创建一个ClassPathBeanDefinitionScanner，当ConfigurationClassPostProcessor扫描类的时候又会在方法里创建一个局部的ClassPathBeanDefinitionScanner，这两个有什么区别？

第一个scanner是负责处理我们手动设置的扫描路径context.scan("包名")，这里要注意如果我们手动设置扫描路径实例化容器的时候是不能传配置类的，因为传进去一个配置类，容器会自动调用refresh()方法，这个时候我们在调用context.scan("包名")就不生效，因为容器已经启动了，设置完之后需要手动调用refresh()方法。

第二个scanner是负责处理@ComponentScan注解的。

修改第一个名字生成器需要再调用applicationContext.setBeanNameGenerator()，修改第二个生成器需要再@ComponentScan注解里设置nameGenerator属性。**注意**修改scanner1的时候他会把生成器放到单例池中，这个时候scanner2也会被修改，也就是说通过applicationContext.setBeanNameGenerator()设置的名字生成器是全局的，所有名字生成器都会使用设置的这个。

###### 2.为什么Spring在加载类的时候不是通过反射，而是使用了ASM技术？

因为通过反射加载的类会进到元数据空间，如果累里面有静态代码块，此时也会执行，但是很有可能这个类不是一个Bean，我们也不需要提前把这个类加载到元数据空间里，ASM就会实现这个效果，最小限度的干扰我们。

###### 3.@Configuration+@Bean怎么保证单例

添加了@Configuration注解，这个类就会被标记成全配置类，全配置类在BeanFactoryPostProcessor的回调里会被CGLib代理，代理的类里加了3个callbackFilter，分别是处理@Bean标记的方法，和setBeanFactory()方法。处理@Bean方法的callback在执行方法前会把方法信息存到threadlocal里判断是否是当前执行的方法避免单例Bean被重复创建：

```java
// 判断当前这个@Bean方法是不是正在执行
// 通过这个增强可以避免下面这种重复创建Bean的写法：
// @Bean
// public X createX() {return new X();}
//
// @Bean
// public Y createY() {
// 	createX();
//	return new Y();
// }
// 当调用createY()的时候，createX()不会通过下面的判断
if (isCurrentlyInvokedFactoryMethod(beanMethod)) {
    // 调用父类方法
    return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);
}
// 如果没通过上面的判断，会直接从容器中获取
return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);
}
```

