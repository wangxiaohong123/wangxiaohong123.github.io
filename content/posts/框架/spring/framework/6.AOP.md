---
title: 6.AOP
tags:
  - spring-framework
categories: 框架
copyright: true
---

AOP和OOP是对应的，OOP是面象对象，AOP是面象切面，在程序运行的过程中可能会产生一些横切性的问题，这些问题一般不会对业务产生影响，比如日志记录，如果不把这些横切性的问题集中到切面里就会散落到整个代码，比如日志，如果不使用AOP那么每个controller的每个方法都需要手动编写日志打印。

Spring通过CGLib和JDK的动态代理实现的AOP。

*   Join point：连接点，程序运行的一个点，由于Spring中使用的CGLib或者JDK动态代理是以方法为单位的，所以join point也就是一个被增强了的方法。
*   Point cut：切点，表示一组连接点。
*   Advice：通知，包括通知内容(增强一个方法的具体业务逻辑);通知的时机(before、after、around、after);通知的目标(通知要作用到那些连接点上)。
*   Introduction：导入，这个可以实现导入某个接口的某个实现类中的某个方法到别的类里。
*   Target object：目标对象，要被增强的对象。
*   AOP proxy：代理对象，增强之后的对象。
*   Aspect：切面，上面的加到一起叫切面，对应了一个包括上面内容的类。

Spring借助了AspectJ的注解，但是处理的逻辑是自己实现的。

最简单的demo：

```java
@Aspect
@Component
public class MyAspect {

	/**
	 * 切点：某个包下的所有类
	 */
	@Pointcut("execution(* com.spring.aop.service.impl..*.*(..))")
	public void pointCutPackage() {}

	/**
	 * 通知
	 * Before：通知的时机
	 * pointCutPackage()：通知的切点
	 */
	@Before("pointCutPackage()")
	public void adviceBefore() {
		System.out.println("before aop");
	}
}
```

###### 切点表达式含义

*   execution：用来匹配连接点，最小粒度是方法。

    ```java
    // execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name- pattern(param-pattern) throws-pattern?) 
    // 这里问号表示当前项可以有也可以没有，其中各项的语义如下:
    // modifiers-pattern:方法的可见性，如public，protected; 
    // ret-type-pattern:方法的返回值类型，如int，void等; 
    // declaring-type-pattern:方法所在类的全路径名，如com.spring.Aspect; 
    // name-pattern:方法名，如buisinessService(); 
    // param-pattern:方法的参数类型，如java.lang.String; 
    // throws-pattern:方法抛出的异常类型，如java.lang.Exception;
    
    // example：
    // 匹配所有public修饰的方法
    execution(public * *(..))
    // 匹配所有set开头的方法
    execution(* set*(..))
    // 匹配AccountService接口中的任意方法
    execution(* com.xyz.service.AccountService.*(..))
    // 匹配service包下的任意方法
    execution(* com.xyz.service.*.*(..))
    // 匹配service包及其子包下的任意方法
    execution(* com.xyz.service..*.*(..))
    ```

*   within：最小粒度是类。

    ```java
    // 匹配service包下的任意方法
    within(com.xyz.service.*)
    
    // 匹配service及其子包下的任意方法
    within(com.xyz.service..*)
    ```

*   this：JDK代理时匹配接口和代理类，CGLib代理时匹配接口和子类

    ```java
    // 匹配代理对象是AccountService类型的
    this(com.xyz.service.AccountService)
    ```

*   target：匹配接口和实现类

    ```java
    // 匹配代理对象是AccountService类型的
    target(com.xyz.service.AccountService)
    ```

*   args：匹配指定参数类型和参数数量的方法，与包名、类名无关。

    ```java
    // 匹配方法的参数只有一个并且是Serializable
    // execution也可以指定方法的参数，但是他指定的是声明方法的时候的参数类型
    // args指定的是运行时传入方法的参数类型
    args(java.io.Serializable)
    ```

*   @target、@args、@within、@annotation：匹配方法或者类上有没有这些注解.

##### 自定义注解demo

```java
/**
 * Retention有3个选项，RUNTIME CLASS SOURCE
 * 如果是CLASS这个注解会存在class文件中，当jvm加载class文件的时候会忽略这个注解
 * 如果是SOURCE，在编译完之后的class文件里都不会有
 * RUNTIME就是整个运行时都能用到
 */
@Retention(RetentionPolicy.RUNTIME)
/**
 * 指定注解的作用域，如果不写表示这个注解可以出现在任何地方
 * TYPE表示只能出现在类上
 * FIELD表示只能出现在属性上
 * METHOD表示只能出现在方法上
 * CONSTRUCTOR表示只能出现在构造方法上
 */
@Target(ElementType.TYPE)
public @interface MyAnnotation {

   /**
    * 如果没有default 当使用这个注解时必须要设置value值
    * 这个value()是一个特殊的属性，使用注解时可以不指定字段的赋值，比如@MyAnnotation("www")
    * 这么写会默认赋值给value
    */
   String value() default "";
    
   Integer age();
}

@MyAnnotation
public class AnnoTest {

	public static void main(String[] args) {
		Class cl = AnnoTest.class;
		// 判断这个类上是否有MyAnnotation注解
		if (cl.isAnnotationPresent(MyAnnotation.class)) {
			// 获取注解对象
			MyAnnotation myAnnotation = (MyAnnotation) cl.getAnnotation(MyAnnotation.class);
			System.out.println(myAnnotation.value());
		}
	}
}
```

##### 动态代理

如果是静态代理的话有两种方式，第一种只需要新建一个类去继承目标类，然后重写目标方法，比如：

```java
public class ProxyClass extends Target {
    @Override
    public void m1() {
        System.out.println("增强逻辑");
        supper.m1();
    }
}
```

第二种新建代理类让它和代理类实现同一个接口，代理类中需要包含目标对象，比如：

```java
public class ProxyClass implements TargetService {
    
    private TargetImpl targetImpl;
    
    public ProxyClass(TargetImpl targetImpl) {
        this.targetImpl = targetImpl;
    }
    
    @Override
    public void m1() {
        System.out.println("增强逻辑");
        this.targetImpl.m1();
    }
}
```

静态代理只能代理指定的类，动态代理可以代理一批符合条件的类。

**动态代理**会直接产生一个class文件，在通过我们传的类加载器把class文件加载到jvm当中，最后通过反射拿到这个类的代理对象，简单demo：

```java
public interface TargetInterface {

	void m1();
}

public class MyInvocationHandler implements InvocationHandler {

	/**
	 * 目标对象
	 */
	private Object object;

	public MyInvocationHandler(Object object) {
		this.object = object;
	}

	@Override
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		System.out.println("方法增强");
		// 执行目标方法
		return method.invoke(object, args);
	}
}

public class ProxyTest {

	public static void main(String[] args) {
		TargetInterface target = (TargetInterface) Proxy.newProxyInstance(
				TargetInterface.class.getClassLoader(),
				new Class[]{TargetInterface.class},
				new MyInvocationHandler((TargetInterface) () -> System.out.println("目标方法执行")));

		target.m1();
	}
}
```

为什么java的动态代理只能基于接口？

因为java实现的代理类会继承Proxy类，java中是单继承的，所以要通过实现接口来实现动态代理。

##### AOP源码入口：

使用AOP需要配置@EnableAspectJAutoProxy注解，这个注解里有个@Import(AspectJAutoProxyRegistrar.class)，AspectJAutoProxyRegistrar实现了ImportBeanDefinitionRegistrar，所以当执行到ConfigurationClassPostProcessor的时候会回调这个类的registerBeanDefinitions()方法，入口就在这个方法里：

```java
public void registerBeanDefinitions(
    AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
	// 这里就是添加一个BeanPostProcessor：AnnotationAwareAspectJAutoProxyCreator
    // 寻找切面、使用ProxyFactory创建代理都是在这个类或者他的父类里
    AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);
    // 获取注解元数据
    AnnotationAttributes enableAspectJAutoProxy =
        AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);
    if (enableAspectJAutoProxy != null) {
        // 默认注解里这两个属性都是false
        if (enableAspectJAutoProxy.getBoolean("proxyTargetClass")) {
            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
        }
        if (enableAspectJAutoProxy.getBoolean("exposeProxy")) {
            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
        }
    }
}
```

