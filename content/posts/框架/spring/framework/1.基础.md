---
title: 1.基础
tags:
  - spring-framework
categories: 框架
copyright: true
---

##### 1.源码编译

源码的README.md有编译源码的步骤，但是由于操作系统、硬件环境可能会出现一些问题，而且文档里说的是没有开发工具的情况，这里我们自己把源码下载直接导入到idea里。

首先确保idea里配置好了git，然后下载gradle5.6安装。

###### 1）修改配置文件

然后进入下载的spring源码的根目录，这里下载的是5.2.x，找到build.gradle文件，修改repositories属性为阿里云镜像：

```properties
repositories {
    // mavenCentral()
    // maven { url "https://repo.spring.io/libs-spring-framework-build" }
    maven { url "https://maven.aliyun.com/nexus/content/groups/public/"}
    maven { url "https://maven.aliyun.com/nexus/content/repositories/jcenter"}
    maven { url "https://repo.spring.io/libs-spring-framework-build" }
    maven { url "https://repo.spring.io/snapshot" } // Reactor
    maven { url "https://oss.jfrog.org/artifactory/oss-snapshot-local" } // RSocket
}
```

在spring源码的根目录的gradle.properties文件中可以查看当前源码的小版本，我的是5.2.23：

![](https://tva1.sinaimg.cn/large/008vxvgGly1h9mrb4osd8j30je08w0ti.jpg)

进到spring-framework-5.2.x/gradle/wrapper目录下，修改gradle-wrapper.properties文件：

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
# 这里原来是http的url，他会先下载，我们直接把gradle下载到本地让他去本地读取
distributionUrl=file\:///Users/xiaohong/softwareDocuments/env/gradle-5.6.4-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
```

###### 2）导入intellij

直接从intellij打开下载的源码，同时修改gradle的build and run设置为intellij：

![](https://tva1.sinaimg.cn/large/008vxvgGly1h9mrx8jf8tj31ee0tgafs.jpg)

如果提示下面的错误：

```
fatal: not a git repository (or any of the parent directories): .git
```

这个时候需要进到源码根目录执行git初始化命令：

```bash
/Users/xiaohong/IdeaProjects/framework/source/spring/spring-framework-5.2.x
git init
```

重新编译之后会出现下面的错误：

```
fatal: Needed a single revision
```

这个时候需要把源码提交：

```bash
git add --all
git commit -m 'first'
```

如果提示不能构建spring-aspects模块，就去settings.gradle文件里把这个模块删掉。

然后编译完成，新建一个gradle模块spring-example用来测试，然后在build.gradle文件中添加依赖：

```properties
dependencies {
    optional(project(":spring-context"))
}
```

编写测试类：

```java
public class Test {

   public static void main(String[] args) {
      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
      context.register(Bean.class);
      context.refresh();

      System.out.println(context.getBean(Bean.class));
   }
}
```

运行测试类出现下面的错误：

```
java: 程序包org.springframework.objenesis.instantiator不存在
```

找到spring->tasks->other，执行里面的cglibRepackJar和objenesisRepackJar操作：

![](https://tva1.sinaimg.cn/large/008vxvgGly1h9mthiciz7j313v0u0n0u.jpg)

重新运行报下面的错：

```
java: 找不到符号
  符号:   变量 CoroutinesUtils
  位置: 类 org.springframework.core.ReactiveAdapterRegistry.CoroutinesRegistrar
```

构建一下spring-core模块：

![](https://tva1.sinaimg.cn/large/008vxvgGly1h9nu9qapiaj30o80wk414.jpg)

构建完之后spring-core模块下会出现一个jar，把这个jar添加到spring-core模块下：

![](https://tva1.sinaimg.cn/large/008vxvgGly1h9nube4bxyj30wm0ekabs.jpg)

![](https://tva1.sinaimg.cn/large/008vxvgGly1h9nue7gmlsj315e0u0gq4.jpg)

##### 2.日志原理

**一个项目中甚至是一个类中都可能存在多种日志框架** 

*   在spring源码中，日志的实现实在spring-jcl模块里，通过这个模块打印的日志会被覆盖，比如我们在spring源码中新建的测试模块中使用了mybatis，先用logback打印，然后添加log4j框架，log4j的配置会覆盖logback的，结果就是spring自己的日志始终都是log4j打印，但是mybatis的日志始终都是logback打印。
*   spring boot默认使用logback，默认INFO级别，他和spring不一样的是他的日志会统一，不会出现spring的日志和其他框架的日志被两种框架打印。

###### 1）常见的日志框架

java自带的JUL、log4j、log4j2、logback。

项目中存在多种日志框架会有很多问题，比如日志级别的统一，日志格式的统一。

所以最早的时候apache开发了一个commons-jcl，使用这个框架打印的日志可以统一管理，但是有个问题，他硬编码了一个框架的数组，默认第一个是log4j，如果没有找到log4j的依赖就会使用jul来打印，这样导致我们没有办法使用其他的日志框架，而且想要在1期和2期的开发中使用不同框架也没法实现。

然后slf4j框架出现了，slf4j本身不打印日志，他提供了一个绑定器，而且slf4j实现了主流框架的**绑定器**，我们需要引入slf4j和对应的日志框架依赖就可以实现日志的统一。并且他提供了一个**桥接器**，实现的效果就是原来的日志使用log4j打印，引入了logback+slf4j绑定器+slf4j桥接器之后，原来的日志和新日志都是使用logback打印。如果存在多个绑定器会使用第一个然后警告一下。

之所以会出现spring内部的日志不会被我们自己引入框架覆盖是因为在项目的gradle配置文件中自己引入了log4j2的绑定器，但是是测试环境：

```properties
// 这里也能看出来只有在测试环境下才会出现日志框架不被覆盖的情况
testRuntime("org.apache.logging.log4j:log4j-core")
// 这个就是log4j的绑定器
testRuntime("org.apache.logging.log4j:log4j-slf4j-impl")
testRuntime("org.apache.logging.log4j:log4j-jul")
```

###### 2）spring-jcl源码

spring-jcl获取Log对象的方法会走到LogFactory的getLog方法：

```java
public static Log getLog(String name) {
   // 创建具体的log对象
   return LogAdapter.createLog(name);
}
```

然后会走到LogAdapter的createLog()方法：

```java
public static Log createLog(String name) {
   switch (logApi) {
      // log4j2
      case LOG4J:
         return Log4jAdapter.createLog(name);
      // slf4j_full
      case SLF4J_LAL:
         return Slf4jAdapter.createLocationAwareLog(name);
      // slf4j
      case SLF4J:
         return Slf4jAdapter.createLog(name);
      // jul
      default:
         return JavaUtilAdapter.createLog(name);
   }
}
```

这里可以看出来spring支持的日志框架只有两个，log4j2和jul，我们引入的其他框架都需要通过slf4j来实现，关键就是找到logApi变量什么时候赋值和根据什么时候赋值，在上面的静态代码块里：

```java
static {
   // 使用Class.forName()的方式判断是否引入了对应的依赖
   // 根据依赖的日志框架给logApi对象赋值
   if (isPresent(LOG4J_SPI)) {
      // LOG4J_SLF4J_PROVIDER的变量值是org.apache.logging.slf4j.SLF4JProvider
      // 这个变量是log4j2到slf4j的桥接器中的类路径
      // 也就是说只有添加了log4j2到slf4j的桥接器依赖+slf4j依赖才会修改spring源码中的日志框架
      // 这也解释了为什么我们引入了logback框架后spring源码的日志打印还是使用log4j2
      if (isPresent(LOG4J_SLF4J_PROVIDER) && isPresent(SLF4J_SPI)) {
         // log4j-to-slf4j bridge -> we'll rather go with the SLF4J SPI;
         // however, we still prefer Log4j over the plain SLF4J API since
         // the latter does not have location awareness support.
         logApi = LogApi.SLF4J_LAL;
      }
      else {
         // Use Log4j 2.x directly, including location awareness support
         logApi = LogApi.LOG4J;
      }
   }
   else if (isPresent(SLF4J_SPI)) {
      // Full SLF4J SPI including location awareness support
      logApi = LogApi.SLF4J_LAL;
   }
   else if (isPresent(SLF4J_API)) {
      // Minimal SLF4J API without location awareness support
      logApi = LogApi.SLF4J;
   }
   else {
      // java.util.logging as default
      logApi = LogApi.JUL;
   }
}
```

###### 3）面试：spring日志原理

*   5之前用的是commons-jcl,jcl内部写死了一个日志框架的数组，启动服务时遍历数组，找到和我们依赖相同的日志框架，如果没有就是用jul。
*   5之后用的是spring-jcl，jcl停止维护之后对jcl的二次开发，他是一个单独的模块。而且Spring5在加载LogAdapter的时候会给logApi变量赋值，他会判断如果引入了log4j2到slf4j的桥接器和slf4j的依赖后，才会把logApi赋值成slf4j，在调用createLog()方法的时候会根据这个logApi的类型创建对应的日志对象。

###### 4）面试：spring5的新特性

新的日志模块、webflux