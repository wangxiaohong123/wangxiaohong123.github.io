---
title: 2.注入相关
tags:
  - spring-framework
categories: 框架
copyright: true
---

##### 1.自动注入和手动注入

手动注入就是通过xml方式，要么是\<property/\>标签通过set方法注入，要么提供\<constructor-arg/\>标签通过构造方法注入。

自动注入就是设置bean得注入方式并提供对应得set方法或者构造方法，spring就会自己分析方法完成注入。

在AbstractBeanDefinition中有一个属性叫**autowireModel**，他有4个值可选：

*   AUTOWIRE_NO(默认)：手动注入。
*   AUTOWIRE_BY_NAME：按属性名称自动注入。Spring 寻找与需要自动装配的属性同名的bean。例如，如果一个 bean定义的注入模式被设置为AUTOWIRE_BY_NAME，并且它包含一个master属性（即它有一个 setMaster(..)方法），那么 Spring 会查找一个命名为master的bean，并使用它来设置该属性。
*   AUTOWIRE_BY_TYPE：和AUTOWIRE_BY_NAME类似，只不过他是按照类型，如果容器中出现多个相同type会抛出异常。
*   AUTOWIRE_CONSTRUCTOR：通过构造函数+byType注入，如果容器中没有构造函数中指定的bean会抛出异常。
*   AUTOWIRE_AUTODETECT(被弃用)：

总结：官网上写的注入方式有两种，setter方法和构造方法，不管是手动注入还是自动注入都是通过这两种方式实现。注入模型有四种，默认是手动注入，byType和byName都是通过setter方法注入。byName是根据setter方法去掉set后把第一个字母改成小写的那么去找。通过@Autowired或者@Resource注解实现的注入既不属于setter注入也不是构造方法注入。

##### 2.@Autowired源码

@Autowired注入对象的源码在AutowiredAnnotationBeanPostProcessor类中，这个类里有两个内部类，一个是AutowiredMethodElement用来处理方法上的@Autowired，另一个是AutowiredFieldElement用来处理成员变量上的@Autowired注解。

AutowiredAnnotationBeanPostProcessor类实现了InstantiationAwareBeanPostProcessorAdapter，在程序启动的时候一定会触发postProcessProperties()方法：

```java
public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {
   // 根据当前bean找到所有加了@Autowired和@Value注解的变量或者方法
   // 然后用找到的变量或者方法创建对应的注入器
   InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);
   try {
      metadata.inject(bean, beanName, pvs);
   }
   return pvs;
}
```

InjectionMetadata就是注入器，AutowiredFieldElement类继承了InjectionMetadata.InjectedElement，在metadata.inject(bean, beanName, pvs);代码中就是遍历刚才拿到的InjectedElement集合，然后调用他的inject()方法：

```java
public void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {
   Collection<InjectedElement> checkedElements = this.checkedElements;
   Collection<InjectedElement> elementsToIterate =
         (checkedElements != null ? checkedElements : this.injectedElements);
   if (!elementsToIterate.isEmpty()) {
      for (InjectedElement element : elementsToIterate) {
         element.inject(target, beanName, pvs);
      }
   }
}
```

所以@Autowired注解最终会走到AutowiredFieldElement的inject()方法里：

```java
protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {
   Field field = (Field) this.member;
   Object value;
   // 这个是处理缓存的
   if (this.cached) {
      try {
         value = resolvedCachedArgument(beanName, this.cachedFieldValue);
      }
      catch (NoSuchBeanDefinitionException ex) {
         // Unexpected removal of target bean for cached argument -> re-resolve
         value = resolveFieldValue(field, bean, beanName);
      }
   }
   else {
      // 解析注入的值
      value = resolveFieldValue(field, bean, beanName);
   }
   if (value != null) {
      ReflectionUtils.makeAccessible(field);
      field.set(bean, value);
   }
}
```

resolveFieldValue()方法里先解析变量的描述，比如变量名什么的，然后根据描述去beanFactory中拿到对象：

```java
private Object resolveFieldValue(Field field, Object bean, @Nullable String beanName) {
      // 拿到依赖的描述器，里面有依赖的所有信息
      DependencyDescriptor desc = new DependencyDescriptor(field, this.required);
      desc.setContainingClass(bean.getClass());
      Set<String> autowiredBeanNames = new LinkedHashSet<>(1);
      Assert.state(beanFactory != null, "No BeanFactory available");
      TypeConverter typeConverter = beanFactory.getTypeConverter();
      Object value;
      try {
         // 根据描述器从beanFactory拿到对象
         value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
      }
      catch (BeansException ex) {
         throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex);
      }
      synchronized (this) {
          // 这里是一些缓存的处理
         ……
      }
      return value;
   }
}
```

beanFactory.resolveDependency()会走到DefaultListableBeanFactory中，然后又调用了doResolveDependency()方法：

```java
public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,
      @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

   InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);
   try {
      Object shortcut = descriptor.resolveShortcut(this);
      if (shortcut != null) {
         return shortcut;
      }
      // 获取依赖的类型
      Class<?> type = descriptor.getDependencyType();
      Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
      if (value != null) {
         if (value instanceof String) {
            String strVal = resolveEmbeddedValue((String) value);
            BeanDefinition bd = (beanName != null && containsBean(beanName) ?
                  getMergedBeanDefinition(beanName) : null);
            value = evaluateBeanDefinitionString(strVal, bd);
         }
         TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
         try {
            return converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());
         }
         catch (UnsupportedOperationException ex) {
            // A custom TypeConverter which does not support TypeDescriptor resolution...
            return (descriptor.getField() != null ?
                  converter.convertIfNecessary(value, type, descriptor.getField()) :
                  converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));
         }
      }
      // 判断当前依赖能不能注入多个值
      // 比如我们依赖的是个list：
      // @Autowired
      // private List<xx> xxs
      Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);
      // 如果返回的multipleBeans不是空就直接返回
      // 反过来，如果是空就说明注入的对象只能是1个
      if (multipleBeans != null) {
         return multipleBeans;
      }
      // 根据类型查找
      // 这个map里的值不是具体的对象，而是class对象
      Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
      if (matchingBeans.isEmpty()) {
         // 如果没有找到需要注入的对象会判断required属性是否为true，默认就是true
         // 抛出NoSuchBeanDefinitionException异常
         if (isRequired(descriptor)) {
            raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
         }
         return null;
      }

      String autowiredBeanName;
      Object instanceCandidate;

      if (matchingBeans.size() > 1) {
         // 拿到注入的对象名
         autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);
         if (autowiredBeanName == null) {
            if (isRequired(descriptor) || !indicatesMultipleBeans(type)) {
               return descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);
            }
            else {
               // In case of an optional Collection/Map, silently ignore a non-unique case:
               // possibly it was meant to be an empty collection of multiple regular beans
               // (before 4.3 in particular when we didn't even look for collection beans).
               return null;
            }
         }
         // 根据对象名去map中获取对应的对象
         instanceCandidate = matchingBeans.get(autowiredBeanName);
      }
      else {
         // 只有一个对象的情况
         Map.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();
         autowiredBeanName = entry.getKey();
         instanceCandidate = entry.getValue();
      }
		// 一些其他处理比如实例化拿到的最终class对象，省略
      ……
      return result;
   }
}
```

##### 3.@Resource注解源码

处理@Resource注解的类是CommonAnnotationBeanPostProcessor，他也继承了InstantiationAwareBeanPostProcessor类，这个类和AutowiredAnnotationBeanPostProcessor处理的逻辑差不多，只不过他扫描的是@Resource注解修饰的变量，在CommonAnnotationBeanPostProcessor类中有一个内部类ResourceElement，他继承了LookupElement，而LookupElement又继承了InjectionMetadata.InjectedElement，所以核心的处理方法在InjectedElement的inject()方法里：

```java
protected void inject(Object target, @Nullable String requestingBeanName, @Nullable PropertyValues pvs)
      throws Throwable {

   // 如果是属性走下面的逻辑
   if (this.isField) {
      Field field = (Field) this.member;
      ReflectionUtils.makeAccessible(field);
      // 通过反射赋值
      // getResourceToInject(target, requestingBeanName)是到容器中找到需要被注入的对象
      field.set(target, getResourceToInject(target, requestingBeanName));
   }
   else {
      // 处理方法的逻辑
      if (checkPropertySkipping(pvs)) {
         return;
      }
      try {
         Method method = (Method) this.member;
         ReflectionUtils.makeAccessible(method);
         method.invoke(target, getResourceToInject(target, requestingBeanName));
      }
      catch (InvocationTargetException ex) {
         throw ex.getTargetException();
      }
   }
}
```

getResourceToInject()方法还是会走到ResourceElement里：

```java
protected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {
   return (this.lazyLookup ? buildLazyResourceProxy(this, requestingBeanName) :
         getResource(this, requestingBeanName));
}
```

getResource()方法先校验，然后再调用autowireResource()方法：

```java
protected Object autowireResource(BeanFactory factory, LookupElement element, @Nullable String requestingBeanName)
      throws NoSuchBeanDefinitionException {

   Object resource;
   Set<String> autowiredBeanNames;
   String name = element.name;

   // 会走到下面的逻辑
   if (factory instanceof AutowireCapableBeanFactory) {
      AutowireCapableBeanFactory beanFactory = (AutowireCapableBeanFactory) factory;
      // 获取变量的描述信息
      DependencyDescriptor descriptor = element.getDependencyDescriptor();
      // 当我们使用@Resource注解时，没有设置name属性，element.isDefaultName就为true
      // factory.containsBean(name)是判断单例池中是否有name对应的对象或者容器当中是否有一个名字是name的BeanDefinition
      if (this.fallbackToDefaultTypeMatch && element.isDefaultName && !factory.containsBean(name)) {
         autowiredBeanNames = new LinkedHashSet<>();
         // 这个逻辑和AutowiredAnnotationBeanPostProcessor处理@Autowired注解的一样，先根据类型，在根据name查找
         resource = beanFactory.resolveDependency(descriptor, requestingBeanName, autowiredBeanNames, null);
         if (resource == null) {
            throw new NoSuchBeanDefinitionException(element.getLookupType(), "No resolvable resource object");
         }
      }
      else {
         // 走到这里的逻辑就是如果@Resource指定了name属性或者根据变量名可以在容器中找到对应的bean或者BeanDefinition就直接从容器中获取
         // 因为你既然指定了名字，那么就只能根据名字去找，就算可以根据类型找到，也不能给你用，因为你指定了名字
         resource = beanFactory.resolveBeanByName(name, descriptor);
         autowiredBeanNames = Collections.singleton(name);
      }
   }
   else {
      resource = factory.getBean(name, element.lookupType);
      autowiredBeanNames = Collections.singleton(name);
   }

   // 省略一些代码
	……
   return resource;
}
```

**总结： @Autowired的后置处理器在AutowiredAnnotationBeanPostProcessor的内部类里，@Resource的后置处理器在CommonAnnotationBeanPostProcessor的内部类里。默认情况下@Resource和注解一样会先根据类型去找，找到多个在根据name找，当@Resource指定name属性或者容器中存在name对应的bean就会根据name去找，所以@Resource的name优先级更高。这两个注解既不是setter方法注入，也不是构造方法注入，他俩是通过反射直接调用Field.set()方法注入。**

到这里有个疑问，默认都是手动注入，什么时候会调用构造方法和setter方法注入，现在只知道可以手动调用BeanDefinition的setAutowireMode()方法修改注入模型。

##### 4.@Order源码

首先Spring会先扫描，然后在实例化bean，目前我不知道怎么干扰扫描的顺序，实例化的顺序可以干扰但是不是用@Order注解，也就是说@Order并不影响类的加载顺序，也不会影响Bean执行Spring内部初始化方法的顺序(比如实现某些接口，Spring会在Bean生命周期的某个环节回调)。

@Order影响的AOP的通知顺序，还有一种情况是把带@Order注解的Bean放到集合中遍历执行时，执行顺序是@Order注解的倒叙(值越小越先执行)。比如下面的这种：

```java
@Autowired
private List<TestBean> testBeans;

public void test() {
    // 如果TestBean有@Order注解修饰，那么下面在执行的时候会按照注解的value值倒序执行
    for (TestBean bean : testBeans) {
        bean.run();
    }
}
```

解析@Order注解的代码在DefaultListableBeanFactory的resolveMultipleBeans()方法中，这个方法里有很多分支，比如处理数组、集合、map等等，拿到一个Comparator，然后根据compartor排序：

```java
// 这个Comparator是Spring实现的OrderComparator
Comparator<Object> comparator = adaptDependencyComparator(matchingBeans);
if (comparator != null) {
    ((List<?>) result).sort(comparator);
}
```

所以在排序的时候会走到OrderComparator的doCompare方法里：

```java
private int doCompare(@Nullable Object o1, @Nullable Object o2, @Nullable OrderSourceProvider sourceProvider) {
   // 判断是否实现了PriorityOrdered接口
   boolean p1 = (o1 instanceof PriorityOrdered);
   boolean p2 = (o2 instanceof PriorityOrdered);
   if (p1 && !p2) {
      return -1;
   }
   else if (p2 && !p1) {
      return 1;
   }

   // 都没实现再去获取order的值
   int i1 = getOrder(o1, sourceProvider);
   int i2 = getOrder(o2, sourceProvider);
   return Integer.compare(i1, i2);
}
```

上面可以看到不只是@Order注解会影响集合中Bean的顺序，还有是否实现了PriorityOrdered接口，查看获取@Order注解的值的代码：

```java
private int getOrder(@Nullable Object obj, @Nullable OrderSourceProvider sourceProvider) {
   Integer order = null;
   if (obj != null && sourceProvider != null) {
      // 这个是处理其他的排序规则
      Object orderSource = sourceProvider.getOrderSource(obj);
      if (orderSource != null) {
         if (orderSource.getClass().isArray()) {
            for (Object source : ObjectUtils.toObjectArray(orderSource)) {
               order = findOrder(source);
               if (order != null) {
                  break;
               }
            }
         }
         else {
            order = findOrder(orderSource);
         }
      }
   }
   return (order != null ? order : getOrder(obj));
}
```

这个方法里没有获取Order的值，结论是@Order的优先级很低，继续往下跟：

```java
protected int getOrder(@Nullable Object obj) {
   if (obj != null) {
      // 这里会走到AnnotationAwareOrderComparator的findOrder()方法
      Integer order = findOrder(obj);
      if (order != null) {
         return order;
      }
   }
   // 没有Order注解会给一个默认值Integer.MAX_VALUE
   return Ordered.LOWEST_PRECEDENCE;
}
```

AnnotationAwareOrderComparator的findOrder()方法也没有直接获取Order注解，而是先判断了是否实现Order接口：

```java
protected Integer findOrder(Object obj) {
   // 这里也不是获取Order的值，这里只判断了是否实现了Order接口
   Integer order = super.findOrder(obj);
   if (order != null) {
      return order;
   }
   // 这里才是拿到注解的值
   return findOrderFromAnnotation(obj);
}
```

findOrderFromAnnotation()方法才是获取Order注解的值：

```java
private Integer findOrderFromAnnotation(Object obj) {
   AnnotatedElement element = (obj instanceof AnnotatedElement ? (AnnotatedElement) obj : obj.getClass());
   // 拿到所有注解
   MergedAnnotations annotations = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY);
   // 去注解里找到Order，然后再拿到Order的值
   Integer order = OrderUtils.getOrderFromAnnotations(element, annotations);
   // 这个是DecoratingProxy的实现的处理
   if (order == null && obj instanceof DecoratingProxy) {
      return findOrderFromAnnotation(((DecoratingProxy) obj).getDecoratedClass());
   }
   return order;
}
```

**总结：当遍历Bean集合的时候，遍历的顺序是：实现PriorityOrdered接口 -> 实现Order接口 -> Order注解，都没有的话返回默认值Integer.MAX_VALUE**

##### 5.@Lookup注解的使用

当单例Bean中注入了原型Bean(@Scope("prototype"))的时候，如果我们还在全局变量中注入，是实现不了原型Bean的效果的，比如下面这种情况：

```java
@Component
@Scope("prototype")
public abstract class Lb {}

@Component
@Slf4j
public abstract class Lc {
    
    @Autowired
    private Lb b;
    
    public void printInfo() {
        log.debug("lb.info:{}", b);
        log.debug("lb.info:{}", b);
    }
}
```

这么写会出现两次输出b的内存地址是相同的，因为是一个对象，可以使用@Lookup注解：

```java
@Component
@Slf4j
public abstract class Lc {
    public void printInfo() {
        Lb b = createB();
        log.debug("lb.info:{}", b);
        
        b = createB();
        log.debug("lb.info:{}", b);
    }

    /**
     * 加上@Lookup注解后Spring会使用cgLib实现这个类的子类来代理这个类，并且重写这个方法
     */
    @Lookup
    public abstract Lb createB();
}
```

##### 6.@DependsOn注解

被@DependsOn("test")修饰的Bean在实例化的时候会先实例化test这个Bean。

##### 7.Supplier

Supplier的作用是我们可以自己指定使用哪个构造方法，而且不是通过反射的方式实例化Bean：

```java
public class Test {

   public static void main(String[] args) {
      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
      GenericBeanDefinition beanDefinition = new GenericBeanDefinition();
      beanDefinition.setBeanClass(A.class);

      // SupplierFactory不需要存在spring容器中
      beanDefinition.setInstanceSupplier(SupplierFactory::instanceObject);

      context.registerBeanDefinition("a", beanDefinition);

      context.refresh();

      System.out.println(context.getBean(A.class));
   }

   static class SupplierFactory {
      public static A instanceObject() {
         return new A(1);
      }
   }
}
```

###### 8.java内省

主要就是处理JavaBean的属性，通过setter方法设置。他和反射不一样，反射可以操作任何类，也可以知道类的信息，但是内省是根据set方法来推断属性：

```java
public class IntrospectTest {
    public void testIntrospect() throws Exception {
        BeanInfo bf = Introspector.getBeanInfo(TestBean.class);
        // 获取属性描述符
        PropertyDescriptor[] propertyDescriptors = bf.getPropertyDescriptors();
        for (PropertyDescriptor pd : propertyDescriptors) {
            // 获取对应属性名
            System.out.println(pd.getName);
            // 使用属性描述符可以拿到对应的方法
            Method method = pd.getWriteMethod();
        }
    }
}
```

如果我们定义的属性没有set方法，那么内省是拿不到这个属性的，而且内省会多拿出来一个属性叫class，因为Object里有个getClass()方法。**Spring里set()方法的自动注入使用内省来实现**，所以在Spring里set自动注入是不需要有具体的属性的，只要提供一个set方法就可以。

