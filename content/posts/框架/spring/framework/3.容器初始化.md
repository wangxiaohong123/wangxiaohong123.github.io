---
title: 3.容器初始化
tags:
  - spring-framework
categories: 框架
copyright: true
---

首先想一下如果我们自己实现了一个框架怎么把对象交给spring容器管理，比如类似mybatis使用动态代理生成的对象？

*   @Service……这种注解：不行，这个注解写到类上，就算我们动态生成的对象可以加上这个注解，Spring也不会扫描。

*   xml+Bean标签：不行，和上面一样。

*   @Bean注解：可以，向下面这样：

    ```java
    @Bean
    public MyMapper myMapper() {
        return (MyMapper) MySqlSession.getMapper(MyMapper.class);
    }
    ```

*   使用FactoryBean：可以：

    ```java
    @Component
    public class MyFactoryBean implements FactoryBean {
    
    	Class mapperInterface;
    
    	public void setMapperInterface(Class mapperInterface) {
    		this.mapperInterface = mapperInterface;
    	}
    
    	@Override
    	public Object getObject() throws Exception {
    		// 单例池 存放大部分的Bean
    		return  MySqlSession.getMapper(mapperInterface);
    	}
    
    	@Override
    	public Class<?> getObjectType() {
    		return mapperInterface;
    	}
    }
    ```

*   使用Spring api：可以：

    ```java
    public void customMapper(){
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
    	// 先配置一个扫描的路径
        context.register(MyConfig.class);
        MyMapper mapper = (MyMapper) MySqlSession.getMapper(MyMapper.class);
       
        context.getBeanFactory().registerSingleton("myMapper", mapper);
    }
    ```

*   动态向容器注册BeanDefinition：可以，BeanFactory并没有提供添加自定义BeanDefinition的方法。但是可以实现ImportBeanDefinitionRegistrar接口来动态注册BeanDefinition：

    ```java
    /**
     * 实现了ImportBeanDefinitionRegistrar的类如果加上Spring的注解比如@Component是不会被扫描的
     */
    public class MyImportBeanDefinitionRegistart implements ImportBeanDefinitionRegistrar {
        
    	Map<String,BeanDefinition> map = new HashMap<>();
        
    	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
    		// 模拟扫描
    		scan();
    		for (String key : map.keySet()) {
    			AbstractBeanDefinition mapperBd = (AbstractBeanDefinition) map.get(key);
                // 这里就和上面使用FactoryBean的方式整合到一起了
    			Class mapperClz = mapperBd.getBeanClass();
    			mapperBd.setBeanClass(MyFactoryBean.class);
                // 这里要传个字符串，Spring会转成我们要的Class类型
    			mapperBd.getPropertyValues().add("mapperInterface", mapperClz.getName());
    			registry.registerBeanDefinition(key,mapperBd);
    		}
    	}
    
    	public void scan() {
    		// 把类解析成BeanDefinition
    		BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(TMapper.class);
            map.put("tmapper", builder.getBeanDefinition());
    		builder = BeanDefinitionBuilder.genericBeanDefinition(AMapper.class);
            map.put("amapper", builder.getBeanDefinition());
    	}
    
    }
    ```

MyBatis使用的是FactoryBean方式，官网推荐的是使用xml配置MyBatis提供的MapperFactoryBean，这个类就实现了FactoryBean，使用xml是而不是@Component注解第一是为了不让我们配置扫描路径，第二是为了让MapperFactoryBean返回的类型可配置。

但是有个问题，如果我项目里有几百张表，我就要写几百个\<bean>标签，Mybatis还提供了一个注入多个mapper的方式，\<mapper:scan\>标签或者@MapperScan注解，这种批量扫描的实现就是上面的动态向容器注册BeanDefinition的实现。

##### 1.容器初始化

在Spring中容器对象大致分为两种：Beanfactory和ApplicationContext，Beanfactory只支持Bean的实例化和自动依赖注入，而ApplicationContext还支持生命周期管理、自动注册BeanPostProcessor（很多注解都是依赖这个功能实现的）、事件发布等等。也就是说和这两个类有关系的都可以叫做容器。

##### 2.容器PostProcessor的执行

假设调用new AnnotationConfigApplicationContext(MyConfig.class);来初始化容器：

```java
public AnnotationConfigApplicationContext(Class<?>... componentClasses) {
    // 调用自己的构造方法
    this();
    // 把我们传进来的对象转成BeanDefinition添加到beanDefinitionMap里
    register(componentClasses);
    refresh();
}
```

调用默认的构造方法干了很多事：

```java
public AnnotationConfigApplicationContext() {
   // 在这之前会先调用父类的构造方法，给beanFactory赋值DefaultListableBeanFactory
   // 这个东西类似于渲染器
   // 调用他的register()方法可以根据一个类渲染一个BeanDefinition出来
   // 实例化这个类的时候会把5个非常重要的类变成BeanDefinition存到beanDefinitionMap里
   this.reader = new AnnotatedBeanDefinitionReader(this);
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
```

首先先看一下父类GenericApplicationContext的构造方法：

```java
public GenericApplicationContext() {
    // 这个beanFactory很关键，里面有一个map叫beanDefinitionMap
    // 它是用来存储类转成的BeanDefinition对象
   this.beanFactory = new DefaultListableBeanFactory();
}
```

之后生成的所有BeanDefinition都会存到beanFactory中。

然后看实例化AnnotatedBeanDefinitionReader对象，他的构造方法里面有一行代码很关键：

```java
// this.registry就是AnnotationConfigApplicationContext
AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
```

方法的实现会调用同类的registerAnnotationConfigProcessors()方法，在这个方法里实例化6个很重要的BeanDefinition并添加到beanDefinitionMap中：

```java
if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
    // 添加internalConfigurationAnnotationProcessor：ConfigurationClassPostProcessor
    // 这个类完成了50%的核心功能
    RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
    def.setSource(source);
    beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
}

if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
    // 添加internalAutowiredAnnotationProcessor：AutowiredAnnotationBeanPostProcessor
    // 主要是用来解析@Autowired注解
    RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
    def.setSource(source);
    beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
}

// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.
if (jsr250Present && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {
    // 添加internalCommonAnnotationProcessor：CommonAnnotationBeanPostProcessor
    // 主要是用来解析@Resource注解
    RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);
    def.setSource(source);
    beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));
}

// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.
// 如果是JPA才会进下面的分支
if (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {
    // 添加internalPersistenceAnnotationProcessor：PersistenceAnnotationBeanPostProcessor
    RootBeanDefinition def = new RootBeanDefinition();
    try {
        def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,
                                            AnnotationConfigUtils.class.getClassLoader()));
    }
    catch (ClassNotFoundException ex) {
        throw new IllegalStateException(
            "Cannot load optional framework class: " + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);
    }
    def.setSource(source);
    beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));
}

if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {
    // 添加internalEventListenerProcessor：EventListenerMethodProcessor
    RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);
    def.setSource(source);
    beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));
}

if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {
    // 添加internalEventListenerFactory：DefaultEventListenerFactory
    RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);
    def.setSource(source);
    beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));
}
```

回到构造方法，继续调用refresh()，这个方法的实现在父类AbstractApplicationContext中，父类的代码中有一行代码很关键：

```java
// 在这里完成的扫描
// 把我们自己的类转成BeanDefinition添加到beanDefinitionMap里
// 并且执行了Spring认为可靠的实现了BeanFactoryPostProcessor的BeanDefinition
// 怎么才算可靠？1可以被扫描到；2通过api添加到容器中；
invokeBeanFactoryPostProcessors(beanFactory);
```

invokeBeanFactoryPostProcessors(beanFactory);方法里又有一行代码很关键：

```java
// beanFactory就是之前创建的
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
```

getBeanFactoryPostProcessors()会拿到一个BeanFactoryPostProcessors对象集合，这个list里存的都是其他框架或者我们自己通过调用context.addBeanFactoryPostProcessor()添加进来的，这个方法的实现非常复杂：

```java
/**
 * PostProcessorRegistrationDelegate类
 * 这个方法的注释里的父类指实现BeanFactoryPostProcessor接口的实现类
 * 子类指实现BeanDefinitionRegistryPostProcessor接口的实现类
 */
public static void invokeBeanFactoryPostProcessors(
      ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {
   // 这个用来存放Spring认为处理完的BeanFactoryPostprocessor和他的子类BeanDefinitionRegistryPostProcessor
   // 但是这个set不存储通过api添加的BeanFactoryPostprocessor或者BeanDefinitionRegistryPostProcessor
   // 防止重复执行，为什么set中不存api添加的？因为下面需要重复的去BeanFactory中获取然后执行，所以需要去重，通过api添加的不会重复获取
   Set<String> processedBeans = new HashSet<>();
   // 因为这里拿到的beanFactory是ListableBeanFactory，他实现了BeanDefinitionRegistry，这里一定为true
   if (beanFactory instanceof BeanDefinitionRegistry) {
      // 这里转成了BeanDefinitionRegistry为了动态注册BeanDefinition
      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
      // 这个list用来存储所有BeanFactoryPostProcessor的实现类
      List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();
      // 这个list用来存储所有BeanDefinitionRegistryPostProcessor的实现类
      List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();

      // 拿到通过api添加的BeanFactoryPostProcessor
      for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
         if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
            // 如果是子类BeanDefinitionRegistryPostProcessor的实现类就执行子类的方法
            BeanDefinitionRegistryPostProcessor registryProcessor =
                  (BeanDefinitionRegistryPostProcessor) postProcessor;
            registryProcessor.postProcessBeanDefinitionRegistry(registry);
            // 然后添加到子类的集合里
            registryProcessors.add(registryProcessor);
         }
         else {
            // 如果是父类不执行直接添加到父类的list里
            regularPostProcessors.add(postProcessor);
         }
      }
      // 他表示当前要执行的子类
      List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

      // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
      // 首先到beanFactory的beanDefinitionMap或者单例池中找到所有子类的实现类的name，这个name其实是类的全路径
      // 因为这个时候spring还没初始化完，单例池中的Bean和BeanFactoryPostProcessor没有关系，所以这里不需要考虑单例池
      String[] postProcessorNames =
            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      // 这里只能拿到internalConfigurationAnnotationProcessor：ConfigurationClassPostProcessor
      // 之前实例化的五个BeanFactoryPostProcessor只有他是BeanDefinitionRegistryPostProcessor的实现类
      for (String ppName : postProcessorNames) {
         // 判断是否实现了PriorityOrdered接口
         // ConfigurationClassPostProcessor是实现了的
         if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            // beanFactory.getBean有两个功能，单例池中有就拿出来
            // 单例池中没有就找到BeanDefinition实例化成Bean放到单例池中
            // 拿到这个Bean之后添加到要执行的子类集合中，在添加到已经执行完的集合中
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      // 将要执行的子类集合排序，根据PriorityOrdered排序
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      // 然后又把要执行的子类添加到子类集合里，为什么还要加到子类里？
      // 因为下面执行的时候只会执行子类的方法，所有子类的子类方法执行完了之后还要在执行子类里的父类方法
      // 最后的最后才执行父类的父类方法
      registryProcessors.addAll(currentRegistryProcessors);
      // 遍历执行子类的方法
      // 到这里执行的只有ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry()方法
      // todo 这个类的这个方法里就完成了扫描
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      // 执行完了把要执行的子类集合清空
      currentRegistryProcessors.clear();

      // 又去拿到子类的实现类，因为ConfigurationClassPostProcessor完成了扫描
      // 所以这里还可以拿到我们自己实现的通过注解(比如@Component注解)能被扫描到的子类
      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      for (String ppName : postProcessorNames) {
         // 因为上面执行过一些子类，所以这里需要根据执行完的set去重
         // 然后再判断是否实现了Ordered接口，注意PriorityOrdered是Ordered的子类
         if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
            // 之前没有执行过并且实现了Ordered接口就添加到将要被执行的集合中
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            // 然后标记已经处理完
            processedBeans.add(ppName);
         }
      }
      // 重复上面的操作，排序，遍历，执行，清空
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      registryProcessors.addAll(currentRegistryProcessors);
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();

      // 下面是一个死循环执行的还是上面的步骤
      // 这个是为了执行我们自己实现的BeanDefinitionRegistryPostProcessor里添加新的BeanDefinitionRegistryPostProcessor
      // 他会一直执行这个过程直到找不到新的BeanDefinitionRegistryPostProcessor
      boolean reiterate = true;
      while (reiterate) {
         reiterate = false;
         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
         for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName)) {
               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
               processedBeans.add(ppName);
               reiterate = true;
            }
         }
         sortPostProcessors(currentRegistryProcessors, beanFactory);
         registryProcessors.addAll(currentRegistryProcessors);
         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
         currentRegistryProcessors.clear();
      }

      // 最后执行所有子类中的父类方法
      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
      // 执行通过api添加的父类的父类方法
      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
   } else {
      // 正常情况不会进到这里
      // 这里也只是执行了通过api添加的BeanFactoryPostProcessor
      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
   }

   // 找到所有父类，这里也会扫描出来子类全限定名
   String[] postProcessorNames =
         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);

   // 存储所有直接实现PriorityOrdered接口的父类
   List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
   // 存储所有直接实现Ordered接口的父类的name
   List<String> orderedPostProcessorNames = new ArrayList<>();
   // 存储所有没实现Ordered接口的父类的name
   List<String> nonOrderedPostProcessorNames = new ArrayList<>();
   for (String ppName : postProcessorNames) {
      // 如果之前处理过就跳过
      if (processedBeans.contains(ppName)) {}
      // 把ppName放到对应的集合中
      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
         // 这个集合的先实例化了，todo 为什么？
         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
      }
      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
         orderedPostProcessorNames.add(ppName);
      }
      else {
         nonOrderedPostProcessorNames.add(ppName);
      }
   }

   // 排序执行实现了PriorityOrdered接口的
   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

   // 排序执行实现了Ordered接口的
   List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());
   for (String postProcessorName : orderedPostProcessorNames) {
      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   sortPostProcessors(orderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

   // 排序执行没实现了Ordered接口的
   List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());
   for (String postProcessorName : nonOrderedPostProcessorNames) {
      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

   beanFactory.clearMetadataCache();
}
```

##### 3.容器后置处理的一些问题

这些问题没有官方解答，都是看了源码的猜想。

###### 1）BeanDefinitionRegistryPostProcessor和ImportBeanDefinitionRegistrar的区别

他俩都是动态添加BeanDefinition，当执行内置并且实现了PriorityOrdered接口的BeanFactoryPostProcessor的时候(也就是ConfigurationClassPostProcessor)，会去回调@Import注解中声明的ImportBeanDefinitionRegistrar的实现类。他俩的区别主要是：

*   回调ImportBeanDefinitionRegistrar的实现类时比回调BeanFactoryPostProcessor多了一个参数AnnotationMetadata，这个里面放了@Import注解所在类的变量；

###### 2）为什么只有priorityOrderedPostProcessors先实例化了

和priorityOrderedPostProcessors一起的还有两个集合orderedPostProcessorNames和nonOrderedPostProcessorNames，执行的顺序也是这个顺序，为了防止在执行BeanFactoryPostProcessor的时候修改其他没执行的BeanFactoryPostProcessor，所以只有最先被执行的那批BeanFactoryPostProcessor可以被先实例化，其他的两个集合都要保证尽可能晚的实例化。

###### 3）BeanFactoryPostProcessor其实也开放了BeanDefinition的注册，为什么还要BeanDefinitionRegistryPostProcessor

BeanFactoryPostProcessor的postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)方法里的参数其实是ListableBeanFactory，这个BeanFactory其实是可以注册BeanDefinition的。

因为执行BeanFactoryPostProcessor的时候是没有死循环的，也就是说我们在BeanFactoryPostProcessor中又添加了BeanFactoryPostProcessor的实现类是不会被执行的。

还有一个问题是虽然Spring容器中会有通过BeanFactoryPostProcessor中添加的BeanDefinition，但是被BeanFactoryPostProcessor中添加的Bean中有一些注解是不生效的，比如@Bean注解。所以尽量不要使用这种方式添加BeanDefinition。

###### 4）怎么理解BeanFactoryPostProcessor

首先他是一个容器的后置处理器，他是整个Spring容器在初始化的时候提供给我们对BeanFactory对象进行扩展的。

*   他可以修改或者添加beanDefinitionMap里的元素，可以修改某个BeanDefinition的注入模型；

*   我们还可以在回调中通过下面的代码实现忽略某个类型的自动注入：

    ```java
    // 在容器的生命周期内都不会 自动注入 K类型的Bean
    // 注意，@Autowired或者@Resource不属于自动注入，也不属于手动注入
    beanfactory.ignoreDependencyType(K.class);
    ```

*   还可以忽略一个Bean中的set方法注入：

    ```java
    // 这个会忽略K中的set方法的自动注入
    // 就是说这个是标记某个类中的set方法就是普通的set方法
    beanfactory.ignoreDependencyInterface(K.class);
    ```

    比如我们有一个类获取ApplicationContext：

    ```java
    /**
     * 这个是Spring推荐的获取容器的写法，首先这个Bean肯定会被扫描到
     * 然后重写的这个set方法不会被注入，在容器初始化的时候有一行代码写了：
     * beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
     * Spring会在特定的时机来回调这个方法
     */
    @Component
    public class Test implements ApplicationContextAware {
        Applicationcontext applicationContext;
        
        @Override
        public void setApplicationContext(Applicationcontext applicationContext) throws BeansException {
            this.applicationContext = applicationContext;
        }
    }
    ```

###### 5）容器后置处理器的注入问题

如果我们在BeanFactoryPostProcessor或着BeanDefinitionRegistryPostProcessor的实现类中注入某个Bean是不会生效的，因为这个时候容器正在启动，而处理@Autowired或者@Resource注解的BeanPostProcessor还在beanDefinitionMap里，他俩只要不在BeanFactory的Lis\t<BeanPostProcessor\> beanPostProcessors里就不会生效，所以在容器的后置处理器中不能注入Bean。

