---
title: 5.Bean的实例化
tags:
  - spring-framework
categories: 框架
copyright: true
---

##### 1.单例池

在BeanFactory中beanDefinitionMap存放的是bean的名字作为key，类对应的BeanDefinition作为value，还有一个singletonObjects用来存放已经实例化好的Bean，Spring中叫单例池。

###### 2.实例化源码

在启动容器结束后就已经完成了Bean的扫描，ApplicationContext的refresh()方法中会调用下面的方法，就是Bean实例化的入口：

```java
// 完成不是懒加载的单例Bean的实例化
finishBeanFactoryInitialization(beanFactory);
```

真正的入口在finishBeanFactoryInitialization(beanFactory);方法里的最后一行：

```java
beanFactory.preInstantiateSingletons();
```

这个类里先校验，然后把name前面拼上"&"去调用getBean()方法，这个方法中会判断如果单例池中没有这个Bean回去创建：

```java
public void preInstantiateSingletons() throws BeansException {
   if (logger.isTraceEnabled()) {
      logger.trace("Pre-instantiating singletons in " + this);
   }
    
   // 这个beanDefinitionNames存的是beanDefinitionMap的key
   List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);

   for (String beanName : beanNames) {
      // 先从mergedBeanDefinitions(map)中根据name拿到BeanDefinition
      // todo mergedBeanDefinitions和beanDefinitionMap有什么区别
      // todo 为什么获取BeanDefinition要搞得真么复杂，直接遍历beanDefinitionMap不可以吗
      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
      // 抽象类或者非单例类或者懒加载的类不会实例化
      if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
         // 验证是否是FactoryBean
         if (isFactoryBean(beanName)) {
            // 把name前面拼上"&"，然后获取Bean
            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
            if (bean instanceof FactoryBean) {
               FactoryBean<?> factory = (FactoryBean<?>) bean;
               boolean isEagerInit;
               if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                  isEagerInit = AccessController.doPrivileged(
                        (PrivilegedAction<Boolean>) ((SmartFactoryBean<?>) factory)::isEagerInit,
                        getAccessControlContext());
               }
               else {
                  isEagerInit = (factory instanceof SmartFactoryBean &&
                        ((SmartFactoryBean<?>) factory).isEagerInit());
               }
               if (isEagerInit) {
                  getBean(beanName);
               }
            }
         }
         else {
             // 非FactoryBean得话走这里
            getBean(beanName);
         }
      }
   }

   // Trigger post-initialization callback for all applicable beans...
   for (String beanName : beanNames) {
      Object singletonInstance = getSingleton(beanName);
      if (singletonInstance instanceof SmartInitializingSingleton) {
         SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
         if (System.getSecurityManager() != null) {
            AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
               smartSingleton.afterSingletonsInstantiated();
               return null;
            }, getAccessControlContext());
         }
         else {
            smartSingleton.afterSingletonsInstantiated();
         }
      }
   }
}
```

getBean()方法里直接调用了doGetBean()方法：

```java
protected <T> T doGetBean(
      String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)
      throws BeansException {
   // 1.验证名字的合法性
   String beanName = transformedBeanName(name);
   Object bean;

   // Eagerly check singleton cache for manually registered singletons.
   // 1.尝试从单例池中获取Bean
   Object sharedInstance = getSingleton(beanName);
   if (sharedInstance != null && args == null) {
      if (logger.isTraceEnabled()) {
         if (isSingletonCurrentlyInCreation(beanName)) {
            logger.trace("Returning eagerly cached instance of singleton bean '" + beanName +
                  "' that is not fully initialized yet - a consequence of a circular reference");
         }
         else {
            logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
         }
      }
      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
   }
   // 如果Bean还没被创建会走到这个分支
   else {
      // 如果这个Bean在正在创建的原型集合中就抛异常
      if (isPrototypeCurrentlyInCreation(beanName)) {
         throw new BeanCurrentlyInCreationException(beanName);
      }

      // 处理父子容器
      BeanFactory parentBeanFactory = getParentBeanFactory();
      if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
         // Not found -> check parent.
         String nameToLookup = originalBeanName(name);
         if (parentBeanFactory instanceof AbstractBeanFactory) {
            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                  nameToLookup, requiredType, args, typeCheckOnly);
         }
         else if (args != null) {
            // Delegation to parent with explicit args.
            return (T) parentBeanFactory.getBean(nameToLookup, args);
         }
         else if (requiredType != null) {
            // No args -> delegate to standard getBean method.
            return parentBeanFactory.getBean(nameToLookup, requiredType);
         }
         else {
            return (T) parentBeanFactory.getBean(nameToLookup);
         }
      }

      if (!typeCheckOnly) {
         markBeanAsCreated(beanName);
      }

      try {
         RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
         checkMergedBeanDefinition(mbd, beanName, args);

         // Guarantee initialization of beans that the current bean depends on.
         // 处理@DependsOn注解
         String[] dependsOn = mbd.getDependsOn();
         if (dependsOn != null) {
            for (String dep : dependsOn) {
               if (isDependent(beanName, dep)) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
               }
               //先去处理@DependsOn注解里的类
               registerDependentBean(dep, beanName);
               try {
                  getBean(dep);
               }
               catch (NoSuchBeanDefinitionException ex) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        "'" + beanName + "' depends on missing bean '" + dep + "'", ex);
               }
            }
         }

         // Create bean instance.
         // 如果是单例的就创建Bean
         if (mbd.isSingleton()) {
            sharedInstance = getSingleton(beanName, () -> {
               try {
                  // 开始创建
                  return createBean(beanName, mbd, args);
               }
               catch (BeansException ex) {
                  // Explicitly remove instance from singleton cache: It might have been put there
                  // eagerly by the creation process, to allow for circular reference resolution.
                  // Also remove any beans that received a temporary reference to the bean.
                  destroySingleton(beanName);
                  throw ex;
               }
            });
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
         }

         else if (mbd.isPrototype()) {
            // It's a prototype -> create a new instance.
            Object prototypeInstance = null;
            try {
               beforePrototypeCreation(beanName);
               prototypeInstance = createBean(beanName, mbd, args);
            }
            finally {
               afterPrototypeCreation(beanName);
            }
            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
         }

         else {
            String scopeName = mbd.getScope();
            if (!StringUtils.hasLength(scopeName)) {
               throw new IllegalStateException("No scope name defined for bean '" + beanName + "'");
            }
            Scope scope = this.scopes.get(scopeName);
            if (scope == null) {
               throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
            }
            try {
               Object scopedInstance = scope.get(beanName, () -> {
                  beforePrototypeCreation(beanName);
                  try {
                     return createBean(beanName, mbd, args);
                  }
                  finally {
                     afterPrototypeCreation(beanName);
                  }
               });
               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
            }
            catch (IllegalStateException ex) {
               throw new BeanCreationException(beanName,
                     "Scope '" + scopeName + "' is not active for the current thread; consider " +
                     "defining a scoped proxy for this bean if you intend to refer to it from a singleton",
                     ex);
            }
         }
      }
      catch (BeansException ex) {
         cleanupAfterBeanCreationFailure(beanName);
         throw ex;
      }
   }

   // Check if required type matches the type of the actual bean instance.
   if (requiredType != null && !requiredType.isInstance(bean)) {
      try {
         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
         if (convertedBean == null) {
            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
         }
         return convertedBean;
      }
      catch (TypeMismatchException ex) {
         if (logger.isTraceEnabled()) {
            logger.trace("Failed to convert bean '" + name + "' to required type '" +
                  ClassUtils.getQualifiedName(requiredType) + "'", ex);
         }
         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
      }
   }
   return (T) bean;
}
```

真正创建Bean的代码在**createBean(beanName, mbd, args);**里，但是这个方法显示通过**resolveBeforeInstantiation(beanName, mbdToUse);**处理了一下AOP的@Before，然后通过**doCreateBean(beanName, mbdToUse, args);**创建Bean：

```java
protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
      throws BeanCreationException {

   // Instantiate the bean.
   // 这个BeanWrapper属于对Bean的一层包裹
   BeanWrapper instanceWrapper = null;
   if (mbd.isSingleton()) {
      // 移除单例的缓存
      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
   }
   if (instanceWrapper == null) {
      // 推断supplier、推断构造方法，创建对象
      instanceWrapper = createBeanInstance(beanName, mbd, args);
   }
   Object bean = instanceWrapper.getWrappedInstance();
   Class<?> beanType = instanceWrapper.getWrappedClass();
   if (beanType != NullBean.class) {
      mbd.resolvedTargetType = beanType;
   }

   // Allow post-processors to modify the merged bean definition.
   synchronized (mbd.postProcessingLock) {
      if (!mbd.postProcessed) {
         try {
            // 这里就会执行所有MergedBeanDefinitionPostProcessor的实现类
            // 比如AutowiredAnnotationBeanPostProcessor就会在这个时候找到所有@Autowired注解的属性或者方法缓存起来
            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
         }
         catch (Throwable ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                  "Post-processing of merged bean definition failed", ex);
         }
         mbd.postProcessed = true;
      }
   }

   // Eagerly cache singletons to be able to resolve circular references
   // even when triggered by lifecycle interfaces like BeanFactoryAware.
   boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
         isSingletonCurrentlyInCreation(beanName));
   if (earlySingletonExposure) {
      if (logger.isTraceEnabled()) {
         logger.trace("Eagerly caching bean '" + beanName +
               "' to allow for resolving potential circular references");
      }
      // 把Bean封装成BeanFactory缓存到singletonFactories中
      // 这个是为了做循环依赖的支撑
      addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
   }

   // Initialize the bean instance.
   Object exposedObject = bean;
   try {
      // 完成属性填充
      populateBean(beanName, mbd, instanceWrapper);
      // 初始化Bean
      exposedObject = initializeBean(beanName, exposedObject, mbd);
   }
   catch (Throwable ex) {
      if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {
         throw (BeanCreationException) ex;
      }
      else {
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex);
      }
   }

   if (earlySingletonExposure) {
      Object earlySingletonReference = getSingleton(beanName, false);
      if (earlySingletonReference != null) {
         if (exposedObject == bean) {
            exposedObject = earlySingletonReference;
         }
         else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
            String[] dependentBeans = getDependentBeans(beanName);
            Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
            for (String dependentBean : dependentBeans) {
               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                  actualDependentBeans.add(dependentBean);
               }
            }
            if (!actualDependentBeans.isEmpty()) {
               throw new BeanCurrentlyInCreationException(beanName,
                     "Bean with name '" + beanName + "' has been injected into other beans [" +
                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                     "] in its raw version as part of a circular reference, but has eventually been " +
                     "wrapped. This means that said other beans do not use the final version of the " +
                     "bean. This is often the result of over-eager type matching - consider using " +
                     "'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.");
            }
         }
      }
   }

   // Register bean as disposable.
   try {
      registerDisposableBeanIfNecessary(beanName, bean, mbd);
   }
   catch (BeanDefinitionValidationException ex) {
      throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, "Invalid destruction signatrue", ex);
   }

   return exposedObject;
}
```

属性填充会先去判断我们有没有重写过InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation()方法，这个方法可以控制是否进行属性填充，然后对@Autowired和@Resource进行注入，最后在实现自动注入：

```java
protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
   if (bw == null) {
      if (mbd.hasPropertyValues()) {
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, "Cannot apply property values to null instance");
      }
      else {
         // Skip property population phase for null instance.
         return;
      }
   }

   // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
   // state of the bean before properties are set. This can be used, for example,
   // to support styles of field injection.
   if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
      for (BeanPostProcessor bp : getBeanPostProcessors()) {
         // 这里会执行InstantiationAwareBeanPostProcessor的所有实现类
         // 如果postProcessAfterInstantiation()方法返回的是false，是不会继续填充属性的
         if (bp instanceof InstantiationAwareBeanPostProcessor) {
            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
            if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
               return;
            }
         }
      }
   }

   PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);

   int resolvedAutowireMode = mbd.getResolvedAutowireMode();
   if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
      // Add property values based on autowire by name if applicable.
      if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
         autowireByName(beanName, mbd, bw, newPvs);
      }
      // Add property values based on autowire by type if applicable.
      if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
         autowireByType(beanName, mbd, bw, newPvs);
      }
      pvs = newPvs;
   }

   boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
   boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);

   PropertyDescriptor[] filteredPds = null;
   if (hasInstAwareBpps) {
      if (pvs == null) {
         pvs = mbd.getPropertyValues();
      }
      for (BeanPostProcessor bp : getBeanPostProcessors()) {
         if (bp instanceof InstantiationAwareBeanPostProcessor) {
            // 执行InstantiationAwareBeanPostProcessor的postProcessProperties()方法
            // @Autowired和@Resource就是在这里处理的
            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
            PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
               if (filteredPds == null) {
                  filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
               }
               pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
               if (pvsToUse == null) {
                  return;
               }
            }
            pvs = pvsToUse;
         }
      }
   }
   if (needsDepCheck) {
      if (filteredPds == null) {
         filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
      }
      checkDependencies(beanName, mbd, filteredPds, pvs);
   }

   if (pvs != null) {
      // 实现自动注入
      applyPropertyValues(beanName, mbd, bw, pvs);
   }
}
```

回过头看初始化Bean的代码，这里主要是处理一些Aware接口、@PostConstruct注解或者方法，最后执行BeanPostProcessor的postProcessAfterInitialization()方法，AOP通过这个方法生成的代理：

```java
protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {
   if (System.getSecurityManager() != null) {
      AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
         invokeAwareMethods(beanName, bean);
         return null;
      }, getAccessControlContext());
   }
   else {
      // 这里会判断这个Bean是否实现了Aware接口，然后执行里面的方法
      // 判断是否继承BeanNameAware、BeanClassLoaderAware、BeanFactoryAware
      invokeAwareMethods(beanName, bean);
   }

   Object wrappedBean = bean;
   if (mbd == null || !mbd.isSynthetic()) {
      // 这里主要是处理一些生命周期的注解，比如@PostConstruct
      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
   }

   try {
      // 这个和上面对应，他是处理方法的
      invokeInitMethods(beanName, wrappedBean, mbd);
   }
   catch (Throwable ex) {
      throw new BeanCreationException(
            (mbd != null ? mbd.getResourceDescription() : null),
            beanName, "Invocation of init method failed", ex);
   }
   if (mbd == null || !mbd.isSynthetic()) {
      // 这里执行postProcessAfterInitialization()方法
      // 大部分的BeanPostProcessors都没有实现这个方法
      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
   }

   return wrappedBean;
}
```

这里一个半成品的Bean就创建完了，但是还没有放进单例池中。

很少对Bean生命周期的前半部分扩展，很少在干扰Bean的初始化和干扰Bean的注入。大部分都是对BeanPostProcessor的postProcessorafterInitialization()方法进行扩展，比如AOP。

##### 3.循环依赖

循环依赖就是A依赖B，B依赖A。**Spring是不支持非单例Bean或者通过构造方法注入的循环依赖的**。

当扫描完Bean开始实例化的时候，会去调用BeanFactory的getBean()方法然后再调用到doGetBean()方法，这个方法里会先尝试从第3级缓存获取Bean：

```java
Object sharedInstance = getSingleton(beanName);
```

假设现在是第一次获取Bean A，此时拿到的一定是null，然后回往下走到创建Bean A的分支，真正创建Bean A的代码是下面这段：

```java
sharedInstance = getSingleton(beanName, () -> {
   try {
      // 开始创建
      return createBean(beanName, mbd, args);
   }
   catch (BeansException ex) {
      // Explicitly remove instance from singleton cache: It might have been put there
      // eagerly by the creation process, to allow for circular reference resolution.
      // Also remove any beans that received a temporary reference to the bean.
      destroySingleton(beanName);
      throw ex;
   }
});
```

**注意**这里先调用的是getSingleton()方法，getSingleton()方法需要两个参数，bean名字和ObjectFactory对象，上面创建了一个新的ObjectFactory对象，然后重写了getObject()方法，在getObject()方法里调用的createBean()方法。

getSingleton()方法关键代码：

```java
/**
 * DefaultSingletonBeanRegistry类
 */
public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
    synchronized (this.singletonObjects) {
        // this.singletonObjects就是单例池，我也把他叫做1级缓存
        // 尝试从1级缓存中拿
        Object singletonObject = this.singletonObjects.get(beanName);
        if (singletonObject == null) {
            if (this.singletonsCurrentlyInDestruction) {
                // 正在被销毁就抛出异常
            }
            // 把这个Bean加到singletonsCurrentlyInCreation集合中
            // 标记为正在被创建的Bean
            beforeSingletonCreation(beanName);
            try {
                // 因为上面重写了getObject()方法，所以这里调用了上面的是createBean()方法
                singletonObject = singletonFactory.getObject();
                newSingleton = true;
            } finally {
                // 把Bean名字从singletonsCurrentlyInCreation集合里移出
                // 意思就是取消标记为正在被创建的Bean
                afterSingletonCreation(beanName);
            }
            if (newSingleton) {
                // 把实例化好的Bean放到单例池中
                // 就是删掉2、3级缓存，添加到1级缓存
                addSingleton(beanName, singletonObject);
            }
        }
        return singletonObject;
    }
}
```

通过singletonFactory.getObject()一定会走到createBean()方法，然后再走到doCreateBean()方法，doCreateBean()方法的关键代码：

```java
protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
			throws BeanCreationException {
    if (instanceWrapper == null) {
        // 推断supplier、推断构造方法，创建对象
        instanceWrapper = createBeanInstance(beanName, mbd, args);
    }

    synchronized (mbd.postProcessingLock) {
        if (!mbd.postProcessed) {
            // 这里就会执行所有MergedBeanDefinitionPostProcessor的实现类
            // 比如AutowiredAnnotationBeanPostProcessor就会在这个时候找到所有@Autowired注解的属性或者方法缓存起来
            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
        }
    }
    // 单例并且正在创建
    boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
                                      isSingletonCurrentlyInCreation(beanName));
    if (earlySingletonExposure) {
        // 把Bean封装成ObjectFactory(BeanFactory)
        // 添加到singletonFactories和registeredSingletons，从earlySingletonObjects移出
        // 	Map<String, ObjectFactory<?>> singletonFactories
        // 	Map<String, Object> earlySingletonObjects
        // 	Set<String> registeredSingletons
        // 这个是为了做循环依赖的支撑
        // getEarlyBeanReference()方法也会在循环依赖时，拿到ObjectFactory对象后调用
        // todo 为什么要缓存一个半成品的Bean？
        addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
    }

    // Initialize the bean instance.
    Object exposedObject = bean;
    try {
        // 完成属性填充
        populateBean(beanName, mbd, instanceWrapper);
    }
	……
}
```

这里首先扫描需要注入的属性存起来，然后把A放到3级缓存里，接走到属性注入的代码，当发现需要注入Bean B时又会从getBean(B)开始走一样的步骤，当注入B的属性时，发现B又依赖了A，此时又走到了getBean(A)方法。
这个时候A的状态是正在被创建，并且A和B都在3级缓存里，这个时候getSingleton()方法的处理就不一样了：

```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    // 从单例池里拿
    // 这个map首先用到，暂且叫他1级缓存
    Object singletonObject = this.singletonObjects.get(beanName);
    // 如果是空并且这个Bean正在创建
    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
        // 这个map第2个被用到，暂且叫他2级缓存
        // 这里第一次也获取不到
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
            synchronized (this.singletonObjects) {
                // Consistent creation of early reference within full singleton lock
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        // 这个map第3个被用到，暂且叫他3级缓存
                        // 这个缓存里存储的是ObjectFactory，为什么是ObjectFactory，而不是一个Bean，哪怕是半成品的Bean
                        // 如果我们对一个Bean进行了代理，同时这个Bean a和其他Bean b发生了循环依赖
                        // 创建Bean的时候肯定是创建a，创建到一半属性注入的时候发现需要b，创建b的时候又回过头去创建a
                        // 这个时候返回的就应该是a的代理了，因为此时虽然a还是个半成品，但是b马上就创建好了
                        // Spring并不知道b创建好了之后会不会马上去调用a
                        // 所以一些扩展的动作就比如AOP的代理需要在ObjectFactory的getObject()方法中实现
                        ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                        if (singletonFactory != null) {
                            // 如果是循环依赖这里调用getObject()方法就会调用创建ObjectFactory的时候传进来的lambda表达式
                            singletonObject = singletonFactory.getObject();
                            // 把这个Bean放到2级缓存
                            // todo 为什么要放到2级缓存
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            // 从3级缓存中删除
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }
    return singletonObject;
}
```

当从3级缓存中拿到A的ObjectFactory对象后还是会调用重写的getObject()方法，这个getObject()对应的是**getEarlyBeanReference(beanName, mbd, bean)**，这个方法非常关键，这个可以保证注入的A哪怕被AOP代理也不会出现问题，处理完A之后就会把A从3级缓存拿到2级缓存，然后B会从属性注入继续执行，B走完之后A也会继续属性注入。

可以调用**context.setAllowCircularReferences(false);**关闭循环依赖，但是需要在容器refresh()方法之前调用。

##### 4.问题

###### 1）怎么理解AOP

AOP是面向切面编程，在面向对象的过程中可能会衍生出一些横切性的问题，比如日志记录、事务的提交，面向切面就是把这些问题统一处理。Spring AOP通过扩展BeanPostProcessor的postProcessorafterInitialization()方法+cgLib/jdk代理实现了AOP。

###### 2）怎么回答Bean的生命周期

Bean的生命周期我理解的是分成6个阶段：

1.   容器启动阶段：扫描、实例化BeanDefinition对象，然后把他存到beanDefinitionMap变量中，注册BeanPostProcessor以及验证BeanDefinition的合法性(因为有的对象是prototype的)；
2.   Bean的实例化：推断实例化方式(supplier方式、静态工厂方法、构造方法等等)，利用这个推断出来的方式实例化对象；
3.   属性注入：提前暴露半成品的Bean用来做循环依赖的支持，查找注入信息(找到@Autowired和@Resource)，判断是否关闭属性注入，如果没关闭就解析刚才查找的注解进行注入；
4.   Bean的初始化：aware接口的回调比如BeanNameAware，各种初始化方法的回调，执行BeanPostProcessor的postProcessorafterInitialization()方法，这个也是对Bean生命周期扩展使用最多的一个方法，比如AOP；
5.   Bean的缓存：删掉创建Bean产生的临时变量，把Bean放到单例池中；
6.   Bean的销毁：回调销毁方法，移出单例池；

###### 3）循环依赖

先大概说一下Bean的生命周期，然后描述一下什么是循环依赖，然后再提到3级缓存怎么解决，以及为什么要有3级缓存。

###### 4）3级缓存

3级缓存就是DefaultSingletonBeanRegistry里的3个map：

1.   Map<String, Object> singletonObjects，这个也叫单例池，里面放的是完整的Bean，他是在getSingle()方法中最先被查找的，所以先叫他第1级缓存。
2.   Map<String, Object> earlySingletonObjects，这里面放的是半成品的Bean，他是在getSingle()方法中第2个被查找的，所以先叫他第2级缓存。
3.   Map<String, ObjectFactory<?>> singletonFactories，这里放的是封装了半成品Bean的ObjectFactory对象，她最后被查找，所以先叫他第3级缓存，也是为了解决循环依赖。

只有第3级缓存里放的是ObjectFactory对象，这是为了解决AOP对Bean进行了代理，此时发生循环依赖被注入时就应该是代理产生的类。

###### 5）后置处理器操作Bean的问题

假设程序中有一个MyBean，然后我们创建了两个BeanPostProcessor，一个BeanPostProcessor中注入了MyBean：

```java
@Autowired
MyBean myBean;
```

另一个BeanPostProcessor中执行以下代码：

```java
@Override
public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    if(beanName.equals("myBean")) {
        Class<?> aClass = bean.getClass();
        Field[] fs = aClass.getDeclaredFields();
        for (Field f : fs) {
            if(f.getName().equals("str")){
                f.setAccessible(true);
                f.set(bean,"spring");
            }
        }
        return bean;
    }
    // 返回null停止执行其他后置处理器
    return null;
}
```

*   在上面的代码中修改了MyBean里的str属性值，当我们在代码里打印MyBean的两个属性是全都是null，但是第一个BeanPostProcessor中注入的MyBean是有值的：

    正常注入时没问题的，当Bean创建完成之后会遍历BeanFactory里的List\<BeanPostProcessor\> beanPostProcessors变量，而我们上面声明的BeanPostProcessor还没有放到list里，当遍历第一个BeanPostProcessor时，发现需要注入MyBean，这个时候会先创建MyBean对象，MyBean创建完之后又会执行Bean的后置处理器，但是问题就来了，此时我们还有两个BeanPostProcessor没有创建完，所以创建MyBean的时候不会走我们自己创建的这两个BeanPostProcessor，所以第二个BeanPostProcessor中修改MyBean的属性会不生效。

*   如果把第一个BeanPostProcessor的注入去掉，第二个BeanPostProcessor中修改MyBean里的str属性值会生效，这个时候创建MyBean的时机变晚了，BeanPostProcessor已经全部被注册到了BeanFactory中的list里，这个时候就正常了。

*   如果第一个BeanPostProcessor实现了Ordered接口对注入没有影响，但是如果改成实现PriorityOrdered就注入不进去：

    处理@Autowired和@Resource注解的BeanPostProcessor实现了PriorityOrdered接口，正常情况下我们自己BeanPostProcessor实例化的时候处理@Autowired和@Resource注解的BeanPostProcessor已经创建好了，所以可以正常注入，但是如果我们自己的BeanPostProcessor也实现了PriorityOrdered，那就保证不了实例化自己的BeanPostProcessor的时候处理@Autowired和@Resource注解的BeanPostProcessor是否已经创建好了。

*   还是第一个BeanPostProcessor实现了Ordered接口但是注入了一个需要被AOP的Bean，因为他返回了null，会导致停止执行其他的后置处理器，此时AOP的后置处理器在Order之后还没有执行，所以会导致AOP失效；如果第一个BeanPostProcessor实现了PriorityOrdered接口，就算他不返回null，AOP也会失效，AOP实现了Ordered接口，所以注入MyBean的时候处理AOP的BeanPostProcessor还没创建好。

