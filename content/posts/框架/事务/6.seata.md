---
title: 事务-6.seata
tags:
  - 事务
categories: 框架
copyright: true
---

### seata原理

#### AT模式原理

首先有一个Seata Server负责控制事务的提交和回滚，每个服务里需要引入seata client负责监听sql，并生成对应的undo_log，undo_log存储在表里，并且操作本地数据和插入undo_log在同一本地事务中，当服务完成本地事务后需要告诉Seata Server分支事务提交成功，所有分支事务都完成后(**那个角色提交？**)向Seata Server提交事务并释放全局锁，如果存在某个服务发生异常，此时Seata Server会向提交分支事务成功的服务发送执行回滚日志消息，再由seata client执行对应的undo_log。

![seataAT模式](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/seata AT模式.png)

#### 读写隔离原理

seata的隔离级别是读未提交，未提交指的是分布式事务没有提交，并不是本地事务。

首先完整的流程如下图，在提交本地事务前必须要通过Seata Server获取全局锁，其他分布式事务在没有拿到全局锁前不能提交本地事务，如果没有全局锁会导致多个分布式事务同时操作一条数据，发生回滚时数据错乱的问题，但是引入的全局锁会让性能下降的严重，所以AT模式的分布式事务只用在跟钱相关的操作里，其他时候如果需要用到分布式事务可以使用mq的软事务。

![seataAT模式读写隔离原理](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/seata AT模式读写隔离原理.png)

#### 死锁问题

比如上图两个事务操作同一条数据，事务1中服务A的操作执行完成并且提交了本地事务，此时事务2开始执行服务A的操作，此时全局锁在事务1上，所以事务2的服务A没法提交本地事务，他会等待拿到全局锁，但是这个时候他是持有11001的本地锁的，事务1在执行服务B操作的时候发生异常需要回滚，服务A收到回滚消息需要拿到11001的本地锁，出现了事务1持有事务2需要的全局锁，事务2持有事务1需要的本地锁，循环等待了，seata为了解决这个死锁问题在获取全局锁的时候加了个超时机制，如果超时会回滚数据并释放锁。

#### 使用seata

前提：Seata Server启动好，每个服务对应的库创建好undo_log表。

pom中添加依赖：

```xml
<!-- 引入seata整合分布式事务 -->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-seata</artifactId>
    <exclusions>
        <exclusion>
            <groupId>io.seata</groupId>
            <artifactId>seata-spring-boot-starter</artifactId>
        </exclusion>
    </exclusions>
</dependency>

<!-- 跟安装的seata-server需要保持版本一致 -->
<dependency>
    <groupId>io.seata</groupId>
    <artifactId>seata-spring-boot-starter</artifactId>
    <version>1.3.0</version>
</dependency>
```

添加配置：

```yml
seata:
  tx-service-group: ruyuan-eshop-order-group
  service:
    grouplist:
      ruyuan-eshop-seata: 127.0.0.1:8091
    vgroup-mapping:
      ruyuan-eshop-order-group: ruyuan-eshop-seata
```

在分布式事务的入口，比如创建订单方法使用一下注解替换@Transactional：

```java
@GlobalTransactional(rollbackFor = Exception.class)
```

其他被调用的服务还是使用@Transactional不变，会自动被seata client代理。

### 使用seata后的并发问题

使用seata的服务有3个，营销、库存和订单，当接口被同时调用的时候会锁定用户选中的优惠券、商品的库存，用户的优惠券对吞吐的影响不大，同一个用户同时下单才会有影响，但是库存的影响就会很大，使用seata会导致同一个商品只能串行的被下单，这个时候解决方案大约有3种：

1.   库存分片维护，比如一个商品的库存有3w个，分成1k片，这样就可以保证1k人同时买这个商品了，但是通过MySQL维护1k分同一个商品很麻烦，补货操作、一些分片没有库存，一些分片有库存、剩余库存展示等等，相当费劲；
2.   不使用seata，使用rocket mq这种最终一致性的事务；
3.   不使用AT模式，不用AT模式就不会有全局锁，可以改成营销和订单是AT模式，他俩和库存是TCC模式，seata本身就支持sega、AT、TCC等分布式事务；

### seata实现TCC事务

seata实现TCC事务肯定是要seata server充当tm角色，以数据库缓存双写举例，写数据库和写缓存分别是单独的接口+实现类，每个接口都有字节的try()、commit()和cancel()方法，并且接口上需要标注@LocalTCC注解：

```java
@LocalTCC
public interface LockMysqlStockTccService {

    @TwoPhaseBusinessAction(name = "lockMysqlStockTccService", commitMethod = "commit", rollbackMethod = "rollback")
    boolean deductStock(BusinessActionContext actionContext,
                        @BusinessActionContextParameter(paramName = "deductStock") DeductStockDTO deductStock);

    void commit(BusinessActionContext actionContext);

    void rollback(BusinessActionContext actionContext);
}
```

在这个接口中deductStock()就对应try()方法，使用@TwoPhaseBusinessAction标记表示两阶段事务，注解里指定了tcc的名称(唯一)和提交方法名、回滚方法名，try()方法中有两个参数，BusinessActionContext actionContext表示事务的上下文，可以通过这个获取全局事务id，@BusinessActionContextParameter这个注解的意思是参数会在上下文中传播，即能通过BusinessActionContext对象在commit()方法及rollback()方法中取到该参数值，可以指定多个，实现类中不需要有特殊的注解，但是需要使用TccResultHolder对象操作事务状态，实现类代码：

```java
@Service
@Slf4j
public class LockMysqlStockTccServiceImpl implements LockMysqlStockTccService {

    @Transactional(rollbackFor = Exception.class)
    @Override
    public boolean deductStock(BusinessActionContext actionContext, DeductStockDTO deductStock) {
        String xid = actionContext.getXid();
        // 标识try阶段开始执行
        TccResultHolder.tagTryStart(getClass(), 业务key, xid);
        // 悬挂问题：rollback接口比try接口先执行，即rollback接口进行了空回滚，try接口才执行，导致try接口预留的资源无法被取消
        // 解决空悬挂的思路：即当rollback接口出现空回滚时，需要打一个标识（在数据库中查一条记录），在try这里判断一下
        if(isEmptyRollback()) {
            TccResultHolder.removeResult(getClass(), 业务key, xid);
            return false;
        }
		// 业务代码……
        // 标识try阶段执行成功
        if(result >0) {
            TccResultHolder.tagTrySuccess(getClass(), 业务key, xid);
        }
        return true;
    }

    @Override
    public void commit(BusinessActionContext actionContext) {
        String xid = actionContext.getXid();
        DeductStockDTO deductStock = ((JSONObject)actionContext.getActionContext("deductStock")).toJavaObject(DeductStockDTO.class);
        // 幂等
        // 当出现网络异常或者TC Server异常时，会出现重复调用commit阶段的情况，所以需要进行幂等操作
        if(!TccResultHolder.isTrySuccess(getClass(), 业务key, xid)) {
            return;
        }
        // 业务代码……
        // 移除标识
        TccResultHolder.removeResult(getClass(), 业务key, xid);
    }

    @Override
    public void rollback(BusinessActionContext actionContext) {
        String xid = actionContext.getXid();
        DeductStockDTO deductStock = ((JSONObject)actionContext.getActionContext("deductStock")).toJavaObject(DeductStockDTO.class);
        // 空回滚处理
        if(TccResultHolder.isTagNull(getClass(), 业务key, xid)) {
            log.info("mysql:出现空回滚");
            insertEmptyRollbackTag();
            return;
        }

        // 幂等处理
        // try阶段没有完成的情况下，不必执行回滚，因为try阶段有本地事务，事务失败时已经进行了回滚
        // 如果try阶段成功，而其他全局事务参与者失败，这里会执行回滚
        if(!TccResultHolder.isTrySuccess(getClass(), 业务key, xid)) {
            log.info("mysql:无需回滚");
            return;
        }
        // 业务代码……
        // 移除标识
        TccResultHolder.removeResult(getClass(), 业务key, xid);
    }
}
```

修改缓存的接口和实现类除了业务都一样，大概流程如下图

![](https://tva1.sinaimg.cn/large/008i3skNly1gxzsr3pj0gj31cq0u00vm.jpg)

TccResultHolder并不是seata里的，是我们自己实现的一个本地标记TCC事务状态的工具类，代码如下：

```java
public class TccResultHolder {

    /**
     * 标识TCC try阶段开始执行的标识
     */
    private static final String TRY_START = "TRY_START";

    /**
     * 标识TCC try阶段执行成功的标识
     */
    private static final String TRY_SUCCESS = "TRY_SUCCESS";

    /**
     * 保存TCC事务执行过程的状态
     */
    private static Map<Class<?>, Map<String, String>> map =
            new ConcurrentHashMap<Class<?>, Map<String, String>>();

    /**
     * 标记try阶段开始执行
     */
    public static void tagTryStart(Class<?> tccClass,String bizKey, String xid) {
        setResult(tccClass,bizKey,xid,TRY_START);
    }

    /**
     * 标记try阶段执行成功
     */
    public static void tagTrySuccess(Class<?> tccClass,String bizKey, String xid) {
        setResult(tccClass,bizKey,xid,TRY_SUCCESS);
    }

    /**
     * 判断标识是否为空
     */
    public static boolean isTagNull(Class<?> tccClass,String bizKey,String xid) {
        String v = getResult(tccClass,bizKey,xid);
        if(StringUtils.isBlank(v)) {
            return true;
        }
        return false;
    }

    /**
     * 判断try阶段是否执行成功
     */
    public static boolean isTrySuccess(Class<?> tccClass,String bizKey,String xid) {
        String v = getResult(tccClass,bizKey,xid);
        if(StringUtils.isNotBlank(v) && TRY_SUCCESS.equals(v)) {
            return true;
        }
        return false;
    }


    public static void setResult(Class<?> tccClass,String bizKey, String xid, String v) {
        Map<String, String> results = map.get(tccClass);

        if (results == null) {
            synchronized (map) {
                if (results == null) {
                    results = new ConcurrentHashMap<>();
                    map.put(tccClass, results);
                }
            }
        }
		//保存当前分布式事务id
        results.put(getTccExecution(xid,bizKey), v);
    }

    public static String getResult(Class<?> tccClass,String bizKey, String xid) {
        Map<String, String> results = map.get(tccClass);
        if (results != null) {
            return results.get(getTccExecution(xid,bizKey));
        }

        return null;
    }


    public static void removeResult(Class<?> tccClass,String bizKey, String xid) {
        Map<String, String> results = map.get(tccClass);
        if (results != null) {
            results.remove(getTccExecution(xid,bizKey));
        }
    }

    private static String getTccExecution(String xid,String bizKey) {
        return xid+"::"+bizKey;
    }
}
```

为什么需要这个？用于解决TCC幂等，空回滚/悬挂问题

*   空悬挂/空回滚问题：空回滚是rollback()的空回滚，空悬挂是try()的空悬挂，比如说try()接口莫名其妙的卡住了，这个时候seata判断try()执行失败进行回滚操作，回滚操作完成后try()方法才执行完，这样就会出现两个问题，回滚方法没有回滚的数据，try()方法执行成功出现脏数据。

    这个时候使用TccResultHolder记录try()方法的状态，当出现空回滚时直接在数据库中插入一条空回滚记录，然后在try()方法执行时先从数据库中查询是否存在空回滚记录，如果存在就不执行try()操作。

*   幂等问题：commit或者cancel在失败的时候会不断的被发起重试，比如commit()或者cancel()执行完了但是和seata server通信失败，所以会出现幂等问题。

    解决幂等还是要用TccResultHolder的事务状态，当commit或者cancel结束后会把当前事务从TccResultHolder中移除，表示事务操作结束，如果被重复调用但是内存中没有这条数据就不会执行业务操作。

### seata实现AT和TCC混合事务

第一种方案：使用rocket mq，比如生单，在锁定优惠券之后插入订单数据，然后发送mq消息锁定库存！

**这样会出现很多问题，比如丢消息导致的库存超卖、重复消费导致库存多扣，由于是异步扣库存，订单服务并不知道实时库存状态。**

第二种方案：把锁定库存接口的@GlobalTransactional注解去掉，这样库存、订单、营销使用同一个全局事务，但是库存使用的是TCC，订单和营销使用的是AT，订单和库存还是rpc同步调用。
