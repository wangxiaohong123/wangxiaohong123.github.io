---
title: 事务-3.TCC事务
tags:
  - 事务
categories: 框架
copyright: true
---

![](../images/TCC事务.png)

主业务服务就是调用其他服务的接口，比如说下订单的接口，在这个接口中需要冻结用户钱包金额，主业务服务就是订单服务，从业务服务就是钱包服务，钱包服务需要提供三个接口：try接口、confirm接口、cancel接口。

业务活动管理器就是管理分布式事务状态的，他会去触发从业务服务的confirm和cancel接口。

**try阶段**：会锁定资源，没有资源锁定的操作，try接口就可以留空。

**confirm**：执行具体的逻辑；

**cancel**：对之前的变动回滚；

### TCC的两个变种

*   异步型TCC方案：从业务服务之前加一层消息服务，从业务服务只有一个confirm接口，try操作就是在消息服务中写入一条confirm消息，confirm操作就是把这个消息发送到从业务服务，cancel操作就是把消息删掉，比如从业务服务已经写好了接口，如果现在要改成分布式事务，需要加两个接口，一个try，一个concel，加一个消息服务，从业务服务就不需要加接口了。
*   补偿性TCC方案：只有两个阶段，一个do接口，一个compensate接口，其实就是把try拿掉了。

### 国内的热门TCC框架

1.  tcc-transaction：对spring cloud整合不太好，dubbo还行。
2.  himly：他的整合都是用xml格式，现在都是注解了。
3.  ByteTCC：支持TCC和saga事务，注解驱动，和spring cloud整合还行。

byteTCC可以实现tcc事务和saga事务，在tcc事务中，try和cancel是对应起来的，如果confirm失败会一直重试，cancel失败也会一直重试，而在saga事务中，没有confirm，try就是执行业务逻辑，cancel提供对应的反向数据操作。

### byteTCC源码

首先使用byteTCC需要在dataSource组件加入注解：**@Import(SpringCloudConfiguration.class)**，SpringCloudConfiguration.class里面是对cloud的组件比如feign创建了自己的动态代理，实现自己的逻辑。

启动类上添加注解**@ImportResource({ "classpath:bytetcc-supports-springcloud.xml" }) **，这个xml配置了很多bean。

服务之间的事务上下文都是通过request的header传递。

bytejta表中如果只有一条记录，说明try执行完了，confirm或者cancel还没执行成功，正常来说一个事务会对应两条记录。

CompensableWork会定时（60s）重试失败的confirm或者cancel，也是调用CompensableCoordinatorController中的接口，同时在刚启动的时候他也会去恢复没执行的事务。

链式调用也是使用resourceList。

在bytetcc中，confirm和cancel失败会一直重试，直到成功，讲道理来说，confirm失败也应该调用对应的cancel，cancel失败不断重试就完美了。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gi22bwbbbwj30u01autzp.jpg)

