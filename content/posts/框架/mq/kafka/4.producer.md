---
title: 4.producer
date: 2021-08-06 06:27:35
tags:
  - 大数据
categories: kafka
copyright: true
---

### 发送消息过程

首先每个producer会从配置的broker上拉取topic、分区、broker等信息，在producer收到消息之后会先封装成一个producerRecord对象，然后把对象交给序列化组件，然后经过partitioner组件分配发送到那个broker上，如果发消息时没指定key，也没指定分区算法，默认会轮询，然后把消息发送给缓冲区，通过sender组件从缓冲区读取数据，打包成batch发送给broler。

![](https://tva1.sinaimg.cn/large/008i3skNly1gthbtdzthoj60uz0u0gnm02.jpg)

### 常见异常

**LeaderNotAvailableException**：leader不可用，这个时候可能是leader挂了，正在选举；

**NotControllerException**：如果controller所在的broker挂了就会出现这个异常；

**NetworkException**：网络异常；

这些异常一般重试就可以解决。

**TimeOutException**：默认连接broker的超时时间是30s，如果30s没连上kafka可能集群都挂了。

### 参数配置

1.   buffer.memory：缓冲的大小，默认是33554432，就是32M，如果说发送消息速度特别快，等到senderer线程封装batch在发送出去会慢一点，慢慢缓冲区满了发送消息就会卡住，刚开始可能是够用的，可以在发送消息前后加时间戳，看到发送消息大于10mx的时候可能就是缓冲区满了。
2.   compression.type：发送消息时压缩算法，默认是none，开启后会增加CPU的开销，但是可以提升吞吐量，效率最好的就是lz4。
3.   batch.size：打包发送的数据的字节数，默认是16k，这个在高并发的时候是偏小的，可以统计每100ms的消息的发送数量，然后适当调大这个值，看看吞吐量是不是有提升，16k是偏小的，一般是64k或者128k。
4.   linger.ms：默认是0，可以设置成50或者100，意思是在50ms还没凑到batch大小，也把消息发送出去。
5.   max.request.size：默认是1048576，就是1M，表示单条消息的最大值，1M是偏小的，可以设置成10M。
6.   request.timeout.ms：超时时间，默认30s，够用。
7.   retries：发送失败的重试次数，3到5次就可以cover住一般的异常了，不放心的话可以重试10次，但是重试可能导致消息的重复后者消息的乱序，因为在你重试的时候可能别的消息已经发出去了。
8.   retry.backoff.ms：每次重试的毫秒数。
9.   max.in.flight.request.per.connection：同时间发送消息的条数，如果设置成1表示同时间只能发同一条消息，就是在消息重试的时候其他消息需要等待这个法成功。
10.   acks：他有3个选项，0：表示只要发出去就算成功，不管leader写没写成功；1：leader写成功才算成功；-1或者all：leader和所有follower写成功才算成功；
11.   max.block.ms：默认60s，当缓冲区慢了的时候，会阻塞住60s，超过时间会抛出异常。

### 自定义分区

一般情况不需要顺序消费的话发送消息时连key都不需要指定，默认的轮询就好了，如果想要顺序比支付和退款，这种需要先付钱在退款的可以把key设置成订单的id，这样就会发送到固定的partition上，broker的写一定是有序的，所以这个分区器一般用不到，如果非要用可以实现Partitioner接口：

```java
public class HotDataPartitioner implements Partitioner {

    private Random random;

    @Override
    public void configure(Map<String, ?> configs) {
        random = new Random();
    }

    @Override
    public int partition(String topic, Object keyObj, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) {
        String key = (String)keyObj;
        List<PartitionInfo> partitionInfoList = cluster.availablePartitionsForTopic(topic);
        int partitionCount = partitionInfoList.size();
        int hotDataPartition = partitionCount - 1;
        return !key.contains(“hot_data”) ? random.nextInt(partitionCount - 1) : hotDataPartition;
    }
}
```

然后把配置partitioner就可以了：

```java
props.put(“partitioner.class”, “com.xxxx.HotDataPartitioner”);
```

### 自定义序列化

自定义序列化我感觉更没用，jsonString已经很方便了。

### 自定义拦截器

个人觉得这个页比较鸡肋，他就是说发消息之前把每条消息的同一处理，我觉得在用3方的时候应该尽量减少对3方的依赖，最好是只用核心功能。

