---
title: 2.nameServer相关原理
tags:
  - RocketMQ
categories: 中间件
copyright: true
---

##### 核心数据模型

首先要有一个集群信息clusterAddrTable:类似下面这样

```json
{
    // 这里是集群名称:集群中的broker名称数组
    "myCluster": ["myBroker01","myBroker02"]
}
```

broker信息brokerAddrTable，以broker的主从为元素的数组，broker名称作为key，相同名称的broker组成了brokerAddrs信息：

```json
 [{
     "myBroker01": {
         "cluster": "myCluster",
         "brokerAddrs": [{
             // ip:端口
             0: "xx.xx.xx.xx:xxx"
         },{
             1: "xx.xx.xx.xx:xxx"
         }]
     }
},{
    "myBroker02": {
        "cluster": "myCluster",
        "brokerAddrs": [{
            0: "xx.xx.xx.xx:xxx"
        },{
            1: "xx.xx.xx.xx:xxx"
        }]
    }
}]
```

broker的心跳信息brokerLiveTable，里面保存了上一次心跳时间以及对应的ha节点地址，比如broker是一主一从，从节点心跳信息的haServerAddr就是主节点的地址：

```json
{
    "xx.xx.xx.xx:xxx": {
        "lastUpdateTimestamp": 2323123123123,
        "haServerAddr": "xx.xx.xx.xx:xxx"
    },
    "xx.xx.xx.xx:xxx": {
        "lastUpdateTimestamp": 2323123123123,
        "haServerAddr": "xx.xx.xx.xx:xxx"
    }
}
```

topic信息topicQueueTable，主要就是保存topic在那几个broker上，每个broker上有几个writeQueue和几个readQueue：

```json
{
    "myTopic": [{
        "brokerName": "myBroker01",
        "readQueueNums": 4,
        "writeQueueNums": 4
    },{
        "brokerName": "myBroker02",
        "readQueueNums": 4,
        "writeQueueNums": 4
    }]
}
```

