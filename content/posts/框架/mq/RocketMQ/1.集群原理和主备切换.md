---
title: 1.集群原理和主备切换
tags:
  - RocketMQ
categories: 中间件
copyright: true
---

### 集群原理

##### 1）4.5之前的集群原理

RocketMq默认就是集群模式，扩展也很简单，功能多而且使用java写的，但是捐给Apache了，也找不到中文文档，英文的还比较简单。 上面三个是目前社区最活跃的三个消息中间件，个人觉得RocketMQ没啥大缺点。

nameServer，代替zk，负责维护broker集群信息(默认每隔10s摘除超过120s没法送心跳的broker节点)，以及同步broker信息到producer。nemeServer的集群是不需要互相通信的，属于Peer-to-Peer对等的集群架构实现了高可用，每个nameServer是相互独立的。并且nameServer不能实现broker的选举，就是说当master-broker挂掉之后需要人工切换master-broker在重启服务。

broker负责收发消息持久化到本地，每个master-broker可以配置一主多从保证高可用，broker会定时发送心跳到所有nameServer证明自己可用，broker可以配置集群名称，相同集群名称的broker为一个集群。broker也可以配置自己的名称，相同名称的broker是主从关系，通过brokerId区分主从节点，id是0为主节点，大于0是从节点。

producer发送消息时先根据nameServer中获取到的节点信息和topic信息负载均衡到一个queue，然后根据queue反向拿到broker信息，这样就可以向指定的broker发送消息了。

![](https://tva1.sinaimg.cn/large/008i3skNly1gze0rdxeynj30z00u0tbc.jpg)
但是这种集群是没法保证主节点宕机之后自动的主从切换的，从切点只能提供现有消息的读取。所以broker在4.5之前并不是高可用的。

##### 2）4.5之后的集群原理

raft协议：raft是一个方法论，每个broker刚启动的时候都是follower，然后会给自己一个150ms~300ms的随机休眠时间，然后最先完成休眠的follower会把自己的身份变成candidate(leader的候选角色)，接下来进入投票环节，首先他肯定投票给自己，然后他会发送请求发送给其他follower进行拉票，但是每个follower只有一张票，当follower收到拉票请求之前没有投过票，他就会把票投给这个candidate，当这个candidate得到的投票超过了半数(quorum)之后，他就会变成leader。然后当leader选举出来之后会定时向其他节点发送leader的心跳，高速他们已经有leader了，其他节点收到leader心跳之后会重置休眠时间，继续休眠，这样可以实现leader还在的时候其他节点永远没有机会发起选举。

在4.5版本之后不需要配置brokerId，还是相同broker name的为一个组，broker就是基于状态基实现的leader选举：

*   leader状态：初始化的状态都是follower，对应的行为是maintainAsFollower->是否收到leader心跳包，如果没有就执行倒计时把自己切换成candidate状态任务。
*   candidate状态：当有broker苏醒后就变成了candidate状态，candidate状态对应的行为是maintainAsCandidate->给自己投票并发送拉票请求到其他节点，其他节点都投完票之后会判断拿到的票是否超过半数，如果是否就要重新睡眠，如果是是就把状态切换成leader。
*   leader状态：变成leader之后对应的行为变成了maintainAsLeader->向其他节点发送leader心跳，其他节点收到心跳之后会重新休眠并返回结果，如果超过半数follower返回响应就继续定时发送心跳，如果返回的响应少于半数就会把自己重新变成candidate状态。

##### 主备切换

RocketMQ通过自己实现的DLedger组件实现了raft协议和消息存储等功能，主备切换和上面的原理是一样的。

执行以下命令安装Dledger： 


```shell
git clone https://github.com/openmessaging/openmessaging-storage-dledger.git
cd openmessaging-storage-dledger
mvn clean install -DskipTests
```
下载RcoketMQ4.5.2解压导入到intellij中，在terminal切换到项目根目录中运行以下命令进行源码包编译：  

```shell
mvn -Prelease-all -DskipTests clean install -U
```
编译之后将distribution模块下target文件夹中的rocketmq-4.5.2.tar.gz上传到三台虚拟机并解压，修改解压后文件夹下的bin目录下的runserver.sh和runbroker.sh两个文件中的jvm配置。在conf目录下新建文件夹1m-2s-sync，添加一主两从broker文件。然后执行命令启动一个nameserver和三个broker： 

```shell
# 启动nameserver
nohup sh mqnamesrv &
# 使用broker-a.properties启动broker
nohup sh mqbroker -c /usr/local/rocketmq/rocketmq-4.5.2/conf/1m-2s-sync/broker-a.properties >/dev/null 2>&1 &
```
启动控制台查看broker集群

![](https://tva1.sinaimg.cn/large/006tNbRwly1gatwwkqlesj311y0ck75c.jpg)

可以看到192.168.0.3的虚拟机上的broker是master，然后杀掉这个进程，几秒钟后再次查看控制台

![](https://tva1.sinaimg.cn/large/006tNbRwly1gatwyhzt8hj311y08f3z9.jpg)

192.168.0.3虚拟机上的broker已经没有了，192.168.0.5的虚拟机自动切换成了leader。