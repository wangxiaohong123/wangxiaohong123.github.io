---
title: 4.消息消费
tags:
  - RocketMQ
categories: 中间件
copyright: true
---

读写分离主从漂移设计：RocketMQ默认是不倾向于读写分离的，默认的读写都是走主节点，从节点相当于热备份，当主节点检测出自己压力过大时，会返回一个从节点信息告诉消费者下次在从节点拉取，然后拉取一段时间之后，从节点检测出自己消息积压量小于物理内存的30%就会又返回主节点的信息，让消费者下次尝试从主节点拉取消息。这种有的时候访问主，有的时候访问从就叫ip漂移。

他为什么要采取这种惰性的读写分离呢？因为他要维护每个消费者对消息的消费进度，如果一直读写分离，并且有多个从节点，每次消费都可能从任意一个从节点读取，这样是没法维护消费进度的，在RocketMQ中，从节点每隔10s会和主节点进行offset同步，这样也不会支持频繁的读写分离，因为会有大量的重复消息。kafka连漂移都没有。

但是在4.5之后由于改成了raft协议选举，他有个特点就是过半写成功就算成功，当有一些节点没写成功发生了ip漂移就可能导致有些消息无法读取，这样就和kafka一样了。

### 绑定consume queue逻辑

想要拿到消息首先需要绑定consume Queue，一个消费者可以消费多个consumeQueue，但是多个消费者不能消费相同的consume Queue，具体绑定到那个consume Queue是有消费者自己计算的，从nameServer上获取topic信息之后就知道有几个consume queue了，然后就可以计算要绑定到那个queue上，queue在那台broker上，但是有个关键的地方就是他需要知道一个consumer group里有哪些消费者，当消费者启动的时候会去想broker注册，这样随便找一个broker就能找到消费者组的所有信息。

分配consumeQueue的算法：平均算法、轮询分配、一致性hash、配置化、机房分配，由consumer的RebalanceService组件实现。

### 拉取消息模式

拉取消息的组件命名上看有pull和push，但是底层实现都是pull模式，当没有开启long polling的时候也就是默认情况下就是short polling，他在拉取消息时如果没有消息会挂起1s，1s之后会在去检查有没有消息，没有就返回，如果开启了long polling会长时间挂起，然后broker上有一个后台线程每隔5s去检查有没有新的消息，这个时候就要分pull还是push，如果是push就会挂起等待后台线程检查有新消息或者超过15s返回，如果是pull模式最多挂起的时间应该是20s。

### 并发消费

消费者会在内存里维护多个processQueue，每个processQueue都和自己绑定的consumeQueue对应，当拉取消息的线程拉取到消息之后会把消息写到内存的processQueue里，然后会有一个线程池来消费这个processQueue的数据，这个线程池就是我们在初始化消费者的时候设置的线程池，然后线程池里的线程拿到消息之后就回去回调我们的自己的消费逻辑。

### 消费进度管理

当我们消费完之后如果返回的是成功就会把消息从processQueue中删掉并且更新自己内存里的消费进度，然后在通过后台向线程把消费进度异步通知broker，broker也是把消费进度更新到内存里，然后通过后台线程异步刷盘。

如果返回的是失败broker会把消息写到一个延迟消息的topic里去，等到时间后再把消息拿出来重新写到原来的topic中。