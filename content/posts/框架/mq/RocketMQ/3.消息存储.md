---
title: 3.消息存储
tags:
  - RocketMQ
categories: 中间件
copyright: true
---

### 存储方式

每个topic中的消息是分布存储到broker集群上的，也就是说每个master-slave集群只存储一个topic的部分消息，但是怎么确定每个broker上存储那些消息呢？RocketMQ使用MessageQueue来记录消息，每个topic可以有多个MessageQueue，这些MessageQueue尽量均匀的分布到所有master-broker上，而每个MessageQueue存储的消息数量尽量平均，每条消息分发到那个MessageQueue上由选择的策略决定，RocketMQ提供了很多策略。比如一个集群有两个master-broker：master-brokera和master-brokerb，在创建topic时设置MessageQueue的数量为4，这个时候master-brokera上会有两个MessageQueue：MessageQueue0和MessageQueue1，master-brokerb上有两个MessageQueue：MessageQueue2和MessageQueue3，当有10000条消息写入到这个topic中时，理想情况是master-brokera上有5000条消息，master-brokerb上有5000条消息，master-brokera和master-brokerb中的MessageQueue各有2500条消息，通过存储不同的MessageQueue中的消息来实现消息的分布式存储，MessageQueue只是他的逻辑概念，真正到磁盘上会编程consumeQueue。

#### 1.自动容错机制

sendLatencyFaultEnable配置：如果访问一个master-broker的延迟过高，一段时间内不会安排这个broker写消息，可以避免master-broker故障后进行主备切换时访问挂掉的master-broker失败，读数据处理看源码的时候回来写。

#### 2.持久化方式

RocketMQ的日志默认在$HOME/store/文件夹下，可以自定义配置。在store/commitlog文件夹下存储的是一堆数字名称的文件，比如00000000000000000000，这些文件记录了所有消息，每个文件限定最多1G，文件的名称是文件里第一条消息相对于所有文件的总偏移量；在store/consumequeue/{topic}/{queueId}/文件夹下存储的也是一堆数字名称的文件的，这些文件存储相关topic下的MessageQueue中的消息信息（消息在CommitLog中的offset偏移量，消息的长度，以及tag hashcode），可以理解为记录的的是当前MessageQueue里的消息在CommitLog中的地址，每条信息是20字节(8字节的offset，4个字节的消息大小，8字节的hash值)，每个文件保存30万条数据，5.72M。
![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzn68ksbuyj20tm0jqmy2.jpg)
这样每个consumer group都保存自己消费到了第几条消息就可以找到是第几个consume queue文件，在consume queue中找到消息，然后根据消息的总偏移量+二分查找定位到commit log文件，计算在commit log文件中的偏移量(总偏移量 - 文件名)，获取到消息内容。然后还有一个index file，他是负责条件查找消息的。

#### 3.写入流程

当broker收到写入请求时，会把消息追加到commit log里，同时有一个后台线程监听commit log，把新数据同步到consume queue中。

将消息写入这两个文件就是持久化，RocketMQ提供两种刷盘方式：

* 异步刷盘：broker收到消息后将消息写入os操作系统的PageCache（也叫os-cache），由操作系统控制每500ms将缓冲区的消息异步刷入磁盘文件，可能会导致消息丢失；
* 同步刷盘：broker收到消息后直接写入磁盘文件，降低性能保证数据不丢失，使用顺序写比随机写快很多；

![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzpg276vf2j21ds0p4767.jpg)

##### 3.1page cache高并发读写问题

在高并发的场景下很有可能读取的消息还在page cache中，如果写入和读取都是同一个page cache会出现频繁征用，导致阻塞、导致执行失败(broker busy异常)，RocketMQ提供了一个transientStorePoolEnabled(启用瞬时存储池)机制，通过配置文件配置，打开之后会变成内存级别的读写分离。他会先把消息写到堆外内存中，然后由后台线程定时刷新到page cache中，这样page cache就没有高并发的写操作，也就没有page cache频繁征用问题。

##### 3.2broker写入消息，消息丢失问题

当同步刷盘时，理论上不会导致消息丢失，但是如果写入commit log时，broker挂掉，监听commit log的线程也会消失，这样consume queue也不会有丢失的消息，当broker启动的时候回去对比consume queue和commit log的差异，完成数据同步。异步刷盘时broker宕机不会影响os cache中的消息刷入commit log，但是服务器宕机会导致os cache中的消息丢失。如果开启了transientStorePoolEnabled会导致broker宕机或者我们自己重启的时候，堆外内存中的消息丢失。

没有解决办法，看tradeoff了。

##### 3.3.主从同步

从节点启动时会和主节点建立连接，然后主节点创建HAConnection组件，建立连接之后从节点会创建两个线程，HAClient请求发送组件和HAClient请求响应组件，通过请求发送线程发送同步数据请求，传过去一个max offset，表示当前节点的topic消息的最大偏移量，然后主节点把大于这个offset的消息全部返回给从节点，交给请求响应线程刷盘：
![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzphqmd0a3j21ku0u0q66.jpg)

pull模式：RocketMQ在4.5之前使用的是pull模式，他要求从节点主动发送同步消息请求，这个模式要想保证消息0丢失需要主节点把消息写到磁盘里，并且等到从节点拉取消息的请求中携带的max offset比当前消息大才行，这就会导致写入的吞吐量降低几个数量级，估计最快也要几百ms。

push模式：就是主节点主动推送消息到从节点，当要求消息0丢失的时候反而是push模式要快一点。但是主从同步还设计到了消息的commited的状态问题。

##### 3.4 RocketMQ4.5版本之后的写入流程

4.5之后通过DLedger实现的raft协议写入消息，然后通过DLedger的异步复制实现主从同步消息，然后同步等待从节点返回结果，其实就是push模式。这样就有个问题，就是当只有leader写成功，这个时候他还在等follower的写成功结果时，这条消息是不能被消费到的，还有一个就是改成DLedger之后消息存储格式发生了变化，他分成了header和body，body里放的就是原来commitLog的数据，然后consumeQueue里的偏移量变成了body的起始偏移量。
