---
title: 5.常见问题
tags:
  - RocketMQ
categories: 中间件
copyright: true
---

### 消息丢失

0丢失方案：发送端发送事务消息：half消息加commit or rollback方式，broker同步刷盘加主从同步，消费端确保一条线程消费成功后提交偏移量；

### 消息重复消费问题

消费端重复消费的场景：首先我们拉取到的消息可能有很多条，这一批消息如果有一条失败就要全部返回RECONSUME_LATER，在拉取到这些消息后就可能导致之前成功消费的又处理一遍；然后提交偏移量在broker那里是先写到内存在异步刷盘，这也会导致偏移量不准，还有一种情况是broker主节点宕机，从节点的consumer group偏移量信息不是最新的，也会导致消息重复消费。

解决方案是使用redis或者zk的分布式锁，这个要基于业务逻辑来实现，或者基于redis/数据库的唯一索引的幂等检查，消费成功之后插入一条数据，消费之前判断是否有这条数据，这样也要根据msgId进行加锁；

### 消息乱序

由于rocketMQ将消息存储到多个messageQueue中，很有可能数据库中一条数据的操作被放在了不同的messageQueue里，消费时可能会发生乱序的问题，所以在发送消息的时候就要保证有序的数据发到同一个messageQueue中。如果想要保证消息有序在消费的时候如果失败了也不可以进重试队列了，重试过来的消息和乱序消费时没区别的，只能返回SUSPEND_CURRENT_QUEUE_A_MOMENT暂停或者成功状态然后记录，根据具体业务处理。

生产者代码：

```java
// 根据订单id，将同一个订单发送到同一个messageQueue中
// 异步send方法的四个参数：消息实体；messageQueue选择器；选择器参数o；回调函数；
Long orderId = 0L;
producer.send(message, (list, message1, o) -> {
    Long orderId1 = (Long) o;
    // 根据队列取余
    Long index = orderId1 % list.size();
    return list.get(index.intValue());
}, orderId, new SendCallback() {
    @Override
    public void onSuccess(SendResult sendResult) {
        log.info("发送消息结果:{}", sendResult);
    }

    @Override
    public void onException(Throwable throwable) {
        throwable.printStackTrace();
        log.error("发送失败");
    }
});
```

消费者代码：

```java
// 注册MessageListenerOrderly监听，使用单线程消费，保证消息顺序消费
consumer.registerMessageListener((MessageListenerOrderly) (list, consumeOrderlyContext) -> {
    consumeOrderlyContext.setAutoCommit(true);
    try{
        for(MessageExt messageExt : list){
            // 处理消息
        }
        return ConsumeOrderlyStatus.SUCCESS;
    }catch (Exception e){
        return ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;
    }
});
```

### 海量数据发送

比如说千万用户的推送任务，
