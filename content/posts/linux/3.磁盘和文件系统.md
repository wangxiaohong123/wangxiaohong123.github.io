---
title: linux-3.磁盘和文件系统
tags:
  - linux
categories: 基础
copyright: true
---

磁盘的物理组成：

*   原型碟片：记录数据。
*   机械手臂：包括手臂和磁头(擦写碟片上的数据)。
*   主轴马达：可以转动碟片。
*   扇区：最小的物理存储单元，有512B和4k两种格式。
*   柱面：扇区组成的一圈。早起分区以柱面为单位，现在使用扇区。
*   磁盘分区表：一种是限制比较多的MBR(Master boot record)，一种是比较新的GPT，MBR中第一个扇区最重要，里面放的主引导记录(MBR，446B)+分区表(64B)，目前最新的是GPT分区表。

磁盘文件名：

*   物理磁盘的文件名一般都叫/dev/sd[a-p]\[1-128\]
*   虚拟磁盘的文件名一般是/dev/vd[a-d]\[1-128\]
*   如果是磁盘阵列的话一般是/dev/md[0-128]
*   LVM一般是/dev/VGNAME/LVNAME这种

分区之后一般都需要格式化一下，因为每个系统使用的文件系统不一样，比如win98以前用FAT，win2000之后用NTFS，Linux正统文件系统是ext2，一些发行版的Linux使用其他文件系统，比如CentosOS7使用xfs文件系统。

### 文件系统

##### 文件系统特性

linux的文件系统可以分成6个区块的数据：

*   超级区块的数据：记录文件系统的整体信息，比如inode和数据区块的总量、使用量、剩余量、文件系统的格式和相关信息。
*   inode：记录文件信息，比如文件的属性(时间、属组)、权限、文件数据所在区。一个文件占用一个inode。每个inode是128B或者256B。
*   数据区块：实际记录文件内容，文件太大的时候会占用多个区块，并且一个区块只能写一个文件，如果有剩余空间就浪费了。
*   文件系统描述：描述每个区块群组的开始、结束区块，以及inode、超级区块等介于那个区块之间。
*   区块对照表：记录空的区块。
*   inode对照表：记录使用和未使用的inode号。

上面除了超级区块的5个组成一个区块群组(block group)，一个文件系统只有一个超级区块的数据，如果有多个也是这个的备份。

Linux在读取文件的时候先根据inode把数据所在的区块都读出来，而FAT格式的文件系统，比如U盘是没有inode的，他只是在数据区块中记录下一个数据区块的编号，所以没法一次读取，只能一个一个读，这样就会有个问题，磁盘转一圈可能没读完，需要转好几圈，所以这种系统可以经常清理磁盘碎片，让同一个数据区块挨的进点，方便读取。

可以使用**dumpe2fs [-bh] 设备文件名**查看超级区块信息，但是xfs是不支持这个命令的：

```bash
# 打印块设备属性，可以看到我的是ext4
blkid
# /dev/vda1: UUID="1114fe9e-2309-4580-b183-d778e6d97397" TYPE="ext4" 

# -b 列出保留为坏道的部分
# -h 只显示超级区块信息，不展示其他区段内容
dumpe2fs /dev/vda1

dumpe2fs 1.42.9 (28-Dec-2013)
# 文件系统名称
Filesystem volume name:   <none>
# 上一次挂载的目录位置
Last mounted on:          /
Filesystem UUID:          1114fe9e-2309-4580-b183-d778e6d97397
Filesystem magic number:  0xEF53
Filesystem revision #:    1 (dynamic)
# 文件系统特性
Filesystem featrues:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize
Filesystem flags:         signed_directory_hash 
# 默认挂载参数
Default mount options:    user_xattr acl
# 文件系统状态，如果是dirty就说明有被修改过的文件但是还在内存，没有刷到粗盘
Filesystem state:         clean
Errors behavior:          Continue
Filesystem OS type:       Linux
# inode总数
Inode count:              2621440
# 区块总数
Block count:              10484164
# 保留区块总数
Reserved block count:     471777
# 可用区块数量
Free blocks:              5941100
# 可用inode数量
Free inodes:              2484489
First block:              0
# 单个区块的大小
Block size:               4096
Fragment size:            4096
Reserved GDT blocks:      1021
Blocks per group:         32768
Fragments per group:      32768
Inodes per group:         8192
Inode blocks per group:   512
Flex block group size:    16
Filesystem created:       Thu Jul 11 10:52:00 2019
Last mount time:          Thu Mar 10 16:03:03 2022
Last write time:          Fri Mar 11 00:03:02 2022
Mount count:              6
Maximum mount count:      -1
Last checked:             Thu Jul 11 10:52:00 2019
Check interval:           0 (<none>)
Lifetime writes:          3907 MB
Reserved blocks uid:      0 (user root)
Reserved blocks gid:      0 (group root)
First inode:              11
# inode容量
Inode size:               256
Required extra isize:     28
Desired extra isize:      28
Journal inode:            8
First orphan inode:       1050033
Default directory hash:   half_md4
Directory Hash Seed:      0163c9aa-b271-4625-b08d-5a774c70359e
# 日志相关信息
Journal backup:           inode blocks
Journal featrues:         journal_incompat_revoke
日志区块总大小:             128M
Journal length:           32768
Journal sequence:         0x0380a708
Journal start:            14867

# 第一区块群组信息
Group 0: (Blocks 0-32767) [ITABLE_ZEROED]
  Checksum 0x0314, unused inodes 8175
  # 主要超级区块位置
  主 superblock at 0, Group descriptors at 1-3
  保留的GDT块位于 4-1024
  Block bitmap at 1025 (+1025), Inode bitmap at 1041 (+1041)
  Inode表位于 1057-1568 (+1057)
  14316 free blocks, 8177 free inodes, 2 directories, 8175个未使用的inodes
  # 那些区块可用
  可用块数: 11727-12287, 12301, 12318, 12336, 12352, 12374, 12390, 12409, 12426, 12440-12719, 13296-13708, 14304-17854, 18201-25833, 27287-28583, 30376-30604, 32424-32767
  可用inode数: 12, 14, 18-8192
  # 其他区块群组信息
Group 1: (Blocks 32768-65535) [INODE_UNINIT, ITABLE_ZEROED]
……
```

xfs系统相比ext2、ext3、ext4来说多了两个区，他的数据区(data section)可以理解成ext系列的所有区块，但是不包括ext3和ext4的日志，xfs的文件系统活动区(log section)就是用日志用来记录文件的变化，xfs的实时运行区(realtime section)是用来实时分配inode和区块的，这也是他和ext系列系统的最大区别。可以使用**xfs_info 挂载点/设备文件名**命令查看xfs文件系统信息。

### 磁盘

##### 1.磁盘的操作

###### 磁盘整体使用

df [-ahikHTm] 目录或者文件名，参数说明：

*   -a：列出所有的文件系统，包括系统特有的/proc等文件系统；
*   -k：以kBytes的容量显示各文件系统；
*   -m：以mBytes的容量显示各文件系统；
*   -h：以可读的gbytes、mbytes、kbytes等格式自行显示；
*   -H：以M=1000k替换M=1024k的进位方式；
*   -T：列出分区的文件系统名称；
*   -i：不用磁盘容量，以inode的数量来显示；

没有任何参数就是把系统内的所有文件系统全列出来：

```bash
df

文件系统(文件系统所在硬盘分区)   1K-块(说明下面的数字是kb)     已用       可用     已用%    挂载目录
devtmpfs                            16112916             0     16112916    0%      /dev
tmpfs                               16123372             0     16123372    0%    /dev/shm
tmpfs                               16123372           1168    16122204    1%      /run
tmpfs                               16123372             0     16123372    0%   /sys/fs/cgroup
/dev/vda1                           41147472         28956356  10287624    74%        /
tmpfs                               3224676              0     3224676     0%    /run/user/0
```

如果加上-T就可以看到文件系统的名称，常见的就是ext系列和xfs，但是大部分都是特殊系统，这些特殊系统一般都是在内存里的。所以他们的已用和已用百分比都是0，他们的容量也都很大，我觉得没啥意义。由于df显示的文件系统的整体信息，所以他是读取的超级区块的内容，运行非常快。

###### 查看文件系统的磁盘容量

du [-ahskm] 文件或目录名称，参数说明：

*   -a：列出所有的文件和目录容量，默认仅统计以目录为单位的文件总大小；
*   -h：以可读的格式显示；
*   -s：仅列出总量，不显示每个目录；
*   -k：以kb的格式显示；
*   -m：以mb的格式显示；

什么参数都不加就是列出所有目录的容量，包括子目录，我一般经常用**du -sh \***，有时候执行du命令时会出现【No such file or directory】的错误，那是因为这些文件或者目录是在内存中的，磁盘上当然找不到，比如/proc下面的所有东西都是基于内存的。

##### 连接

连接分为硬链接和软连接，符号连接就类似windows的快捷方式，他是创建一个新的文件或者目录，然后inode中记录了链接文件的地址，硬链接类似别名，在链接文件对应的inode中在添加一个文件名，一份数据，两个指向，他不会占用新的inode，同时他也更安全，删掉一个文件也不影响访问，但是硬链接只支持同一个文件系统下的文件，目录由于维护起来非常麻烦，所以不支持。

```bash
# s是符号链接，没有s就是硬链接
# f表示如果目标文件已经存在就直接删除在创建文件建立连接
ln [-sf] 源文件 目标文件
```

需要注意的是，新创建目录比如/tmp/test的时候会自动生成两个目录/tmp/test/.和/tmp/test/..，/tmp/test/.指向/tmp/test，而/tmp/test/..指向/tmp/，所以刚创建的目录的链接是2，/tmp/test和/tmp/test/.，创建目录的父目录的链接数会加1。

##### 2.增加磁盘

增加磁盘的步骤：划分磁盘，建立可用磁盘分区-->对硬盘格式化成系统可用的文件系统-->检验文件系统-->创建挂载点，挂载磁盘。

还有一些细节比如硬盘需要多大、要不要日志、怎么划分inode和数据区等等需要根据场景考虑。

###### 1）观察分区状态

使用**lsblk [-dfimpt] [device]**列出所有磁盘列表：

```bash
# -d：不列出磁盘的分区数据
# -f：列出磁盘的文件系统
# -i：使用ASCII码字符输出
# -m：输出设备在/dev下面的权限
# -p：列出完整文件名
# -t：列出磁盘的详细信息，比如阵列机制、预读写什么的

lsblk

NAME        MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
/dev/vda    253:0    0  40G  0 disk 
└─/dev/vda1 253:1    0  40G  0 part /
# NAME：文件名
# MAJ:MIN：主要和次要设备代码
# RM：是否能卸载
# SIZE：容量
# RO：是否为只读设备
# TYPE：disk(磁盘)、partition(分区)、rom(只读存储器)
# MOUNTPOINT：挂载点
```

如果要看UUID，我还是习惯使用**blkid**列出设备的UUID，他返回的列表还带着文件系统。

使用**parted device print**查看分区信息：

```bash
parted /dev/vda print

Model: Virtio Block Device (virtblk) 				# 这应该是厂商
Disk /dev/vda1: 42.9GB								# 总容量
Sector size (logical/physical): 512B/512B			# 物理扇出大小
Partition Table: loop								# 分区表格式(MBR/GPT)，loop表示没有分区，整块磁盘是一个分区
Disk Flags: 
# 分区数据
Number  Start  End     Size    File system  标志
 1      0.00B  42.9GB  42.9GB  ext4
```

###### 2）磁盘分区

磁盘分区主要有MBR和GPT两种格式，parted命令都支持，MBR也可以使用fdisk命令，GPT也可以使用gdisk命令。

直接gdisk/fdisk 设备名就可以进行按提示分区了，如果不知道有什么命令就输入问号或者m。更新完之后分区不会马上更新，需要重启或者执行partprobe命令。

剩下的省略，在私房菜7.3。

###### 3）文件系统挂载和卸载

首先一个文件系统不能挂载到多个目录，同一个目录下也不能挂载多个文件系统，并且被当做挂载点的目录应该是空的，因为目录挂载了一个文件系统之后，目录里原来的内容会被隐藏，直到卸载挂载的文件系统。

```bash
# 不加参数的mount只是列出目前的挂载信息
mount
# 挂载文件系统
mount LABEL/UUI/设备名='' 挂载点

-a：根据配置文件/etc/fstab把所有没挂载的磁盘都挂载上来
-l：mount -l表示列出当前的挂载信息，在加一列label
-t：指定预挂载类型，linux支持的有xfs、ext3、ext4、reiserfs、vfat、iso9660、nfs、cifs、smbfs，后面3个是网络文件系统，CentOS不需要加这个参数，他会自动根据超级区块加自己的驱动测试挂载，找到合适的文件系统
-n：默认情况下系统会把挂载的情况写到/etc/mtab中，-n表示不写入
-o：这个可以配置挂载的额外参数：
	async，sync：指定挂载的系统是同步写入还是异步写入
	atime，noatime：是否修改文件的读取时间，节约性能可以设置成noatime
	ro，rw：挂载的文件系统是只读还是读写
	auto，noauto：这个文件系统是否允许执行mount -a时被自动挂载
	dev，nodev：文件系统中是否允许建立设备文件
	suid，nosuid：是否允许文件系统中包含suid/sgid格式的文件
	exec，noexec：是否允许文件系统中有可执行的二进制文件
	user，nouser：是否允许文件系统让任何人执行mount命令，nouser就是只有root可以
	remount：重新挂载，更新参数或者系统出错时候使用
	默认的参数：rw，suid，dev，exec，auto，nouser，async
```

卸载：

```bash
umount [-fn] 设备名或者挂载点

-f：强制卸载
-l：比-f还强的强制卸载
-n：不更新/etc/mtab的情况下卸载
```

