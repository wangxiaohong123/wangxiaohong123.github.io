---
title: linux-5.bash
tags:
  - linux
categories: 基础
copyright: true
---

##### bash是shell的一种

操作系统就是一组软件，通过这组软件来管理硬件和监控，如果这组软件能被用户随意使用，那么操作系统就很容易崩溃，但是又不能不让用户使用操作系统，所以就有了操作系统之上的一层程序，通过这层程序指挥内核，然后内核再去操作硬件。现在关系变成了应用程序-->内核-->硬件，这样一层一层的关系，我理解的就是硬件像蛋黄，内核是蛋清，应用程序是蛋壳，所以叫shell(壳程序)。壳程序的功能是提供用户操作系统的一个界面。

也就是说只要能操作内核程序的软件都叫壳程序，比如图形界面的软件(视频播放器这种)，比如bash，我们可以在bash中运行操作内核的命令，比如man、chmod等等。

##### shell有很多个

最开始的时候UNIX有很多的发展者，就会对应多个shell的版本，比如Bourne shell(sh)，Sun里的C shell，商用的K shell，TCSH(增强版C shell)。Linux使用的是Bouren Again Shell(bash)，是Bourne shell的增强版本，在/etc/shells里可以看到能够使用的shell：

```bash
/bin/sh # 等于/usr/bin/sh
/bin/bash # 等于/usr/bin/bash
/usr/bin/sh
/usr/bin/bash
```

我的虚拟机里有两种shell，sh和bash，而在/etc/passwd文件中记录的账号信息外，最后就有一个字段标记这个账号登录后使用的shell类型，差不多长这样：

```bash
root:x:0:0:root:/root:/bin/bash
# /sbin/nologin是一个奇怪的shell，他的目的是不想让用户以其他服务登录主机
bin:x:1:1:bin:/bin:/sbin/nologin
```

##### 查询是否是bash shell的内置命令

使用type [-tpa] name来查询name是否是bash内置的命令，没有参数时只会显示是外部命令还是内部命令，参数说明：

*   -t：把name以以下字眼显示意义：file(外部命令)，alias(别名设置的命令)，builtin(bash内置命令)。
*   -p：如果name是外部命令，显示完整文件名。
*   -a：把PATH变量定义的路径中，所有包含name的命令都列出来，包括alias。

##### 1.变量的使用和设置

查看变量使用echo，但是变量前要加$。$更多的用法使用man echo查看，赋值变量直接使用等号，例如：

```bash
# echo ${myname}也是输出变量
# 如果没有这个变量在bash中会输出一个空
echo $myname

# 给变量赋值后在打印变量就可以看到变量的值了
myname=xiaohong
echo ${myname}
```

不同的shell处理不存的变量也不同，bash中返回空，但是有的shell中会抛出异常，同时变量的设置也要遵循规则：

*   变量和变量内容只能用1个等号连接
*   等号两边不能有空格，如果有空格需要用双引号或者单引号把变量内容包起来，如果使用双引号抱起来，双引号里的特殊字符还是保持原来的特性，比如var="lang is \$LANG"，echo var的时候会显示lang is zh_CN.UTF-8，单引号中的特殊字符没有特性
*   变量名只能是英文字母或者数字，而且不能以数字开头
*   变量中有特殊字符可以使用\来转移，比如enter、$、空格等
*   如果在赋值的时候需要其他命令的结果可以使用\$(命令)，比如：version=\$(uname -r)，这个时候echo \$version得到的是3.10.0-957.21.3.el7.x86_64
*   如果是变量扩增使用"\$变量"累加内容或者\${变量}累加内容，比如PATH="\$PATH":/home/bin或者PATH=\${PATH}:/home/bin
*   遍历如果需要在其他子程序执行，需要使用export让变量变成环境变量
*   一般大写的变量是系统默认变量，自定义的变量可以使用驼峰，方便判断
*   取消变量使用**unset 变量名称**

###### 环境变量

使用env查看环境变量：

```bash
# 直接env，没有参数
env

# 主机名
HOSTNAME=iZ8vb9pqllwonfla2hr371Z
# 终端的环境类型
TERM=xterm
# 目前环境使用的shell是哪个程序
SHELL=/bin/bash
# 历史命令保存条数
HISTSIZE=1000
# 远程连接客户端的ip
SSH_CLIENT=123.123.45.41 1943 22
SSH_TTY=/dev/pts/0
# 当前用户
USER=root
# 一些颜色信息
LS_COLORS=……
# 使用者的mailbox位置
MAIL=/var/spool/mail/root
# 执行文件查找的路径，使用冒号分割
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
# 当前工作目录
PWD=/root
# 语系数据
LANG=zh_CN.UTF-8
HISTCONTROL=ignoredups
SHLVL=1
# 当前用户的根目录
HOME=/root
# 登录的账号名
LOGNAME=root
# 连接信息 123.123.45.41端口是1943连接172.30.60.105端口是22
SSH_CONNECTION=123.123.45.41 1943 172.30.60.105 22
LESSOPEN=||/usr/bin/lesspipe.sh %s
XDG_RUNTIME_DIR=/run/user/0
# 上一次使用命令的最后一个参数
_=/usr/bin/env
```

还要一些没列出来的，比如RANDOM，echo \$RANDOM会输出0\~32767的随机数，比如声明一个0\~9的随机数：

```bash
declare -i number=$RANDOM*10/32768
echo $number
```

set查看所有变量：

bash中除了环境变量还有和bash操作界面有关的变量，以及用户自定义的变量，使用set都可以显示出来：

```bash
set
# 执行完会显示一堆东西，比如$、?、PS1等等，这些都是系统变量
# 可以打印echo $?试一下
```

使用export声明环境变量：

子进程只会继承父进程的环境变量，所以自定义的变量不能在子进程中使用，这个时候就要使用**export 变量名来共享给其他进程，如果export后面没有变量名也可以列出环境变量。

##### 整数和数组类型的变量

正常使用等号赋值的变量都是字符串的，比如sum=100+200，echo的时候不会显示300，而是显示"100+200"这个字符串，可以使用declare命令：

```bash
# 如果declare后面没有任何参数效果和env一样，列出所有的环境变量
declare [-aixr] variable
# -a：把variable定义成数组类型
# -i：把variable定义成整数类型
# -x：把variable变成环境变量
# -r：把variable设置成只读，不能修改变量类型，也不能unset，需要重新登录才能恢复，我猜+r就是去掉只读属性
```

数组变量的赋值就是**arr[index]=content**，比如arr[0]="small ming"。

如果想要读取键盘的输入要使用read命令：

```bash
read [-pt] variable

-p：提示信息
-t：最长等待时间(秒)

# 把输入的字符串赋值给named变量，提示please keyin your name，最多等待30s
read -p "please keyin your name" -t 30 named
```

##### 2.命令别名和历史

设置命令别名使用alias:

```bash
alias lm='ls -al | more'
# ls -al | more是分页显示所有文件，包括隐藏的
# 使用alias之后可以直接输入lm达到ls -al | more的效果

# 如果alias后面没有参数就是列出所有别名
alias
```

取消别名使用unalias：

```bash
# 删除lm这个别名
unalias lm
```

**如果别名和其他命令冲突的时候会执行那个？**这就要说一下命令查找顺序：

*   如果是路径就根据路径查找，比如/bin/ls或者./ls
*   只有命令先根据别名查找
*   别名里没有就去bash的内置命令中查找
*   不是别名也不是bash内置的就根据$PATH的顺序找到第一个

比如执行/bin/ls是没有颜色的，执行ls是有颜色的，因为ls是一个别名：**alias ls='ls --color=auto'**。

查看历史命令使用history：

```bash
# 查看最后n条历史命令
history n

# 清空shell中的所有history
history -c

history [-raw] histfiles
# -r：把histfiles内容读取到history记录中
# -a：把新增的历史写入到histfiles文件中，如果文件不存在就写到~/.bash_history文件里
# -w：把所有的history写到histfiles文件里
```

正常情况下每次注销的时候才会把使用期间的命令写到~/.bash_history文件中，这个文件被攻击时肯定要被黑客查看的。

执行历史命令：

```bash
# 执行倒数第n条命令
!n
# 从后往前找到第一个command开头的命令并执行
!command
# 执行上一个命令
!!
```

##### 3.bash操作环境

###### 1）登录信息

登录信息就是在登录成功后打印出来的类似下面这种信息：

```bash
# /etc/issue文件内容
Last login: Tue Jun 28 15:12:43 2022 from 123.123.45.41
# /etc/motd文件内容
Welcome to Alibaba Cloud Elastic Compute Service !
```

打印的=内容配置在/etc/issue文件中，可以使用man issue查看可以设置那些东西。

需要注意的是如果是telnet远程登录需要修改/etc/issue.net文件。下面的Welcome……是/etc/motd文件的内容，比如我们要告诉登录着系统会在某个时间维护就可以修改这个文件。

###### 2）配置文件

上面说得别名、变量的设置在注销后会失效，如果想保留设置需要修改配置文件，在login shell和non login shell中读取的配置文件是不同的，login shell就是获取bash时需要完整的流程，比如从tty1切换到tty2需要重新登录，non login shell就是不需要重新登录。

一般login shell会在登录之后读取两个配置文件：

*   /etc/profile：这个是系统的整体配置，这个配置文件可以利用用户ID决定很多重要的变量数据，也是只有login shell会读取的配置文件，主要有：
    *   PATH：根据UID决定要不要含有sbin的系统命令目录。
    *   MAIL：根据账号设置好用户的mailbox到/var/spool/mail/账号名。
    *   USER：根据账号设置这个变量。
    *   HOATNAME：根据主机hostname设置这个变量。
    *   HISTSIZE：设置历史命令记录数。
    *   umask：root默认是022，其他用户时002等。
    
    /etc/profile还会调用其他外部的配置文件，按照顺序读取：
    
    *   /etc/profile.d/*.sh：只要用户有可读权限就会读取profile.d目录下的所有sh文件，这里面的sh文件规范了bash的颜色、语系、内置的别名文件，如果想创建共享的别名就要在这个目录下增加sh文件
    *   /etc/local.conf：由/etc/profile.d/lang.sh调用，语系的重要配置文件
    *   /usr/share/bash-completion/completions/*：由/etc/profile.d/bash_completion.sh加载，这个命令补齐的配置
    
*	~/.bash_profile：这个也是只有login shell才会读取，除了这个还会读取\~/.bash_login和\~/.profile，优先级是逐渐降低的，并且只会读取一个，也就是说\~/.bash_profile不存在才会去读取\~/.bash_login，这个文件最终会读取\~/.bashrc这个配置文件。

在修改完配置文件时是不生效的，因为只有每次登录才会读取，这个时候需要使用**source/应为字母的点 配置文件名**重新读取配置文件的内容，比如下面的两个命令都可以刷新配置：

```bash
source ~/.bashrc
. ~/.bashrc
```

Non login shell只会读取\~/.bashrc。\~/.bashrc文件是red Hat特有的，其他的发行版可能叫不同的文件名。

###### 3）通配符和特殊符号

| 通配符 | 意义                                                         |
| ------ | ------------------------------------------------------------ |
| *      | 匹配0到无穷多个任意字符，ll -d /etc/cron*意思是列出/etc下面的以cron开头的文件 |
| ?      | 匹配任意一个字符，ll -d /etc/?????意思是/etc下面长度是5的文件名 |
| []     | 匹配人一个匹配中括号中字符，ll -d /etc/[c]*意思是/etc下面包以字母c开头的文件 |
| [-]    | [0-9]表示0到9之间的任意数字，ll -d /etc/\*[0-9]\*表示/etc下包含数字的文件 |
| [\^]   | 和[]意思相反，ll -d /etc/[\^a-z]*意思是/etc下不是字母开头的文件 |

| 特殊符号 | 内容                                                         |
| -------- | ------------------------------------------------------------ |
| #        | 注释符号                                                     |
| \\       | 转义符                                                       |
| \|       | 管道，分割两个管道命令                                       |
| ;        | 连续命令分割                                                 |
| ~        | 用户的家目录                                                 |
| $        | 使用变量的前导符                                             |
| &        | 将命令变成后台任务                                           |
| !        | 逻辑运算非                                                   |
| /        | 目录符号，路径分隔符                                         |
| >、>>    | 数据流重定向，输出定向，分别是【替换】、【累加】             |
| <、<<    | 数据流重定向，输入定向，分别是【把文件内容输入到指定设备】、【结束输入的字符】 |
| ''       | 单引号，不具备变量替换功能                                   |
| ""       | 具备变量替换功能                                             |
| ``       | 标记可先执行的命令，等同于$()                                |
| ()       | 中间是子shell的开始和结束                                    |
| {}       | 命令区块                                                     |

##### 4.数据流重定向

数据流分成标准输入，标准输出和标准错误输出，当执行命令发生错误时是标准错误输出。

###### 1）输出重定向

就是把数据流重定向到其他设备，比如打印机或者文件中，1>或者>就是把源文件删掉重新写，1>>或者>>就是在源文件的基础上追加，其中1表示标准输出(stdout)，不写的话默认也是1，2表示标准错误输出(stderr)，例如把stdout和stderr输出到不同文件：

```bash
find /home -name .bashrc > list_right 2> list_error
```

如果不想要数据流的话就把输出指向垃圾桶黑洞(/dev/null)，他可以吃掉任何导向这个设备的信息，如果要将stdout和stderr写到同一个设备就使用&>或者2>&1，例如：

```bash
find /home -name .bashrc &> list
find /home -name .bashrc > list 2>&1
```

###### 2）输入重定向

用文件内容代替键盘输入：

```bash
# 这样catfile里的内容就和.bashrc的内容完全一样了
cat > catfile < ~/.bashrc
```

<<表示结束输入的字符，比如要定义输入eof时就结束：

```bash
cat > catfile << "eof"
> this is a test
> ok now stop
> eof
# 输入完eof之后会直接退出输入界面，不需要按[ctrl + d]
```

##### 5.多条命令连续执行

如果多条命令没有相关性，就是用;分割，比如执行一次sync后关机:

```bash
sync; shutdown -h now
```

但是如果要依赖前一个命令的返回结果就需要使用&&或者||，命令在执行后返回$?的值，这个值如果是0就说明执行成功了，&&和||就是根据这个返回值来判断是否要继续执行命令的

| cmd1 && cmd2   | 如果cmd1执行完毕且正确($?=0)就执行cmd2，错误就结束 |
| -------------- | -------------------------------------------------- |
| cmd1 \|\| cmd2 | 如果cmd1执行完毕且正确($?=0)就结束，错误就执行cmd2 |

例如:

```bash
# 先检查/tmp/abc目录是否存在，如果存在就创建/tmp/abc/hehe
ls /tmp/abc && touch /tmp/abc/hehe
```

##### 6.管道命令

管道命令使用【|】分割，他和多命令不一样，管道命令是处理上一个命令的结果，不是执行结果，是命令返回结果，管道命令必须要符合两个要求：

*   只处理标准输出，忽略标准错误输出
*   必须要接受前一个命令的数据成为标准输入继续处理

比如ls、cp这种就不能到管道命令。

###### 1）选取命令

选取命令有两个，一个cut，一个grep，不管那个都是针对行来操作的。

cut：

```bash
# -d通常要和-f一起使用，-d的意思是按照特殊字符来切分
# -f的意思是取低级段
cut -d '分割字符' -f fields

# 取出PATH变量中的第5个路径
echo ${PATH} | cut -d ':' -f 5
# 取出PATH变量中的第3和第5个路径
echo ${PATH} | cut -d ':' -f 3,5

# -c表示取出固定字符区间
cut -c 字符区间

# 把export输出的信息的每行的前11个字符去掉
# 每行都会去！，如果是12-20意思就是每行只显示第12到20个字符
export | cut -c 12-
```

grep是分析一行的信息是否符合要求：

```bash
grep [-acinvABE] --color=auto] '查找的字符串' filename
# -a：把2进制文件以文本文件的方式查找
# -c：计算找到匹配字符串的次数
# -i：忽略大小写
# -n：输出行号
# -v：反向选择，找到不匹配的那些行
# -A：after的意思，后面接数字(比如-A3)，除了改行外，后面的n行也列出来
# -B：before的意思，同A
# -E：使用高级的正则表达式，或者egrep效果等同于grep -E，他俩是别名关系
# --color=auto：关键字加颜色

# 把last中出现root的行显示出来
last | grep -i 'root'
```

###### 2）排序命令

sort：

```bash
sort [-fbMnrtuk] [file or stdin]
# -f：忽略大小写
# -b：忽略最前面的空格
# -M：以月份的名字来排序
# -n：使用纯数字排序(默认是文字形式排序)
# -r：倒排
# -t：分隔符，默认是tab分割
# -u：就是uniq，相同的数据去重
# -k：以什么区间来排序(默认的话就是每行第一个字符开始排)

# 查看/etc/passwd内容并排序
cat /etc/passwd | sort
# 先把每行按照:拆分，然后按照第3列排序
cat /etc/passwd | sort -t ':' -k 3
```

uniq：

```bash
uniq [-ic]
# -i：忽略大小写
# -c：进行计数
```

wc：

```bash
wc [-lwm]
# -l：仅列出行
# -w：仅列出多少字
# -m：多少字符

# 列出/etc/man_db.conf文件有多少行、字和字符
cat /etc/man_db.conf | wc
```

