---
title: 2.NIO-channel
tags:
  - 网络
categories: NIO
copyright: true
---

在buffer读取或者写入数据到磁盘或者socket的时候是要先写入channel的，数据管道的角色。

##### 写数据

###### 1.使用buffer加channel往磁盘顺序写数据demo

顺序写就是一直往后追加：

```java
// 构造一个传统的文件输出流
FileOutputStream out = new FileOutputStream("/Users/xiaohong/IdeaProjects/io_temp/hello.txt");
// 通过文件输出流获取fileChannel，以nio的方式写文件
// getChannel的时候使用的Synchronized加锁，可以保证多线程操作的时候是同一个FileChannel时是线程安全的
// 新创建的channel的position是0，多个线程操作同一个channel时需要注意position的变化
FileChannel channel = out.getChannel();

ByteBuffer buffer = ByteBuffer.wrap("hello word".getBytes());
// 顺序写
channel.write(buffer);
// position变成0，在写一遍buffer中的内容
buffer.rewind();
channel.write(buffer);
// 强迫这个fileChannel对文件的更新强制刷到磁盘，都则会在OS cache里停留一段时间
// true就是文件元数据的修改也强制刷到磁盘上
channel.force(true);

channel.close();
out.close();
// 写完后文件里的内容：hello worldhello world
```

###### 2.使用buffer加channel往磁盘随机写数据demo

随机写就是从指定位置开始写，会覆盖原有内容：

```java
FileOutputStream out = new FileOutputStream("/Users/xiaohong/tmp/hello.txt");
final FileChannel channel = out.getChannel();

ByteBuffer buffer = ByteBuffer.wrap("hello world".getBytes());
channel.write(buffer);
buffer.rewind();
// 调整channel的position
channel.position(5);
channel.write(buffer);

channel.close();
out.close();
// 写完后文件里的内容：hellohello world
```

##### 读数据

###### 1.使用channel读文件

```java
public static void main(String[] args) throws IOException {
    // 文件中的内容是hellohello world
    FileInputStream in = new FileInputStream("/Users/xiaohong/tmp/hello.txt");

    // 通过输出流获取nio的channel，以nio的形式读写
    final FileChannel channel = in.getChannel();

    ByteBuffer buffer = ByteBuffer.allocate(16);
    // 把文件的内容读到缓冲区
    channel.read(buffer);
    // 此时应该把position复位，否则会出现BufferUnderflowException
    buffer.flip();
    byte[] data = new byte[16];
    buffer.get(data);
    System.out.println(new String(data));

    channel.close();
    in.close();
}
```

###### 2.文件锁方式读取文件

虽然在一个jvm内可以保证多个线程使用同一个channel时线程安全的，但是多个jvm时就不能保证线程安全，这个时候可以用文件锁，

```java
RandomAccessFile in = new RandomAccessFile("/Users/xiaohong/tmp/hello.txt", "rw");
FileChannel channel = in.getChannel();

// 如果出现锁互斥，在lock这里会卡住，等待别人释放锁
// 三个参数，起始位置，结束位置，true表示是共享锁
// 如果文件存在共享锁，此时谁都不能写入数据
// 如果输入流是FileInputStream，当文件有共享锁时，增加独占锁会报错
// 如果输入流是RandomAccessFile，当文件有共享锁时，增加独占锁会阻塞
FileLock lock = channel.lock(0, Integer.MAX_VALUE, true);

ByteBuffer buffer = ByteBuffer.allocate(16);
channel.read(buffer);

buffer.flip();
byte[] data = new byte[16];
buffer.get(data);
System.out.println(new String(data));

lock.release();
channel.close();
in.close();
```

使用**FileLock lock = channel.lock(0, Integer.MAX_VALUE, true);和lock.release()**来加文件锁和释放文件锁，true就表示共享锁，false是独占锁。如果要加独占锁的话需要使用RandomAccessFile操作文件，使用输入流会报错。加共享锁之后谁都不能写数据，加了独占锁之后只有自己能读写数据。加锁的情况适合一个操作系统多个虚拟机对文件操作的情况。

![](https://tva1.sinaimg.cn/large/008vxvgGly1h71cpc2jxbj31x60p0go0.jpg)

