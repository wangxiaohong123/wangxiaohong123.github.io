---
title: 4.netty-client建立连接源码
tags:
  - 网络
categories: netty
copyright: true
---

建立连接的源码入口在Bootstrap的doResolveAndConnet()方法里：

```java
private ChannelFutrue doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) {
    // 这一步和服务端启动一样
    // 初始化一个channel注册到selector上去
    final ChannelFutrue regFutrue = initAndRegister();
    final Channel channel = regFutrue.channel();

    if (regFutrue.isDone()) {
        if (!regFutrue.isSuccess()) {
            return regFutrue;
        }
        // 建立连接方法
        return doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());
    } else {
        // 以防万一这里会做一步检查
        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
        regFutrue.addListener(new ChannelFutrueListener() {
            @Override
            public void operationComplete(ChannelFutrue futrue) throws Exception {
                Throwable cause = futrue.cause();
                if (cause != null) {
                    promise.setFailure(cause);
                } else {
                    // Registration was successful, so set the correct executor to use.
                    // See https://github.com/netty/netty/issues/2586
                    promise.registered();
                    doResolveAndConnect0(channel, remoteAddress, localAddress, promise);
                }
            }
        });
        return promise;
    }
}
```

```java
/**
 * Bootstrap中的建立连接方法
 */
private ChannelFutrue doResolveAndConnect0(final Channel channel, SocketAddress remoteAddress,
                                           final SocketAddress localAddress, final ChannelPromise promise) {
    try {
        final EventLoop eventLoop = channel.eventLoop();
        AddressResolver<SocketAddress> resolver;
        try {
            resolver = this.resolver.getResolver(eventLoop);
        } catch (Throwable cause) {
            channel.close();
            return promise.setFailure(cause);
        }

        // 如果已经resolve了或者remoteAddress不是一个远程地址就会尝试执行doConnect()方法
        // 这步感觉就是解析了一下server的地址,封装成InetSocketAddress对象
        if (!resolver.isSupported(remoteAddress) || resolver.isResolved(remoteAddress)) {
            doConnect(remoteAddress, localAddress, promise);
            return promise;
        }

        final Futrue<SocketAddress> resolveFutrue = resolver.resolve(remoteAddress);

        if (resolveFutrue.isDone()) {
            final Throwable resolveFailureCause = resolveFutrue.cause();

            if (resolveFailureCause != null) {
                // Failed to resolve immediately
                channel.close();
                promise.setFailure(resolveFailureCause);
            } else {
                // 真正的建立连接
                doConnect(resolveFutrue.getNow(), localAddress, promise);
            }
            return promise;
        }

        // Wait until the name resolution is finished.
        resolveFutrue.addListener(new FutrueListener<SocketAddress>() {
            @Override
            public void operationComplete(Futrue<SocketAddress> futrue) throws Exception {
                if (futrue.cause() != null) {
                    channel.close();
                    promise.setFailure(futrue.cause());
                } else {
                    doConnect(futrue.getNow(), localAddress, promise);
                }
            }
        });
    } catch (Throwable cause) {
        promise.tryFailure(cause);
    }
    return promise;
}
```

最后建立连接的代码会走到NioSocketChannel的doConnect()方法里：

```java
protected boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception {
    if (localAddress != null) {
        doBind0(localAddress);
    }

    boolean success = false;
    try {
        // 这里对应的代码就是nio的channel.connect(new InetSocketAddress("localhost", 9000));
        boolean connected = SocketUtils.connect(javaChannel(), remoteAddress);
        if (!connected) {
            // 建立完连接之后设置关注事件是SelectionKey.OP_CONNECT
            // 等待服务端建立完连接做相应处理
            selectionKey().interestOps(SelectionKey.OP_CONNECT);
        }
        success = true;
        return connected;
    } finally {
        if (!success) {
            doClose();
        }
    }
}
```

