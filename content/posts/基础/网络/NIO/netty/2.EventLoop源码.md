---
title: 2.netty-服务端启动源码
tags:
  - 网络
categories: netty
copyright: true
---

### 一、创建EventLoop源码

通过`EventLoopGroup parentGroup = new NioEventLoopGroup(); `创建EventLoopGroup，EventLoopGroup是一个接口，他继承了EventExecutorGroup，而EventExecutorGroup又继承了java的ScheduledExecutorService，所以EventLoopGroup就是一个定时调度线程池。而NioEventLoopGroup继承了MultithreadEventLoopGroup，这个MultithreadEventLoopGroup就是EventLoopGroup的一个实现类：

![](https://tva1.sinaimg.cn/large/008vxvgGly1h728x52mclj30xg0nawgx.jpg)

调用无参的NioEventLoopGroup构造方法时会一步一步把**线程数、线程池、selectorProvider(这里会返回默认的线程工厂和selectorProvider)、selectStrategyFactory、拒绝策略**给赋上默认值，然后调用父类的构造方法：

```java
// 此时nThreads=0，executor=null，selectorProvider=SelectorProvider.provider()
// selectStrategyFactory=DefaultSelectStrategyFactory.INSTANCE
super(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());
```

进到父类的构造方法首先会判断如果线程数是0，就设置成DEFAULT_EVENT_LOOP_THREADS，DEFAULT_EVENT_LOOP_THREADS的计算方法：

```java
// 获取io.netty.eventLoopThreads配置，如果没有就取cpu核数 * 2
// 然后在和1取最大值
DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(
    "io.netty.eventLoopThreads", NettyRuntime.availableProcessors() * 2));
```

然后继续调用MultithreadEventLoopGroup的父类MultithreadEventExecutorGroup的构造方法，入口就在这里：

```java
protected MultithreadEventExecutorGroup(int nThreads, Executor executor,
                                        EventExecutorChooserFactory chooserFactory, Object... args) {
    // 检查线程数是否大于0
    checkPositive(nThreads, "nThreads");

    if (executor == null) {
        // 如果executor是空，创建一个新的executor
        // ThreadPerTaskExecutor他其实就是Executor，只不过创建线程的时候使用的传进去的newDefaultThreadFactory()
        executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());
    }

    // 根据线程数创建一个EventExecutor数组
    children = new EventExecutor[nThreads];

    for (int i = 0; i < nThreads; i ++) {
        boolean success = false;
        try {
            // 这个方法会被NioEventLoopGroup实现
            children[i] = newChild(executor, args);
            success = true;
        } catch (Exception e) {
            // TODO: Think about if this is a good exception type
            throw new IllegalStateException("failed to create a child event loop", e);
        } finally {
            if (!success) {
                // 有一个失败的就关闭之前创建的EventExecutor
                for (int j = 0; j < i; j ++) {
                    children[j].shutdownGracefully();
                }

                // 在循环一次之前创建的EventExecutor
                // 再确认停止成功时发生异常就通知持有线程interrupt异常
                for (int j = 0; j < i; j ++) {
                    EventExecutor e = children[j];
                    try {
                        while (!e.isTerminated()) {
                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);
                        }
                    } catch (InterruptedException interrupted) {
                        // Let the caller handle the interruption.
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }
        }
    }

    chooser = chooserFactory.newChooser(children);

    // 给每个child天加一个监听器
    final FutrueListener<Object> terminationListener = new FutrueListener<Object>() {
        @Override
        public void operationComplete(Futrue<Object> futrue) throws Exception {
            if (terminatedChildren.incrementAndGet() == children.length) {
                terminationFutrue.setSuccess(null);
            }
        }
    };

    for (EventExecutor e: children) {
        e.terminationFutrue().addListener(terminationListener);
    }

    // 保存一份和children相同的集合到readonlyChildren，但是是只读的
    Set<EventExecutor> childrenSet = new LinkedHashSet<EventExecutor>(children.length);
    Collections.addAll(childrenSet, children);
    readonlyChildren = Collections.unmodifiableSet(childrenSet);
}
```

再看NioEventLoopGroup的newChild方法：

```java
/**
 * args就是上面构造方法收到的一系列参数
 */
@Override
protected EventLoop newChild(Executor executor, Object... args) throws Exception {
    // 拿到参数
    SelectorProvider selectorProvider = (SelectorProvider) args[0];
    SelectStrategyFactory selectStrategyFactory = (SelectStrategyFactory) args[1];
    RejectedExecutionHandler rejectedExecutionHandler = (RejectedExecutionHandler) args[2];
    EventLoopTaskQueueFactory taskQueueFactory = null;
    EventLoopTaskQueueFactory tailTaskQueueFactory = null;

    int argsLength = args.length;
    if (argsLength > 3) {
        taskQueueFactory = (EventLoopTaskQueueFactory) args[3];
    }
    if (argsLength > 4) {
        tailTaskQueueFactory = (EventLoopTaskQueueFactory) args[4];
    }
    // 用上面的参数创建NioEventLoop就完事了
    return new NioEventLoop(this, executor, selectorProvider,
            selectStrategyFactory.newSelectStrategy(),
            rejectedExecutionHandler, taskQueueFactory, tailTaskQueueFactory);
}
```

### 二、初始化ServerSocketChannel和注册到selector源码

`  new ServerBootstrap();`没有代码，然后通过我们的代码设置两个group；设置channel时其实是设置了ReflectiveChannelFactory；设置option属性时是把对应的k、v放进一个map里；最后在设置一个childHandler；**其中除了childGroup和childHandler，其他的都在父类AbstractBootstrap中**。

启动之前需要先绑定端口号，在bind()方法中先把我们传进来的地址和端口封装成InetSocketAddress对象，然后调用doBind()方法：

```java
private ChannelFutrue doBind(final SocketAddress localAddress) {
    // 创建ChannelFutrue
    final ChannelFutrue regFutrue = initAndRegister();
    final Channel channel = regFutrue.channel();
    if (regFutrue.cause() != null) {
        return regFutrue;
    }

    if (regFutrue.isDone()) {
        // At this point we know that the registration was complete and successful.
        ChannelPromise promise = channel.newPromise();
        doBind0(regFutrue, channel, localAddress, promise);
        return promise;
    } else {
        // 这里注册基本上就完成了，添加一个监听以防万一和绑定端口
        // PendingRegistrationPromise的父类是DefaultChannelPromise
        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
        regFutrue.addListener(new ChannelFutrueListener() {
            @Override
            public void operationComplete(ChannelFutrue futrue) throws Exception {
                Throwable cause = futrue.cause();
                if (cause != null) {
                    // 注册到selector失败
                    promise.setFailure(cause);
                } else {
                    // 设置状态
                    promise.registered();
					// 绑定端口和channel关闭事件
                    doBind0(regFutrue, channel, localAddress, promise);
                }
            }
        });
        return promise;
    }
}
```

```java
final ChannelFutrue initAndRegister() {
    Channel channel = null;
    try {
        // 这个channelFactory是上面创建的ReflectiveChannelFactory
        // 这里是通过反射来创建最开始传进来的NioServerSocketChannel
        // NioServerSocketChannel是netty自己对ServerSocketChannel的封装
        channel = channelFactory.newChannel();
        init(channel);
    } catch (Throwable t) {
        if (channel != null) {
            // channel can be null if newChannel crashed (eg SocketException("too many open files"))
            channel.unsafe().closeForcibly();
            // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
        }
        // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
    }

    // 这里的group()获取的就是之前创建的parentGroup
    ChannelFutrue regFutrue = config().group().register(channel);
    if (regFutrue.cause() != null) {
        if (channel.isRegistered()) {
            channel.close();
        } else {
            channel.unsafe().closeForcibly();
        }
    }

    // If we are here and the promise is not failed, it's one of the following cases:
    // 1) If we attempted registration from the event loop, the registration has been completed at this point.
    //    i.e. It's safe to attempt bind() or connect() now because the channel has been registered.
    // 2) If we attempted registration from the other thread, the registration request has been successfully
    //    added to the event loop's task queue for later execution.
    //    i.e. It's safe to attempt bind() or connect() now:
    //         because bind() or connect() will be executed *after* the scheduled registration task is executed
    //         because register(), bind(), and connect() are all bound to the same thread.

    return regFutrue;
}
```

##### 1.NioServerSocketChannel初始化过程

初始化NioServerSocketChannel的代码是`channelFactory.newChannel();`，通过反射创建，所以直接进到构造方法中查看。首先是通过nio创建ServerSocketChannel：

```java
private static ServerSocketChannel newChannel(SelectorProvider provider, InternetProtocolFamily family) {
    try {
        ServerSocketChannel channel =
            SelectorProviderUtil.newChannel(OPEN_SERVER_SOCKET_CHANNEL_WITH_FAMILY, provider, family);
        // 默认情况下family是null，上面是不会创建channel的
        // 所以默认创建的代码就是provider.openServerSocketChannel()
        return channel == null ? provider.openServerSocketChannel() : channel;
    } catch (IOException e) {
        throw new ChannelException("Failed to open a socket.", e);
    }
}
```

然后调用父类的构造方法，把channel和关注事件传给父类AbstractNioMessageChannel，在AbstractNioMessageChannel中又调用了父类AbstractNioChannel的构造方法：

```java
protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) {
    // 父类是AbstractChannel，这个构造方法里没啥东西
    super(parent);
    // 设置ServerSocketChannel
    this.ch = ch;
    // 设置关注事件
    this.readInterestOp = readInterestOp;
    try {
        // 设置非阻塞
        ch.configureBlocking(false);
    } catch (IOException e) {
        try {
            ch.close();
        } catch (IOException e2) {
            logger.warn("Failed to close a partially initialized socket.", e2);
        }
        throw new ChannelException("Failed to enter non-blocking mode.", e);
    }
}
```

调用完父类构造方法之后还要创建一个NioServerSocketChannelConfig对象：

```java
public NioServerSocketChannel(ServerSocketChannel channel) {
    super(null, channel, SelectionKey.OP_ACCEPT);
    // 这个是一堆配置和ServerSocket对象这些
    config = new NioServerSocketChannelConfig(this, javaChannel().socket());
}
```

##### 2.init(channel)方法源码

```java
void init(Channel channel) {
    setChannelOptions(channel, newOptionsArray(), logger);
    setAttributes(channel, newAttributesArray());

    ChannelPipeline p = channel.pipeline();

    // 初始化实行
    final EventLoopGroup currentChildGroup = childGroup;
    final ChannelHandler currentChildHandler = childHandler;
    final Entry<ChannelOption<?>, Object>[] currentChildOptions = newOptionsArray(childOptions);
    final Entry<AttributeKey<?>, Object>[] currentChildAttrs = newAttributesArray(childAttrs);

    // 添加在即内置的处理链路
    p.addLast(new ChannelInitializer<Channel>() {
        @Override
        public void initChannel(final Channel ch) {
            final ChannelPipeline pipeline = ch.pipeline();
            ChannelHandler handler = config.handler();
            if (handler != null) {
                pipeline.addLast(handler);
            }

            ch.eventLoop().execute(new Runnable() {
                @Override
                public void run() {
                    pipeline.addLast(new ServerBootstrapAcceptor(
                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                }
            });
        }
    });
}
```

##### 3.channel注册到selector源码

通过`config().group().register(channel);`方法注册到selector，这里的config().group()其实就是获取这个类中的group变量，而这个变量是我们开始创建的parentGroup，那么register()方法就会走到MultithreadEventLoopGroup类中：

```java
public ChannelFutrue register(Channel channel) {
    // 因为parentGroup是个EventExecutor[]
    // 猜测这个next()一定是轮询或者随机之类的取一个EventExecutor出来
    return next().register(channel);
}
```

跟了几层源码找到了next()方法：

```java
public EventExecutor next() {
    // 这个idx就是一个AtomicLong，所以是轮询获取EventExecutor
    return executors[(int) Math.abs(idx.getAndIncrement() % executors.length)];
}
```

因为这个EventExecutor就是NioEventLoop，拿到EventExecutor就可以调用NioEventLoop的register()方法注册了，但是NioEventLoop继承了SingleThreadEventLoop，而且没重写register方法，所以register()方法是在SingleThreadEventLoop中的：

```java
public ChannelFutrue register(final ChannelPromise promise) {
    ObjectUtil.checkNotNull(promise, "promise");
    promise.channel().unsafe().register(this, promise);
    return promise;
}
```

最后会走到AbstractNioChannel的doRegister()方法中，关键代码就1句，原生的nio注册代码

```java
// javaChannel()拿到的就是通过构造方法传进来的NioServerSocketChannel
// 创建serverSocketChannel的时候已经设置了accept事件，为什么这里还是写死的0，而不是用哪个全局变量op_accept
selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);
```

##### 4.绑定端口源码

在注册完selector上之后就要进行绑定端口操作：

```java
doBind0(regFutrue, channel, localAddress, promise);
```

```java
private static void doBind0(
    final ChannelFutrue regFutrue, final Channel channel,
    final SocketAddress localAddress, final ChannelPromise promise) {

    channel.eventLoop().execute(new Runnable() {
        @Override
        public void run() {
            if (regFutrue.isSuccess()) {
                // 先绑定端口，在添加channel关闭监听
                channel.bind(localAddress, promise).addListener(ChannelFutrueListener.CLOSE_ON_FAILURE);
            } else {
                promise.setFailure(regFutrue.cause());
            }
        }
    });
}
```

![](https://tva1.sinaimg.cn/large/008vxvgGly1h74tu0fdqgj318y0u0782.jpg)

