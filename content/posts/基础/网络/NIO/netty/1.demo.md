---
title: 1.netty-demo
tags:
  - 网络
categories: netty
copyright: true
---

新建工程，引入依赖：

```xml
<dependency>
    <groupId>io.netty</groupId>
    <artifactId>netty-all</artifactId>
    <version>4.1.82.Final</version>
</dependency>
```

###### server端：

```java
public class NettySever {
    public static void main(String[] args) {
        // 声明两个EventLoopGroup
        EventLoopGroup parentGroup = new NioEventLoopGroup();
        EventLoopGroup childGroup = new NioEventLoopGroup();

        // netty的服务器声明
        ServerBootstrap serverBootstrap = new ServerBootstrap();

        try {
            serverBootstrap.group(parentGroup, childGroup)
                    // 监听端口的serverChannel
                    .channel(NioServerSocketChannel.class)
                    // 用来存放等待处理的客户端请求的队列大小
                    .option(ChannelOption.SO_BACKLOG, 1024)
                	// 处理客户端请求的handler
                    .childHandler(new ChildChannelHandler());

            // 尝试启动服务，绑定端口并同步等待启动服务器的结果
            ChannelFutrue channelFutrue = serverBootstrap.bind(50070).sync();
            // 同步等待关闭服务器的结果
            channelFutrue.channel().closeFutrue().sync();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            parentGroup.shutdownGracefully();
            childGroup.shutdownGracefully();
        }
    }

    /**
     * 处理每个客户端连接的socketChannel的逻辑
     */
    private static class ChildChannelHandler extends ChannelInitializer<SocketChannel> {

        @Override
        protected void initChannel(SocketChannel socketChannel) {
            // 针对网络请求的处理逻辑
            socketChannel.pipeline().addLast(new NettyServerHandler());
        }
    }
}
```

server端handler：

```java
public class NettyServerHandler extends ChannelInboundHandlerAdapter {

    /**
     * 从对应的连接里读取请求
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        // 这个是netty的ByteBuf
        ByteBuf requestBuffer = (ByteBuf) msg;
        byte[] requestByte = new byte[requestBuffer.readableBytes()];
        requestBuffer.readBytes(requestByte);

        String request = new String(requestByte, "UTF-8");
        System.out.println("收到请求:" + request);

        String response = "我收到你的请求了，返回响应给你";
        ByteBuf responseBuffer = Unpooled.copiedBuffer(response.getBytes());
        ctx.writeAndFlush(responseBuffer);
    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        ctx.flush();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        ctx.close();
    }
}
```

###### 客户端：

客户端和服务端差不多，客户端少了一个线程组：

```java
public class NettyClient {

    public static void main(String[] args) {
        EventLoopGroup group = new NioEventLoopGroup();

        Bootstrap bootstrap = new Bootstrap();
        bootstrap.group(group)
                .channel(NioSocketChannel.class)
                .option(ChannelOption.TCP_NODELAY, true)
                .handler(new ChannelInitializer<Channel>() {
                    @Override
                    protected void initChannel(Channel channel) throws Exception {
                        channel.pipeline().addLast(new NettyClientHandler());
                    }
                });

        try {
            // 这里是建立连接，不是监听端口
            ChannelFutrue channelFutrue = bootstrap.connect("127.0.0.1", 50070).sync();
            channelFutrue.channel().closeFutrue().sync();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            group.shutdownGracefully();
        }
    }
}
```

client端handler：

```java
public class NettyClientHandler extends ChannelInboundHandlerAdapter {

    private final ByteBuf requestBuffer;

    public NettyClientHandler () {
        byte[] requestBytes = "你好，我发送第一条消息".getBytes();
        requestBuffer = Unpooled.buffer(requestBytes.length);
        requestBuffer.writeBytes(requestBytes);
    }

    /**
     * 建立连接后的动作
     */
    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        ctx.writeAndFlush(requestBuffer);
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ByteBuf responseBuffer = (ByteBuf) msg;
        byte[] responseBytes = new byte[responseBuffer.readableBytes()];
        responseBuffer.readBytes(responseBytes);
        String response = new String(responseBytes, "UTF-8");
        System.out.println("收到响应:" + response);
    }
}
```

