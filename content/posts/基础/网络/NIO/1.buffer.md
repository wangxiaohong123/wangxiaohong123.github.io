---
title: 1.NIO-buffer
tags:
  - 网络
categories: NIO
copyright: true
---

##### 一 创建缓冲区

创建缓冲区有3种方式：

###### 1.创建空缓冲区

创建空缓冲区适合用在从磁盘文件读取数据或者从网络里读取数据

```java
ByteBuffer buffer = ByteBuffer.allocate(10);
```

###### 2.创建有数据的缓冲区

把现有数据写入磁盘或者网络

```java
byte[] data = new byte[] {1, 2, 3};
ByteBuffer buffer = ByteBuffer.wrap(data);
```

###### 3.direct缓冲区

正常的缓冲区前面还有一个jvm的缓冲区(堆外内存)，读取和写入都是要经过jvm的缓冲区，使用direct模式创建缓冲区，就没有jvm的缓冲区，性能会高一点

```java
ByteBuffer buffer = ByteBuffer.allocateDirect(10);
```

不管是把jvm内存中的数据刷到磁盘、socket或者从磁盘读取数据到jvm，都是要先经过一个buffer。

##### 二 buffer demo

*   capacity：缓冲区的大小；
*   limit：limit是用来卡死一个界限，比如buffer中有5个数据（1到5），limit指向3，就只能操作第3位之前的数据1、2、3这三个个数，默认limit和capacity是一样的；
*   position：下一个读取数据的位置；
*   mark：就是一个标记，调用reset()方法时，position会回到mark的位置；
*   remaining：当前position距离limit还有多少位；

一般常用的byteBuffer、charBuffer，像什么longBuffer之类的没用过；

```java
// 操作缓冲区
byte[] data = new byte[] {1, 2, 3};
ByteBuffer buffer = ByteBuffer.wrap(data);
System.out.println(buffer.capacity());
System.out.println(buffer.position());
// 设置position的位置
buffer.position(1);
System.out.println(buffer.limit());
// 从buffer中读取一位
System.out.println(buffer.get());
// 设置mark
buffer.mark();
```

##### 三 常见方法

*   clear()：把position变成0，limit变成capacity，废弃mark，并不是删除数据了，这样再写的时候可以覆盖旧的数据；
*   flip()：把limit变成position，然后position变成0，这样的话在读取数据就只能从0读取到之前的position了；
*   rewind()：limit不变，position变成0，比如说刚读完一遍数据，还想在读一遍，用这个方法就可以了；
*   reset()：让position回到mark位置，但是需要先调用mark()方法，否则会报错；
*   get()：读取数据，可以直接把数据读到数组中；
*   put()：插入或覆盖数据，可以直接写入数组；

