---
title: 3.NIO-selector
tags:
  - 网络
categories: NIO
copyright: true
---

selector是专门在网络通信中使用的，多路复用思想。基于操作系统底层的select机制，监听所有客户端的连接，收到请求不会处理，一般都是交给一个队列，这样selector就专门干监听，我们只要创建一个线程池，每个线程绑定一个队列，消费这个队列就可以了。

##### NIO网络demo-服务端

```java
public class NIOServer {

	private static final CharsetEncoder encoder = Charset.forName("UTF-8").newEncoder();
    private static final CharsetDecoder decoder = Charset.forName("UTF-8").newDecoder();
  
    private static ByteBuffer readBuffer;  
    private static Selector selector;  

    public static void main(String[] args) {
    	init();
    	listen();
    }  
       
    private static void init(){
        // 读取请求数据的缓冲区
        readBuffer = ByteBuffer.allocate(1024);
        // 监听客户端连接的channel
        ServerSocketChannel servSocketChannel;

        try {  
            servSocketChannel = ServerSocketChannel.open();
            // 设置为非阻塞
            // 否则SocketChannel没有事件时，selector会一直阻塞住，不去监听其他channel
            servSocketChannel.configureBlocking(false);
            // 9000是服务端监听的端口号
            // backlog是请求的队列长度是100，意思就是最多支持100个客户端保持连接
            servSocketChannel.socket().bind(new InetSocketAddress(9000), 100);
            selector = Selector.open();
            // 把servSocketChannel注册到selector上，并且配置监听的事件是OP_ACCEPT
            // OP_ACCEPT的意思是tcp连接请求
            servSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
	private static void listen() {
        while(true){
            try{
                // 这里会阻塞住，等待有事件产生
                // 所以nio是同步非阻塞的
                selector.select();
                // 一个SelectionKey约等于1个请求
                Iterator<SelectionKey> keysIterator = selector.selectedKeys().iterator();
                while(keysIterator.hasNext()){
                    SelectionKey key = keysIterator.next();
                    keysIterator.remove();
                    // 处理事件
                    // 正常来说应该把这个事件放到队列中，交给线程池处理
                    handleKey(key);
                }
            }
            catch(Throwable t){
                t.printStackTrace();
            }
        }
    }
   
    private static void handleKey(SelectionKey key) throws IOException {
        SocketChannel channel = null;
        try{
            // 处理连接请求
            if(key.isAcceptable()) {
                ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();
                // 进行tcp3次握手后会生成一个socketChannel
                // 通过socketChannel就可以实现和客户端收发数据
                channel = serverChannel.accept();
                channel.configureBlocking(false);
                // 把SocketChannel注册到selector上，并设置监听的请求是OP_READ
                channel.register(selector, SelectionKey.OP_READ);
            } else if(key.isReadable()) {
                // 处理客户端发送过来的数据
                channel = (SocketChannel) key.channel();
                // 缓冲区复位
                readBuffer.clear();
                // 把数据写入到缓冲区
                int count = channel.read(readBuffer);

                if(count > 0) {
                    // 让position变成0，limit变成接收到的字符长度
                    // 这样就可以只读取这次收到的数据了
                    readBuffer.flip();
                    CharBuffer charBuffer = decoder.decode(readBuffer);
                    System.out.println("收到请求：" + charBuffer.toString());

                    // 返回响应
                    channel.write(encoder.encode(CharBuffer.wrap("收到")));
                } else {
                    channel.close();
                }                        
            }
        } catch(Throwable t) {
            t.printStackTrace();
            if(channel != null){
                channel.close();
            }
        }
    }
}
```

##### NIO网络demo-客户端

```java
public class NIOClient {
	
	private static final CharsetEncoder encoder = Charset.forName("UTF-8").newEncoder();
    private static final CharsetDecoder decoder = Charset.forName("UTF-8").newDecoder();

	public static void main(String[] args) {
        for(int i = 0; i < 10; i++) {
            new Worker().start();
        }
    }  

	static class Worker extends Thread {
	
		@Override  
		public void run() {
			SocketChannel channel = null;
			Selector selector = null;
			try {
				// 创建SocketChannel注册到selector上，并且设置关注的事件是OP_CONNECT
				channel = SocketChannel.open();
				channel.configureBlocking(false);
				channel.connect(new InetSocketAddress("localhost", 9000));

				selector = Selector.open();
				channel.register(selector, SelectionKey.OP_CONNECT);

				while(true) {
					selector.select();
					Iterator<SelectionKey> keysIterator = selector.selectedKeys().iterator();
					while(keysIterator.hasNext()) {
						SelectionKey key = keysIterator.next();
						keysIterator.remove();

						// 处理建完连接
						if(key.isConnectable()) {
							if(channel.isConnectionPending()) {
								if(channel.finishConnect()) {
									key.interestOps(SelectionKey.OP_READ);  
									channel.write(encoder.encode(CharBuffer.wrap("你好")));  
								} else {
									key.cancel();
								}  
							}                                                
						} else if(key.isReadable()) {
							// 处理服务端发送过来的数据
							ByteBuffer byteBuffer = ByteBuffer.allocate(128);
							channel.read(byteBuffer);
							byteBuffer.flip();
							CharBuffer charBuffer = decoder.decode(byteBuffer);
							System.out.println("收到响应：" + charBuffer.toString());
							
							channel.write(encoder.encode(CharBuffer.wrap("你好")));    
						}
					}
				}
			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				if(channel != null) {
					try {
						channel.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
				}
				   
				if(selector != null) {
					try {  
						selector.close();  
					} catch (IOException e) {  
						e.printStackTrace();  
					}  
				}  
			}  
		}
	}
}
```

##### SelectionKey，就相当于一个SocketChannel，主要有4个方法

*   key.isAcceptable()：当有客户端连接时触发，这个时候需要获取ServerSocketChannel调用accept方法，然后注册监听事件；
*   key.isConnectable()：表示建立连接成功或者失败或者还没完成，需要在内部继续判断是否完成连接；
*   key.isWritable()：可以写数据；
*   key.isReadable()：读取数据；

![](https://tva1.sinaimg.cn/large/008vxvgGly1h71cf76w8xj31la0jydhe.jpg)

##### 粘包和拆包

一般拆包的解决办法就是设置定义头，头内定义数据体的长度，在接收数据的时候创建缓存，把limit设置成消息体的大小，读取数据时使用remaining()表示position == limit，如果不等于就说明没读完，这时候需要把数据放到缓存中，等待下次继续读取。

还有一种解决粘包的办法是自定义个字符串，如果遇见这个字符串就结束读取。

粘包一直读就可以了，读完指定字节的数据之后如果还有数据就继续读。

