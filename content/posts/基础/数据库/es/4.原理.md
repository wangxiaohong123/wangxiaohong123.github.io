---
title: es-4.原理
tags:
  - elasticsearch
categories: 数据库
copyright: true
---

### 1.读写原理

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1nfx4hv54j218w0u0n1i.jpg)

在写入数据的时候先记录translog到os cache同时把数据写到内存的indexing buffer中，这个时候数据是查不到的，内存的indexing buffer中的数据每隔一秒会刷到os cache中，刷到os cache之后才能查到数据。os cache中的数据每个5s(默认)或者达到512m(默认)会刷入磁盘，所以如果es的进程挂了最多会丢1s的数据，primary所在服务器宕机也只会丢失1s数据(副本中还有一份数据)，primary和replica所在服务器都宕机才会丢失5s数据(这种情况极少极少)。

##### 1.1写优化

-   **数据不丢**：如果想要数据不丢就设置`index.translog.durability: request`，他会让translog同步刷盘，性能也会降低。
-   **常规写优化**：如果允许数据部分丢失可以设置`index.translog.durability: async`，只要translog写到os cache就算成功，还可以设置`index.translog.sync_interval`和`index.translog.flush_threshold_size`控制os cache刷盘的频率。
-   **段合并优化**：`indices.memory.index_buffer_size`参数控制indexing buffer的大小，如果写满了就会执行刷盘操作，默认是堆内存的10%，可以调大；每次从os cache将索引数据刷盘都会生成一个新的segment文件，segment文件数量到限制后会执行合并操作，数量限制通过`index.merge.policy.segments_per_tier`参数控制，默认是10，可以调大；

##### 1.2查询优化

- **增加page cache**：es的搜索时严重依赖内存的，如果内存没有需要从磁盘搜索，这个速度就慢了，所以要给es足够内存，一般都是jvm占一般，os cache占一半。
- **减少存储空间**：保证没用的数据不写入es，减少数据的大小，\_source、\_all(6.x后默认禁用)能禁用就禁用，有一些字段不是查询条件比如业务id可以把index属性设置成false，有一些字段不需要持久化就把store属性设置成false。
- **容量和集群规划**：搭建es时要考虑数据占用空间，并计算未来3年、5年数据的增长来选择机器配置，同时primary要比机器数量多一点，保证以后可以扩容(因为primary shad数量不能修改)。
- **冷热数据分离**：识别出来索引中的冷数据，比如2年前的数据，这些数据可以持久化到Hadoop中。
- **pre-index**：预索引，比如说价格是33.22，存储时额外加一个字段存储的是10-50，表示这个价格所在的区间，根据价格范围查找的时候要比直接根据价格字段快，但是也快不了太多。
- **提升缓存命中**：比如把日期粗化到天，如果是精确到秒很难用到jvm的缓存，也快不了太多。
- **os cache预热**：机器重启的时候可以设置`index.store.preload`，会把索引提前加载到os cache中。

### 2.数据路由原理

数据路由：因为一个document只能存在一个primary shard上，在创建数据的时候es需要决定这条文档应该放在哪个shard上。

路由算法：shard = hash(routing) % primary shard数量，当操作中有\_id时，这个routing就是\_id，然后算出hash值在和primary shard的数量求余。routing值可以手动指定，比如说PUT /test_index/_doc/1?routing=user_id。
这样就可以解释为什么primary shard的数量不可变了，一旦发生变化查找数据很容易就找不到。

### 3.deep paging

深度分页的意思就是说比如现在有3个shard上有index的数据，每个shard存100000条，然后我要查第10000到10010条数据，他就会把每个shard上的前10010条数据都拿出来，然后根据score排序在拿到第10000到10010条数据返回，deep paging很耗带宽、内存、CPU。

### 4.filter和其他搜索区别

filter只是根据条件过滤，其他搜索像must还需要计算相关度然后在排序，如果只是要筛选使用filter可以提高性能，filter还是用了cache保存最常用的filter。

### 5.相关度分数算法

TF/IDF(term frequency/inverse document frequency )算法：

*   term frequency：搜索的词条在文本里出现了多少次，次数越多越相关；
*   inverse document frequency：搜索的此条在整个index中出现的次数越多就越不想关， 比如搜索词条中有两个词，一个词在整个index中出现5000次，一个词只出现100次，肯定出现100次的词更容易影响分数；
*   field-length norm：field长度和相关度成反比；

在查询命令的url后面拼上explain参数表示打印出相关度计算的detail。

### 6.doc values(正排索引)

就是类似MySQL，按行存储，排序只能用doc values，如果内存足够的话doc values会存在os cache中，否则只会在磁盘上。

