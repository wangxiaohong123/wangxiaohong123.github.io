---
title: 聚合
tags:
  - elasticsearch
categories: 数据库
copyright: true
---

聚合分析的field是不能分词的，因为他用的正排索引，可以在建立索引的时候把fielddata设置成true。

根据颜色分组：

```json
GET /tvs/sales/_search
{
  "size": 0, // size就是document的数据，设置成0就是不要document
  "aggs": {
    "popular_color": {
      "terms": {
        "field": "color"
      }
    }
  }
}
```

聚合最关键的两个词：bucket和metric，bucket是分组，metric是计算，比如平均值，最大值等等。

***

### metric操作

#### avg

```json
// 根据颜色分组，求出每个颜色的平均价格
GET /tvs/sales/_search
{
   "size" : 0,
   "aggs": {
      "colors": {
         "terms": {
            "field": "color",
            "order": { // 默认是以color分组之后的数值降序，现在修改为分组之后的平均价格降序
                "avg_price": "desc"
            }
         },
         "aggs": { 
            "avg_price": { 
               "avg": {
                  "field": "price" 
               }
            }
         }
      }
   }
}
```

下钻：aggs中嵌套aggs，在分完的组中在分组：

```json
// 在颜色组在按品牌分组
GET /tvs/sales/_search
{
   "size" : 0,
   "aggs": {
      "group_by_colors": {
         "terms": {
            "field": "color"
         }, 
         "aggs": {
            "color_avg_price": { 
               "avg": {
                  "field": "price" 
               }
            },
            "brand": {
              "terms": {
                "field": "brand"
              },
              "aggs": {
                "brand_avg_price": {
                  "avg": {
                    "field": "price"
                  }
                }
              }
            }
         }
      }
   }
}
```

#### max和min

```json
GET /tvs/sales/_search
{
  "size": 0, 
  "aggs": {
    "group_by_color": {
      "terms": {"field": "color"},
      "aggs": {
        "max_price": {"max": {"field": "price"}},
        "min_price": {"min": {"field": "price"}}
      }
    }
  }
}
```

#### sum

```json
GET /tvs/sales/_search
{
  "size": 0, 
  "aggs": {
    "group_by_color": {
      "terms": {"field": "color"},
      "aggs": {
        "sum_price": {"sum": {"field": "price"}}
      }
    }
  }
}
```

***

histogram操作：

```json
// histogram会按照给定区间分组
GET /tvs/sales/_search
{
  "size": 0,
  "aggs": {
    "group_by_price": {
      "histogram": {
        "field": "price",
        "interval": 2000 // 以2000为区间，比如 0~2000，2000~4000
      },
      "aggs": {
        "sum_price": {
          "sum": {
            "field": "price"
          }
        }
      }
    }
  }
}
```

date_histogram：

```json
// 统计每个月的销量
// 就是以sold_date按月份分组
GET /tvs/sales/_search
{
  "size": 0,
  "aggs": {
    "histogram_by_sold_date": {
      "date_histogram": {
        "field": "sold_date",
        "interval": "month", // 每月，quarter是每季度
        "min_doc_count": 0, // 如果不设置这个，当有月份没有数据的时候不会显示
        "format": "yyyy-MM-dd",
        "extended_bounds": { // 设置起始和终止日期
          "min": "2016-01-01",
          "max": "2017-12-31"
        }
      }
    }
  }
}
```

aggs和query一起使用的时候，aggs相关会在query的结果基础上聚合，如果想不基于query的结果可以加一个global:{}，比如

```json
GET /tvs/sales/_search 
{
  "size": 0, 
  "query": {
    "term": {
      "brand": {
        "value": "长虹"
      }
    }
  },
  "aggs": {
    "single_brand_avg_price": { // 以query的结果求平均价格
      "avg": {
        "field": "price"
      }
    },
    "all": { // 所有品牌的平均价格
      "global": {},
      "aggs": {
        "all_brand_avg_price": {
          "avg": {
            "field": "price"
          }
        }
      }
    }
  }
}
```

***

### 近似聚合算法

有些算法是易并行的，比如说max，可以边搜索边确定max，别如说有三个shard，求max只需要在三个shard都找完的时候返回max，在协调节点上比较三个max的值就可以了，这些算法叫做易并行算法。

不易并行的算法需要把数据都拿到协调节点上，很费空间，所以es采用近似的算法，会有一些误差，但是很快。

#### cartinality（去重算法）会有5%的错误率

```json
GET /tvs/sales/_search
{
  "size" : 0,
  "aggs" : {
      "months" : {
        "date_histogram": {
          "field": "sold_date",
          "interval": "month"
        },
        "aggs": {
          "distinct_colors" : {
              "cardinality" : {
                "field" : "brand",
                "precision_threshold": 100 // 这个是优化错误率的，占用内存 = precision_threshold*8 bit，值越大错误率越小
              }
          }
        }
      }
  }
}
```

#### percentiles

求网站的tp50、tp95、tp99

```json
GET /website/logs/_search
{
  "size": 0,
  "aggs": {
    "latency_percentiles": {
      "percentiles": {
        "field": "latency",
        "percents": [
          50,
          95,
          99
        ]
      }
    },
    "latency_avg": {
      "avg": {
        "field": "latency"
      }
    }
  }
}
```

### percentile_ranks

统计200ms以内的请求和1000毫秒以内的请求占比

```json
GET /website/logs/_search
{
  "size": 0,
  "aggs": {
    "group_by_province": {
      "terms": {
        "field": "province"
      },
      "aggs": {
        "latency_percentile_ranks": {
          "percentile_ranks": {
            "field": "latency",
            "values": [
              200,
              1000
            ],
            "compression": 100 // 计算使用的节点，越多越准确
          }
        }
      }
    }
  }
}
```

fielddata和doc value是两码事，fielddata是把分词的field建立正排索引放到内存中。doc value是添加数据时建立的正排索引放在磁盘中。而fielddata是在聚合时才创建正排索引放在内存中。fielddata是可以配置预加载的。

监控fielddata内存使用：

```
GET /_stats/fielddata?fields=*

GET /_nodes/stats/indices/fielddata?fields=*

GET /_nodes/stats/indices/fielddata?level=indices&fields=*
```

