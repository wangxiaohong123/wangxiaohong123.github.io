---
title: 2.安装es
tags:
  - elasticsearch
categories: 数据库
copyright: true
---

#### 1准备工作

首先准备3台虚拟机，三台机器上进行相同的操作

##### 1.1修改系统参数

修改资源配置文件：`vim /etc/security/limits.conf`：

```shell
# *表示任何用户
# soft表示警告值，hard是真正限制的阈值
# nofile是文件描述符数量，nproc是开启进程数
* soft nofile 65535
* hard nofile 65535
* soft nproc 4096
* hard nproc 4096
```

修改这个配置要退出当前用户重新登录生效。

修改sysctl配置文件：`vim /etc/sysctl.conf`修改每个进程可以拥有的虚拟内存区域的数量

```properties
vm.max_map_count=262144
```

执行`sysctl -p`刷新配置

##### 1.2创建es用户

执行命令`useradd es`添加名为es的用户，执行命令`passwd es `然后根据提示输入要设置密码比如qiyuan1502，再次输入确认密码完成设置。

##### 1.3创建目录

```shell
mkdir -p /app/elasticsearch
mkdir -p /app/elasticsearch/data
mkdir -p /app/elasticsearch/log
```

#### 2安装es

到官网[https://www.elastic.co/cn/downloads/past-releases#elasticsearch ]下载es安装包，上传到服务器下的/app/elasticsearch文件夹中解压：

```shell
tar -zxvf elasticsearch-7.9.3-linux-x86_64.tar.gz
```

##### 2.1修改配置文件

进入解压之后的es的配置文件夹中：`cd /app/elasticaearch/elasticsearch-7.9.3/config`，清空elasticsearch.yml并重新编辑：

```shell
echo '' > elasticsearch.yml
vim elasticsearch.yml
```

配置如下：

```yaml
# 集群名称
cluster.name: escluster
# 节点名称
node.name: esnode1
# 节点⻆⾊
node.master: true
node.data: true
# 最⼤的节点数
node.max_local_storage_nodes: 3
# 绑定的ip地址
network.host: 0.0.0.0
# 对外的端⼝
http.port: 9300
# 节点之间通信的端⼝
transport.tcp.port: 9800
# 节点发现和集群选举
discovery.seed_hosts: ["172.30.60.105","172.30.60.106","172.30.60.107"]
cluster.initial_master_nodes: ["esnode1","esnode2","esnode3"]
# 数据目录和日志目录
path.data: /app/elasticsearch/data
path.logs: /app/elasticsearch/log
# 让kibana上可以看到堆栈监控数据
xpack.monitoring.enabled: true
xpack.monitoring.collection.enabled: true
# 索引缓冲区
# 占总堆的百分比
indices.memory.index_buffer_size: 30%
# 最小值
indices.memory.min_index_buffer_size: 128m
```

修改jvm参数：`vim jvm.options`，开发环境先给512m

```shell
-Xms512m
-Xmx512m
```

##### 2.2搞其他两台机器

使用scp把es东西复制过去

```shell
cd /
scp -r app root@172.30.60.106:/
```

然后到其他两台机器上修改elasticsearch.yml里的node.name参数

### 2.3修改3台机器的elasticsearch文件夹的属主和属组

```shell
chown -R es:es /app/elasticsearch
```

##### 2.4启动es

切换用户并启动：

```shell
su es
/app/elasticsearch/elasticsearch-7.9.3/bin/elasticsearch -d
tail -f /app/elasticsearch/log/escluster.log
```

访问http://8.142.71.78:9300/_cat/health?v查看集群状态，我这里只启动一个节点
![](https://tva1.sinaimg.cn/large/e6c9d24ely1h04u9wbd2mj21us07k75l.jpg)

#### 3安装kibana

新启动一台虚拟机，这个对配置没要求。创建kibana用户：

```shell
useradd kibana
passwd kibana
```

在官网https://www.elastic.co/cn/downloads/past-releases#kibana下载7.9.3的kibana上传到服务器并解压

```shell
tar -zxvf kibana-7.9.3-linux-x86_64.tar.gz
```

创建目录

```shell
mkdir -p /app/kibana
```

进到kibana配置目录修改配置信息：

```shell
echo '' > kibana.yml
vim kibana.yml
```

配置如下：

```yaml
# kibana的端⼝
server.port: 9000
# 绑定的地址
server.host: "0.0.0.0"
# es的地址
elasticsearch.hosts: ["http://172.30.60.105:9300","http://172.30.60.106:9300","http://172.30.60.107:9300"]
# 显示的语⾔
i18n.locale: "zh-CN"
```

修改kibana文件夹的属组和属主：

```shell
chown -R kibana:kibana /app/kibana/
```

启动kibana：

```shell
 nohup /app/kibana/kibana-7.9.3-linux-x86_64/bin/kibana &
```

浏览器输入http://8.142.71.78:9400/进入kibana页面。

#### 4部署分词器

##### 4.1修改IK分词器代码

下载7.9.3版本的IK分词器源码https://github.com/medcl/elasticsearch-analysis-ik/archive/refs/tags/v7.9.3.zip，导入到intellij中。
然后找到要在哪里加入我们的代码：
![](https://tva1.sinaimg.cn/large/e6c9d24ely1h04xsm3iv4j21g90u0n5n.jpg)

首先在pom文件中添加mysql依赖，虽然我下载的是7.9.3，但是pom里写的是7.4.0，这里也需要改一下：

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.20</version>
</dependency>
```

然后在Dictionary类的同级创建一个DictLoader类，代码如下：

```java
package org.wltea.analyzer.dic;

import org.apache.logging.log4j.Logger;
import org.elasticsearch.common.io.PathUtils;
import org.wltea.analyzer.help.ESPluginLoggerFactory;

import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Path;
import java.sql.*;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashSet;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

/**
 * 加载MySQL中词库内容
 *
 * @author wanghongyu
 */
public class DictLoader {

    private static final Logger LOGGER = ESPluginLoggerFactory.getLogger(DictLoader.class.getName());

    private static final DictLoader INSTANCE = new DictLoader();

    private final String url;

    private final String username;

    private final String password;

    private final AtomicBoolean extensionWordFirstLoad = new AtomicBoolean(false);

    private final AtomicReference<String> extensionWordLastLoadTimeRef = new AtomicReference<>(null);

    private final AtomicBoolean stopWordFirstLoad = new AtomicBoolean(false);

    private final AtomicReference<String> stopWordLasLoadTimeRef = new AtomicReference<>(null);

    private DictLoader() {
        Properties mysqlConfig = new Properties();
        Path configPath = PathUtils.get(Dictionary.getSingleton().getDictRoot(), "jdbc.properties");
        try {
            mysqlConfig.load(new FileInputStream(configPath.toFile()));
            this.url = mysqlConfig.getProperty("jdbc.url");
            this.username = mysqlConfig.getProperty("jdbc.username");
            this.password = mysqlConfig.getProperty("jdbc.password");
        } catch (IOException e) {
            throw new IllegalStateException("加载jdbc.properties配置⽂件发⽣ 异常");
        }
        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
        } catch (ClassNotFoundException e) {
            throw new IllegalStateException("加载数据库驱动时发⽣异常");
        }
    }

    public static DictLoader getInstance() {
        return INSTANCE;
    }

    public void loadExtensionWords() {
        Connection connection = null;
        Statement statement = null;
        ResultSet resultSet = null;
        String sql;

        if (extensionWordFirstLoad.compareAndSet(false, true)) {
            // 首次加载全量的词
            sql = "SELECT word FROM extension_word";
        } else {
            // 后面按时间加载增量的词
            sql = "SELECT word FROM extension_word WHERE update_time >='" + extensionWordLastLoadTimeRef.get() + "'";
        }

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String nowString = sdf.format(new Date());
        extensionWordLastLoadTimeRef.set(nowString);
        // 加载扩展词词库内容
        try {
            connection = DriverManager.getConnection(url, username, password);
            statement = connection.createStatement();
            resultSet = statement.executeQuery(sql);
            LOGGER.info("从mysql加载extensionWord, sql={}", sql);
            Set<String> extensionWords = new HashSet<>();
            while (resultSet.next()) {
                String word = resultSet.getString("word");
                if (word != null) {
                    extensionWords.add(word);
                    // TODO 这⾥为了⽅便看⽇志，把加载到的扩展词全都打印出来了
                    LOGGER.info("从mysql加载extensionWord, word={}", word);
                }
            }
            // 放到字典⾥
            Dictionary.getSingleton().addWords(extensionWords);
        } catch (Exception e) {
            LOGGER.error("从mysql加载extensionWord发⽣异常", e);
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (SQLException e) {
                    LOGGER.error(e);
                }
            }
            if (null != statement) {
                try {
                    statement.close();
                } catch (SQLException e) {
                    LOGGER.error(e);
                }
            }
            if (null != connection) {
                try {
                    connection.close();
                } catch (SQLException e) {
                    LOGGER.error(e);
                }
            }
        }
    }

    public void loadMysqlStopWords() {
        Connection connection = null;
        Statement statement = null;
        ResultSet resultSet = null;
        String sql;

        if (stopWordFirstLoad.compareAndSet(false, true)) {
            sql = "SELECT word FROM stop_word";
        } else {
            sql = "SELECT word FROM stop_word WHERE update_time >= '" + stopWordLasLoadTimeRef.get() + "'";
        }
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String nowString = dateFormat.format(new Date());
        stopWordLasLoadTimeRef.set(nowString);
        // 加载词库内容
        try {
            connection = DriverManager.getConnection(url, username, password);
            statement = connection.createStatement();
            resultSet = statement.executeQuery(sql);
            LOGGER.info("从mysql加载stopWord, sql={}", sql);
            Set<String> stopWords = new HashSet<>();
            while (resultSet.next()) {
                String word = resultSet.getString("word");
                if (word != null) {
                    stopWords.add(word);
                    LOGGER.info("从mysql加载stopWord，word={}", word);
                }
            }
            // 放到字典⾥
            Dictionary.getSingleton().addStopWords(stopWords);
        } catch (Exception e) {
            LOGGER.error("从mysql加载extensionWord发⽣异常", e);
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (SQLException e) {
                    LOGGER.error(e);
                }
            }
            if (statement != null) {
                try {
                    statement.close();
                } catch (SQLException e) {
                    LOGGER.error(e);
                }
            }
            if (connection != null) {
                try {
                    connection.close();
                } catch (SQLException e) {
                    LOGGER.error(e);
                }
            }
        }
    }
}
```

然后将Dictionary的getDictRoot()改成public，在增加一个addStopWords(Collection\<String\> words)方法:

```java
/**
 * 添加停用词
 */
public void addStopWords(Collection<String> words) {
    if (null != words) {
        for (String word : words) {
            if (null != word) {
                singleton._StopWords.fillSegment(word.trim().toCharArray());
            }
        }
    }
}
```

然后在Dictionary类中最开始我们打的todo注释下完善代码

```java
new Thread(() -> {
    while (true) {
        try {
            DictLoader dictLoader = DictLoader.getInstance();
            dictLoader.loadExtensionWords();
            dictLoader.loadMysqlStopWords();
            TimeUnit.SECONDS.sleep(60);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}).start();
```

##### 4.2数据库相关

建表语句：

```mysql
CREATE TABLE `extension_word` ( `id` int(11) NOT NULL AUTO_INCREMENT, `word` varchar(64) NOT NULL, `create_time` datetime NOT NULL, `update_time` datetime NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
CREATE TABLE `stop_word` ( `id` int(11) NOT NULL AUTO_INCREMENT, `word` varchar(64) NOT NULL, `create_time` datetime NOT NULL, `update_time` datetime NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
```

config目录下新建配置文件jdbc.properties:

```properties
jdbc.url=jdbc:mysql://172.30.60.105:3306/es_ik?useUnicode=true&useSSL=false&characterEncoding=utf8&serverTimezone=Asia/Shanghai
jdbc.username=root
jdbc.password=qiyuan1502
```

##### 4.3部署

执行`mvn clean package`命令打包，然后3台es机器分别执行以下操作：

新建目录

```shell
mkdir -p /app/elasticsearch/elasticsearch-7.9.3/plugins/ik
```

然后把elasticsearch-analysis-ik-7.9.3.zip传到ik目录下解压，然后把刚刚打包的源码jar上传到ik目录里进行覆盖，把mysql-connector-java-8.0.20.jar也传上去，把jdbc.properties传到ik/config下，最后重启es：

```shell
ps -ef | grep elasticsearch
kill 24479
echo '' > /app/elasticsearch/log/escluster.log
/app/elasticsearch/elasticsearch-7.9.3/bin/elasticsearch -d
tail -f /app/elasticsearch/log/escluster.log
```

重启的时候可能会报错：

**Caused by: java.security.AccessControlException: access denied ("java.lang.RuntimePermission" "setContextClassLoader")**

解决方法：

```shell
vim /app/elasticsearch/elasticsearch-7.9.3/jdk/conf/security/java.policy

# 添加如下配置
permission java.lang.RuntimePermission "setContextClassLoader";
```

然后又遇到错

**Caused by: java.security.AccessControlException: access denied ("java.net.SocketPermission" "172.19.16.88:3306" "connect,resolve"**

在之前的配置中添加配置后再次重启：

```shell
permission java.net.SocketPermission "*", "connect,resolve";
```

上面的两个错都是java安全管理器和访问权限相关的，可以看《java核心技术 卷2》第9章。

#### 5部署拼音分词器

