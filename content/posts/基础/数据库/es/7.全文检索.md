---
title: 全文检索
tags:
  - elasticsearch
categories: 数据库
copyright: true
---

一般match都是拆词，包含一个词就可以

```json
// 查询title中包含java或者elasticsearch
GET /forum/article/_search
{
  "query": {
    "match": {
      "title": "java elasticsearch"
    }
  }
}
// 这么写的时候，es把他转换成should语法，像下面这样
GET /forum/article/_search
{
  "query": {
    "bool": {
        "should": [
            "match": {
              "title": "java"
            },
      		"match": {
              "title": "elasticsearch"
            }
        ]
    }
  }
}
```

如果想要必须都包含，也就是并且关系

```json
GET /forum/article/_search
{
  "query": {
    "match": {
      "title": {
        "query": "java elasticsearch",
        "operator": "and"
      }
    }
  }
}
// 这么写的话就会转成must，和上面的例子一样，就是把should变成must
```

至少匹配条件的3/4

```json
GET /forum/article/_search
{
  "query": {
    "match": {
      "title": {
        "query": "java elasticsearch hadoop spark",
        "minimum_should_match": "75%" // 这里可以写百分比，也可以写数字，匹配几个，也叫去长尾
      }
    }
  }
}
```

**权重**

```json
// boost越大越优先展示
GET /forum/article/_search
{
  "query": {
    "bool": {
      "must": {
        "match": {
          "title": "java"
        }
      },
      "should": [
        {
          "match": {
            "title": {
              "query": "elasticsearch",
              "boost": 3
            }
          }
        },
        {
          "match": {
            "title": {
              "query": "hadoop",
              "boost": 2
            }
          }
        }
      ]
    }
  }
}
```

***

多shard情况下，可能会导致相关度不准，因为相关度的IDF的相关度只在当前shard内计算。如果数据量分布均匀时，是不会出现这个情况的，生产环境下数据量很大，根据概率学，不会出现相关度偏差太大的情况，或者在查询时设置`search_type=dfs_query_then_fetch`，设置了这个参数，es会把所有shard的IDF放在本地global计算一下，不过一般不会设置这个，因为很影响性能。

***

如果全文检索了多个field，多个字段的相关分数之和越高越靠前，如果想要按照单个字段的相关度分数排序需要使用dis_max，如果想要把其他field的匹配度也算进去，但是不是整个匹配度，还可以配置其他的field的权重，使用tie_breaker

```json
GET /forum/article/_search
{
  "query": {
    "dis_max": {
      "queries": [
        {
          "match": {
            "title": "java solution"
          }
        },
        {
          "match": {
            "content": "java solution"
          }
        }
      ]
    }
  }
}
```

把match、boost、dis_max、tie_breaker、minimum_should_match综合起来就是multi_match：

```json
GET /forum/article/_search
{
  "query": {
    "multi_match": {
      "query": "java soution",
      "type": "best_fields", // 相当于dis_max
      "fields": ["title^2", "content"], // ^2就是boost
      "tie_breaker": 0.3,
      "minimum_should_match": "50%"
    }
  }
}
```

best_fields：单个filed匹配的越多越靠前；

most_fields：所有field匹配的越多越靠前，most_field不支持minimum_should_match；

cross_fields：配合operator: and，要求term必须全部出现，一般跨多个field搜索就用这个；

可以使用copy_to把多个字段合成一个隐藏字段，解决了most_field的弊端。

***

**近似匹配**

比如说搜索java spark，要求他俩必须全部包含。

#### phrase match

要求term间不能有其他词，原理：先找到包含java和spark的field，然后在比较这两term的position，java的position必须必spark大1。

slop参数：slop可以允许term不挨着，配置最多能移动多少次，如果移动了slop次数还没和document的field重合，就是匹配不上了，并且设置了slop参数，term就可以不按顺序来了。

```json
GET /forum/article/_search
{
  "query": {
    "match_phrase": {
      "content": "java spark",
        "slop": 3
    }
  }
}
```

#### proximity_match

加了slop的match_phrase就是proximity_match。

##### 召回率和精准度的平衡

*   召回率：搜索到的document数量在所有doc数量的比例；
*   精准度：term越近越排在前面；

混合使用match和近似匹配平衡召回率和精准度：

```json
GET /forum/article/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "title": {
              "query": "java spark",
              "minimum_should_match": "1"
            }
          }
        }
      ],
      "should": {
        "match_phrase": {
          "title": {
            "query": "java spark",
            "slop": 50
          }
        }
      }
    }
  }
}
```

***

### 搜索推荐

```json
GET /my_index/my_type/_search 
{
  "query": {
    "match_phrase_prefix": {
      "title": {
        "query": "hello d",
        "slop": 1,
        "max_expansions": 5 // 最多匹配多少
      }
    }
  }
}
```

没啥用

##### ngram

感觉像是把词放进一个字典树里了，使用ngram需要设置搜索时候的分词器，要不然查询速度太慢了。

#### 误拼写

```json
GET /my_index/my_type/_search 
{
  "query": {
    "match": {
      "title": {
        "query": "SURPIZE ME",
        "fuzziness": "AUTO", // 自动纠正误拼写
        "operator": "and"
      }
    }
  }
}
```

