---
title: 3.es-入门
tags:
  - elasticsearch
categories: 数据库
copyright: true
---

在7版本以后废弃了type类型，所以一些crud操作的命令会跟着改变

### api

cat api用来查看es中的各种数据，api结尾带上v表示结果带上列名。

##### 查看基本的集群信息

```http
GET _cat/health?v
```

这个请求完了会拿到一个结果，最主要的就是看status参数，他有3个值：

*   green：每个索引的primary shard和replica shard都是active状态；
*   yellow：部分replica shard不是active状态，处于不可用状态，当单节点启动es，创建索引默认都是有一个replica shard的，但是replica不能喝primary在一台机器上，这样就会导致这个index的状态是yellow；
*   red：部分索引的primary shard不是active状态，可能有部分数据已经丢失了；

#####	查看集群中的索引。

```http
GET _cat/indices?v
```

##### 查看索引下文档个数

```http
GET /_cat/count/{index}?h=count
```

##### 查看文档个数、索引占用磁盘空间

```http
 GET /_cat/indices/{index}?v
```

##### 创建一条索引

```http
PUT /{index}?pretty
```

##### 删除一个索引。

```http
DELETE /{index}
```

#####	添加文档

```http
PUT /{index}/_doc/{id}

PUT /{index}/_create/{id}
```

老版本使用/{index}/{type}/{id}添加文档，如果index和type不存在，es会自动创建，并且默认会把每个field都建立倒排索引，需要注意index下多个type的id也不能相同，否则会报`illegal_argument_exception`错误，但是要废弃了。

```json
// 在ecommerce索引下添加3条文档
PUT /ecommerce/_doc/1
{
    "name" : "gaolujie yagao",
    "desc" :  "gaoxiao meibai",
    "price" :  30,
    "producer" :      "gaolujie producer",
    "tags": [ "meibai", "fangzhu" ]
}
PUT /ecommerce/_doc/2
{
    "name" : "jiajieshi yagao",
    "desc" :  "youxiao fangzhu",
    "price" :  25,
    "producer" :      "jiajieshi producer",
    "tags": [ "fangzhu" ]
}

PUT /ecommerce/_doc/3
{
    "name" : "zhonghua yagao",
    "desc" :  "caoben zhiwu",
    "price" :  40,
    "producer" :      "zhonghua producer",
    "tags": [ "qingxin" ]
}
```

插入成功会返回下面的信息：

```json
{
  "_index" : "ecommerce",
  "_type" : "product",
  "_id" : "1",
  "_version" : 1,
  "result" : "created",
  // 如果是单节点会出现total=2，successful=1的情况
  // 那是因为这个索引的replica shard不存在，所以只能写一个primary shard
  "_shards" : {
    "total" : 2,
    "successful" : 1,
    "failed" : 0
  },
  "_seq_no" : 0,
  "_primary_term" : 1
}
```

##### 根据id查询文档

```http
GET /{index}/_doc/{id}
```

比如查询刚刚插入的id为1的数据，可以使用：`GET /ecommerce/product/1`命令查询，但是这个url要被停用了，代替的额命令为：GET /ecommerce/_doc/1`：

```json
{
  "_index" : "ecommerce",
  "_type" : "product",
  "_id" : "1",
  "_version" : 1,
  "_seq_no" : 0,
  "_primary_term" : 1,
  "found" : true,
  // 这个就是我们要得document
  "_source" : {
    "name" : "gaolujie yagao",
    "desc" : "gaoxiao meibai",
    "price" : 30,
    "producer" : "gaolujie producer",
    "tags" : ["meibai","fangzhu"]
  }
}
```

注意看上面的返回值里有两个字段\_seq_no和\_primary_term，下面有用

##### 修改文档：

```json
PUT /{index}/_doc/{id}

// 这么写要求参数里的field必须和es中的文档完全一样，和添加是一个url，如果少写字段那么更新成功后少写的字段也会被删掉
// 其实就是先标记成删除，然后在新增
PUT /ecommerce/_doc/1
{
    "name" : "jiaqiangban gaolujie yagao",
    "desc" :  "gaoxiao meibai",
    "price" :  30,
    "producer" :      "gaolujie producer",
    "tags": [ "meibai", "fangzhu" ]
}
```

partial update方式：

```http
POST /{index}/_update/{id}

// 如果只想更新几个指定field，其余field不变可以这么写
// partial update内部的原理和PUT的是一样的，只不过查询，替换，然后删除在新增发生在es内部
POST /ecommerce/_update/1
{
  "doc": {
    "name": "jiaqiangban gaolujie yagao"
  }
}
```

##### 修改的并发问题

多个线程同时修改是会导致脏数据问题的，可以使用乐观锁方案，在旧版本中使用version判断，新版本要使用seq_no和primary_term两个字段，在修改之前先查询，修改的时候加上刚查出来的seq_no和primary_term，seq_no和version是一个道理，但是他是属于整个index的，也就是index中的任何一条文档被修改或者新增，他都会自增，每次修改都会自增，primary_term表示文档所在主分片的编号：

```http
PUT /ecommerce/_doc/1?if_seq_no=5&if_primary_term=1
{
    "name" : "jiaqiangban gaolujie yagao",
    "desc" :  "gaoxiao meibai",
    "price" :  30,
    "producer" : "gaolujie producer1",
    "tags": [ "meibai", "fangzhu" ]
}

###
<!-- 
	partial update内部是实现了乐观锁的，但是如果版本不对会直接失败，
	请求可以使用retry_on_conflict设置乐观锁更新失败后的重试次数
-->
POST /ecommerce/_update/1?retry_on_conflict=5
{
  "doc": {
    "name": "jiaqiangban gaolujie yagao"
  }
}
```

如果使用seq_no和primary_term解决并发问题会有一个问题就是seq_no是属于整个index的，乐观锁粒度变粗**会不会有性能问题**。

#####	删除文档

```http
DELETE /{index}/{id}
```

这个是软删，不会把数据删掉，只有当磁盘不够的时候才会删。

---

### 六种搜索方式

不管那种查询返回的结果都是一样的：

```json
{
  "took" : 2, // 耗时多少毫秒
  "timed_out" : false, // 是否超时
  // shard信息，因为我单机启动所以只有一个primary shard
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 3, // 查询结果的数量
      "relation" : "eq"
    },
    "max_score" : 1.0, // 相关度，分数越大越匹配
    "hits" : [{ // 数据列表
        "_index" : "ecommerce",
        "_type" : "product",
        "_id" : "2",
        "_score" : 1.0,
        "_source" : {
          "name" : "jiajieshi yagao",
          "desc" : "youxiao fangzhu",
          "price" : 25,
          "producer" : "jiajieshi producer",
          "tags" : [
            "fangzhu"
          ]
        }
      }……]
  }
}
```

##### 1：query string search，查询请求的参数以String的方式拼接到url里

比如查询名字中含有牙膏按价格倒叙返回：`GET /ecommerce/product/_search?q=name:yagao&sort=price:desc ` :

如果什么都不写：`GET /ecommerce/product/_search`就是所有文档。

##### 2：query DSL（Domain Specified Language）就是把查询条件放在body里，是json格式。

```json
// 查询所有商品
GET /ecommerce/_search
{
  "query": {
    "match_all": {}
  }
}

// 查询名字包含yagao，倒叙返回
GET /ecommerce/_search
{
  "query": {
    "match": {
      "name": "yagao"
    }
  },
  "sort": [
    {"price": "desc"}
  ]
}

// 分页查询
GET /ecommerce/_search
{
  "query": {"match_all": {}},
  "from": 1, // 从第几条开始
  "size": 1 // 查询多少条
}

// 查询所有商品，只查询名称和价格
GET /ecommerce/_search
{
  "query": {"match_all": {}},
  "_source": ["name", "price"]
}
```

##### 3：query filter 查询里有多个条件

```json
// 查询名字包含牙膏并且价格大于25的商品
GET /ecommerce/_search
{
  "query": {
    "bool": {
      "must": [{
          "match": {
            "name": "yagao"
          }
        }],
      "filter": {
        "range": {
          "price": {"gt": 25}
        }
      }
    }
  }
}
```

##### 4：Full-text search 全文检索

其实他和上面的搜索时一样的，只是下面的搜索条件能计算出不同的相关度，也就是搜索结果的score分数不同

```json
// 全文检索，producer会先被拆解，每个词去匹配，返回的结果按匹配分数从大到小排序
GET /ecommerce/_search
{
  "query": {
    "match": {
      "producer": "yagao producer"
    }
  }
}
```

##### 5：phrase search 短语搜索

他跟上面的搜索时反过来的，不会拆词，必须全部匹配才可以，有点像SQL的like %yagao producer%

```json
GET /ecommerce/_search
{
  "query": {
    "match_phrase": {
      "producer": "yagao producer"
    }
  }
}
```

##### 6：highlight search 高亮搜索

高亮的意思就是结果里多一个highlight的字段，把field命中条件的部分用标间标记一下

```json
// 结果的producer这个field中匹配的部分高亮显示
GET /ecommerce/_search
{
  "query": {
    "match": {
      "producer": "producer"
    }
  },
  "highlight": {
    "fields": {
      "producer": {}
    }
  }
}
// 返回的结果会多一个highlight字段
"highlight" : {
    "producer" : [
        "jiajieshi <em>producer</em>"
    ]
}
```

---

### 聚合分析

```json
// 7.0之后不支持type，需要加上include_type_name参数
// PUT /ecommerce/_mapping/product?include_type_name=true，设置tags属性的fielddata为true
{
  "properties": {
    "tags": {
      "type": "text",
      "fielddata": true
    }
  }
}
// 查询每个tags的属性对应多少条数据，size：0是不查询具体数据 
// GET /ecommerce/product/_search
{
  "size": 0,
  // aggs表示聚合处理
  "aggs": {
    "group_by_tags": {
      // terms表示按照什么分组
      "terms": {
        "field": "tags"
      }
    }
  }
}

// 先按tags分组，在计算每组的平均价格
// GET /ecommerce/product/_search
{
  "size": 0, 
  "aggs": {
    "group_by_tags": {
      "terms": {
        "field": "tags"
      },
      "aggs": {
        "avg_price": {
          "avg": {
            "field": "price"
          }
        }
      }
    }
  }
}

// 在上面的基础上，把结果用avg_price降序排序
// GET /ecommerce/product/_search
{
  "size": 0, 
  "aggs": {
    "group_by_tags": {
      "terms": {
        "field": "tags",
        "order": {
          "avg_price": "desc"
        }
      },
      "aggs": {
        "avg_price": {
          "avg": {
            "field": "price"
          }
        }
      }
    }
  }
}
```

***

### 脚本

5.0之前是groovy，5.0之后换成了painless，官方不推荐使用脚本，说是会影响性能，先不研究。

***

### 批量查询

批量查询可以减少网络开销，使用GET /_mget批量获取：

```http
GET /_mget
{
  "docs": [
    {
      "_index": "ecommerce",
      "_id": 1
    }]
}
```

如果批量查询的文档都在一个index中，可以把index放到url里：

```http
GET /ecommerce/_mget
{
  "docs": [
    {
      "_id": 1
    },
    {
      "_id": 2
    }]
}
<!-- 参数也可以变成下面这样 -->
{
	"ids": [1,2]
}
```

---

### 批量操作

批量操作除了删除其他的命令都需要成对出现，第一个json串表示命令，第二个json串表示数据，批量操作的命令是POST /_bulk，批量操作有四个命令：

```json
{"delete": {"_index": "test_index","_id": 1}} // 删除操作

{"create": {"_index": "test_index","_id": 1}} // PUT 强制创建
{"testfield": "field"}

{"index": {"_index": "test_index","_id": 1}} // 普通PUT操作，可以是创建也可以是全量修改
{"testfield": "field"}

{"update": {"_index": "test_index","_id": 1}} // partial update操作
{"docs": {"testfield": "field"}}
```

bulk api要求一个json串必须在一行，每个json串单独一行，为什么要把json写到一行？在es收到批量操作后如果是随意换行，es需要把数据先转成jsonArray，然后在去拆分，在转成string去发送到不同的shard，如果是一行一行的，直接拆就完事了。数据量很大的时候把数据转成jsonArray是很费内存的，可能会频繁的yong gc。

***

### 一致性

在增删改操作的时候可以在url上加上consistency=one/all/quorum。

*   one：只要primary shard是active状态就可以执行；
*   all：primary shard和replica shard都是active才可以执行；
*   quorum：所有shard中大部分都是active就可以执行；

quorum的计算方式：(primary的数量 + number_of_replicas) / 2 + 1，number_of_replicas是每个primary对应的replica数量，其实就是shard总数 / 2 + 1，当number_of_replicas <= 1的时候不判断quorum。