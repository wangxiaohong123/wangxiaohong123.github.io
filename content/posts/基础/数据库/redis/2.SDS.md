---
title: redis-2.SDS
tags:
  - redis
categories: 数据库
copyright: true
---

##### 1.SDS结构

redis3.2之前的SDS长这样：

| free(4字节) | len(4字节)  | buf[]                    |
| ----------- | ----------- | ------------------------ |
| buf剩余长度 | buf使用长度 | 字符数组，最后一位是'\0' |

free+len固定需要8字节，这样有个弊端，当字符串很小的时候可能2个字节就够了，如果字符串很大可能4字节还存不下长度，所以redis5之后针对free和len改成了5种sdshdr：

1.   sdshdr5：常量字符串，不支持扩容，使用1个字节标识，低3位表示类型(比如sdshdr5类型)，高5位表示len；

2.   sdshdr8：他多了一个alloc记录总长度：

     | len        | alloc  | flags                           | buf[]    |
     | ---------- | ------ | ------------------------------- | -------- |
     | 已使用长度 | 总长度 | 1字节，低3位表示类型，高5位预留 | 字符数组 |

3.   sdshdr16、sdshdr32、sdshdr64和sdshdr8是一样的，不过len和alloc的类型不一样，分别使用uint8(无符号1字节int)、uint16、uint32、uint64。

对应的结构体：

```c
/**
 * __attribute__ ((__packed__))是优化对齐
 */
struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
```

##### 2.创建字符串

创建字符串对应sds.c的sdsnewlen()方法：

```c
sds sdsnewlen(const void *init, size_t initlen) {
    // sds指针
    void *sh;
    // 返回的结果，因为返回的是buf[]指针
    // 所以这个就可以理解成buf[]
    sds s;
    // 根据长度确定类型
    char type = sdsReqType(initlen);
    /* Empty strings are usually created in order to append. Use type 8
     * since type 5 is not good at this. */
    // 如果type是sdshdr5并且字符串是空，把类型改成sdshdr8
    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;
    // 这个是当前类型的头长度，就是len、alloc、flag这些
    int hdrlen = sdsHdrSize(type);
    unsigned char *fp; /* flags pointer. */
    // 根据长度申请内存空间，头 + 体 + '\0'
    sh = s_malloc(hdrlen+initlen+1);
    if (init==SDS_NOINIT)
        init = NULL;
    else if (!init)
        memset(sh, 0, hdrlen+initlen+1);
    if (sh == NULL) return NULL;
    // 把s指向buf[]
    s = (char*)sh+hdrlen;
    // buf[]的上一位就是flags的位置
    fp = ((unsigned char*)s)-1;
    // 初始化
    switch(type) {
        case SDS_TYPE_5: {
            *fp = type | (initlen << SDS_TYPE_BITS);
            break;
        }
        case SDS_TYPE_8: {
            SDS_HDR_VAR(8,s);
            sh->len = initlen;
            sh->alloc = initlen;
            *fp = type;
            break;
        }
        case SDS_TYPE_16: {
            SDS_HDR_VAR(16,s);
            sh->len = initlen;
            sh->alloc = initlen;
            *fp = type;
            break;
        }
        case SDS_TYPE_32: {
            SDS_HDR_VAR(32,s);
            sh->len = initlen;
            sh->alloc = initlen;
            *fp = type;
            break;
        }
        case SDS_TYPE_64: {
            SDS_HDR_VAR(64,s);
            sh->len = initlen;
            sh->alloc = initlen;
            *fp = type;
            break;
        }
    }
    // 拷贝
    if (initlen && init)
        memcpy(s, init, initlen);
    // 最后一位添加结束符
    s[initlen] = '\0';
    // 返回buf[]
    return s;
}
```

**注意：当我们创建空字符串的时候并不会创建sdshdr5类型的SDS，因为sdshdr5是常量，redis认为如果初始化的时候是空串，很可能会对他进行修改，所以会创建一个sdshdr8类型的字符串。**

##### 3.释放字符串

释放分两种，保留内存和释放内存，释放内存的在sdsfree()函数里：

```c
void sdsfree(sds s) {
    // 空就返回
    if (s == NULL) return;
    // 先把指针指向sds的头，s指针的上一位就是flags，flags里有sds的type，根据type能计算head的长度，就可以把指针移动到sds的起始地址了
    // 然后调用s_free()释放内存
    s_free((char*)s-sdsHdrSize(s[-1]));
}
```

保留内存是sdsclear()函数：

```c
void sdsclear(sds s) {
    // len赋值成0
    sdssetlen(s, 0);
    // 清空buf[]
    s[0] = '\0';
}
```

##### 4.字符串拼接

字符串拼接的流程很简单，但是他需要判断是否需要扩容，拼串是sdscatsds()函数，sdscatsds()里面调用了sdscatlen()函数：

```c
sds sdscatlen(sds s, const void *t, size_t len) {
    // 当前buf[]的长度
    size_t curlen = sdslen(s);
    // 判断是否需要扩容,需要扩容就返回扩容后的sds
    s = sdsMakeRoomFor(s,len);
    if (s == NULL) return NULL;
    // 拼串
    memcpy(s+curlen, t, len);
    // 设置新串的长度
    sdssetlen(s, curlen+len);
    // 结尾加结束符
    s[curlen+len] = '\0';
    return s;
}
```

扩容的代码：

```c
sds sdsMakeRoomFor(sds s, size_t addlen) {
    void *sh, *newsh;
    // 计算剩余空间
    size_t avail = sdsavail(s);
    size_t len, newlen;
    // 获取type
    char type, oldtype = s[-1] & SDS_TYPE_MASK;
    int hdrlen;

    /* Return ASAP if there is enough space left. */
    // 如果可用空间>=要拼接的字符串长度直接返回
    if (avail >= addlen) return s;
    
    // 拿到已使用长度
    len = sdslen(s);
    // 指向sds头的指针
    sh = (char*)s-sdsHdrSize(oldtype);
    // 拼串之后的长度
    newlen = (len+addlen);
    // 下面处理预留空间的
    if (newlen < SDS_MAX_PREALLOC)
        // 如果新长度小于1M，扩容成2倍
        newlen *= 2;
    else
        // 否则扩容成新长度 + 1M
        newlen += SDS_MAX_PREALLOC;

    // 通过新长度计算type
    type = sdsReqType(newlen);

    /* Don't use type 5: the user is appending to the string and type 5 is
     * not able to remember empty space, so sdsMakeRoomFor() must be called
     * at every appending operation. */
    // 不使用sdshdr5存储，因为5不能存空格
    if (type == SDS_TYPE_5) type = SDS_TYPE_8;
    // 根据type计算头长度
    hdrlen = sdsHdrSize(type);
    if (oldtype==type) {
        // 扩容之后类型不变扩展空间
        // 应该就是重新申请内存
        newsh = s_realloc(sh, hdrlen+newlen+1);
        if (newsh == NULL) return NULL;
        // 指针指向新buf[]
        s = (char*)newsh+hdrlen;
    } else {
        /* Since the header size changes, need to move the string forward,
         * and can't use realloc */
        // 申请新空间
        newsh = s_malloc(hdrlen+newlen+1);
        if (newsh == NULL) return NULL;
        // 拷贝数据
        memcpy((char*)newsh+hdrlen, s, len+1);
        s_free(sh);
        // 修改指针
        s = (char*)newsh+hdrlen;
        // flags赋值
        s[-1] = type;
        // len赋值
        sdssetlen(s, len);
    }
    // 设置总长度
    sdssetalloc(s, newlen);
    // 返回buf[]
    return s;
}
```

我觉得扩容之后type有没有改变都需要扩容buf[]，buf[]和头需要保持一致，那么内存地址一定会发生改变，就需要拷贝数据，但是源码里只调用了s_realloc()函数，猜测s_realloc()有复制原数据的操作。

##### 5.字符串的编码

字符串的编码分3种，主要也是为了省空间：

*   embstr：字符串长度<=44字节使用这个编码；
*   raw：其他情况使用这个编码(数字除外)；
*   int：整数类型字符串使用这个编码；

字符串的编码在object.c的createStringObject()函数里:

```c
#define OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44
robj *createStringObject(const char *ptr, size_t len) {
    // 根据长度使用不同编码
    if (len <= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)
        // 短字符串编码
        return createEmbeddedStringObject(ptr,len);
    else
        // 普通字符串编码
        return createRawStringObject(ptr,len);
}
```

在进行编码之后还会判断字符串是不是可以使用int编码格式存储，在tryObjectEncoding()函数里：

```c
robj *tryObjectEncoding(robj *o) {
    long value;
    sds s = o->ptr;
    size_t len;

    /* Make sure this is a string object, the only type we encode
     * in this function. Other types use encoded memory efficient
     * representations but are handled by the commands implementing
     * the type. */
    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);

    /* We try some specialized encoding only for objects that are
     * RAW or EMBSTR encoded, in other words objects that are still
     * in represented by an actually array of chars. */
    if (!sdsEncodedObject(o)) return o;

    // 如果这个对象被使用就不进行编码优化
     if (o->refcount > 1) return o;

    len = sdslen(s);
    // 长度小于20进行数字转化，转成long long
    if (len <= 20 && string2l(s,len,&value)) {
        if ((server.maxmemory == 0 ||
            !(server.maxmemory_policy & MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) &&
            value >= 0 &&
            // OBJ_SHARED_INTEGERS是10000
            value < OBJ_SHARED_INTEGERS)
        {
            decrRefCount(o);
            incrRefCount(shared.integers[value]);
            // 根据索引返回共享的整型数组的value
            return shared.integers[value];
        } else {
            // 转成其他整型
            if (o->encoding == OBJ_ENCODING_RAW) sdsfree(o->ptr);
            o->encoding = OBJ_ENCODING_INT;
            o->ptr = (void*) value;
            return o;
        }
    }

    // 不能转换编码就简单处理返回了，代码省略
}
```

简单来看的话就是如果这个字符串可以转成数字，就判断内存和数字是不是小于10000，**redis在启动的时候会初始化一个全局共享的0～9999数组，所以只有当索引大于等于0小于10000的时候才能在这个数组里拿到值**，满足条件会返回共享数组里的value，否则就转成其他整型。
