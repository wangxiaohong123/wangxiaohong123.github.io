---
title: redis-3.跳表
tags:
  - redis
categories: 数据库
copyright: true
---

##### 1.结构

![跳表数据结构](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/跳表数据结构.png)

跳表的结构体：

```c
// 跳表节点
typedef struct zskiplistNode {
    // 跳表的value
    sds ele;
    // 跳表的score
    double score;
    // 指向最底层的前一个节点的指针
    struct zskiplistNode *backward;
    // 有几层就会有几个元素
    struct zskiplistLevel {
        // 同一层的下一个元素
        struct zskiplistNode *forward;
        // 到下一个节点跳过了多少个节点
        unsigned long span;
    } level[];
} zskiplistNode;

// 跳跃表节点链表
typedef struct zskiplist {
    // 头尾指针
    // 头节点的level长度是64，ele是空，score等于0，
    struct zskiplistNode *header, *tail;
    // 跳表长度(不包括头节点)
    unsigned long length;
    // 跳表高度
    int level;
} zskiplist;
```



##### 2.创建跳表

创建跳表比较简单，主要在申请内存，初始化header信息，**在创建跳表的时候会直接创建64层的header**，代码对应t_zset.c的zslCreate()函数：

```c
zskiplist *zslCreate(void) {
    int j;
    // 定义一个跳表
    zskiplist *zsl;
    // 申请内存
    zsl = zmalloc(sizeof(*zsl));
    // 层高是1
    zsl->level = 1;
    // 长度是0
    zsl->length = 0;
    // 创建头节点，层高传的最大值，score是0，ele是null
    zsl->header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);
    // header的每层forward先赋空，跨度赋0
    for (j = 0; j < ZSKIPLIST_MAXLEVEL; j++) {
        zsl->header->level[j].forward = NULL;
        zsl->header->level[j].span = 0;
    }
    zsl->header->backward = NULL;
    zsl->tail = NULL;
    return zsl;
}
```

##### 3.查找排位

查找排位就是找到目标元素的index，利用span(当前节点到下一个节点跨越的最底层节点数)找到index，对应的代码在t_zset.c的zslGetRank()

```c
unsigned long zslGetRank(zskiplist *zsl, double score, sds ele) {
    zskiplistNode *x;
    unsigned long rank = 0;
    int i;

    x = zsl->header;
    // 从最高层level开始
    for (i = zsl->level-1; i >= 0; i--) {
        // x->level[i].forward 有下一个节点
        // x->level[i].forward->score < score 下一个节点的分数小于目标分数
        // x->level[i].forward->score == score 下一个节点的分数等于目标分数
        // sdscmp(x->level[i].forward->ele,ele) <= 0 下一个节点的ele小于目标ele
        while (x->level[i].forward &&
            (x->level[i].forward->score < score ||
                (x->level[i].forward->score == score &&
                sdscmp(x->level[i].forward->ele,ele) <= 0))) {
            // 累加当前节点的span
            rank += x->level[i].span;
            // 跳到本层的下一个节点
            x = x->level[i].forward;
        }

        /* x might be equal to zsl->header, so test if obj is non-NULL */
        // 找到元素返回排位值
        if (x->ele && sdscmp(x->ele,ele) == 0) {
            return rank;
        }
    }
    return 0;
}
```

所有根据rank的查找都和这个类似，比如zslGetElementByRank，因为他是个链表，没法根据index直接拿到节点，所以他需要按照zslGetRank的思路遍历累加span，直到累加的span和目标rank相同。

##### 4.插入节点

插入节点分3步：找到要插入的位置->随机层高->插入数据，代码在t_zset.c的zslInsert()函数里:

```c
zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
    // update是记录搜索的节点， x是指向新增节点的指针
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    // rank用来计算和下一个节点的span，因为新增节点会产生随机层数，有几层rank数组就会有几个元素
    unsigned int rank[ZSKIPLIST_MAXLEVEL];
    int i, level;

    serverAssert(!isnan(score));
    x = zsl->header;
    // 从顶层遍历，找到要插入的位置
    for (i = zsl->level-1; i >= 0; i--) {
        // 如果是顶层的话rank[i]赋值成0，否则rank[i]=rank[i+1]
        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];
        // 查找的逻辑和zslGetRank()差不多
        while (x->level[i].forward &&
                (x->level[i].forward->score < score ||
                    (x->level[i].forward->score == score &&
                    sdscmp(x->level[i].forward->ele,ele) < 0)))
        {
            // 本城rank累加
            rank[i] += x->level[i].span;
            x = x->level[i].forward;
        }
        // 记录搜索的节点
        update[i] = x;
    }
    
    // 获得随机层高
    level = zslRandomLevel();
    // level大于层高的处理
    if (level > zsl->level) {
        for (i = zsl->level; i < level; i++) {
            rank[i] = 0;
            update[i] = zsl->header;
            update[i]->level[i].span = zsl->length;
        }
        zsl->level = level;
    }
    // 创建新节点
    x = zslCreateNode(level,score,ele);
    // 开始设置有关节点的forward、span、backword等属性
    for (i = 0; i < level; i++) {
        x->level[i].forward = update[i]->level[i].forward;
        update[i]->level[i].forward = x;

        /* update span covered by update[i] as x is inserted here */
        x->level[i].span = update[i]->level[i].span - (rank[0] - rank[i]);
        update[i]->level[i].span = (rank[0] - rank[i]) + 1;
    }

    /* increment span for untouched levels */
    for (i = level; i < zsl->level; i++) {
        update[i]->level[i].span++;
    }
    x->backward = (update[0] == zsl->header) ? NULL : update[0];
    if (x->level[0].forward)
        x->level[0].forward->backward = x;
    else
        zsl->tail = x;
    zsl->length++;
    return x;
}
```

随即层高的代码：

```c
int zslRandomLevel(void) {
    int level = 1;
    // ZSKIPLIST_P是晋升率，配置的是0.25
    // 0xFFFF是65535，ZSKIPLIST_P * 0xFFFF=16383.75(约等于16384)
    // 生成一个随机数和65535做与运算，如果小于16384就把层高+1
    // 可以理解成每次都是ZSKIPLIST_P的概率让层高+1
    while ((random()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF))
        level += 1;
    // level小于64就返回level，大于64就返回64
    return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
}
```

##### 5.删除节点

```c
int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    int i;

    // 遍历找到要删除的节点
    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
                (x->level[i].forward->score < score ||
                    (x->level[i].forward->score == score &&
                     sdscmp(x->level[i].forward->ele,ele) < 0)))
        {
            x = x->level[i].forward;
        }
        update[i] = x;
    }
    
    x = x->level[0].forward;
    if (x && score == x->score && sdscmp(x->ele,ele) == 0) {
        // 删除节点，修改span、level、forward这些东西
        zslDeleteNode(zsl, x, update);
        // 释放内存
        if (!node)
            zslFreeNode(x);
        else
            *node = x;
        return 1;
    }
    /* not found */
    return 0;
}
```

