---
title: springboot+哨兵
tags:
  - redis
categories: 数据库
copyright: true
---

### 作用

* 集群监控，负责监控redis master和slave进程是否正常工作
* 消息通知，如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员
* 故障转移，如果master node挂掉了，会自动转移到slave node上，同时会修改redis的配置文件
* 配置中心，如果故障转移发生了，通知client客户端新的master地址

quorum = 1（配置）：当主节点挂掉时，需要至少多少个哨兵节点认为master宕机就会进行主备切换；majority（概念）：哨兵运行数的最小值，比如当两个哨兵集群时，majority就是2，三个哨兵集群时，majority还是2，如果是两个哨兵集群，redis所在的服务器宕机，哨兵也不可用，此时majority数变成1，无法完成主备切换，所以哨兵一般最少三个集群。

### 主观宕机和客观宕机

一个哨兵认为master宕机叫做主管宕机，quorum数量的哨兵都觉得master宕机了就是客观宕机，这时候会进行主备切换。

### 选举机制

* (down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state，理解为一个salve跟master断开连接的时间太长不参加选举
* 按照slave优先级进行排序，slave priority越低，优先级就越高
* 如果slave priority相同，再看salve同步数据的偏移量，哪个slave复制了越多的数据，offset越靠后，优先级就越高
* 如果上面两个条件都相同，那么选择一个run id比较小的那个slave

### 搭建

一个哨兵集群可以监控多个redis主从，哨兵集群需要最少三台redis，这三个redis只要解压执行make、make test、make install即可。

三台机器分别执行如下操作：

创建两个目录

```shell
mkdir /etc/sentinel
mkdir -p /var/sentinel/5000
mkdir -p /var/log/sentinel/5000
```

将redis目录下的sentinel.conf拷贝到本地修改名字为5000.conf并修改配置：

```shell
# 后台启动
daemonize yes
# 日志输出路径
logfile /var/log/sentinel/5000
# 哨兵所在虚拟机ip
bind 192.168.0.6
port 5000
dir /var/sentinel/5000
# redismaster节点的ip
# mymaster：redis主备集群名称
# 2：quorum值
sentinel monitor mymaster 192.168.0.3 6379 2
# 主备切换时，超过30s没切换成功由另一个哨兵进行切换
sentinel down-after-milliseconds mymaster 30000
# 主备切换之后，原来的salve需要重新绑定master并同步数据，1就是一次绑定1个salve
sentinel parallel-syncs mymaster 1
# master的redis密码
sentinel auth-pass mymaster redis-pass
```

将5000.conf上传到/etc/sentinel目录下。

***

**启动哨兵**：redis-sentinel /etc/sentinel/5000.conf

进入哨兵客户端：redis-cli -h 192.168.0.3 -p 5000

* 查看mymaster集群的master信息：sentinel master mymaster
* 查看mymaster集群的slaves信息：sentinel slaves mymaster
* 查看其它哨兵信息：sentinel sentinels mymaster
* 查看mymaster集群的master的地址：sentinel get-master-addr-by-name mymaster

停止某个哨兵后需要在其他哨兵上执行SENTINEL RESET *；

slave下线的时候需要在所有哨兵执行SENTINEL RESET mymaster

### 使用RedirTemplete操作redis主从

主要是想试验一下spring对哨兵的支持，随便创建个springboot项目，创建一个user表，配置文件：

```yaml
server:
  port: 8081
spring:
  application:
    name: eshop
  datasource:
    type: com.zaxxer.hikari.HikariDataSource
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://192.168.0.6:3306/eshop?useUnicode=true&characterEncoding=utf-8
    username: root
    password: root
    hikari:
      initialSize: 10
      minIdle: 5
      maxWait: 60000
      maxActive: 100
      timeBetweenEvictionRunsMillis: 60000
      minEvictableIdleTimeMillis: 300000
      validationQuery: SELECT 1 FROM DUAL
      testWhileIdle: true
      filters: stat,wall,slf4j
      connectionProperties: durid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000
  redis:
  	# 配置哨兵之后不需要配置redis的ip和端口
    sentinel:
      password:
      master: mymaster
      nodes: 192.168.0.3:5000,192.168.0.5:5000,192.168.0.6:5000
    database: 0
    # Redis服务器连接密码（默认为空）
    password:
    # 连接池最大连接数（使用负值表示没有限制）
    jedis:
      pool:
        max-active: 300
        # 连接池最大阻塞等待时间（使用负值表示没有限制）
        max-wait: 1s
        # 连接池中的最大空闲连接
        max-idle: 100
        # 连接池中的最小空闲连接
        min-idle: 50
    # 连接超时时间（毫秒）
    timeout: 1000ms
mybatis-plus:
  mapper-locations: classpath:/mybatis/*Mapper.xml
  type-aliases-package: com.xiaohong.eshop.inventory.entity.web
  global-config:
    db-config:
      id-type: auto
      field-strategy: not_empty
      capital-mode: true
  configuration:
    # 驼峰转下划线
    map-underscore-to-camel-case: true
    cache-enabled: false
    # 不加这个查询字段为空时会被隐藏
    call-setters-on-nulls: true
```

相关依赖：

```xml
<dependencies>
		<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-test</artifactId>
        </dependency>
        <!--测试类-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
        <!--spring boot 配置类注解-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>


        <!--集合操作-->
        <dependency>
            <groupId>commons-collections</groupId>
            <artifactId>commons-collections</artifactId>
            <version>3.2.1</version>
        </dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
			<exclusions>
				<exclusion>
					<groupId>org.junit.vintage</groupId>
					<artifactId>junit-vintage-engine</artifactId>
				</exclusion>
			</exclusions>
		</dependency>

		<!--阿里的json转换-->
		<dependency>
			<groupId>com.alibaba</groupId>
			<artifactId>fastjson</artifactId>
			<version>1.2.59</version>
		</dependency>
        <!--集合操作-->
        <dependency>
            <groupId>commons-collections</groupId>
            <artifactId>commons-collections</artifactId>
            <version>3.2.1</version>
        </dependency>
        <!--mysql的连接-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
        <!--mybatisplus-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.0.7.1</version>
        </dependency>
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-generator</artifactId>
            <version>3.0.7.1</version>
        </dependency>
        <!--jedis-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>3.7</version>
        </dependency>
    </dependencies>
```

随便写一个bean初始化Redistemplete

```java
@Bean
public RedisTemplate<String, String> redisTemplate(RedisConnectionFactory factory) {
    StringRedisTemplate template = new StringRedisTemplate(factory);
    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
    ObjectMapper om = new ObjectMapper();
    om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
    jackson2JsonRedisSerializer.setObjectMapper(om);
    //如果key是String 需要配置一下StringSerializer,不然key会乱码 /XX/XX
    template.setValueSerializer(jackson2JsonRedisSerializer);
    template.afterPropertiesSet();
    return template;
}
```

然后写一个方法查询缓存，如果没有就去数据库中查在加到redis中，如果有直接返回，主从都工作时是好使的，然后kill掉master节点，这时候访问会报错，因为master挂掉了，从节点还是readonly，过一会哨兵把主从切换完控制台会打印主备切换信息，这个时候就可以正常使用了，所以主从集群的redis操作最好加上异常处理，没有配置哨兵bean也可以，再看看是不是读写分离，首先安装tcpdump准备抓包：

```shell
yum install -y tcpdump
```

然后运行tcpdum监听指定主机加端口的tcp数据包：

```shell
# 192.168.0.175是我的项目运行主机ip，6379是redis端口
tcpdump tcp port 6379 and src host 192.168.0.175
```

执行查询测试方法会看到redis的从节点抓取到了数据包：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gatx4jzek3j30v404ogly.jpg)

