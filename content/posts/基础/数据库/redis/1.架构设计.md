---
title: redis-1.架构设计
tags:
  - redis
categories: 数据库
copyright: true
---

#### 1.resp协议

resp是redis client和server通信的序列化协议，协议的语法：

*   间隔符：\r\n(linux)；\n(windows)
*   短字符：+
*   长字符串：\$
*   整数：:
*   数组：\*
*   error：-

```shell
# SET name why
# 转换成RESP格式：
# 参数和参数表示符之间都需要使用\r\n分割
# *3表示命令的参数有3个
# $3表示后面跟着长度是3的参数
*3\r\n$3\r\nSET\r\n$4\r\nname\r\n$3\r\nwhy\r\n
```

##### 1.1 redis中的请求响应模式：

1.   串行模式：一次请求一次响应。
2.   双工模式：TCP本身就是双工的，redis中的双工就是批量处理，pipeline。
3.   原子化的批量模式：把多个请求放进一个命令队列。
4.   发布订阅模式：类似消息队列。
5.   脚本化的批量模式：处理lua脚本。

#### 2.启动流程

redis服务端的启动类是server.c，客户端的启动类是redis-cli.c(cli不是client的缩写，是command line interface的缩写)，这两个文件都在src目录下。redis-cli.c的代码还有一部分在deps/hiredis/hiredis.c文件里。

redis启动的时候server.c会先初始化配置，然后初始化服务器，然后加载持久化文件到内存，最后启动事件处理器:

![redis启动流程](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/redis启动流程.png)

#### 3.命令处理流程

redis的命令都存储在RedisCommandTable里，存储的结构体叫redisCommand，这个结构体定义在server.h文件中：

```c
struct redisCommand {
    // 命令名
    char *name;
    // 命令处理函数
    redisCommandProc *proc;
    /**
     * 用来校验的
     *参数数量 > 0时，arity表示参数数量，参数数量 <= 0时，arity > 参数数量
     */
    int arity;
    /**
     * 命令标识，用来区分是什么命令
     * 比如w：写命令；r：读命令；F：记录超时的命令；m：如果内存不足就不执行
     * 命令标识可以组合，比如rF：执行读命令，并且记录超时
     */
    char *sflags; /* Flags as string representation, one char per flag. */
    // sflags的二进制标识
    int flags;    /* The actual flags, obtained from the 'sflags' field. */
    /* Use a function to determine keys arguments in a command line.
     * Used for Redis Cluster redirect. */
    redisGetKeysProc *getkeys_proc;
    /* What keys should be loaded in background when calling this command? */
    int firstkey; /* The first argument that's a key (0 = no keys) */
    int lastkey;  /* The last argument that's a key */
    int keystep;  /* The step between first and last key */
    /**
     * 从服务器启动到现在命令的执行时间和次数
     */
    long long microseconds, calls;
};
```

RedisCommandTable里维护了所有合法的命令，他是一个数组，查找是O(n)，要优化这个就需要把命令放到字典中，key就是命令名，value是redisCommand，字典形式存储命令的方法叫populateCommandTable。

![redis命令处理流程](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/redis命令处理流程.png)

##### 3.1 resp的返回

返回类型有5种：

1.   +ok : 成功 
2.   -Err :失败
3.   : 数字 
4.   \$6 foobar
5.   \*3 数组

返回结果有2步：将数据写入缓冲区或者输出链表(输出链表存在于磁盘)->把缓冲区的数据发送给客户端。**当返回响应的数据过大时，buf无法存储response就会使用replay进行存储，beforeSleep()方法优先遍历buf，也就是说涉及到大数据量的请求可能并不是处理满，而是server优先返回小数据，当buf为空的时候才会去处理replay里的response**

#### 4.底层数据结构

redis中每个db都是redisDb结构体，里面存储的是kv键值对，v使用redisObject结构体封装，redisObject中有个type变量标记具体的类型，在redis5之后基本数据类型有6个：

1.   String：SDS实现，SDS有3种实现，int、embstr和raw；
2.   List：quickList实现；
3.   Set：dict或者intSet实现；
4.   SortSet：skipList或者zipList实现；
5.   Hash：dict或者zipList实现；
6.   Stream：listPack(紧凑列表)或者RaxTree(基数树)实现，主要是用来实现消息队列用法;

#### 5.持久化

redis的持久化不是为了保证数据的完整性，主要是为了做数据恢复。RDB的配置是n秒发生m条数据变化就持久化，这样意外宕机数据肯定是不全的，AOF有3个配置：aof_async_always、aof_async_no和aof_async_EVERSEC，第一个性能太差，后两个会丢数据。

redis的意义是为了提高查询速度，如果配置了aof_async_always会降低性能，只要保证大部分的数据在redis中，冷起之后不会造成缓存穿透等问题就可以。

##### 5.1 RDB

linux的fork会复制代码和数据，而redis的数据都在内存里，所以如果redis的RDB也这么做会阻塞很久而且内存可能都不够。

redis中把数据进行分段，每段中包含了若干个数据，在fork子进程的时候会根据内存中的数据地址创建一个新的虚拟地址，使用自己的地址进行备份，如果数据发生改变会由linux内核把改变的数据所在的段同步给子进程。

RDB的文件结构：

| REDIS  | RDB_VERSION  | AUX_FILED_KEY_VALUE_PAIRS                                   | DB_NUM     | DB_DICT_SIZE     | EXPIRE_DICT_SIZE      | KEY_VALUE_PAIRS | EOF      | CHECK_SUM                    |
| ------ | ------------ | ----------------------------------------------------------- | ---------- | ---------------- | --------------------- | --------------- | -------- | ---------------------------- |
| 固定值 | 当前文件编号 | 一些附加信息，比如redis的版本、是不是aof和rdb的混合文件等等 | 属于哪个db | db里的dict的size | 过期的dict的key的数量 | 真正的数据      | 结束标志 | 校验数，用来判断文件是否完整 |

RDB对应的源码是rdb.c，在他的头文件rdb.h中定义了一个**opcodes**，用来存放一些固定配置，比如EOF是255等：

```c
#define RDB_OPCODE_MODULE_AUX 247   /* Module auxiliary data. */
#define RDB_OPCODE_IDLE       248   /* LRU idle time. */
#define RDB_OPCODE_FREQ       249   /* LFU frequency. */
#define RDB_OPCODE_AUX        250   /* RDB aux field. */
#define RDB_OPCODE_RESIZEDB   251   /* Hash table resize hint. */
#define RDB_OPCODE_EXPIRETIME_MS 252    /* Expire time in milliseconds. */
#define RDB_OPCODE_EXPIRETIME 253       /* Old expire time in seconds. */
#define RDB_OPCODE_SELECTDB   254   /* DB number of the following keys. */
#define RDB_OPCODE_EOF        255   /* End of the RDB file. */

/* Module serialized values sub opcodes */
#define RDB_MODULE_OPCODE_EOF   0   /* End of module value. */
#define RDB_MODULE_OPCODE_SINT  1   /* Signed integer. */
#define RDB_MODULE_OPCODE_UINT  2   /* Unsigned integer. */
#define RDB_MODULE_OPCODE_FLOAT 3   /* Float. */
#define RDB_MODULE_OPCODE_DOUBLE 4  /* Double. */
#define RDB_MODULE_OPCODE_STRING 5  /* String. */
```

RDB的触发方式有两种：

*   配置触发：通过配置的n秒发生m条数据变化就持久化，通过ServerCron函数调用rdbSaveBackground函数；
*   命令触发：执行命令进行rdb会调用bgSaveCommand函数，他也会去调用rdbSaveBackground函数；

rob.c下的rdbSaveBackground函数：

```c
int rdbSaveBackground(char *filename, rdbSaveInfo *rsi) {
    pid_t childpid;
    long long start;
    // 判断是否有aof或者rdb的子进程在执行
    // 如果正在备份就直接返回
    if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;

    server.dirty_before_bgsave = server.dirty;
    server.lastbgsave_try = time(NULL);
    openChildInfoPipe();

    start = ustime();
    // 调用os fork一个子进程
    if ((childpid = fork()) == 0) {
        // 如果创建子进程成功进入到这个逻辑
        int retval;
        /* Child */
        closeListeningSockets(0);
        redisSetProcTitle("redis-rdb-bgsave");
        // save rdb文件，这里会创建临时文件，写数据，然后替换原来的RDB文件
        retval = rdbSave(filename,rsi);
        if (retval == C_OK) {
            size_t private_dirty = zmalloc_get_private_dirty(-1);

            if (private_dirty) {
                serverLog(LL_NOTICE,
                    "RDB: %zu MB of memory used by copy-on-write",
                    private_dirty/(1024*1024));
            }

            server.child_info_data.cow_size = private_dirty;
            sendChildInfo(CHILD_INFO_TYPE_RDB);
        }
        exitFromChild((retval == C_OK) ? 0 : 1);
    } else {
        /* Parent ……*/
    }
    return C_OK; /* unreached */
}
```

##### 5.2 AOF

AOF文件存储的是RESP格式的指令，他有3种save方式：

*   aof_fsync_no：不保存，但是redis停止、aof停止、内存满了都会保存；
*   aof_fsync_eversec：每秒保存；
*   aof_fsync_always：每次数据变更都会触发aof写；

AOF过程分两步：

*   write：在执行名的call函数里调用propagate函数->feedAppendOnlyFile函数，通过这个函数把命令写到aof_buf
*   save：真正的保存，4个地方可以触发真正保存操作：
    *   serverCron函数中调用flushAppendOnlyFile(0)函数(serverCron看起来像redis中所有定时任务的包装)；
    *   beforeSleep函数中调用flushAppendOnlyFile(0)函数；
    *   prepareForShutDown函数中调用flushAppendOnlyFile(1)函数；
    *   stopAppendOnly函数中调用flushAppendOnlyFile(1)函数；

其实核心就两个方法：feedAppendOnlyFile()和flushAppendOnlyFile()，flushAppendOnlyFile()如果收到的是1表示强制执行。

###### 5.2.1 feedAppendOnlyFile函数的代码：

```c
void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc) {
    // 定义空字符串
    sds buf = sdsempty();
    robj *tmpargv[3];

    // 这里会判断aof的是不是当前db，如果不是就发送select命令，选择目标db
    if (dictid != server.aof_selected_db) {
        char seldb[64];

        snprintf(seldb,sizeof(seldb),"%d",dictid);
        buf = sdscatprintf(buf,"*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n",
            (unsigned long)strlen(seldb),seldb);
        server.aof_selected_db = dictid;
    }

    // 把命令转成resp格式，就是把过期时间和正常命令分开转换
    if (cmd->proc == expireCommand || cmd->proc == pexpireCommand ||
        cmd->proc == expireatCommand) {
        // 过期时间相关命令
        /* Translate EXPIRE/PEXPIRE/EXPIREAT into PEXPIREAT */
        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[1],argv[2]);
    } else if (cmd->proc == setexCommand || cmd->proc == psetexCommand) {
        // pset命令处理
        /* Translate SETEX/PSETEX to SET and PEXPIREAT */
        tmpargv[0] = createStringObject("SET",3);
        tmpargv[1] = argv[1];
        tmpargv[2] = argv[3];
        buf = catAppendOnlyGenericCommand(buf,3,tmpargv);
        decrRefCount(tmpargv[0]);
        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[1],argv[2]);
    } else if (cmd->proc == setCommand && argc > 3) {
        // 带过期时间的set命令处理
        int i;
        robj *exarg = NULL, *pxarg = NULL;
        /* Translate SET [EX seconds][PX milliseconds] to SET and PEXPIREAT */
        buf = catAppendOnlyGenericCommand(buf,3,argv);
        for (i = 3; i < argc; i ++) {
            if (!strcasecmp(argv[i]->ptr, "ex")) exarg = argv[i+1];
            if (!strcasecmp(argv[i]->ptr, "px")) pxarg = argv[i+1];
        }
        serverAssert(!(exarg && pxarg));
        if (exarg)
            buf = catAppendOnlyExpireAtCommand(buf,server.expireCommand,argv[1],
                                               exarg);
        if (pxarg)
            buf = catAppendOnlyExpireAtCommand(buf,server.pexpireCommand,argv[1],
                                               pxarg);
    } else {
        // 其他命令处理
        buf = catAppendOnlyGenericCommand(buf,argc,argv);
    }

    if (server.aof_state == AOF_ON)
        // 把拼好的buf写入到aof_buf
        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));

    // 判断aof重写，重写由子进程执行
    if (server.aof_child_pid != -1)
        // 把格式化后的buf写进rewriteBuf，rewriteBuf是个链表
        aofRewriteBufferAppend((unsigned char*)buf,sdslen(buf));
    // 释放变量
    sdsfree(buf);
}
```

###### 5.2.2 flushAppendOnlyFile函数流程：

![aof刷盘流程](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/aof刷盘流程.png)

###### 5.2.3 AOF重写

重写的方法在aof.c文件的**rewriteAppendOnlyFileBackground**函数，时机有4个：

1.   bgrewriteaof命令显式调用，在aof.c的bgrewriteaofCommand函数中调用；
2.   开启AOF，比如启动时AOF是打开的，关闭在开启就会执行重写，还有一种情况是如果从节点开启了AOF，在主从复制时会关闭AOF，复制完成后重新打开AOF。在aof.c的startAppendOnly函数中调用；
3.   AOF的重写被设置成调度执行，对应aof_rewrite_scheduled配置，在server.c的serverCron函数中被调用；
4.   AOF文件的大小超过阈值，也在server.c的serverCron函数中被调用；

重写AOF时父进程会把新的写命令放进重写缓冲块中，缓冲块的结构体在aof.c中定义：

```c
/**
 * AOF重写缓冲块
 */
typedef struct aofrwblock {
    // 已使用和剩余大小
    unsigned long used, free;
    // 缓冲块数组，默认10M
    char buf[AOF_RW_BUF_BLOCK_SIZE];
} aofrwblock;
```

如果一个缓冲块写满了会追加一个新的缓冲块，多个缓冲块构成了aof_rewrite_buf_blocks，他是个list。子进程需要读取父进程的aof_rewrite_buf_blocks追加到新的aof文件从，同时也要通知父进程aof已经结束，不需要维护aof_rewrite_buf_blocks，这里父子进程的通信使用了管道：

*   数据管道：用来传输aof_rewrite_buf_blocks；
*   通信管道：子进程通知父进程不需要写aof_rewrite_buf_blocks了，父进程通知子进程已经不写了，子进程在管道中读取到'!'时就停止；

创建管道的代码也在aof.c文件中：

```c
int aofCreatePipes(void) {
    int fds[6] = {-1, -1, -1, -1, -1, -1};
    int j;

    // 父进程向子进程写数据的管道
    if (pipe(fds) == -1) goto error; /* parent -> children data. */
    // 子进程通知父进程停止传输的管道
    if (pipe(fds+2) == -1) goto error; /* children -> parent ack. */
    // 父进程向子进程回复停止传输的管道
    if (pipe(fds+4) == -1) goto error; /* parent -> children ack. */
    /* Parent -> children data is non blocking. */
    if (anetNonBlock(NULL,fds[0]) != ANET_OK) goto error;
    if (anetNonBlock(NULL,fds[1]) != ANET_OK) goto error;
    // 注册fds[2]事件，fds[2]对应的是aof_pipe_read_ack_from_child，还传入了一个函数aofChildPipeReadable
    // aofChildPipeReadable函数就是用来处理读取子进程的停止通知
    if (aeCreateFileEvent(server.el, fds[2], AE_READABLE, aofChildPipeReadable, NULL) == AE_ERR) goto error;

    // 父进程向子进程写数据的fd
    server.aof_pipe_write_data_to_child = fds[1];
    // 子进程读父进程写数据的fd
    server.aof_pipe_read_data_from_parent = fds[0];
    // 子进程写父进程通知的fd
    server.aof_pipe_write_ack_to_parent = fds[3];
    // 父进程读子进程通知的fd
    server.aof_pipe_read_ack_from_child = fds[2];
    // 父进程写子进程通知的fd
    server.aof_pipe_write_ack_to_child = fds[5];
    // 子进程读父进程通知的fd
    server.aof_pipe_read_ack_from_parent = fds[4];
    server.aof_stop_sending_diff = 0;
    return C_OK;
}
```

![aof重写流程1](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/aof重写流程1.png)

##### 5.3 混合持久化

4.0之后新增了混合持久化，这个持久化发生在aof重写的时候，其实就是aof重写的第一步，把数据库里的数据以rdb格式写进aof文件而不是转成resp格式。判断的代码就在rewriteAppendOnlyFile()函数里：

```c
if (server.aof_use_rdb_preamble) {
    int error;
    // 开启混合持久化当前数据使用rdb重写
    if (rdbSaveRio(&aof,&error,RDB_SAVE_AOF_PREAMBLE,NULL) == C_ERR) {
        errno = error;
        goto werr;
    }
} else {
    // 使用aof重写
    if (rewriteAppendOnlyFileRio(&aof) == C_ERR) goto werr;
}
```

