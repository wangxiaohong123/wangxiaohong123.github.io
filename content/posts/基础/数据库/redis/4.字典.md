---
title: redis-4.字典
tags:
  - redis
categories: 数据库
copyright: true
---

字典的底层由两个hash table实现，一个table用来正常存储数据，另一个在rehash时使用，具体的结构体：

```c
typedef struct dict {
    // 字典类型，指向dictType
    dictType *type;
    // dictEntry中函数的参数
    void *privdata;
    // 两个hash表
    // ht[0]原始hash表
    // ht[1]扩容的时候使用
    dictht ht[2];
    // rehash标识，-1表示没有rehash，其他表示当前rehash进度的数组索引
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
    // 迭代器
    unsigned long iterators; /* number of iterators currently running */
} dict;
```

dictht就是真正存储数据的hash table，dictType里面封装了一些方法，比如计算hash值、比较等等，dictType的结构体：

```c
typedef struct dictType {
    // 计算key的hash值
    uint64_t (*hashFunction)(const void *key);
    // 复制key
    void *(*keyDup)(void *privdata, const void *key);
    // 赋值value
    void *(*valDup)(void *privdata, const void *obj);
    // 比较key
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
    // 销毁key
    void (*keyDestructor)(void *privdata, void *key);
    // 销毁value
    void (*valDestructor)(void *privdata, void *obj);
} dictType;
```

dictht的结构体：

```c
typedef struct dictht {
    // 指针数组，指向数组中的节点
    dictEntry **table;
    // 数组长度，初始是4，每次扩容长度*2
    unsigned long size;
    // 掩码 = size  -1
    // 用来通过位运算计算索引值，和java一样
    unsigned long sizemask;
    // 元素个数
    unsigned long used;
} dictht;
```

dictEntry是具体的key和value：

```c
typedef struct dictEntry {
    // 存储任意类型的key
    void *key;
    // value，他是个联合体
    union {
        // value值
        void *val;
        // 如果是数字类型的value直接存值
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    // hash冲突的时候链表指针
    struct dictEntry *next;
} dictEntry;
```

**注意：hash存储数字类型的value是直接存储值，这样更快但是更消耗内存**

##### 1.初始化

启动redis的时候会创建一个字典，用来存储数据库中的数据：

```c
// 创建hash表
dict *dictCreate(dictType *type,
        void *privDataPtr)
{
    // 申请内存
    dict *d = zmalloc(sizeof(*d));

    // 初始化字典， 96字节
    _dictInit(d,type,privDataPtr);
    return d;
}

/* Initialize the hash table */
int _dictInit(dict *d, dictType *type,
        void *privDataPtr)
{
    // 重置两个hash table
    _dictReset(&d->ht[0]);
    _dictReset(&d->ht[1]);
    d->type = type;
    d->privdata = privDataPtr;
    // 设置当前无rehash
    d->rehashidx = -1;
    d->iterators = 0;
    return DICT_OK;
}
```

新增、删除、修改的API和java的差不多，不一样的地方是在操作的时候可能在rehash，所以两个hash table都会操作。

##### 2.渐进式rehash

rehash对应的函数是dict.c的dictRehash()，每次rehash一个数组元素，不管元素是当节点还是链表，执行hash的增删改查的时候都会进行判断当前是否在rehash，如果是就执行dictRehash()函数，rehash一个数组节点：

```c
/**
 * n是要rehash的节点个数
 */
int dictRehash(dict *d, int n) {
    // 遍历数组找到不为空的节点，这个n*10就是标记要找多少次
    int empty_visits = n*10; /* Max number of empty buckets to visit. */
    if (!dictIsRehashing(d)) return 0;

    while(n-- && d->ht[0].used != 0) {
        dictEntry *de, *nextde;

        /* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0 */
        assert(d->ht[0].size > (unsigned long)d->rehashidx);
        // 找到第一个要rehash的节点
        // 找n * 10次
        while(d->ht[0].table[d->rehashidx] == NULL) {
            d->rehashidx++;
            if (--empty_visits == 0) return 1;
        }
        // 要rehash的节点赋值
        de = d->ht[0].table[d->rehashidx];
        /* Move all the keys in this bucket from the old to the new hash HT */
        // 把一个数组元素的链表全部rehash
        while(de) {
            uint64_t h;

            nextde = de->next;
            /* Get the index in the new hash table */
            // 计算新的索引值
            h = dictHashKey(d, de->key) & d->ht[1].sizemask;
            // 把de的next指向rehash数组的索引位置元素
            de->next = d->ht[1].table[h];
            // de放到rehash数组中，看起来像是头插法
            d->ht[1].table[h] = de;
            // 两个数组的使用数量变化
            d->ht[0].used--;
            d->ht[1].used++;
            // de移除之后de的next变成de
            de = nextde;
        }
        d->ht[0].table[d->rehashidx] = NULL;
        d->rehashidx++;
    }

    /* Check if we already rehashed the whole table... */
    if (d->ht[0].used == 0) {
        // rehash完成之后把ht[1]赋值给ht[0]
        zfree(d->ht[0].table);
        d->ht[0] = d->ht[1];
        _dictReset(&d->ht[1]);
        d->rehashidx = -1;
        return 0;
    }

    /* More to rehash... */
    return 1;
}
```

除了操作hash会执行rehash，在server.c的serverCron()函数中会调用databasesCron()函数，这个函数会调用incrementallyRehash(**int** dbid)函数，用来rehash数据库的数据，因为数据库的数据就是一张大的hash表。

有个问题，普通操作传进来的参数n=1，会查找10次ht[0]，如果找到元素就rehash，没找到就返回了，在incrementallyRehash()函数中传进来的n=100，会查找1000次，找不到就返回，是不是说dt[0]里第1001及之后的元素永远不会rehash？

不会，因为**不管是找到要rehash的节点还是rehash之后都是使用rehashidx指针，这个是跟着rehash增长的。**

**rehash完成之后把rehashidx设置成-1，这个参数用来判断是否正在rehash。**

**总结**：渐进式rehash在数据库层(db0这种)每次rehash 100个节点，在普通key层每次rehash 1个节点。

##### 3.反转二进制迭代

redis的hash正常遍历使用迭代器，在使用迭代器的时候会阻塞hash的所有操作，2.8之后出现了dictScan()函数，他使用reverse binary iterator(反转二进制迭代)实现了渐进式迭代。

反转二进制就是说正常二进制累加是从低位开始向高位不断进1，反转二进制是从高位开始向地位不断进1，redis通过这种方式实现了在扩容和缩容的时候也可以快速定位元素下标。

渐进式迭代对应dict.c的dictScan()函数，这个函数有两个分支，没有rehash和正在rehash，没有rehash就正常遍历，正在rehash时的遍历逻辑：

```c
// rehash的时候需要遍历两个数组
t0 = &d->ht[0];
t1 = &d->ht[1];

/* Make sure t0 is the smaller and t1 is the bigger table */
// 保证t0比t1小
// 这个算法需要先遍历小的数组
if (t0->size > t1->size) {
    t0 = &d->ht[1];
    t1 = &d->ht[0];
}

m0 = t0->sizemask;
m1 = t1->sizemask;

/* Emit entries at cursor */
if (bucketfn) bucketfn(privdata, &t0->table[v & m0]);
de = t0->table[v & m0];
while (de) {
    next = de->next;
    fn(privdata, de);
    de = next;
}

/* Iterate over indices in larger table that are the expansion
         * of the index pointed to by the cursor in the smaller table */
do {
    /* Emit entries at cursor */
    if (bucketfn) bucketfn(privdata, &t1->table[v & m1]);
    de = t1->table[v & m1];
    while (de) {
        next = de->next;
        fn(privdata, de);
        de = next;
    }

    /* Increment the reverse cursor not covered by the smaller mask.*/
    v |= ~m1;
    v = rev(v);
    v++;
    v = rev(v);

    /* Continue while bits covered by mask difference is non-zero */
} while (v & (m0 ^ m1));
```

