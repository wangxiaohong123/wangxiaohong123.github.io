---
title: redis-5.整数集合
tags:
  - redis
categories: 数据库
copyright: true
---

##### 一 intset

redis中如果set类型存储的元素都是有符号整数并且size小于512会使用整数集合来存储元素。intset是一个有序不可重复的整形数组。

###### 1.查找元素

查找元素在inset.c的intsetFind()函数：

```c
uint8_t intsetFind(intset *is, int64_t value) {
    // 获取value的encoding
    uint8_t valenc = _intsetValueEncoding(value);
    // 如果value的encoding小于等于intset的encoding就开始查找
    // 如果是大于的话intset里肯定没有，不需要查找
    return valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,NULL);
}

static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) {
    int min = 0, max = intrev32ifbe(is->length)-1, mid = -1;
    int64_t cur = -1;

    // intset是空字节返回0
    if (intrev32ifbe(is->length) == 0) {
        if (pos) *pos = 0;
        return 0;
    } else {
        // 如果value大于intset的最大值返回0
        if (value > _intsetGet(is,intrev32ifbe(is->length)-1)) {
            if (pos) *pos = intrev32ifbe(is->length);
            return 0;
        } else if (value < _intsetGet(is,0)) {
            // value小于intset的最小值返回0
            if (pos) *pos = 0;
            return 0;
        }
    }

    // 二分查找
    while(max >= min) {
        mid = ((unsigned int)min + (unsigned int)max) >> 1;
        cur = _intsetGet(is,mid);
        if (value > cur) {
            min = mid+1;
        } else if (value < cur) {
            max = mid-1;
        } else {
            break;
        }
    }
    if (value == cur) {
        if (pos) *pos = mid;
        return 1;
    } else {
        if (pos) *pos = min;
        return 0;
    }
}
```

###### 2.添加元素

添加和删除都差不多，找到要修改的位置+挪动其他元素+插入元素：

```c
intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {
    uint8_t valenc = _intsetValueEncoding(value);
    uint32_t pos;
    if (success) *success = 1;

    // 如果value的编码大于intset的编码就进行编码升级
    if (valenc > intrev32ifbe(is->encoding)) {
        /* This always succeeds, so we don't need to curry *success. */
        return intsetUpgradeAndAdd(is,value);
    } else {
        // 如果找到了value直接返回，因为intset不可重复
        if (intsetSearch(is,value,&pos)) {
            if (success) *success = 0;
            return is;
        }

        // 把要插入的位置之后的元素后移
        is = intsetResize(is,intrev32ifbe(is->length)+1);
        if (pos < intrev32ifbe(is->length)) intsetMoveTail(is,pos,pos+1);
    }

    // 插入元素
    _intsetSet(is,pos,value);
    // 长度+1
    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);
    return is;
}
```

###### 3.编码升级

intset存在3种编码：

```c
#define INTSET_ENC_INT16 (sizeof(int16_t))
#define INTSET_ENC_INT32 (sizeof(int32_t))
#define INTSET_ENC_INT64 (sizeof(int64_t))
```

这样是为了更省内存，而且还可以快速判断查找的元素是否在intset中，当查找的value的编码大于intset的编码的时候可以直接返回不存在：

```c
static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {
    uint8_t curenc = intrev32ifbe(is->encoding);
    uint8_t newenc = _intsetValueEncoding(value);
    int length = intrev32ifbe(is->length);
    // 如果value<0，prepend = 1，否则prepend = 0
    int prepend = value < 0 ? 1 : 0;

    // 设置升级之后的编码
    is->encoding = intrev32ifbe(newenc);
    // 编码升级，重新申请内存，数组长度+1
    is = intsetResize(is,intrev32ifbe(is->length)+1);

    // 数组重新赋值
    while(length--)
        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));

    // 如果prepend = 1说明value小于0
    // 当value<0还要进行编码升级说明value比intset的最小值还小，插入进头就可以
    if (prepend)
        _intsetSet(is,0,value);
    else
        // 否则就说明value比intset最大值还大
        _intsetSet(is,intrev32ifbe(is->length),value);
    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);
    return is;
}
```

##### 二