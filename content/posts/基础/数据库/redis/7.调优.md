---
title: redis-调优
tags:
  - redis
categories: 数据库
copyright: true
---

同步操作：

*   读写客户端数据；
*   过期机制是在主线程中执行的；
*   淘汰策略也是在主线程中执行；

异步操作：

*   主从同步生成全量的RDB；
*   lazy-free机制，把bigkey的释放内存的耗时操作放在了异步线程中执行；
*   AOF放入rewrite，重写采用的是写时复制机制，最开始只会fork一个子进程，子进程会先复制父进程中的内存页表信息，父子进程指向同一个地址的数据，这时候子进程就可以开始写日志了，但是会有两种情况引起阻塞：1）内存页表很大，也就是数据量很多，在fork完成之前都会阻塞住；2）当有新的数据写入时，父进程会创建新的数据，新申请数据如果很大，因为内存的分配是以页为单位的，默认4k，如果申请了bigkey的内存，会产生耗时，如果操作系统开启的内存大页机制，阻塞的概率会提高很多。

4.0特性：

*   提出了一个混合使用AOF和RDB的的方法，就是说RDB按照正常频率执行，在这期间的数据变更使用AOF来记录；
*   异步删除和异步清空，unlink命令或者flushall async，lazy-free机制，会尝试异步释放空间操作（比如过期key、淘汰、主从）；

耗时操作：

*   读写bigkey时，分配内存和释放内存会产生耗时；
*   使用复杂度是O(n)的指令；
*   大量key过期；
*   内存不够，这时候每次写入前都会淘汰一些key；
*   AOF设置成always，每次都要刷盘；
*   主从同步时生成全量RDB的一瞬间会阻塞住；

### 生产调优

1. repl_backlog_size一般要配置成（主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小） * 2。因为主从之间的缓冲区是环形的，防止缓冲区写满主库还继续写入，导致数据被覆盖。
1. 绑核：每个CPU有多个运行核心，叫做物理核，每个物理核都有私有的L1和L2，每个CPU的所有物理核共享一个L3，L1和L2一般都是几k左右，三级缓存会有百兆左右，这也叫NUMA架构，跨核后操作延迟不相等。每个物理核一般会有两个逻辑核，因为如果是多核的情况，一个redis程序运行在了多个CPU socket上，这样数据要通过缓存传递，说白了就是减少上下文的切换。首先使用lscpu查看所有逻辑核，以及每个核的编号和对应的cpu socket，使用**taskset -c 0,3 ./redis-server**把redis和0核和3核绑定绑定，一般都是绑两个逻辑核，一个用来异步处理，但是这两个逻辑核要在同一个物理核下。
1. 使用**./redis-cli --intrinsic-latency 120**查看redis120s内的延迟。
1. 什么时候横向扩容？
    *   先找到进程号**$ redis-cli info | grep process_id**
    *   cd /proc/[进程号]
    *   cat smaps | egrep '^(Swap|Size)'，检查swap数值，如果很大就需要扩容了

5.   关闭huge page，在/et/rc.local里加入配置`echo never >/sys/kernel/mm/transparent_hugepage/enabled`，默认是开启，如果开启会导致fork的速度变慢。
6.   vm.overcommit_memory，找linux申请内存，但是不马上使用，默认是0，意思就是有内存就可以申请，没有内存就申请失败，redis的生产一般设置成1，允许redis超量使用内存，一直到服务器的内存都用完。
7.   降低redis被系统killer概率，这是swappiness，这个是物理内存不够的时候会swap刷到磁盘，防止linux的oom killer机制，在/etc/sysctl.conf里配置vm.swappiness=1，如果linux的版本<=3.5就配置成0，这样可以让redis在内存不够时不被系统杀死；找到redis的pid，然后echo -17 > /proc/redis的pid/oom_adj
8.   修改文件句柄数，默认的进程可以打开文件句柄是4096，使用`ulimit -Sn xx`设置可以打开的文件句柄数。

##### 结合慢查询日志优化

slowlog-log-slower-than配置默认是10000us，设置请求时间超过多少算慢查询。然后把慢查询日志存到双向链表里。

slowlog-max-len设置存放慢查询日志的链表大小，超过最大值会移除最早的。一般最少要配置1000。

然后通过`slowlog len`获取慢查询日志长度，`slowlog get n`获取n条慢查询日志。

##### 基于pipeline和lua进行多指令优化

处理请求的流程：发送请求->进入队列->处理请求->返回响应，进入队列和处理请求非常快，一般都是纳秒级，来回的网络通信可能花费几十ms，如果连续执行10次redis操作可能就几百ms了，这个时候可以使用pipeline或者lua脚本打包命令一起发送一起执行。

##### 连接池配置

以jedis客户端举例，jedisPool默认最多8个连接，如果8个连接都在使用就会等待maxWaitMills，或者配置了blockWhenExhausted=false，这样就不会等待，两种情况都会报错(could not get a resource)，一般blockWhenExhausted都会设置成true，8个连接也够用了，maxWaitMills不超过1s，这样假设每次redis执行消耗10ms，一台4c8g的机器每秒可以处理800个redis请求。

