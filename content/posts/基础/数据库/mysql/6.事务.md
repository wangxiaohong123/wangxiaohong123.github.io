---
title: MySQL-6.事务
tags:
  - MySQL
categories: 数据库
copyright: true
---

##### 一）事务的4个特性

*   原子性：同一个事物内的SQL要么都成功要么都失败，innodb中使用undo log保证数据的回滚，在事务执行过程中如果宕机的话没有提交的事务不会被恢复，因为redo log中的日志是uncommit的。
*   一致性：原子性+隔离性+持久性是为一致性服务的，一致性说的是事务开始之前到结束不会破坏数据库的完整性，可以理解为其他3个特性加在一起就是一致性。一致性分为约束一致性和数据一致性：
    *   约束一致性：针对表结构的外键、唯一索引等约束；
    *   数据一致性：由原子性+隔离性+持久性共同保证的结果；
*   隔离性：一个事务执行过程中不能被其他事物干扰，针对隔离性SQL定义了4个隔离级别，分别通过锁和mvcc实现。
*   持久性：事务提交之后对数据的改变是永久性的，innodb通过bin log + redo log(两阶段提交) + 双写缓冲区实现持久性。

控制多个事务对数据的操作其实就是隔离性，通过锁+mvcc实现。

查看系统中事物的语句是：

```sql
# 查看持续时间超过60s的事物
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

##### 二）数据库并发的问题

针对于隔离性SQL定义了四种隔离级别来解决4种并发问题：

1.   脏写：比如两个事务，一个A，一个B，A先将一个null值修改为a，但是还没有提交事务，可能还有别的数据要处理，这时候B过来把a改成了b，然后提交数据，然后A处理别的数据失败执行回滚，此时数据又变成了null，这就是脏写。
2.   脏读：比如两个事务，一个事务A，一个事务B，事务A读取数据为a，然后就去处理别的数据了，没有提交事务，这时候事务B过来把a改成null但是也没有提交事务，然后事务A处理完回来再去读取数据变成了null，一下就蒙了，这就是脏读。脏读和脏写都是因为一个事务去读了另一个事务还没有提交事务的更新操作。
3.   不可重复读：不可重复读和脏读的区别是不可重复读不能读取没提交事务的数据，脏读是读到了其他事物没提交的数据，属于脏数据。出现不可重复读的原因是在一次事务中对同一条数据的读取可能被别的事务改值并且提交，这么一看不可重复读算不算并发问题都可以，要根据业务去定义。
4.   幻读：幻读和不可重复读的区别是不可重读是修改，幻读是增加或者删除，导致一次事务中多次读取的数据条数不一样。

##### 三）SQL标准事务隔离

这是SQL不是MySQL，SQL数据库都有隔离级别，事务的隔离级别就是锁+MVCC的封装。

*   read uncommitted：读未提交，不会发生脏写，但是会有其他三个并发读问题，不适用MVCC并且不加锁实现这个隔离级别。
*   read committed：读已提交，就是说不能读取没有提交事务的值，这种隔离级别不会发生脏写和脏读，但是会有可重复读和幻读，一般都说RC。
*   repeatable read：可重复读，在一次事务中不管别人有没有提交过修改这个值的事务，读出来的值都是一样的，这种隔离级别只可能产生幻读问题，一般叫他RR。
*   serializable：串行化了，没人用，都串行了肯定不会有并发问题，性能太低，所有操作都加锁。

在spring中使用@Transactional(isolation=Isolation.DEFAULT)来设置隔离级别，DEFAULT就是默认，由数据库决定。

查看当前数据库的隔离级别的语句是：

```sql
show variables like 'transaction_isolation';
```

##### 四）MVCC

这个是数据库为了实现高并发的数据访问，通过事务的可见性来保证事务能够看见应该看见的版本，他的优点是读可以不加锁，并且读写不冲突。通过undo log版本链 + read view机制实现。

###### 1）undo log版本链

每条数据都有两个隐藏的字段，trx_id和roll_pointer，trx_id是最新修改数据的事务id，而roll_pointer指向的是最后一次更新之前的undo log，undo log是链表结构，每个undo log元素都有修改前的值、trx_id和roll_pointer，trx_id就是那次修改的id，roll_pointer指向前一次的undo log元素，也就是说具体的数据行和undo log之间通过roll_pointer组成单向链表。

通过undo log版本链可以实现事务没提交的时候其他事务可以去读版本链中的已经提交的最新版本的undo log上的最新数据。

###### 2）ReadView机制

ReadView是数据的快照，里面有四个重要的属性：

*   m_ids：和这条数据相关的并且还没提交的事务id集合；
*   min_trx_id：m_ids里的最小值；
*   max_trx_id：m_ids里的最大值+1，也就是下一个新生成的事务的id；
*   creator_trx_id：当前事务的id；

工作原理：假设现在有两个事务，a(事务id是45)读取数据，b(事务id是54)修改数据，a在读取，表中的这条数据的trx_id是33:

*   那此时a的ReadView中的m_ids就是[45，54]，min_trx_id就是45，max_trx_id是55，creator_trx_id是45。
*   b的ReadView中的m_ids就是[45，54]，min_trx_id就是45，max_trx_id是55，creator_trx_id是54。

当a读取数据时发现33是小于45的他就会直接读取表中的数据，当b来修改发现33也是小于45(min_trx_id)的，这就说明他可以直接修改数据，但是修改之前会先获取锁然后生成一条新的undo log和redo log，undo log的trx_id是54。当a再回来读取数据时发现数据的trx_id变成了54，此时他会拿着自己的m_ids去遍历undo log版本链，直到找到m_ids中没有(m_ids中没有就说明事务已经提交)并且trx_id比min_trx_id小的undo log，也就是trx_id是33的那条undo log去读取数据。

###### 3）ReadView实现RC级别

ReadView机制加undo log版本链默认实现的是RR级别，想要实现RC级别就要每次查询都生成一个ReadView，每次都生成新的ReadView就代表m_ids会持续把已经完成的事务去掉，并且在查找数据时只需要判断undo版本链上的trx_id不在m_ids里，就读取，不比较min_trx_id。

###### 4）MVCC中读操作的分类

快照读：基于undo log读取快照信息，这个操作不需要对数据加锁也可以解决修改数据时无法读取数据的问题，快照读中不会出现幻读问题；

当前读：读取数据库中的最新数据，需要对数据加锁，比如读取数据时添加 lock in share mode显示添加共享锁，增删改也是当前读，因为删除或者修改会先查询，这个查询本身是带着锁的；

**MVCC解决了读读、读写、写读问题，但是解决不了写写问题，需要加锁**
