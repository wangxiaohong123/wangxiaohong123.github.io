---
title: MySQL-5.三个log
tags:
  - MySQL
categories: 数据库
copyright: true
---

### redo log

WAL机制：预写日志机制，这是一种日志先行机制，意思是刷新数据的时候，先把数据对应的log刷新到磁盘上的对应的log file中，然后再根据log file刷新数据。针对redo log的WAL机制就是先将内存中的redo log buffer刷新到磁盘上的redo log file里，然后再根据redo log file刷新磁盘上的数据。这样有个好处是如果直接修改磁盘数据是随机写，但是WAL的话会顺序写日志，然后异步随机写。

##### 1）基本概念

redo log叫重做日志，它包括两部分，一部分是内存中的redo log buffer，另一部分是磁盘上的redo log file。通过redo log可以实现数据的持久型。

##### 2）数据刷盘

脏页落盘的chack point：

1.   强制落盘：关闭数据库的时候把所有脏页落盘；
2.   主线程定时将脏页写入磁盘；
3.   当redo log快写满的时候：redo log在75%到90%之间会异步落盘，超过90%会同步落盘；
4.   lru链表中有脏页被淘汰的脏页会落盘；
5.   buffer pool中的脏页超过75%会落盘；

##### 3）redo log刷盘策略

redo log持久化策略通过innodb_flush_log_at_trx_commit来配置，这个属性有3个选项，分别是0、1、2：

1.   为0时：redo log buffer每秒会写入到os cache，并调用fsync操作进行刷盘，设置成0的话当系统崩溃的时候可能会丢失1s的数据。
2.   为1时：事务提交时会直接写入os cache并调用fsync操作刷到磁盘，这种不会丢失数据，但是磁盘io会很频繁。
3.   为2时：事务提交时会写入os cache，由后台线程每秒执行fsync操作，这种只要不是服务器宕机就不会丢失数据。

##### 4）日志格式

redo log记录的是哪个数据页的哪个位置上的数据被修改，修改为多少。

| type     | space id   | page number | offset           | len                                | data               |
| -------- | ---------- | ----------- | ---------------- | ---------------------------------- | ------------------ |
| 日志类型 | 表空间的id | 数据页号    | 数据页中的偏移量 | 修改的内容不确定长度时占用的字节数 | redo log的具体内容 |

日志类型有很多种，在5.7里有五十多种，比如type=1的时候是MLOG_1BYTE，意思是某个偏移量处写入了1字节的数据，type=30的时候是MYLOG_WRITE_STRING，表示修改了字符串的值，这种不确定长度的值的修改会使用len进行标记。

##### 5）刷盘时机

*   首先在MySQL关闭的时候是必须要刷盘的；
*   其次MySQL在后台有一个线程会每秒刷一次；
*   然后如果1s内产生的redo log超过了redo log buf的一半大小会马上进行刷盘；
*   最后事务提交的时候会进行刷盘；

默认情况下磁盘中的redo log只有两个文件，ib_logfile0和ib_logfile1，写满了就会覆盖。这两个文件组成了一个日志组。组里的日志文件组成立一个环，比如ib_logfile0写满了会去写ib_logfile1，ib_logfile1写满了之后又会去写ib_logfile0。其中write pos表示当前日志记录到的位置，check point表示将日志记录写进磁盘，然后会将日志擦除，write pos和check point是追逐关系，当write pos追上check point的时候不能写继续写redo log。

并且在check point进行刷盘的时候是以redo log block为单位进行的，和数据页很像，一个redo log block是512字节，由head（12字节）、body（496字节）、trailer（4字节）组成：

### undo log(回滚日志)

在开启事务之前会记录当前数据的状态到undo log里，比如删除数据的操作就会记录插入日志，事务提交之后不会销毁，由后台线程purge thread定时扫描回收，同时undo log也有对应的redo log！

undo log主要用来提供回滚操作，实现了事务的原子性，可以通过undo log进行回滚。undo log的第二个作用是可以实现多版本并发控制，就是mvcc机制里的快照读。

##### 1）工作原理

在事务开始之前innodb会生成一个全局唯一递增的trx_id，每行数据还有3个隐藏列：

1.   DB_ROW_ID：当建表时没有指定主键或者唯一索引的字段会生成一个DB_ROW_ID。
2.   DB_TRX_ID：事务id。
3.   DB_ROLL_PTR：回滚指针，指向undo log，增删改数据的时候这个指针会指向刚刚创建的undo log。
4.   next_record：指向上一条数据的指针，所以表中的数据是从后到前方向的单链表。

### binlog

他是一个二进制日志，用来记录用户对数据库的增删改操作，他是所有引擎公用的，不限制大小，他记录的是一条SQL的原始逻辑。

常用于主从复制和数据恢复(通过mysqlBinlog工具或者其他数据同步工具)

##### 1）三种模式

1.   row：日志会记录每一行记录被修改的情况，主从的时候最好使用这个，缺点就是批量操作的时候会产生大量的日志。
2.   statement：记录每一条修改数据的SQL，比如一个批量修改10条数据的SQL，这个模式下binlog中只有1条SQL，row模式下会产生10条SQL。可能会导致主从数据不一致。
3.   mixed：上面两个模式的混合，根据场景进行模式切换。

##### 2）写入机制

内存中有一块区域是binlog cache，首先会在binlog cache中记录binlog然后写到os cache在fsync到磁盘。

通过sync_binlog设置binlog的落盘策略，由3个选项：

1. 为0时：每次提交事务写到os cache就算成功。
1. 为1时(默认)：每次提交事务都会fsync到磁盘。
1. 大于1时(假设设置的值为n)：提交事务只写到os cache，累计达到n个的时候刷到磁盘。

每个事务线程都会有自己的binlog cache，事务执行过程中会把SQL封装成log event，然后事务线程会把log event放到binlog cache中，在写到os cache中，在根据刷盘策略决定是否刷到磁盘。

##### 3）redo log和binlog的区别

1.   redo log是innodb引擎独有的，binlog是MySQL实现的所有引擎共享的。
2.   redo log记录的是数据的偏移量和具体修改的值，binlog记录的是SQL逻辑。
3.   redo log循环写，redo log会被覆盖，binlog是一直增长的，所以binlog可以做全量的数据恢复，redo log只保存少量日志用来做数据库崩溃恢复。