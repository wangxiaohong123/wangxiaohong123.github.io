---
title: MySQL查询计划
tags:
  - MySQL
categories: 数据库
copyright: true
---

真正的SQL优化是根据优化器给出的执行计划，改写SQL，改良索引，让SQL性能提升。

### 名词
1) system：表中只有1行数据。
2) const：直接通过聚簇索引或者索引覆盖或者二级索引加回表就能返回结果的语句，性能是常量级，但是二级索引必须是unique key，也就是说只能查出来一条；
3) ref：普通二级索引，而且条件必须是全值匹配，有个例外，当查询条件是主键 is not null时，也是ref；
4) res_or_null：这个是说查询使用二级索引的全值匹配，但是有个条件是 is not null；
5) range：这个也是用了索引，但是是范围查询；
6) index：这个意思是查询条件没用索引，但是遍历的是索引的B+树，比如有一个联合索引 x1 + x2 + x3，执行语句select x1, x2, x3 from table where name='大叔大'，查询的字段都在索引中，遍历索引的B+树要比遍历数据页快，不过他还是类似全表扫描；
7) index_merge：单表查询时，使用了多个索引，然后把结果合并；
8) all：全表扫描；

不管是内联还是外联，都叫循环嵌套关联，应该尽可能让查询都用上索引，否则查询次数是乘积关系。
### 执行计划成本
成本就是需要消耗的资源，MySQL定义把数据页加载到内存消耗IO成本是1.0，在内存中计算比如排序、分组、验证符合条件消耗CPU成本是0.2。

使用二级索引扫描的时候粗略的认为一个范围区间就是一个数据页

#### 计算全表扫描的成本
使用show table status lie '表名'可以查看表的相关信息，比如rows：有多少行数据（innodb的估计值）；data_length：聚簇索引占的字节数，使用data_length/1024/16差不多是有多少个数据页，那么全表扫描的成本 = (data_length / 1024 / 16) * 1.0 + rows * 0.2
#### 计算二级索引扫描成本

比如说使用25 < name < 100 or 150 < name < 200，name是个索引，这是两个区间，可以近似成两个数据页，IO成本就是2 * 1.0，比如查到了100条数据，这100条数据的CPU成本就是100 * 0.2，而且还需要回表，回表的时候暴力认为一条数据需要对应数据页，那回表把数据页加载到内存的IO成本就是100 * 1.0，内存的CPU成本是100 * 0.2，这个查询的成本就是2 + 20 + 100 + 20 = 142。
### 查看执行计划
在SQL语句前面加个explain就可以看到执行计划
* id：一条语句可能有多个select，每个select有一个id，这个id表示这个语句的执行顺序，越大优先级越高。

* select_type：查询类型，比如simple(简单的查询，没有子查询或者交并差集操作)，primary(当查询有子查询的时候外层的查询叫primary)，subquery(子查询)，union(union关键字连接的语句)，derived（临时表，就是from中包含的子查询）。

* table：表名。

* partitions：分区信息，一般没人用。

* type：为了找到数据使用的扫描方式，就是const、ref这些。

* possible_keys：可能用到的索引。

* key：实际使用的索引。

* key_len：索引被使用的长度，越长越说明索引被利用的越充分。

* ref：跟索引等值匹配的时候，匹配值的一些信息。

* rows：估计可能读多少条数据，这个很关键，越小越快。

* filtered：经过搜索条件过滤后剩余数据的百分比。

* extra：其他信息，比如查询条件里前两字段使用了索引，回表拿到数据后进行第三个查询条件的过滤，这里就会显示一个using where，也可能是全表扫描或者索引失效。

一般如果对结果很意外可以接着执行show warnings查看转变后的sql。