---
title: MySQL优化
tags:
  - MySQL
categories: 数据库
copyright: true
---

### 参数优化：

##### 1）buffer pool参数优化

- 查看缓冲池大小，一般可以调成服务器内存的70%。

    ```sql
    mysql> show variables like '%innodb_buffer_pool_size%';
    +-------------------------+-----------+
    | Variable_name           | Value     |
    +-------------------------+-----------+
    | innodb_buffer_pool_size | 134217728 |
    +-------------------------+-----------+
    
    mysql> select 134217728 / 1024 / 1024;
    +-------------------------+
    | 134217728 / 1024 / 1024 |
    +-------------------------+
    |            128.00000000 |
    +-------------------------+
    ```

- 在线调整InnoDB缓冲池大小

    innodb_buffer_pool_size可以动态设置，允许在不重新启动服务器的情况下调整缓冲池的大小.

    ```sql
    mysql> SET GLOBAL innodb_buffer_pool_size = 268435456;
    Query OK, 0 rows affected (0.10 sec)
    
    mysql> show variables like '%innodb_buffer_pool_size%';
    +-------------------------+-----------+
    | Variable_name           | Value     |
    +-------------------------+-----------+
    | innodb_buffer_pool_size | 268435456 |
    +-------------------------+-----------+
    ```

    监控在线调整缓冲池的进度

    ```sql
    mysql> SHOW STATUS WHERE Variable_name='InnoDB_buffer_pool_resize_status';
    
    +----------------------------------+----------------------------------------------------------------------+
    | Variable_name                    | Value                                                        |
    +----------------------------------+----------------------------------------------------------------------+
    | Innodb_buffer_pool_resize_status | Size did not change (old size = new size = 268435456. Nothing to do. |
    +----------------------------------+----------------------------------------------------------------------+
    ```

*   设置多个buffer pool，多个buffer pool可以提交多线程读写的并发，通过下面的参数设置buffer pool个数，最多可以设置64个：

    ```sql
    mysql> show variables like 'innodb_buffer_pool_instances';
    +------------------------------+-------+
    | Variable_name                | Value |
    +------------------------------+-------+
    | innodb_buffer_pool_instances | 1     |
    +------------------------------+-------+
    ```

*   chunk大小优化

    buffer pool是由很多个chunk组成的，每个chunk都会存储一些描述数据和缓存页，每个chunk的大小默认是是128M，引入chunk是为了方便动态调整buffer pool的大小，调整buffer pool时是以chunk为单位进行拷贝的。通过下面的参数设置chunk的大小：

    ```sql
    mysql> show variables like 'innodb_buffer_pool_chunk_size';
    +-------------------------------+-----------+
    | Variable_name                 | Value     |
    +-------------------------------+-----------+
    | innodb_buffer_pool_chunk_size | 134217728 | 
    +-------------------------------+-----------+
    ```

    **缓冲池的大小 = n * (chunk_size * instances)**，n是正整数，MySQL会动态调整。

*   buffer pool参数评估

    通过下面的两个数据计算缓存命中率来判断buffer pool参数设置是否合理：

    ```shell
    # innodb_buffer_pool_reads：表示InnoDB缓冲池无法满足的请求数。需要从磁盘中读取
    # innodb_buffer_pool_read_requests：表示从内存中读取页的请求数
    命中率 = innodb_buffer_pool_read_requests / (innodb_buffer_pool_read_requests + innodb_buffer_pool_reads)
    ```

    ```sql
    mysql> show status like 'innodb_buffer_pool_read%';
    +---------------------------------------+-------+
    | Variable_name                         | Value |
    +---------------------------------------+-------+
    | Innodb_buffer_pool_read_ahead_rnd     | 0     |
    | Innodb_buffer_pool_read_ahead         | 0     |
    | Innodb_buffer_pool_read_ahead_evicted | 0     |
    | Innodb_buffer_pool_read_requests      | 12701 |
    | Innodb_buffer_pool_reads              | 455   |
    +---------------------------------------+-------+
    
    -- 此值低于90%，则可以考虑增加innodb_buffer_pool_size。
    mysql> select 12701 / (455 + 12701) * 100 ;
    +-----------------------------+
    | 12701 / (455 + 12701) * 100 |
    +-----------------------------+
    |                     96.5415 |
    +-----------------------------+
    ```

##### 2）page相关参数优化

可以使用`innodb_page_size`设置page的大小，Page页管理状态相关参数：

```sql
mysql> show global status like '%innodb_buffer_pool_pages%';
+----------------------------------+-------+
| Variable_name                    | Value |
+----------------------------------+-------+
#  InnoDB缓冲池中包含数据的页数。 该数字包括脏页面和干净页面
| Innodb_buffer_pool_pages_data    | 515   |
# 显示在内存中修改但尚未写入数据文件的InnoDB缓冲池数据页的数量（脏页刷新）
| Innodb_buffer_pool_pages_dirty   | 0     |
# 表示从InnoDB缓冲池中刷新脏页的请求数
| Innodb_buffer_pool_pages_flushed | 334   |
# 显示InnoDB缓冲池中的空闲页面
| Innodb_buffer_pool_pages_free    | 15868 |
# 缓存池中当前已经被用作管理用途或hash index而不能用作为普通数据页的数目
| Innodb_buffer_pool_pages_misc    | 0     |
# 缓存池的页总数目。单位是page
| Innodb_buffer_pool_pages_total   | 16383 |
+----------------------------------+-------+
```

mysql5.7支持4k~64k的页面大小设置，一般来说16k或者更大适合扫描量大、批量更新多的场景，4k或者8k的页面更适合小操作。同时数据页大小会影响存储的数据量。

##### 3）change buffer参数优化

写多读少的情况下，写完不会立即查询更适合调大change buffer，他原来叫insert buffer，只支持插入的二级索引优化，现在增删改都支持，页改名成change buffer。

- **配置change buffer使用模式** 

    **innodb_change_buffering** 配置参数说明

    ```sql
    mysql> show variables like '%innodb_change_buffering%';
    +-------------------------+-------+
    | Variable_name           | Value |
    +-------------------------+-------+
    | innodb_change_buffering | all   |
    +-------------------------+-------+
    ```

    | 选项    | 说明                         |
    | ------- | ---------------------------- |
    | inserts | 插入缓冲                     |
    | deletes | 删除标记缓冲                 |
    | changes | 更新缓冲,由两个缓冲区组成    |
    | purges  | 缓冲在后台发生的物理删除操作 |
    | all     | 表示启用上面所有配置(默认)   |
    | none    | 表示不启用任何配置           |

- **配置change buffer 大小**

    ChangeBuffer占用BufferPool空间，默认占25%，最大允许占50%，可以根据下面参数进行调整：

    ```sql
    mysql> show variables like 'innodb_change_buffer_max_size';
    +-------------------------------+-------+
    | Variable_name                 | Value |
    +-------------------------------+-------+
    | innodb_change_buffer_max_size | 25    |
    +-------------------------------+-------+
    1 row in set (0.00 sec)
    ```

- **查看change buffer的工作状态** 

    ```sql
    show engine innodb status;
    
    -------------------------------------
    INSERT BUFFER AND ADAPTIVE HASH INDEX
    -------------------------------------
    Ibuf: size 1, free list len 0, seg size 2, 0 merges
    merged operations:
     insert 0, delete mark 0, delete 0
    discarded operations:
     insert 0, delete mark 0, delete 0
    ```

    - **size:** 表示已经合并到辅助索引页的数量；

    - **free list len:** 表示空闲列表长度；

    - **seg size：**表示当前Change Buffer的大小，2*16KB；

    - **merges**：表示合并的次数；

    - **merged operations：**表示每个具体操作合并的次数；

        - insert：表示插入操作；
        - delete mark：表示删除标记操作；
        - delete：表示物理删除操作；

##### 4）日志缓冲区参数优化

日志相关参数：

```properties
# 缓冲区大小，默认16M
innodb_log_buffer_size
# 每组的日志文件数
innodb_log_files_in_group
# 日志文件的大小，默认48M
# 一组的所有日志文件总量不能超过512G
innodb_log_file_size
```

日志文件太小会导致频繁切换日志文件还有可能出现大事务没执行完但是日志写满的情况，如果太大的话可能会导致恢复时间过长。

官网建议的是日志文件大小最少应该承载1小时的日志量，所以可以估算1个小时的日志量来设置日志文件大小：

```sql
-- pager分页工具, 只获取 sequence的信息
-- MySQL中提供了一个sequence来统计产生多少日志，但是他从8704字节开始，
mysql> pager grep sequence;
PAGER set to 'grep sequence'

-- 查询状态,并倒计时一分钟
mysql> show engine innodb status\G select sleep(60);
Log sequence number 5399154
1 row in set (0.00 sec)

1 row in set (1 min 0.00 sec)

-- 一分时间后的数据量 5406150
mysql> show engine innodb status\G select sleep(60);
Log sequence number 5406150

-- 关闭pager
mysql> nopager;
PAGER set to stdout
```

然后可以使用(5406150 - 5399154) / 1024 计算出1分钟产生多少k数据，就可以算出1小时产生多少日志，通过这个设置日志文件的大小。

### SQL优化

sql的优化就是使用explain + sql查看优化器优化之后的查询计划，一般type控制在range之前，同时extra是using where的时候也需要看是否是索引失效或者全表扫描，rows越小越快。

一般在压测前会统一创建索引，保证每条SQL都使用索引并且索引数不能超过4个并且更新非常频繁的字段需要衡量是否需要可以索引。

*   MySQL会跟对联合索引从左到右进行排序，所以要左前缀法则才可以用到联合索引，这也可以解释like '%xxx'不能用到索引，在排好序的B+树上不能快速查找以xxx结尾的数据。
*   需要注意对于类型转换(有一个容易忽略的点就是字符串类型的数字需要加单引号)和使用索引计算会导致索引失效。
*   范围查询需要放到条件的最后，否则会导致范围查询后的字段哪怕是同一个联合索引也会导致索引会失效。
*   使用is null 或者is not null或者!=或者or会导致索引失效。
*   排序字段一定要用索引，因为索引本身就是排好序的。
*   减少使用select *，第一因为这么查询数据量可能会很大，第二这么查一定会回表，当可以索引覆盖的时候不要使用这个写法。

上线之后设置`slow_query_log=1`开启慢查询日志(默认关闭)，也可以设置slow_query_log_file设置慢查询日志文件位置，`long_query_time`用来设置慢查询的阈值，超过多少s算是慢查询。配合慢查询日志还需要打开一个参数`log_queries_not_using_indexes`，这个参数是说没有使用索引的查询不记录慢查询日志，这个一定要打开。

##### 导致抖动的原因：

1.  锂电池充放电可以引起性能的抖动；

2.  脏页满了之后执行一个查询，这个查询需要大量的数据，此时就要把脏页的大量数据刷到磁盘上，也会产生性能的抖动；

    解决办法：使用SSD硬盘，脏页刷新是随机读，使用SSD的读写是非常快的，还有一个参数：innodb_io_capacity，这个是设置IO速率的，我们可以使用fio工具得到磁盘随机IO最大速率，然后把值给这个参数。

3.  redo log刷盘的时候，如果磁盘的redo log文件写满了，需要从第一个文件的头部开始覆盖，那这个时候就得把buffer pool中的缓存数据全都刷盘，因为持久化的redo log相当于是没有了，全部刷盘的时候也会让性能抖动；

##### RAID充放电性能抖动

在使用RAID磁盘冗余阵列时，一般都会使用write_back方式写数据，意思是只写到缓存，慢慢输入磁盘，为了防止断电后，缓存中数据丢失，一般RAID卡都会有一块锂电池，在断电时，将缓存数据刷到磁盘中，此时写数据的方式变成直接写磁盘，为了保证锂电池的寿命，会自动过一段时间自己充放电，放电时直接写磁盘导致性能很低，可以修改放电时的写数据方式也是write_back，取消自动放电，改成脚本方式手动在凌晨时充放电。
##### 文件句柄导致的最大连接数限制

Linux设计的初衷是防止一个进程耗尽所有资源，所以默认给进程的文件句柄、最大锁定内存、子进程数、网络缓存都有限制，可以使用ulimit -a 查看进程被限制的各种资源的量，比如MySQL默认的文件句柄只有1024，MySQL启动时会计算出最大连接数是214，这时你设置的最大连接数400是无效的，只能修改文件句柄ulimit -HSn 65535。
##### 缓存页刷盘导致的性能抖动

当redo log文件写满时，因为会覆盖着写，所以要把buffer pool中的脏页全部刷盘，这个时候是比较耗时的，还有当加载很多数据页，buffer pool放不下时，也需要把一部分缓存页刷盘，遇到刷盘时，可能sql语句会比平时慢个刷盘的时间，解决：首先就是要用SSD，因为固态硬盘随机写比机械硬盘快，然后调整参数innodb_io_capacity的大小是硬盘随机写的速率，这样可以最大程度利用SSD的优势，还要把innodb_flush_neighbors设置成0，这样在刷盘时就不会把临近的数据页一起刷盘。这两个参数都是为了减少刷盘时间。
##### 一个查询count耗费几秒问题

有一个圈子服务，在获取用户信息进行推送的时候，需要筛选最近登录的用户推送，推送之前根据推送厂商提供的接口，每次最多只能推送1500个设备，所以需要先查出count是多少，再决定使用limit查询，类似这样的sql select count(id) from user where id in (select user_id from user_extent_info where latest_login_time < XXXX)，这个SQL每次执行会耗费几秒钟，使用explain查看发现会有三条计划，第二条主查询的描述信息里出现了join字样？？？？？并没有join的东西，就怀疑SQL自己优化出来的join，执行show warnings发现确实是SQL自己搞出来的半链接，可以使用 set optimizer_switch='semijoin=off'关闭一下半链接，在执行发现就用两百毫秒，可以确定只要不让他进行半链接优化这个语句就可以快速执行了，但是生产环境不能随意修改这种设置，所以只能修改SQL，一顿瞎猜之后发现在in条件后再加一个or 不成立的条件执行计划就变成了正常的了。
##### 一个订单记录慢查询调优

订单中有一两百万条的数据，用户查询自己的订单记录，语句是这样的select * from order where status=1 and type='' order by id desc limit **,**。刚开始都好好的，突然查询就变成了几秒，查看执行计划发现posible_keys中有这个索引的，描述也写着using where，但是key用的是id，也就是说这个语句是从聚簇索引的B+树最后一条数据开始向前查询，知道查出满足条件的数据条数，使用select * from order where force index(索引名) status=1 and type='' order by id desc limit **,**这样就恢复正常了。分析原因可能有两个，一个开始数据量少，执行计划是二级索引，数据量多了之后MySQL推断where条件查完二级索引会有大量的数据回表，这样还不如直接全表扫描，另一个是可能最开始执行计划就是用id，但是数据量少，数据量多了之后，但是用户还没有订单，这时候每次查询都是每行数据都扫描，就很慢。

