---
title: MySQL-8.索引
tags:
  - MySQL
categories: 数据库
copyright: true
---

##### 索引类型

索引是存储引擎用例快速查找数据的数据结构。innodb只支持B+树索引，但是内部有个自适应的hash索引用来提高查询速度。

###### 1）hash索引

根据索引列计算出hash码，使用hash码+行指针组成hash结构来存储索引，当发生指hash冲突的时候会追加链表。

hash索引做等值查询的时候非常快，但是他不会有索引覆盖的情况，而且他不能范围查询也不能排序。

###### 2）B+树索引

b+树的根节点在内存中，子节点和叶子节点在磁盘

B+树的优点：增加阶数减少树的高度，减少树的高度就是减少磁盘io次数，查询的io次数更稳定。

### 索引匹配规则

* 全值匹配：查询条件和索引的字段完全相同，如果是组合索引，顺序不同优化器也会优化成组合和索引相同的顺序。
* 最左侧列匹配：在组合索引中，正常排序只是按照左侧第一个，如果相同，就用左侧第二个排序，以此类推，最左侧列匹配就是查询条件中有索引包含的列的时候，查询条件必须包含这个列所在的索引的左面所有的列，查询才会走索引。
* 最左前缀匹配：就是左侧第一个列使用like%，一定只能是在右侧放%，比如class_name like '3'%。
* 范围查找：也是左侧第一个列的范围，比如 '3' < class_name and class_name < '5'。
* 等值匹配加范围匹配：范围匹配最多只能有一个，因为等值匹配可以确定下一列是有序的，按照范围查找很容易，但是第一个范围查找结束后，数据对于下一索引列是无序得了，所以只能有一个范围匹配。

### order by的索引使用
order by中有ASC也有DESC的时候是没办法走索引的；

order by后不是列，而是计算出来的字段也是不走索引的；

### group by的索引
group by和order by一样，满足索引使用规则时会走索引，不满足就不会走；
### 回表问题
因为聚簇索引里存储的都是部分列，当使用查询的字段需要回表并且回表次数太多时，MySQL会觉得还不如全表扫描快，全表扫描只需要遍历一遍索引树，所以当我们需要的字段在索引中包含了的时候，就不应该写select *了，这样都不用回表，不得不回表时，最好限制一下条数，否则很可能全表扫描。

### 创建索引
一般在业务开发完成后，需要把所有的sql检查一遍，查询的条件顺序尽量一致，然后根据条件创建组合索引；

但是对于基数很小，比如说是有0或者1，这种体现不出来二分查找的效率，还不如不建索引；

如果字段的值很大，那么可以只是用前几个字符当做索引，不过这种索引在order by或者group by中就不生效了；

避免聚簇索引频繁页分裂，应该使用自增主键；

避免二级索引过多，因为在增删改查的时候是要维护索引的B+树的，索引太多会让增删改变慢，两三个组合索引能覆盖大部分查询就可以；

当where和order by和limit一起使用但是不能同时满足索引时，优先满足where的索引；<br>
当我们使用复核索引查询时，可能有些字段没用上，这样的话还是不会走索引的，如果没用上的列时字典类型，那么可以用加一个in（字典的所有状态），比如一个复合索引，城市+性别+最近七天登录+年龄，当查询语句是where city='哈尔滨' and 21 < age < 25时是不会走索引的，可以改成where city='哈尔滨' and sex in(0, 1) and does_login_in_7_days in(0, 1) and 21 < age < 25，这样就可以正常走索引了；

还有比如简单查询加order by的时候，可以把where条件和order by放到一个索引中，这样是可以只走一个B+索引树的；<br>
尽量让每个查询都用上索引是SQL一种优化技巧，仅仅是一种。