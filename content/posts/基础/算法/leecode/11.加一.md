---
title: 11.加一
tags:
  - 算法
categories: leecode
copyright: true
---

### 题目

给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。

**示例 1：**

```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

### 解题思路

根据题面得到以下结论：

*   数组每一位都是有意义的；
*   数组中的元素都是一个0-9的数

需要注意的是数组中全9的情况，这个时候需要返回[1,0,0,0,0,0……]这样的数组。

##### 找9法

```java
/**
 * 找9法
 *
 * @author xiaohong
 */
public class PlusOneFindNine {

    public int[] plusOne(int[] digits) {
        for (int i = digits.length - 1; i >= 0; i--) {
            if (digits[i] < 9) {
                digits[i]++;
                return digits;
            } else {
                digits[i] = 0;
            }
        }

        // 走到这说明digits里是全9的情况
        int[] res = new int[digits.length + 1];
        res[0] = 1;
        for (int i = 1; i < res.length; i++) {
            res[i] = 0;
        }

        return res;
    }
}
```

##### 大数相加

这个题还有个版本是两个数组相加，这个时候就需要一个carry位记录是否进位：

```java
public class PlusOneBigNumber {

    public int[] plusOne(int[] digits) {
        int[] one = new int[]{1};
        int carry = 0;
        // 如果是两个未知数组，这里需要多一步找到最长的数组
        for (int i = digits.length - 1; i >= 0; i--) {
            int sum = digits[i] + carry;
            if (digits.length - i <= one.length) {
                sum += one[digits.length - i - 1];
            }

            carry = sum / 10;
            digits[i] = sum % 10;
        }

        if (carry == 0) {
            return digits;
        }

        int[] res = new int[digits.length + 1];
        res[0] = 1;
        System.arraycopy(digits, 0, res, 1, res.length - 1);
        return res;
    }
}
```

