---
title: 5.买卖股票的最佳时机
tags:
  - 算法
categories: leecode
copyright: true
---

### 题目

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

示例 ：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

**提示**

-   `1 <= prices.length <= 105`
-   `0 <= prices[i] <= 104`

根据题目得到一下结论：

买入时间要小于卖出时间，也就是买入时的下标i小于卖出时的下标j；
利润不能是负数；
每天只能进行一次交易，就是说不能同时买多次；

### 算法思路

暴力解法肯定很容易，两个for循环，但是时间肯定过不了，盈利公式：

利润=$ price(sale)-price(buy)$

=>利润=$\sum(price(D_{x + 1})-price(D_x))$ for $x\in [i,j-1]$

##### 归约算法

很多年前当人们发现化学、物理、计算机都涉及到了数学，那把数学单独拿出来当做一门学科还是否有必要，直到微积分的出现。计算机也一样，很多专业也涉及计算机比如金融，为什么还要把计算机单独拿出来当做一门专业，因为计算机有两个核心，规约和递归。

当人遇到未知问题的时候会倾向于把未知问题转化成已知问题的求解，再深点就是规约是把复杂问题简单化的一把尺子，他决定了把问题转换成多大粒度的子问题。举个例子：

一个数学家和物理学家坐在一起，突然饮水机着火，物理学家找到一个垃圾桶，把垃圾倒出来装上水然后去浇灭火，人们防止饮水机在着火就专门在饮水机旁边放一个装满水的垃圾桶，第二天数学家和物理学家又坐在了一起，饮水机又着火了，这个时候数学家把垃圾桶里的水倒掉，然后装满垃圾，把装满垃圾的垃圾桶递给了物理学家……。

根据上面的总盈利公式等于每天的盈利之和，比如股票价格[7,1,5,3,6,4]变成盈利的数组就是[-6,4,-2,3,-2]，求最高盈利就是连续的天数盈利最高，变成了求最大连续子数组和的问题：

```java
public int maxProfit(int[] prices) {
    int[] deltaPrices = new int[prices.length-1];
    for(int i=0; i< deltaPrices.length; i++){
        deltaPrices[i] = prices[i+1] - prices[i];
    }
    int maxProfit = maxSubArray(deltaPrices);
    return Math.max(maxProfit, 0);
}

public int maxSubArray(int[] nums) {
    int maxSum = Integer.MIN_VALUE;

    int sum = 0;
    for (int num : nums) {
        sum += num;
        if (sum > maxSum) {
            maxSum = sum;
        }
        if (sum < 0) {
            sum = 0;
        }
    }

    return maxSum;
}
```

##### 贪心算法

如果参考及时止损的思路，假设第一天买入，第二天如果赔了就卖出并且买入，如果遇到赔钱可以理解为遇见了股票的低价，只要遇到了低价我们就重新买入，声明一个变量存储当前最大利润，这样就可以根据局部最优推出全局最优：

```java
public int maxProfit(int[] prices) {
    int sum = 0;
    int buy = prices[0];
    for (int i = 1; i < prices.length; i++) {
        int sale = prices[i];
        int profit = sale - buy;
        sum = Math.max(sum, profit);
        if (profit < 0) {
            buy = sale;
        }
    }

    return sum;
}
```

##### 动态规划

动态方程：
saleOut[k] = max(prices[k] - buyIn[k - 1], saleOut[k - 1])，第k天卖出的最大利润是(第k天卖出价格减去k天之前的最低买入价格)和前k天的最大利润取最大值，所以还需要一个数组记录前k天的买入最低价格：
buyIn[k] = min(prices[k], buyIn[k - 1])，最后返回saleOut数组里的最后一个元素就可以了：

```java
public int maxProfit(int[] prices) {
    int[] buyIn = new int[prices.length];
    int[] saleOut = new int[prices.length];
    saleOut[0] = 0;
    buyIn[0] = prices[0];
    for (int i = 1; i < prices.length; i++) {
        saleOut[i] = Math.max(prices[i] - buyIn[i - 1], saleOut[i - 1]);
        buyIn[i] = Math.min(prices[i], buyIn[i - 1]);
    }
    return saleOut[prices.length - 1];
}
```

力扣上的结果很奇怪，明明动态规划比贪心使用更多的内存，结果内存反馈更优，时间上应该是差不多的，结果动态规划慢了两倍？？

##### 分治法

其实上面的三个算法都是再找卖出日期前的最低价和买入之后的最高价，分治的3个重要的步骤，拆分数组、合并子结果和结束条件，一般数组问题都是2分，当拆分出两个子数组时，买卖的天数会存在3种情况：

*   买卖都在prices1数组中，结果是profitLeft
*   买卖都在prices2数组中，结果是profitRight
*   买入在prices1数组中，卖出在prices2数组中，这个情况其实就是找prices1中的最小值和prices2中的最大值，结果是profitMid

那么合并子结果就是max(profitLeft, profitRight, profitMid)，然后我把递归的结束条件设置为数组长度<4时，因为买入和卖出不能在同一天，所以数组要有两个元素以上才会有意义，当长度<4时直接暴力双重for循环求解：

```java
public int maxProfit(int[] prices) {
    int maxProfit = 0;
    int price = maxSubArrayProfit(prices, 0 , prices.length-1);

    return Math.max(maxProfit, price);
}

public int maxSubArrayProfit(int[] nums, int leftIndex, int rightIndex) {
    int arrayLength = rightIndex - leftIndex + 1;
    if (arrayLength <= 3) {
        int maxProfit = 0;
        for(int i = leftIndex; i<rightIndex; i++){
            for(int j = leftIndex+1; j<=rightIndex; j++){
                int profit = nums[j]- nums[i];
                maxProfit = Math.max(profit, maxProfit);
            }
        }
        return  maxProfit;
    }
    // [0,1,2,3,4,5,6], (5-4)/2 + 4 = 4. 因此midIndex，也就是说midIndex+1永远有意义，如果left<right.
    int midIndex = (rightIndex - leftIndex) / 2 + leftIndex;

    int rightMaxProfit = maxSubArrayProfit(nums, midIndex + 1, rightIndex);
    int leftMaxProfit = maxSubArrayProfit(nums, leftIndex, midIndex);
    int midMaxProfit = maxProfitContainsMidIndex(nums, midIndex, leftIndex, rightIndex);

    return Math.max(leftMaxProfit, Math.max(rightMaxProfit, midMaxProfit));
}

public int maxProfitContainsMidIndex(int[] nums, int mid, int left, int right) {
    int leftMin = Integer.MAX_VALUE;
    int rightMax = Integer.MIN_VALUE;

    if (left < mid) {
        leftMin = getMinNumber(nums, left, mid);
    } else if(left == mid){
        leftMin = nums[mid];
    }

    if(right > mid+1) {
        rightMax = getMaxNumber(nums, mid+1,right);
    } else if(right == mid+1){
        rightMax = nums[mid+1];
    }

    return  rightMax - leftMin;
}

public int getMaxNumber(int[] nums, int start, int end){
    int maxSum = Integer.MIN_VALUE;
    for(int i= start; i<= end; i++){
        if(maxSum < nums[i]){
            maxSum = nums[i];
        }
    }
    return maxSum;
}

public int getMinNumber(int[] nums, int start, int end){
    int minSum = Integer.MAX_VALUE;
    for(int i= start; i<= end; i++){
        if(minSum > nums[i]){
            minSum = nums[i];
        }
    }
    return minSum;
}
```

##### 最大最小栈

感觉这个算法像是归约的变种，
