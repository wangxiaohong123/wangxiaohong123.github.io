---
title: 27.二叉树的中序遍历
tags:
  - 算法
categories: leecode
copyright: true
---

### 题目

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

**示例 1：**

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

**提示：**

-   树中节点数目在范围 `[0, 100]` 内
-   `-100 <= Node.val <= 100`

### 题解

树和图一样都是用节点和边表示的数据结构，树的分类分为有根无根、二叉多叉、有序无序、有标签无标签。

有子节点的叫父节点，没有父节点的叫根节点，没有子节点的叫叶子节点。

前中后序遍历是针对root节点而言的，并且对于任意子树都要需要满足遍历顺序：

*   前序遍历：先root，然后遍历左子树，最后右子树。
*   中序遍历：root的左子树先遍历，然后是root，最后是root的右子树。
*   后序遍历：root的左子树先遍历，然后是root的右子树，最后是root。

##### 1.递归

递归遍历比较简单，前中后序的递归遍历代码：

```java
public class InorderTraversalRecursion {

    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        inOrder(res, root);
        return res;
    }

    /**
     * 前序遍历
     */
    private void preOrder(List<Integer> res, TreeNode curNode) {
        if (null == curNode) {
            return;
        }
        res.add(curNode.val);
        preOrder(res, curNode.left);
        preOrder(res, curNode.right);
    }

    /**
     * 中序遍历
     */
    private void inOrder(List<Integer> res, TreeNode curNode) {
        if (null == curNode) {
            return;
        }
        inOrder(res, curNode.left);
        res.add(curNode.val);
        inOrder(res, curNode.right);
    }

    /**
     * 后序遍历
     */
    private void postOrder(List<Integer> res, TreeNode curNode) {
        if (null == curNode) {
            return;
        }
        postOrder(res, curNode.left);
        postOrder(res, curNode.right);
        res.add(curNode.val);
    }
}
```

##### 2.迭代-栈

因为这个题给的树节点定义没有父节点，因此需要额外保存父节点，要不然遍历到子节点时，父节点会丢失。

然后遍历节点，当发现节点存在左子节点时压栈，然后指针指向他的左子节点，当节点是叶子节点时，把叶子节点放到list中，然后出栈加入list，指针指向出栈的元素的右子节点.

```java
public class InorderTraversalStack {

    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        Stack<TreeNode> roots = new Stack<>();

        while(!roots.empty() || null != root) {
            // 如果root是空，说明这个节点遍历完了，需要从栈中找到父节点
            if (null == root) {
                root = roots.pop();
                res.add(root.val);
                root = root.right;
            } else if (null != root.left) {
                // 左子树不是空，当前节点入栈，指针指向左子树
                roots.push(root);
                root = root.left;
            } else {
                // 左子树是空，说明当前节点是子树的最左节点，需要入栈
                res.add(root.val);
                if (null == root.right && roots.size() > 0) {
                    // 左右子树都是空说明是叶子节点，这个时候需要回溯，但是得先判断栈中还有元素
                    root = roots.pop();
                    res.add(root.val);
                }
                root = root.right;
            }
        }

        return res;
    }
}
```

##### 3.迭代-前驱指针

上面可以看出来，当一个节点是作为左子树的最后一个节点时，需要记录父节点或者父节点的父节点……，此时这个节点一定没有右子节点，如果有右节点，那他肯定不是最后一个节点，所以可以借助右节点变量记录要回溯的节点信息。