---
title: 14.只出现一次的数字
tags:
  - 算法
categories: leecode
copyright: true
---

### 题目

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例 1:**

```
输入: [2,2,1]
输出: 1
```

从题目看数组中存在两类元素，第一类就是出现两次的元素，第二类是只出现一次的，题目要求时间复杂度是线性的，进阶要求是不使用额外变量。

### 题解

只要涉及到数组中找数、奇偶等的问题，排序、hash、set都差不多能解决，解决不了也可以提供思路。

##### 排序法

如果所有数都出现两次，那么一定是一个奇一个偶是一对，如果存在一个数只出现一次，那么这个数一定出现在偶数位(因为数组索引是从0开始)。

```java
public class SingleNumberCommonSolution {

    public int singleNumber(int[] nums) {
        Arrays.sort(nums);
        for (int i = 0; i < nums.length - 1; i += 2) {
            if (nums[i] - nums[i + 1] != 0) {
                return nums[i];
            }
        }

        return nums[nums.length - 1];
    }
}
```

这个算法时间复杂度不是线性的，排序就nlog^n^了，但是空间是O(1)。

##### hash法

因为重复的元素只有两次，所以把数据插入到map时，如果存在这个元素就可以直接删掉了。

```java
public class SingleNumberCommonSolution {

    public int singleNumber(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>(nums.length / 2);

        for (int num : nums) {
            if (map.containsKey(num)) {
                map.remove(num);
            } else {
                map.put(num, 0);
            }
        }

        return map.keySet().stream().findFirst().orElse(-1);
    }
}
```

这个时间复杂度是O(1)，但是空间需要一个额外的map。

##### set法

如果把所有数加和，得到的结果是2x+y，其中x是重复的元素，y是不重复的元素，这样我们在得出x+y就是所有不重复元素的和，就可以得到y了，此时y=2(x+y)-(2x+y)；

```java
public class SingleNumberCommonSolution {

    public int singleNumber(int[] nums) {
        Set<Integer> set = new HashSet<>(nums.length / 2 + 1);
        int sum = 0;
        int half = 0;
        for (int num : nums) {
            sum += num;
            if (!set.contains(num)) {
                half += num;
                set.add(num);
            }
        }

        return half * 2 - sum;
    }
}
```

##### 分治法

如果nums[]有序，当下标i满足nums[i]!=nums[i-1]&&nums[i]==nums[i+1]，那么：

*   如果i是偶数，前面就有偶数个元素，此时目标数在[i,n]之间
*   如果i是奇数，前面就有奇数个元祖，此时目标数在[0,i-1]之间

参考获取第k小元素思路，这样我们可以边排序变找到目标数：

```java
public class SingleNumberDivideConquer {

    public int singleNumber(int[] nums) {
        return getSingleNumber(nums, 0, nums.length-1);
    }

    public int getSingleNumberBySet(int[] nums, int startIndex, int endIndex){
        long sum = 0;
        Set<Integer> uniqueEle = new HashSet<>();
        for(int i=startIndex; i<=endIndex; i++){
            sum += nums[i];
            uniqueEle.add(nums[i]);
        }
        long uniqueSum = 0;
        for(int n: uniqueEle){
            uniqueSum += n;
        }
        return (int) (2*uniqueSum - sum);
    }

    public int getSingleNumber(int[] nums, int startIndex, int endIndex){
        int pIndex = partition(nums, startIndex, endIndex);
        int length = endIndex - startIndex +1;
        if(length <=3){
            return getSingleNumberBySet(nums, startIndex, endIndex);
        }
        if((pIndex - startIndex) % 2 == 0){
            return getSingleNumber(nums, pIndex, endIndex);
        }else {
            return getSingleNumber(nums, startIndex, pIndex-1);
        }
    }

    public int partition(int[] nums, int startIndex, int endIndex) {
        int pivot = randomPick(nums,  startIndex, endIndex);
        int pivotIndex = startIndex;
        for (int i = startIndex; i <= endIndex; i++) {
            if (nums[i] == pivot) {
                pivotIndex = i;
                break;
            }
        }
        // 交换哨兵位置
        swap(nums, pivotIndex, endIndex);

        int smallerIndex = startIndex - 1;
        for (int j = smallerIndex + 1; j < endIndex; j++) {
            if (nums[j] < pivot) {
                swap(nums, j, ++smallerIndex);
            }
        }
        // 让pivot回到正确的位置
        swap(nums, endIndex, ++smallerIndex);
        return smallerIndex;
    }

    public static int randomPick(int[] nums, int startIndex, int endIndex) {
        Random r = new Random();
        Set<Integer> set = new LinkedHashSet<>();
        if(endIndex - startIndex +1 < 22){
            Arrays.sort(nums, startIndex, endIndex+1);
            return nums[(endIndex - startIndex)/2+startIndex];
        }
        while (set.size() < 11) {
            int offset = r.nextInt(endIndex - startIndex + 1);
            set.add(offset);
        }
        int[] x = new int[11];
        Object[] indexArray = set.toArray();
        for (int i = 0; i < indexArray.length; i++) {
            x[i] = nums[(Integer) indexArray[i] + startIndex];
        }
        Arrays.sort(x);
        return x[5];
    }

    public void swap(int[] a, int i, int j) {
        if (a[i] != a[j]) {
            int temp = a[i];
            a[i] = a[j];
            a[j] = temp;
        }
    }
}
```

##### 位运算法

位运算是基于0和1的逻辑运算，操作包含“与、或、非、异或、左移、右移、无符号右移”：

*   非操作（~）：0变1,1变0，一般用在取补码；
*   与操作（&）：两个都是1就是1，其他情况都是0，一般用在掩码联合使用；
*   或操作（|）：有1个1就是1；
*   异或操作（^）：两个位不同就是1，相同是0；
*   左移（<<）：往后补0，左移1位就是乘2；
*   右移（>>）：如果是负数，第一位是1，那么右移之后第一位也要补1，其他位补0，右移1位就是除2；
*   无符号右移（>>>）：正常右移，往前补0；

通过异或直接可以实现这个题的思路，因为重复的数的二进制位可以相互抵消，所以所有数的二进制在某一位做异或操作如果最后是1，说明是这位就是只出现1次数字对应的位的值。

```java
public class SingleNumberByteOperation {

    public int singleNumber(int[] nums) {
        int res = nums[0];
        for (int i = 1; i < nums.length; i++) {
            res ^= nums[i];
        }

        return res;
    }
}
```

