---
title: 7.多数元素
tags:
  - 算法
categories: leecode
copyright: true
---

### 题目

给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。

##### 示例 1：

输入：nums = [3,2,3]
输出：3

##### 示例 2：

输入：nums = [2,2,1,1,1,2,2]
输出：2

##### 提示：

*   n == nums.length
*   1 <= n <= 5 * 10^4^
*   -10^9^ <= nums[i] <= 10^9^

### 算法思路

题目给到的信息是数组长度至少为1，并且一定有解，并且是1个解，那其实就是找到数组中出现次数最多的元素。一般力扣上的1维数组的算法都可以实现O(1)的空间复杂度。

##### hash表求解

hash求解就是把每个元素出现的次数记录到hash表中，然后在遍历hash表找到次数最大的：

```java
public class MajorityElementHashMap {

    public int majorityElement(int[] nums) {
        Map<Integer, Integer> hashMap = new HashMap<>(nums.length);

        for (int num : nums) {
            Integer count = hashMap.getOrDefault(num, 0);
            hashMap.put(num, count + 1);
        }

        int mid = nums.length / 2;

        for (Integer num : hashMap.keySet()) {
            if (hashMap.get(num) - mid > 0) {
                return num;
            }
        }

        return -1;
    }
}
```

##### 随机法

参考两数之和找到一个随机次数，每次生成一个随机数的下标，然后从数组中取出这个数，遍历数组，判断随机拿到这个数是不是想要的结果。

##### 消元法

多数元素有个特性就是比其他元素的个数和还要多，那就可以使用两个指针遍历数组，当发现两个不同元素的时候就把这两个数置空，最后剩下的就是多数元素，不管消除的两个数包不包含多数元素对结果是没有影响的：

```java
public class MajorityElementEliminate {

    public int majorityElement(int[] nums) {
        int i = 0;

        for (int j = 1; j < nums.length; j++) {
            if (i - j == 0 || nums[i] - nums[j] == 0 || nums[j] == -1) {
                continue;
            }
            
            nums[j] = -1;
            nums[i] = -1;
            do {
                i++;
            } while (i < nums.length && nums[i] == -1);
        }
        return nums[i];
    }
}
```

##### 投票法

这个是力扣官方的解法，和消元法的思想一样， 利用多数元素消除少数元素，还是遍历数组，假设第一个元素就是多数元素，使用变量cnt记录元素出现的次数，当发现元素和多数元素不相等的时候cnt--，反之cnt++，如果cnt=0，多数元素就换成当前遍历的元素：

```java
public class MajorityElementElection {

    public int majorityElement(int[] nums) {
        int cnt = 1;
        int majorNum = nums[0];

        for (int i = 1; i < nums.length; i++) {
            int num =  nums[i];
            if (cnt == 0) {
                cnt++;
                majorNum = num;
                continue;
            }

            if (num - majorNum == 0) {
                cnt++;
            } else {
                cnt--;
            }
        }

        return majorNum;
    }
}
```

##### 分治法

能不能用分治法求解就就看能不能将问题拆解，如果存在多数元素，那么**把数组分成两半之后必然有一个数组中存在多数元素**，然后在考虑终止条件，数组长度小于3去找多数元素就没意义了，所以当数组长度小于5的时候就可以不分了，直接找多数元素，如果没有多数元素可以直接返回一个，因为这半里没有多数元素，那么一定在另一半里：

```java
public class MajorityElementDivideConquer {

    public int majorityElement(int[] nums) {
        if (nums.length == 1) {
            return nums[0];
        }
        return subArrayMajority(nums, 0, nums.length - 1);
    }

    public int subArrayMajority(int[] nums, int startIndex, int endIndex){
        int arrayLength = endIndex - startIndex +1;
        if (arrayLength <= 5) {
            Arrays.sort(nums, startIndex, endIndex+1);
            return nums[arrayLength/2+ startIndex];
        }

        int midIndex = startIndex + arrayLength/2;
        int leftMajor = subArrayMajority(nums, startIndex, midIndex);
        if (isMajor(nums, startIndex, endIndex, leftMajor)) {
            return leftMajor;
        } else {
            return subArrayMajority(nums, midIndex + 1, endIndex);
        }
    }

    public boolean isMajor(int[] nums, int startIndex, int endIndex, int major) {
        int cnt = 0;
        int halfLen = (endIndex - startIndex + 1) / 2;
        for (int i = startIndex; i <= endIndex; i++) {
            if (nums[i] - major == 0) {
                cnt++;
            }
        }

        return cnt - halfLen > 0;
    }
}
```

##### 排序法

分治法里得出了一个结论，就是有序的数组中，中间那个元素一定是多数元素，所以直接把数组排序，返回length / 2位置的元素即可：

```java
public class MajorityElementRandomSort {

    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length / 2];
    }
}
```

但是排序算法的时间复杂度是不可能优于nlog^n^的，这个题也不是要把所有的元素都排序，其实就是转换成找到数组中第k小的数。算法导论中选择第k小的数的算法叫BFPRT，有点复杂，时间复杂度也不稳定。