---
title: 8.存在重复元素
tags:
  - 算法
categories: leecode
copyright: true
---

### 题目

给你一个整数数组nums 。如果任一值在数组中出现至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。

**示例 1：**

```
输入：nums = [1,2,3,1]
输出：true
```

**提示：**

-   1 <= nums.length <= 10^5^
-   -10^9^ <= nums[i] <= 10^9^

### 解题思路

第一个注意的就是数组不会是空。至少出现2次这是一个剪枝条件。

这个和两数之和很像，随机和暴力都可以，但是力扣上过不了，随机是有失败概率的，暴力会超时。

##### 排序法

如果把数组排序，只需要用一个指针一直遍历，直到找到和后一个元素相同的情况，为了节省时间，我这里采用两个指针前后同时遍历：

```java
public class ContainsDuplicateSort {

    public boolean containsDuplicate(int[] nums) {
        Arrays.sort(nums);

        for (int i = 1; i <= nums.length / 2; i++) {
            if ((nums[i] - nums[i - 1] == 0) || (nums[nums.length - i] - nums[nums.length - i - 1] == 0)) {
                return true;
            }
        }

        return false;
    }
}
```

##### 线性求解

利用hash、set、bitset存储数组的元素，然后遍历数组的时候检查是否存在重复，hash为例：

```java
public class ContainsDuplicateHash {

    public boolean containsDuplicate(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>(nums.length);

        for (int num : nums) {
            Integer exist = map.get(num);

            if (null != exist) {
                return true;
            }

            map.put(num, 0);
        }

        return false;
    }
}
```

使用bitSet需要注意数组中可能有负数，bitSet中存储的位移应该都是正数，所以多了一步找到最小的负数，把数组所有元素减掉这个最小负数，保证元素在放进bitSet中的时候都是大于0的：

```java
public class ContainsDuplicateBit {

    public boolean containsDuplicate(int[] nums) {
        BitSet set = new BitSet();

        int min = 0;
        for(int num: nums){
            min = Math.min(min, num);
        }

        for (int num : nums) {
            num -= min;
            if (set.get(num)) {
                return true;
            }

            set.set(num);
        }

        return false;
    }
}
```

但是bitSet很慢，慢就慢在当一个数很大时，他需要遍历很多位。