---
title: 28.对称二叉树
tags:
  - 算法
categories: leecode
copyright: true
---

### 题目

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**提示：**

-   树中节点数目在范围 `[1, 1000]` 内
-   `-100 <= Node.val <= 100`

### 题解

对称二叉树就是以根节点为轴的镜像对称，就是说左侧的左子节点要和右侧的右子节点相同，左侧的右子节点要和右侧的左子节点相同，

然后一层一层比较。

##### 1.递归

具有高度可重复的操作，尤其是树的题都可以用递归解决：

```java
public class IsSymmetricRecur {

    public boolean isSymmetric(TreeNode root) {
        return check(root.left, root.right);
    }

    private boolean check(TreeNode left, TreeNode right) {
        if (null == left && null == right) {
            return true;
        } else if (null != left && null != right) {
            return left.val == right.val && check(left.left, right.right) && check(left.right, right.left);
        } else {
            return false;
        }
    }
}
```

##### 2.广度/宽度优先搜索(宽搜，BFS)

借助广度优先思想，把root左边和右边的按层分别放进队列，然后再从队列里取出比较：

```java
public class IsSymmetricIterative {

    public boolean isSymmetric(TreeNode root) {
        Queue<TreeNode> ql = new LinkedList<>();
        Queue<TreeNode> qr = new LinkedList<>();

        if (null == root.right && null == root.left) {
            return true;
        } else if (null == root.right || null == root.left) {
            return false;
        }

        ql.add(root.left);
        qr.add(root.right);
        while (!ql.isEmpty() && !qr.isEmpty()) {
            TreeNode l = ql.poll();
            TreeNode r = qr.poll();
            if (l.val != r.val) {
                return false;
            }

            if (null != l.left && null != r.right) {
                ql.add(l.left);
                qr.add(r.right);
            } else if (null != l.left || null != r.right) {
                return false;
            }

            if (null != r.left && null != l.right) {
                ql.add(l.right);
                qr.add(r.left);
            } else if (null != r.left || null != l.right) {
                return false;
            }
        }

        return true;
    }
}
```

这个中间比较的代码有点绕，笔试时优先选择第一种思路，这个可以作为面试时的口头解法或者写伪代码。

##### 3.序列

BFS并不能确定一个二叉树的结构，在树的算法中，中序遍历+前序遍历可以确定一个唯一的二叉树。

所以我们以root中轴线划分出左右两个子树，要证明这两个子树是镜像对称，可以把左子树的前序遍历+中序遍历和右子树的镜像前序遍历+镜像中序遍历比较，如果完全相等那么就是对称二叉树。

所以我这里把两个数的两种遍历结果存到字符串中，遍历结束之后比较字符串就可以，**注意**当节点缺失左节点或者右节点的时候，需要把缺失的节点存成空格，否则比较的时候容易出错。

```java
public class IsSymmetricOrder {

    public boolean isSymmetric(TreeNode root) {
        String leftOrder = inorderTraversal(root.left);
        String rightOrder = coInorderTraversal(root.right);
        String leftPreorder = preorderTraversal(root.left);
        String rightPreorder = coPreorderTraversal(root.right);
        return leftOrder.equals(rightOrder) && leftPreorder.equals(rightPreorder);
    }

    public String preorderTraversal(TreeNode root) {
        if (root == null) {
            return " ";
        } else if (root.left == null && root.right == null) {
            return String.valueOf(root.val);
        }
        return root.val + preorderTraversal(root.left) + preorderTraversal(root.right);
    }

    public String coPreorderTraversal(TreeNode root) {
        if (root == null) {
            return " ";
        } else if (root.left == null && root.right == null) {
            return String.valueOf(root.val);
        }
        return  root.val + coPreorderTraversal(root.right) + coPreorderTraversal(root.left);
    }

    public String coInorderTraversal(TreeNode root) {
        if (root == null) {
            return " ";
        } else if (root.left == null && root.right == null) {
            return String.valueOf(root.val);
        }
        return coInorderTraversal(root.right) + root.val + coInorderTraversal(root.left);
    }

    public String inorderTraversal(TreeNode root) {
        if (root == null) {
            return " ";
        } else if (root.left == null && root.right == null) {
            return String.valueOf(root.val);
        }
        return inorderTraversal(root.left) + root.val + inorderTraversal(root.right);
    }
}
```

