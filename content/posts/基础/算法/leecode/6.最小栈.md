---
title: 6.最小栈
tags:
  - 算法
categories: leecode
copyright: true
---

### 题目

设计一个支持push，pop，top操作，并能在常数时间内检索到最小元素的栈。实现 MinStack类:

*   MinStack() 初始化堆栈对象。
*   void push(int val) 将元素val推入堆栈。
*   void pop() 删除堆栈顶部的元素。
*   int top() 获取堆栈顶部的元素。
*   int getMin() 获取堆栈中的最小元素。

### 算法思路

*   如果内部使用数组或者链表的话，push、pop、top都可以是O(1)，但是getMin需要O(n)。
*   如果单独维护一个有序数组或者链表，那push和pop就变成了O(log^n^)。
*   如果单独维护一个小顶堆，push是O(log^n^)，pop是O(n + log^n^)，因为需要找到顶堆中的元素。

上面所有的操作都是为了解决getMin的时间复杂度，getMin和元素的插入顺序有关系。

##### 双栈法

参考动态规划的思想，栈的最小元素存成数组，getMin就是拿最小数组的[站长度 - 1]：

```java
public class MinStack_TwoStacks {

    private List<Integer> stack;
    private List<Integer> minStack;

    public MinStack_TwoStacks() {
        stack = new LinkedList<>();
        minStack = new LinkedList<>();
    }

    public void push(int val) {
        if (minStack.size() == 0) {
            minStack.add(val);
        } else {
            minStack.add(Math.min(minStack.get(minStack.size() - 1), val));
        }
        stack.add(val);
    }

    public void pop() {
        if (stack.size() == 0) {
            return;
        }
        stack.remove(stack.size() - 1);
        minStack.remove(minStack.size() -1);
    }

    public int top() {
        if (stack.size() == 0) {
            return -1;
        }
        return stack.get(stack.size() - 1);
    }

    public int getMin() {
        if (stack.size() == 0) {
            return -1;
        }
        return minStack.get(stack.size() - 1);
    }
}
```

##### 单栈法

如果只使用一个数组或者链表，链表里存储的不是一个数值，而是一个对象，这样也可以，但是没啥差别，优化成单栈的目的是为了节省空间，如果使用一个数值记录当前状态的minValue，那数组或者链表里存储元素具体值是不够的，如果存储的是具体值和当前minValue的差值呢？

*   push操作，没有元素就直接赋值minValue，此时栈的第一个元素值是0，如果入栈的值比minValue大，直接存储差值，如果比minValue的元素小就修改minValue的值；
*   pop操作：因为栈中记录的数值是当前数值和上一个minValue的差值，如果栈中数值是正数，说明当前元素比minValue大，直接加上minValue返回即可，如果是负数说明当前元素就是最小值，而且出栈后需要修改minValue值，因为当前栈值是元素和上一个minValue的差值，可以求出上一个minValue的数值；
*   top操作：和pop一样的道里，只不过不需要删除和修改，直接计算出栈顶数值返回；
*   getMin操作：直接返回minValue；

```java
public class MinStack_SingleStacks {

    /**
     * 这里要注意，下面有整数的加减，很容易出现超出范围的情况
     * 所以我把泛型和minValue的类型都设置成了long
     */
    private List<Long> stack;
    private long minValue;

    public MinStack_SingleStacks() {
        stack = new LinkedList<>();
        minValue = Integer.MAX_VALUE;
    }

    public void push(int val) {
        if (stack.size() == 0) {
            minValue = val;
            stack.add(0L);
        } else {
            long difValue = val - minValue;
            stack.add(difValue);
            if (difValue < 0) {
                minValue = val;
            }
        }
    }

    public void pop() {
        if (stack.size() == 0) {
            return;
        }

        long value = stack.remove(stack.size() - 1);
        if (value < 0) {
            minValue -= value;
        }
    }

    public int top() {
        if (stack.size() == 0) {
            return -1;
        }

        long value = stack.get(stack.size() - 1);
        if (value < 0) {
            return Math.toIntExact(minValue);
        } else {
            return Math.toIntExact(value + minValue);
        }
    }

    public int getMin() {
        return Math.toIntExact(minValue);
    }
}
```

##### 链表法

栈和链表是非常像的，都是只能快速访问边缘的元素，如果我们自己实现一个单向链表，top、push、pop都是正常操作，只需要维护一个minValue的指针就可以了：

```java
public class MinStack_Link {

    LinkNode tail;

    public MinStack_Link(){
        tail = null;
    }

    public void  push(int x){
        LinkNode node;
        if(tail == null){
            node = new LinkNode(x, null);
        } else {
            node = new LinkNode(x, tail);
        }
        tail = node;
    }

    public void pop() {
        tail = tail.nextNode;
    }

    public int top() {
        return tail.value;
    }

    public int getMin() {
       return tail.minNode.value;
    }

    private static class LinkNode{
        int value;
        LinkNode minNode;
        LinkNode nextNode;

        LinkNode(int value, LinkNode tail){
            this.value = value;
            nextNode = tail;

            if(tail == null || value < tail.minNode.value){
                minNode = this;
            }else{
                minNode = tail.minNode;
            }
        }
    }
}
```

