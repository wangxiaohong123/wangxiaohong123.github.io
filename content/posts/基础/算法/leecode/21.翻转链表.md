---
title: 21.翻转链表
tags:
  - 算法
categories: leecode
copyright: true
---

### 题目

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

**示例:**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**限制：**

`0 <= 节点个数 <= 5000`

### 题解

这个题的原链表是可以修改的。

##### 1.三指针法

在遍历的时候修改指针的指向

```java
public class ReverseListThreePoints {

    public ListNode reverseList(ListNode head) {
        if (null == head || null == head.next) {
            return head;
        }

        // cur指向没翻转的头，pre指向已经翻转的头，next保护现场
        ListNode pre = null;
        ListNode next;
        ListNode cur = head;
        while (null != cur) {
            // 指针翻转
            next = cur.next;
            cur.next = pre;

            // 指针移动
            pre = cur;
            cur = next;
        }

        return pre;
    }

    static class ListNode {
        int val;
        ListNode next;
        ListNode(int x) {
            val = x;
        }
    }
}
```

##### 2.双指针

上面的解法中，入参head是没用到的，可以用它存储三指针中的某一个指针，其实随便替换一个就行，因为cur指针在每一步都用到了，所以我选择替换cur：

```java
public class ReverseListTwoPoints {

    public ListNode reverseList(ListNode head) {
        if (null == head || null == head.next) {
            return head;
        }

        ListNode pre = head;
        ListNode next;
        while (null != head.next) {
            next = head.next.next;
            head.next.next = pre;

            pre = head.next;
            head.next = next;
        }

        return pre;
    }

    static class ListNode {
        int val;
        ListNode next;
        ListNode(int x) {
            val = x;
        }
    }
}
```

##### 3.堆栈法

猜测题目判断是否翻转成功是通过value来判断的，所以我们可以通过修改value不修改指针来实现，栈的规则是先进后出，很适合这个思路，list也可以，就是遍历的时候需要从后往前，这个算法的时间、空间都不好：

```java
public class ReverseListStack {

    public ListNode reverseList(ListNode head) {
        Stack<Integer> stack = new Stack<>();
        ListNode h = head;

        while (null != h) {
            stack.add(h.val);
            h = h.next;
        }

        h = head;
        while (null != h) {
            h.val = stack.pop();
            h = h.next;
        }

        return head;
    }

    static class ListNode {
        int val;
        ListNode next;
        ListNode(int x) {
            val = x;
        }
    }
}
```