---
title: 22.最长公共前缀
tags:
  - 算法
categories: leecode
copyright: true
---

### 题目

编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。

**示例 1：**

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**提示：**

-   `1 <= strs.length <= 200`
-   `0 <= strs[i].length <= 200`
-   `strs[i]` 仅由小写英文字母组成

### 题解

输入的字符串数组可以理解成一个二维的字符数组，第一维是字符串个数，第二维是字符串的字符数。假设最长公共前缀叫LCP。

##### 1.横向对比

首先LCP一定是数组中所有字符串两两组合得到的LCP的最短的那个，然后LCP满足下面的公式
$$
A,B,C的LCP=LCP((A,B),C) \\
=LCP((A,C),B)\\
=LCP((B,C),A)
$$

```java
public class LongestCommonPrefixTransverseCompare {

    public String longestCommonPrefix(String[] strs) {
        if (null == strs || strs.length == 0) {
            return "";
        }

        String lcp = strs[0];
        for (int i = 1; i < strs.length; i++) {
            lcp = twoStringLcp(lcp, strs[i]);
        }

        return lcp;
    }

    public String twoStringLcp(String s1, String s2) {
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < Math.min(c1.length, c2.length); i++) {
            if (c1[i] != c2[i]) {
                break;
            }

            sb.append(c1[i]);
        }

        return sb.toString();
    }
}
```

##### 2.分治法

上面的横向对比可以改成分治的写法：

```java
public class LongestCommonPrefixDivideConquer {

    public String longestCommonPrefix(String[] strs) {
        if (null == strs || null == strs[0]) {
            return "";
        }

        return divideLcp(strs, 0, strs.length - 1);
    }

    private String divideLcp(String[] strs, int start, int end) {
        if (end - start == 0) {
            return strs[start];
        }
        if (end - start == 1) {
            return twoStringLcp(strs[start], strs[end]);
        }

        int mid = start + (end - start) / 2;
        String l = divideLcp(strs, start, mid);
        String r = divideLcp(strs, mid + 1, end);

        return twoStringLcp(l, r);
    }

    private String twoStringLcp(String s1, String s2) {
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < Math.min(c1.length, c2.length); i++) {
            if (c1[i] != c2[i]) {
                break;
            }

            sb.append(c1[i]);
        }

        return sb.toString();
    }
}
```

##### 3.纵向对比

把字符串数组转成二维的char数组，然后一列一列对比，这样做的好处是比较次数变少了：

```java
public class LongestCommonPrefixAxisCompare {

    public String longestCommonPrefix(String[] strs) {
        if (null == strs || null == strs[0]) {
            return "";
        }

        char[][] cl = new char[strs.length][];
        int minLength = Integer.MAX_VALUE;
        for (int i = 0; i < strs.length; i++) {
            cl[i] = strs[i].toCharArray();
            minLength = Math.min(minLength, strs[i].length());
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < minLength; i++) {
            char norm = cl[0][i];
            for (char[] c : cl) {
                if (c[i] != norm) {
                    return sb.toString();
                }
            }
            sb.append(norm);
        }

        return sb.toString();
    }
}
```

##### 4.排序法

在横向比较的思路里字符串的顺序很重要，如果前2个字符串只需要比较2位那么后面最多就比较2位。如果说字符串能按照某种字典序排序，只需要比较第一个字符和最后一个字符就可以了。

```java
public class LongestCommonPrefixSort {

    public String longestCommonPrefix(String[] strs) {
        if (null == strs || null == strs[0]) {
            return "";
        }

        Arrays.sort(strs);
        return twoStringLcp(strs[0], strs[strs.length - 1]);
    }

    public String twoStringLcp(String s1, String s2) {
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < Math.min(c1.length, c2.length); i++) {
            if (c1[i] != c2[i]) {
                break;
            }

            sb.append(c1[i]);
        }

        return sb.toString();
    }
}
```

如果这么实现时间复杂度是最大的，因为字符串排序本身就需要比较，其实我们要的不是排序，而是找到某种规则下的最大字符串和最小字符串:

```java
public class LongestCommonPrefixSort {

    public String longestCommonPrefix(String[] strs) {
        if (null == strs || null == strs[0]) {
            return "";
        }

        String maxString = strs[0];
        String minString = strs[0];
        for (String str : strs) {
            if (aLargerThanB(str, maxString)) {
                maxString = str;
            }
            if (aLargerThanB(minString, str)) {
                minString = str;
            }

        }
        return twoStringLcp(maxString, minString);
    }

    private boolean aLargerThanB(String a, String b) {
        char[] c1 = a.toCharArray();
        char[] c2 = b.toCharArray();

        for (int i = 0; i < Math.min(c1.length, c2.length); i++) {
            if (c1[i] > c2[i]) {
                return true;
            } else if (c1[i] < c2[i]) {
                return false;
            }
        }

        return a.length() > b.length();
    }

    private String twoStringLcp(String s1, String s2) {
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < Math.min(c1.length, c2.length); i++) {
            if (c1[i] != c2[i]) {
                break;
            }

            sb.append(c1[i]);
        }

        return sb.toString();
    }
}
```

这么改完之后时间并没有快多少，可能java的sort方法优化的比较好。