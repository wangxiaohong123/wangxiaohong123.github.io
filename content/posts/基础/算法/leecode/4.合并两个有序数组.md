---
title: 4.合并两个有序数组
tags:
  - 算法
categories: leecode
copyright: true
---

### 题目

给你两个按非递减顺序排列的整数数组nums1和nums2，另有两个整数m和n ，分别表示nums1和nums2中的元素数目。请你合并nums2到nums1中，使合并后的数组同样按非递减顺序排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1的初始长度为m + n，其中前m个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

示例 1：

输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。

**提示：**

*   nums1.length == m + n
*   nums2.length == n
*   0 <= m, n <= 200
*   1 <= m + n <= 200
*   -109 <= nums1[i], nums2[j] <= 109

根据题目得到以下结论：

非递减顺序排列的整数数组再加上题目的有序数组得到的结论就是数组是递增的，同时返回结果也是递增的。

不需要返回结果，只需要把nums2合并到nums1中。

nums1.length == m + n、1 <= m + n <= 200所以nums1.length>1。

### 算法思路

##### 1.暴力解法

第一种暴力就直接把nums2赋值给nums1的后半段然后数组排序：

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
    // System.arraycopy(nums2, 0, nums1, m, n);
    for (int i = 0; i < n; i++) {
        nums1[m + i] = nums2[i];
    }
    Arrays.sort(nums1);
}
```

第二种暴力解法：其实这个题就是合并两个有序数组，如果使用两个指针分别遍历两个数组，把两个数组按小到大合并到一个新数组，最后赋值给nums1是可以解出来的(也就是归并思想)，但是nums1已经有足够的空间了，这个时候我们可以考虑借助插入排序的思想，**当不考虑使用java内置排序，如果对空间的要求是O(1)可以考虑使用插入排序**。如果我们正序遍历两个数组，会涉及到nums1里的元素后移的问题，时间复杂度很可能到O(n^2^)，因为这道题限制了数组长度，两个数组的长度和都要小于200，所以在力扣上执行时间很快，如果数组长度是10^9^这类的估计会超时，不写了，太麻烦。

##### 2.逆序归并

因为nums1的后半段是可以利用的，所以我们反过来，还是两个指针，从后往前遍历两个数组，把两个数组按从大到小的顺序合并到nums1里就可以了：

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
    int nums1Point = m - 1;
    int resPoint = m + n - 1;
    int nums2Point = n - 1;
    // 这里的判断条件需要注意一下
    // 只要遍历完一个数组也就是其中一个数组的指针小于0就结束
    // 如果所有情况都在这里处理要写很多if条件
    while (nums2Point >= 0 && nums1Point >= 0) {
        if (nums2[nums2Point] > nums1[nums1Point]) {
            nums1[resPoint--] = nums2[nums2Point--];
        } else {
            nums1[resPoint--] = nums1[nums1Point--];
        }
    }
    // 如果nums1没遍历完，nums2遍历完这里的for是不会走的，也不需要走，因为nums1本身就是有序的
    // 如果nuns2没遍历完，nums1遍历完了，因为nums2也是有序的，剩下的数据直接顺序赋值
    for (int i = 0; i <= nums2Point; i++) {
        nums1[i] = nums2[i];
    }
}
```

时间复杂度就是O(m + n)。

