---
title: 29.将有序数组转换成二叉搜索树
date: 2022-11-11 06:27:35
tags:
  - 算法
categories: leecode
copyright: true
---

### 题目

给你一个整数数组 nums ，其中元素已经按升序排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

**示例：**

输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：

**提示：**

-   `1 <= nums.length <= 10`^4^
-   `-10` ^4^`<= nums[i] <= 10`^4^
-   `nums` 按 **严格递增** 顺序排列

### 题解

平衡树就和题面意思一样：满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

二叉搜索树：对于树种任意节点，他的左子树所有节点值都小于自身，右子树的所有节点值都大于自身。

**一个极端的二叉搜索树就是递增的链表**。所以二叉搜索树都要和平衡树结合起来。而且二叉平衡搜索树并不唯一。

##### 1.AVL

因为题目输入的是有序数组，所以我们可以直接遍历，把他转成一个极端的二叉树，在通过左旋、右旋把他变成一个平衡二叉树：

*   左旋公式：

    ```java
    x = 目标节点;
    y = x.right;
    x.right = y.left;
    y.lefy = x;
    ```

左旋转之后的新树左侧高度至少+1，右侧高度至少-1。

*   右旋公式：

    ```java
    x = 目标节点;
    y = x.left;
    x.left = y.right;
    y.right = x;
    ```

右旋之后的高度和左旋相反。

什么时候要进行左旋呢？当右子树比左子树的高度差超过1就要左旋。反过来就需要右旋。而且并不需要考虑子树，因为子树一定是平衡的，因为我们并没有修改子树的结构。

这个一般不会在笔试的时候考，面试的时候说出思路就可以。记录左边深度和右边的深度，然后两个深度超过2就左旋或者右旋，复杂的地方就是不断更新左右的深度。

##### 2.Inorder

题目给出的是一个升序数组，二叉搜索树的中序遍历一定是升序数组。所以数组的中间的数可以作为root，这样可以保证还原的数是平衡的，这样一直递归就完事儿了。

```java
public class SortedArrayToBSTInorder {

    public TreeNode sortedArrayToBST(int[] nums) {
        return subSortedArrayToBST(nums, 0, nums.length - 1);
    }

    public TreeNode subSortedArrayToBST(int[] nums, int start, int end) {
        if (start > end) {
            return null;
        } else if (start == end) {
            return new TreeNode(nums[start]);
        } else {
            int mid = start + (end - start) / 2;
            TreeNode root = new TreeNode(nums[mid]);
            root.left = subSortedArrayToBST(nums, start, mid - 1);
            root.right = subSortedArrayToBST(nums, mid + 1, end);

            return root;
        }
    }
}
```