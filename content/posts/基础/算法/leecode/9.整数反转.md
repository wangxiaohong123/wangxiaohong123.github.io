---
title: 9.整数反转
tags:
  - 算法
categories: leecode
copyright: true
---

### 题目

给你一个32位的有符号整数x ，返回将x中的数字部分反转后的结果。如果反转后整数超过32位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）。

**示例 1：**

```
输入：x = -123
输出：-321
```

**示例 2：**

```
输入：x = 120
输出：21
```

### 解题思路

题目明确规定不能使用比int更大范围的类型。这个题主要有两点需要解决：反转整数和判断溢出，反转比较简单，关键就是判断溢出(因为判断溢出的时候，这个数本身不能溢出)。

反转有两种方法，一种是边取模边计算新数；第二种是先取模然后把模存到list中，然后在遍历list计算新数。

判断溢出也有两种方法，一种是比较法，如果允许存在64位的数，直接和Integer.MIN_VALUE或者Integer.MAX_VALUE比较就可以，不允许的话可以通过不等式转换：
$$
rev * 10 + y > Integer.MAX\_VALUE\ 且\ y = x\ \%\ 10\\
rev * 10 > Integer.MAX\_VALUE - y\\
rev > (Integer.MAX\_VALUE - x\ \%\ 10)\ /\ 10
$$
只要满足这个表达式就说明rev下个数会越界，同理也能得到Integer.MIN_VALUE的公式；

第二种方式就是自检，**如果新数 = rev * 10 + y溢出了，那么新数 / 10和原来是不相等的**。

##### 数学法

```java
public class ReverseMath {

    public int reverse(int x) {
        int res = 0;
        while (x != 0) {
            // 这里是公式rev > (Integer.MAX_VALUE - x % 10) / 10的简化
            // 因为传入的数字是32位，最大值的第一位只能是2
            // 只有超过7的时候才会导致简化的公式不正确
            if (x > 0) {
                if (res > Integer.MAX_VALUE / 10) {
                    return 0;
                }
            } else {
                if (res < Integer.MIN_VALUE / 10) {
                    return 0;
                }
            }

            res = res * 10 + x % 10;
            x /= 10;
        }

        return res;
    }
}
```

时间复杂度的话是log^m^，m是输入的数字大小。

##### 字典序法

上面的比较都是通过整数，把整数拆成字符串或者字典里比较大小就是字典序发的思路。

这里有两个概念，全序和偏序，全序就是任意两个序列都可以比较，偏序就是部分。要把整数转成全序字典，就需要长度补0，比如123会变成0000000123，如果要基于偏序实现比较就需要先比较长度。

```java
public class ReverseLexicography {

    public int reverse(int x) {
        String maxValue = "2147483647";
        if (x < 0) {
            maxValue = "2147483648";
        }

        String rev = reverseNumber(Math.abs(x));

        if (compare(rev, maxValue)) {
            return 0;
        }

        if (x < 0) {
            rev = "-" + rev;
        }

        return Integer.parseInt(rev);
    }

    private String reverseNumber(int x) {
        StringBuilder sb = new StringBuilder();
        char[] chars = String.valueOf(x).toCharArray();
        for (int i = chars.length - 1; i >= 0; i--) {
            sb.append(chars[i]);
        }

        return sb.toString();
    }

    private boolean compare(String x, String max) {
        if (x.length() - max.length() < 0) {
            return false;
        }

        for (int i = 0; i < x.length(); i++) {
            if (x.charAt(i) - max.charAt(i) > 0) {
                return true;
            } else if (x.charAt(i) - max.charAt(i) < 0) {
                return false;
            }
        }

        return false;
    }
}
```

