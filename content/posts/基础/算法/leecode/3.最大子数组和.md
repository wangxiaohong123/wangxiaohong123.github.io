---
title: 3.最大子数组和
tags:
  - 算法
categories: leecode
copyright: true
---

### 题目信息

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。

示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

**提示：**

-   1 <= nums.length <= 10^5^
-   -10^4^ <= nums[i] <= 10^4^

根据题目得到一下结论：

*   输入一个数组，返回一个整数，返回的这个整数是连续子数组的和；
*   连续子数组意思是下标是连续的，也就是说不能打乱顺序了；

### 算法思路

##### 1.暴力解法

使用两个指针，把所有可能的位置求和然后找到最大的，题目要求子数组最少包含一个元素，也就是说指针i<=指针j：

```java
public int maxSubArray(int[] nums) {

    int maxSum = nums[0], sum;

    for (int i = 0; i < nums.length; i++) {
        sum = nums[i];
        maxSum = Math.max(maxSum, sum);
        for (int j = i + 1; j < nums.length; j++) {
            sum += nums[j];
            maxSum = Math.max(sum, maxSum);
        }
    }

    return maxSum;
}
```

这样放到LeetCode提交会不通过，提示时间超出限制，也就是说整个算法过于暴力了，看一下能不能优化或者剪枝，首先两个for循环应该没有什么能优化的，那就看看能不能把数组变短，题目给出的例子`[-2,1,-3,4,-1,2,1,-5,4]`其实是可以变成这样的`[-2,1,-3,4,-1,3,-5,4]`，我们把相邻的两个正数2和1合并成了3，如果2参与了最大值，那他后面的1必须也要参与，这样才会更大，那如果数组里有连续的负数，当第一个负数没参与运算的时候，和他相邻的数组也不能参与运算，所以得到的结论就是相邻的正负符号相同的数可以合并，但是有个例外就是数组中全部都是负数，这个时候需要单独处理。优化后的代码：

```java
public int maxSubArray(int[] nums) {

    // 防止全负数情况，只要先找到一个最大值，这样就可以避免全负数的情况了
    int maxSum = maxValue(nums);
    // 压缩数组
    nums = preHandle(nums);

    int sum;
    for (int i = 0; i < nums.length; i++) {
        sum = nums[i];
        maxSum = Math.max(maxSum, sum);
        for (int j = i + 1; j < nums.length; j++) {
            sum = sum + nums[j];
            maxSum = Math.max(sum, maxSum);
        }
    }

    return maxSum;
}

/**
 * 压缩数组
 */
public int[] preHandle(int[] nums) {
    StringJoiner sj = new StringJoiner(";");
    // 标记当前加和、区域的正负性
    int mark = nums[0] >= 0 ? 1 : 0;
    int sum = 0;
    for (int num : nums) {
        if ((num >= 0 ? 1 : 0) == mark) {
            sum += num;
        } else {
            sj.add(String.valueOf(sum));
            sum = num;
            mark = num >= 0 ? 1 : 0;
        }
    }
    sj.add(String.valueOf(sum));
    String[] numsString = sj.toString().split(";");
    int[] newNums = new int[numsString.length];
    for (int i = 0; i < numsString.length; i++) {
        newNums[i] = Integer.parseInt(numsString[i]);
    }

    return newNums;
}

/**
 * 找到数组的最大值
 */
public int maxValue(int[] nums) {
    int ret = nums[0];
    for (int num : nums) {
        if (num > ret) {
            ret = num;
        }
    }

    return ret;
}
```

结果还是时间超出限制，放弃暴力求解，时间复杂度也很高就不看了。

##### 2.贪心求解

贪心的思想就是找到局部最优解，很适合这道题。上面在压缩数组的时候得到了一个很关键的结论，就是如果数组中存在正数，并且最终结果为[i,j]，那么：

*   当nums[i] > 0，nums[i - 1]一定 < 0;
*   不存在k \in [i,j]，使得sum[i,k] < 0；
*   不存在k \in [0,i-1]，使得sum[0,k] > sum[i,j]；

根据上面的3条结论就可以遍历数组，然后求出一堆连续数组的和，我们只需要用一个变量记录这些连续数组的和中最大的就可以了，当求出的sum小于0的时候就可以把他分成一个连续的数组，下个元素作为下一个连续数组的起始元素：

```java
public int maxSubArray(int[] nums) {
    int maxSum = nums[0];
    int sum = 0;
    for (int num : nums) {
        sum += num;
        maxSum = Math.max(sum, maxSum);
        if (sum < 0) {
            sum = 0;
        }
    }

    return maxSum;
}
```

时间复杂度是O(n)，力扣上击败100%用户，空间也还行。

##### 3.动态规划求解

贪心和动态规划的特性都是子问题求解升级到全局问题的求解，主要有两个相同点：

*   子问题求解满足无后效性，就是说当前子问题的状态解能够帮助我们解决下一步的问题，不需要之前的解，有点像洋葱模型，所以每个子问题的解的状态要足够全面。
*   策略驱动

2个不同点：

*   贪心只保留每个阶段的最优状态，就是局部最优。而动态规划保存的是每个阶段的全部可能状态。
*   贪心的问题解需要具备单调性，当前最优既是全局最优，比如这道题，当前阶段是最大就不需要考虑之前的阶段了。动态规划对全局解是否具有单调性要求不高。

动态规划类似于贪心和枚举的组合，动态规划方程：DP(k) = f(DP(k - 1), element(k))，这个element(k)可以是1个元素也可以是1组元素。动态规划最关键的就是推导出问题的解方程，一般会从少到多推算，但是这道题不需要，我们把k想成以k结束的最优解，也就是说DP(k)=max(DP(k - 1) + nums[k], num[k])，然后我们在声明一个一维数组存储每个节点的最优状态，遍历完数组后在遍历DP数组找到最大值就是最优解：

```java
public int maxSubArray(int[] nums) {
    int[] dp = new int[nums.length];
    // 这里注意动态规划是需要把第一个或者前两个状态赋初始值的
    dp[0] = nums[0];

    for (int i = 1; i < nums.length; i++) {
        // 这里就是刚刚找到的动态方程
        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
    }

    return maxValue(dp);
}

/**
 * 找到数组的最大值
 */
public int maxValue(int[] nums) {
    int ret = nums[0];
    for (int num : nums) {
        if (num > ret) {
            ret = num;
        }
    }

    return ret;
}
```

力扣提交花费2ms，因为多了一步遍历dp数组的操作，同时内存也要比贪心大。

##### 4.分治法求解

分治法的思路有3步：

*   问题递归分割：将原问题分割成n个子问题，分割到可以直观的得到答案；
*   临界问题求解：临界问题就是可以简单求解的问题，求解问题消耗的时间一般都是O(1)，如果临界问题求解的空间复杂度过高很容导致内存溢出；
*   子问题合并：当已知子问题的解时如何得到父问题的解；

一般的分治优先考虑2分，就是从中间分开，前半部分和后半部分被分成了等量的两个新问题，很少情况下会进行3分，如果这道题按照分支的思路首先要找到左边最大和的连续数组，然后在找到右边连续最大和的连续数组，然后还有一种情况就是最大和的连续数组是左边的最后几个元素+右边的前几个元素，这种情况的求解就很像贪心求解的思路：

```java
public int maxSubArray(int[] nums) {
        return maxSumSubArray(nums, 0, nums.length - 1);
    }

/**
 * 递归函数
 */
public int maxSumSubArray(int[] nums, int l, int r) {
    if (r == l) {
        return nums[l];
    }

    int mid = (r - l) / 2 + l;
    int rMax = maxSumSubArray(nums, mid + 1, r);
    int lMax = maxSumSubArray(nums, l, mid);
    int midMax = maxSumContainsMidIndex(nums, l, mid, r);
    return Math.max(rMax, Math.max(lMax, midMax));
}

/**
 * 取切割点左右两侧之和的函数
 */
public int maxSumContainsMidIndex(int[] nums, int l, int mid, int r) {
    int leftMax = Integer.MIN_VALUE;
    int rightMax = Integer.MIN_VALUE;

    if (l < mid) {
        int sum = 0;
        for (int i = mid; l <= i; i--) {
            sum += nums[i];
            if (sum > leftMax) {
                leftMax = sum;
            }
        }
    }

    if(r > mid) {
        int sum = 0;
        for (int i = mid + 1; i <= r; i++) {
            sum += nums[i];
            if (sum > rightMax) {
                rightMax = sum;
            }
        }
    }

    return leftMax + rightMax;
}
```

