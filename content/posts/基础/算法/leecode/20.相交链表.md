---
title: 20.相交链表
date: 2022-10-23 06:27:35
tags:
  - 算法
categories: leecode
copyright: true
---

### 题目

给你两个单链表的头节点`headA`和`headB`，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回`null`。题目数据保证整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。

**自定义评测：**

评测系统 的输入如下（你设计的程序 不适用 此输入）：

*   intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0
*   listA - 第一个链表
*   listB - 第二个链表
*   skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数
*   skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数

评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。

**示例：**

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
```

**提示：**

*   listA 中节点数目为 m
*   listB 中节点数目为 n
*   1 <= m, n <= 3 * 10^4^
*   1 <= Node.val <= 10^5^
*   0 <= skipA <= m
*   0 <= skipB <= n
*   如果 listA 和 listB 没有交点，intersectVal 为 0
*   如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]

### 题解

题目已经说了两个链表都没有环，而且不能对链表进行结构改动，但是我们可以遍历A链表的时候修改val，遍历完B链表在还原val。

##### 1.标记法

这个问题等价于遍历A链表后再遍历B链表时第一个出现在A链表中的元素，所以需要存储A链表的元素：

```java
public class GetIntersectionNodeHashMap {

    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (null == headA || null == headB) {
            return null;
        }

        Map<ListNode, Boolean> map = new HashMap<>();
        ListNode nodeX = headA;
        ListNode nodeY = headB;
        while (null != nodeX) {
            map.put(nodeX, true);
            nodeX = nodeX.next;
        }

        while (null != nodeY) {
            if (map.containsKey(nodeY)) {
                return nodeY;
            }
            nodeY = nodeY.next;
        }

        return null;
    }

    static class ListNode {
        int val;
        ListNode next;
        ListNode(int x) {
            val = x;
            next = null;
        }
    }
}
```

##### 2.修改value

```java
public class GetIntersectionNodeMarkVal {

    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (null == headA || null == headB) {
            return null;
        }

        ListNode nodeX = headA;
        ListNode nodeY = headB;
        while (null != nodeX) {
            nodeX.val += 1000000;
            nodeX = nodeX.next;
        }

        ListNode res = null;
        while (null != nodeY) {
            if (nodeY.val >= 1000000) {
                res = nodeY;
                break;
            }
            nodeY = nodeY.next;
        }

        ListNode nodeZ = headA;
        while (null != nodeZ) {
            nodeZ.val -= 1000000;
            nodeZ = nodeZ.next;
        }
        return res;
    }

    static class ListNode {
        int val;
        ListNode next;
        ListNode(int x) {
            val = x;
            next = null;
        }
    }
}
```

##### 3.反向链表

如果链表从后向前遍历，那么很容易找到相交的点，应为两个链表相交，交点后的元素会一模一样，所以如果可以把链表反转再同时遍历就会简单很多，但是题目的问题反转非常难，第一翻转之后的链表会出现1个节点有2个next指针，这个是没法实现的，第二在找到交点之后需要还原链表。

所以我使用两个hash表示翻转之后的链表：

```java
public class GetIntersectionNodeBackForward {

    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (null == headA || null == headB) {
            return null;
        }
        if (headA == headB) {
            return headA;
        }

        Map<ListNode, ListNode> mapA = new HashMap<>();
        ListNode tailA = headA;
        while (null != tailA.next) {
            mapA.put(tailA.next, tailA);
            tailA = tailA.next;
        }
        Map<ListNode, ListNode> mapB = new HashMap<>();
        ListNode tailB = headB;
        while (null != tailB.next) {
            mapB.put(tailB.next, tailB);
            tailB = tailB.next;
        }

        if (tailA != tailB) {
            return null;
        }

        while (mapA.get(tailA) == mapB.get(tailB)) {
            tailA = mapA.get(tailA);
            tailB = mapB.get(tailB);
        }

        return tailA;
    }

    static class ListNode {
        int val;
        ListNode next;
        ListNode(int x) {
            val = x;
            next = null;
        }
    }
}
```

##### 4.重置起始位置

已经知道了相交的地方一定在链表的后段，如果两个链表的长度相同只需要同时遍历找相同的节点就可以了，但是题目给到的两个链表长度是不一定相同的，所以只需要先把长的链表多出来那部分遍历完，在一起遍历两个节点就可以了：

```java
public class GetIntersectionNodeResetStartingLine {

    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int sizeA = 0, sizeB = 0;
        ListNode headA1 = headA;
        ListNode headB1 = headB;
        while (null != headA1 || null != headB1) {
            if (null != headA1) {
                sizeA ++;
                headA1 = headA1.next;
            }
            if (null != headB1) {
                sizeB ++;
                headB1 = headB1.next;
            }
        }

        headA1 = headA;
        headB1 = headB;
        while (headA1 != headB1 && null != headA1 && null != headB1) {
            if (sizeA > sizeB) {
                headA1 = headA1.next;
                sizeA --;
            } else if (sizeA < sizeB) {
                headB1 = headB1.next;
                sizeB --;
            } else {
                headA1 = headA1.next;
                headB1 = headB1.next;
            }
        }

        if (null == headA1 || null == headB1) {
            return null;
        }
        return headA1;
    }

    static class ListNode {
        int val;
        ListNode next;
        ListNode(int x) {
            val = x;
            next = null;
        }
    }
}
```

##### 5.循环遍历

上面说的是缩短较长的链表，我们还可以让两个链表互相拼接，让他俩一样长，就是声明两个新链表，第一个链表从A开始遍历，让A链表遍历完了继续遍历B链表，第二个链表从B开始遍历，让B链表遍历完继续遍历A链表：

```java
public class GetIntersectionNodeCyclePath {

    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode visitA = headA;
        ListNode visitB = headB;
        boolean continueA = true;
        boolean continueB = true;

        while (visitA != visitB) {
            if (null == visitA) {
                if (continueA) {
                    visitA = headB;
                    continueA = false;
                } else {
                    return null;
                }
            }
            if (null == visitB) {
                if (continueB) {
                    visitB = headA;
                    continueB = false;
                } else {
                    return null;
                }
            }

            // 上面可能会涉及到一次赋值
            // 如果这里不判断，下面又接着赋了一次值，就会少判断一个值
            if (visitA == visitB) {
                return visitA;
            }

            visitA = visitA.next;
            visitB = visitB.next;
        }

        return visitA;
    }

    static class ListNode {
        int val;
        ListNode next;
        ListNode(int x) {
            val = x;
            next = null;
        }
    }
}
```