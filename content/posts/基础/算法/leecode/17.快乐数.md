---
title: 17.快乐数
tags:
  - 算法
categories: leecode
copyright: true
---

### 题目

编写一个算法来判断一个数 n 是不是快乐数。

**「快乐数」** 定义为：

*   对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
*   然后重复这个过程直到这个数变为1，也可能是无限循环但始终变不到1。
*   如果这个过程结果为 1，那么这个数就是快乐数。

如果 n 是 快乐数 就返回 true ；不是，则返回 false 。

**示例：**
$$
\begin{align}
&输入：n = 19\\
&输出：true\\
&解释：\\
&1^2 + 9^2 = 82\\
&8^2 + 2^2 = 68\\
&6^2 + 8^2 = 100\\
&1^2 + 0^2 + 0^2 = 1
\end{align}
$$
**提示：**

-   1 <= n <= 2^31^ - 1

### 题解

首先这个题需要一个终止条件，要不求出结果是1，要不进入无限循环，满足其中一个就有结果。

如果是无限循环的话，数字会越来越大还是说循环几次就变回到了初始值？**结论是不会，推导的过程有点复杂，当初始值经过n次计算如果大于100，下次得到的值一定会收敛，就是比当前数小。**所以如果一个数不是快乐数，应该是会在n个数之间进行无限循环。

##### 1.深度搜索

通过一个map存储访问过的元素，如果出现1就返回true，如果出现map存在的元素就返回false：

```java
public class IsHappyHashMap {

    public boolean isHappy(int n) {
        Map<Integer, Boolean> map = new HashMap<>();

        while (n != 1) {
            Boolean b = map.get(n);
            if (null != b) {
                return false;
            }

            map.put(n, true);

            int tmp = 0;
            while (n != 0) {
                tmp += (n % 10) * (n % 10);
                n /= 10;
            }
            n = tmp;
        }

        return true;
    }
}
```

##### 2.快慢指针

这个题循环的步数不会很多，所以上面使用map或者set记录也可以，如果在一张大的图中搜索，会很占内存，其实这个题很像贪吃蛇，当头碰到身体的任何部位就不是快乐数。

所以我们可以使用快慢指针进行类似找环形链表来解决，快慢指针还可以解决类似寻找链表中地L/n的元素(L是链表的长度)等。

```java
public class IsHappySlowFastPoint {

    public boolean isHappy(int n) {
        int stepNum = 0;
        int fast = n, slow = n;

        while (fast != 1) {
            fast = nextNumber(fast);
            stepNum++;
            if ((stepNum & 1) == 0) {
                slow = nextNumber(slow);
                if (fast - slow == 0) {
                    return false;
                }
            }
        }

        return true;
    }

    private int nextNumber(int n) {
        int tmp = 0;
        while (n != 0) {
            tmp += (n % 10) * (n % 10);
            n /= 10;
        }

        return tmp;
    }
}
```

##### 3.魔法数

魔法数：在一个算法中出现的无计算过程的超级参数，可以大幅度提高代码的执行效率，并且没有办法通过上下文得到数字的含义和计算过程。

我们已知如果n超过了100，那么下一个数一定是变小的，慢慢会比100小，所以我们可以枚举100以内的所有快乐数：

```java
public class IsHappyMagicNumber {

    public boolean isHappy(int n) {
        while (n - 100 > 0) {
            int tmp = 0;
            while (n != 0) {
                tmp += (n % 10) * (n % 10);
                n /= 10;
            }
            n = tmp;
        }
        return isHappy1(n);
    }

    private boolean isHappy1(int n) {
        switch (n) {
            case 1:
            case 7:
            case 10:
            case 13:
            case 19:
            case 23:
            case 28:
            case 31:
            case 32:
            case 44:
            case 49:
            case 68:
            case 70:
            case 79:
            case 82:
            case 86:
            case 91:
            case 94:
            case 97:
            case 100:
                return true;
            default:
                return false;
        }
    }
}
```

根据魔数还有一种取巧的方法，已知非快乐数一定会在100上下浮动，那么只要说在100上下浮动的次数超过5次或者10次这个数就是非快乐数：

```java
public class IsHappyMagicNumber {
    public boolean isHappy(int n) {
        int num = 0;
        int preNum = n;
        do {
            n = nextNumber(n);
            if (n == 1) {
                return true;
            }

            if ((n - 100 < 0 && preNum - 100 > 0) || (n - 100 > 0 && preNum - 100 < 0)) {
                num++;
                if (num >= 5) {
                    return false;
                }
            }
        } while(true);
    }

    private int nextNumber(int n) {
        int tmp = 0;
        while (n != 0) {
            tmp += (n % 10) * (n % 10);
            n /= 10;
        }

        return tmp;
    }
}
```

