---
title: 1.两数之和
tags:
  - 算法
categories: leecode
copyright: true
---

##### 题目：

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值target的那两个整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。

根据题目可以得到的结论：

* 不管存在多少解，找到一个就可以返回，这是一个剪枝条件；
* 数组中的每个元素只能使用一次；
* 下标返回可以无序，无序的结果对算法的限制更小；

首先想到的暴力算法有两种，一种是随机，一种是循环：

1：**随机算法**

随机算法就是随机取一个数，然后在随机取一个数，当两个数的索引不相等时判断两数之和，这个思路简单，关键就是要计算随机多少次

首先先看抛硬币的概率问题，当假设硬币只有正反两种结果的时候，连续抛出两次，**最少有一次为正面的概率并不是100%**，因为正面的概率是0.5，至少有一次为正面的概率并不是0.5+0.5，而是1-(1-0.5)^2^，意思是1-连续两次都是不好的结果的概率，所以当我随机取一个数的时候正确的概率是1/n，那么循环n(n是数组长度)次时，全部未命中的概率是(1-1/n)^n^，然后在带入e的极限公式得到：
$$
(1-\frac 1 n)^n \\
=(1+\frac 1 {-n})^n \\
=[(1+\frac 1 {-n})^{-n}]^{-1} \\
因为e=(1+\frac 1 n)^n \\
所以，命中概率=e^{-1} \approx  1/3
$$
所以至少命中一次的概率约等于2/3，也就是说遍历2n次至少会有一次命中，那么连续两次都命中需要遍历(2n)^2^次，代码如下，leecode已通过：

```java
public int[] twoSumRandom(int[] nums, int target) {
    int[] ret = new int[2];
    Random r = new Random();
    int length = nums.length;
    int i,j;
    for (int count = 0; count < Math.pow(2 * length, 2); count++) {
        i = r.nextInt(length);
        do {
            j = r.nextInt(length);
        } while (i == j);
        if (nums[i] + nums[j] == target) {
            return new int[]{i,j};
        }
    }
    return ret;
}
```

时间复杂度的话最外层就已经是(2n)^2^的了，然后里层还有一个while循环，但是可以忽略，复杂度的话就是n^2^

2：**顺序求解**

顺序求解应该是大部分人最开始审完题的第一个思路，定义两个指针，嵌套循环，需要注意底层循环只需要从外层的索引+1开始遍历即可

```java
public int[] twoSumDeRandom(int[] nums, int target) {
    int[] ret = new int[2];

    for (int i = 0; i < nums.length; i++) {
        for (int j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] == target) {
                return new  int[]{i,j};
            }
        }
    }

    return ret;
}
```

时间复杂度：当i=0时，内层循环n次，当i=1时，内层循环n-1次，n=2，村换n-2次……，循环次数为等比数列求和

[(0 + n) * n] / 2 = n^2^/2

3：二分求解

前面两个算法的时间复杂度都接近n^2^，看顺序求解的话，最外层的循环是没有办法优化的，因为输入的数字可以是负数，所以只能全部遍历一遍，没有啥可能的终止条件，但是内层全遍历一遍是没必要的，如果数组是有序的话，内层用二分查找可以把复杂度降到log^n^,所以当我们遍历之前先把数组排个序，这样复杂度就可能变成nlog^n^：

```java
public int[] twoSumNLogN(int[] nums, int target) {
    int[] ret = new int[2];
    int[] sortedNums = nums.clone();
    Arrays.sort(sortedNums);
    int rightI = nums.length - 1;
    int index;
    for (int i = 0; i < nums.length; i++) {
        index = binarySearch(sortedNums, target - sortedNums[i], i + 1, rightI);
        if (index != -1) {
            ret[0] = getNumberIndex(nums, sortedNums[i], -1);
            ret[1] = getNumberIndex(nums, sortedNums[index], ret[0]);
            break;
        }
    }

    return ret;
}

/**
 * 二分查找
 */
private int binarySearch(int[] nums, int target, int leftI, int rightI) {
    int numMid;
    int midI = leftI + (rightI - leftI)/2;
    while(leftI <= rightI) {
        numMid = nums[midI];
        if (numMid == target) {
            return midI;
        } else if (numMid > target) {
            rightI = midI - 1;
        } else {
            leftI = midI + 1;
        }
        midI = leftI + (rightI - leftI)/2;
    }
    return -1;
}

/**
 * 找到目标元素的下标
 */
private int getNumberIndex(int[] nums, int num, int forbiddenIndex) {
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] == num && i != forbiddenIndex) {
            return i;
        }
    }
    return -1;
}
```

因为结果返回的是原数组的索引，所以需要克隆一个数组用来排序计算，然后在拿到结果时，根据结果的值去原数组中找到索引，这里需要注意的是，为了保障每个元素只能使用一次，在二分查找时的最左索引从i+1开始，在原数组中找下标也需要过滤掉已经选中的元素下标。

时间复杂度：数组的克隆一次遍历为n，下面循环加二分查找时nlog^n^，当找到结果时从原数组中找下标2n

3n+nlog^n^

4：hash求解

还是外层循环没有优化的地方，但是内层循环存在比log^n^更快的查找，就是hash，把数组的数字当做key，索引是value存到hash表中，外层遍历时，只需要判断target-nums[i]是不是在hash表中就可以：

```java
public int[] twoSum(int[] nums, int target) {
    int[] ret = new int[2];

    Map<Integer, Integer> hash = new HashMap<>(nums.length);
    for (int i = 0; i < nums.length; i++) {
        hash.put(nums[i], i);
    }

    for (int i = 0; i < nums.length; i++) {
        int index = hash.getOrDefault(target - nums[i], i);
        if (index != i) {
            ret[0] = i;
            ret[1] = index;
            break;
        }
    }
    return ret;
}
```

需要注意的是如果存在两个以上的相同元素，hash表的方式会不会有影响？不会，因为当结果可以两个相同元素之和时，遍历第一个元素，hash中get到的索引一定不是当前元素。

一般改进的思路都在内存循环，但是在hash解法中存在两个循环，可以想着把他优化成1个循环，就是在一个循环里，如果map中没有target元素就put进去，有的话直接返回结果，这样时间复杂度就变成了n：

```java
public int[] twoSum(int[] nums, int target) {
    int[] ret = new int[2];
    Map<Integer, Integer> match = new HashMap<>(nums.length);
    for (int i = 0; i < nums.length; i++) {
        int t = target - nums[i];
        if (match.containsKey(t)) {
            ret[0] = i;
            ret[1] = match.get(t);
            break;
        }
        match.put(nums[i], i);
    }
    return new int[0];
}
```

