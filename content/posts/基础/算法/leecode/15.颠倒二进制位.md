---
title: 15.颠倒二进制位
tags:
  - 算法
categories: leecode
copyright: true
---

### 题目

颠倒给定的32位无符号整数的二进制位。

**提示：**

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在示例中，输入表示有符号整数-3，输出表示有符号整数 -1073741825。

**示例：**

```
输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
```

##### 分析

*   java中的数都是有符号的(最高位是0表示正数)，并且使用二进制补码来实现的，补码=源码的反码 + 1，所以题目说的实例输入的-3，其实是-3的补码。补码和反码都是为了解决计算机计算减法的问题。题目的意思其实是说如果使用java实现，在位移操作的时候需要考虑无符号位移。
*   取出2进制的最低位可以使用n&1来实现，位数变成高位使用左移操作。

### 题解

##### 1.循环移动

```java
public class ReverseBitsLoopMove {

    public int reverseBits(int n) {
        int res = 0;
        for (int i = 31; i >= 0 ; i--) {
            res += (n & 1) << i;
            n = n >>> 1;
        }

        return res;
    }
}
```

##### 2.位集合翻转

和整数翻转一样的思路，把拿到的数得每一位放到集合中，这样只需要我相对应的位进行调换(比如第32位和第1位交换)，在把集合转成整数就可以了：

```java
public class ReverseBitsBitSet {

    public int reverseBits(int n) {
        BitSet bitSet = new BitSet(32);
        for (int i = 0; i < 32; i++) {
            if ((n & 1) == 1) {
                bitSet.set(i);
            }
            n = n >>> 1;
        }

        int mid = 15;
        while (mid >= 0) {
            swap(bitSet, mid);
            mid--;
        }

        int res = 0;

        for (int i = 0; i < 32; i++) {
            res += bitSet.get(i) ? 1 << i : 0;
        }

        return res;
    }

    private void swap(BitSet bitSet, int mid) {
        int relative = 31 - mid;
        boolean midValue = bitSet.get(mid);
        bitSet.set(mid, bitSet.get(relative));
        bitSet.set(relative, midValue);
    }
}
```

