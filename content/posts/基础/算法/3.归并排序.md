---
title: 3.归并排序
tags:
  - 算法
categories: 基础
copyright: true
---

我觉得归并排序的归并意思是递归、合并，因为这个算法就两步递归和合并。主要的思想就是把数组拆分成两个，两个数组排序完在合并到一起，差分出来的这个数组又可以继续调用这个方法，递归起来了。

归并主要分成自顶向下和自底向上，不管是那种都会有合并的过程，合并方法：

```java
/**
  * 把a[lo]~a[mid]he a[mid+1]~a[hi]合并
  */
public void merge(Comparable[] a, int lo, int mid, int hi) {
    int i = lo, j = mid + 1;
    if (hi + 1 - lo >= 0) {
        System.arraycopy(a, lo, aux, lo, hi + 1 - lo);
    }
    for (int k = lo; k <= hi; k++) {
        if (i > mid) {
            a[k] = aux[j++];
        } else if (j > hi) {
            a[k] = aux[i++];
        } else if (less(aux[j], aux[i])) {
            a[k] = aux[j++];
        } else {
            a[k] = aux[i++];
        }
    }
}
```

### 自顶向下

```java
private void sort(Comparable[] a, int lo, int hi) {
    if (lo >= hi) {
        return;
    }

    int mid = lo + (hi - lo) / 2;
    sort(a, lo, mid);
    sort(a, mid + 1, hi);
    merge(a, lo, mid, hi);
}
```

分析一下时间复杂度，首先可以推出来整个排序的复杂度：C(N) = C(N/2) + C(N/2) + N，第一个C(N/2)表示sort(a, lo, mid);第二个C(N/2)表示sort(a, mid + 1, hi);最后一个N表示merge(a, lo, mid, hi);这个取值最小为N/2，最大才是N，因为merge方法里涉及到计算的是less(aux[j], aux[i])，最好的情况就是比较了N/2次之后就不比较了，最坏情况就是数组的左半部分和有半部分就是一大一小、一大一小，一直比较N次，这里可以就是约等于N。

当N为2^n^时，N/2为2^n-1^，公式变成C(2^n^) = 2C(2^n-1^) + 2^n^，两侧同时除2^n^得到：

C(2^n^)/2^n^ = 2C(2^n-1^) /2^n^+ 1 = C(2^n-1^) /2^n-1^+ 1，把C(2^n-1^)/2^n-1^替换成C(2^n-2^) /2^n-2^+ 1得到：

C(2^n^)/2^n^ = C(2^n-2^) /2^n-2^+ 1 + 1，依次类推得到：

C(2^n^)/2^n^ = C(2^0^)/2^0^ + n，因为C(1) = 0，所以C(2^n^) = n2^n^，把N = 2^n^带入得到：

C(N) = Nlog~2~^N^，当N不是2^n^的时候推算比较复杂，我推不出来。

### 自底向上

自顶向下是把大数组拆分成小数组，然后开始合并，自底向上就是直接合并数组，比如下标0和1合并、2和3合并……然后下标0、1、2、3合并、4、5、6、7合并……一直合并到大数组：

```java
public void sort(Comparable[] a) {
    int n = a.length;
    aux = new Comparable[n];
    // sz是合并数组的长度
    for (int sz = 1; sz < n; sz = sz + sz) {
        for (int lo = 0; lo < n - sz; lo += sz + sz) {
            merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, n - 1));
        }
    }
}
```

他的时间复杂度和自顶向下是一样的。

归并排序的时间很快，但是需要一个额外的数组。