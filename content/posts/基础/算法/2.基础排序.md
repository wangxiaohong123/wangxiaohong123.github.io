---
title: 2.基础排序
tags:
  - 算法
categories: 基础
copyright: true
---

### 基础算法模板

```java
public class Example {
    /**
     * 排序方法
     */
    public static void sort(Comparable[] a) {}
    
    /**
     * 判断数组是否有序
     * 从小到大排序
     */
    public static boolean isSorted(Comparable[] a) {
        for(int i = 1; i < a.length; i++) {
            if (less(a[i], a[i - 1])) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * 比较方法
     */
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }
    
    /**
     * 交换两个元素
     */
    private static void exch(Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
    
    /**
     * 打印数组
     */
    private static void show(Comparable[] a) {
        for (Comparable comparable : a) {
            System.out.println(comparable);
        }
    }
}
```

这套模板可以用在任何实现了Comparable接口的数据类型。我把这个模板里除了排序的方法都放在抽象类中，以后的排序只继承这个抽象类重写sort()方法。BaseSort如下：

```java
public abstract class BaseSort {
    /**
     * 排序方法
     */
    public abstract void sort(Comparable[] a);

    /**
     * 判断数组是否有序
     * 从小到大排序
     */
    protected boolean isSorted(Comparable[] a) {
        for(int i = 1; i < a.length; i++) {
            if (less(a[i], a[i - 1])) {
                return false;
            }
        }
        return true;
    }

    /**
     * 比较方法
     */
    protected boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }

    /**
     * 交换两个元素
     */
    protected void exch(Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    /**
     * 打印数组
     */
    protected void show(Comparable[] a) {
        for (Comparable comparable : a) {
            System.out.println(comparable);
        }
    }
}
```

### 选择排序

选择排序是最简单的排序算法，思路就是遍历数组，找到最小的和第一个交换，如果第一个最小就自己和自己交换，然后从第二个元素开始遍历找到最小的和第二个元素交换，依次类推。

```java
public class Quick extends BaseSort {
    /**
     * 排序方法
     */
    @Override
    public void sort(Comparable[] a) {
        for (int i = 0; i < a.length; i++) {
            int min = i;
            for (int j = i + 1; j < a.length; j++) {
                if (less(a[j], a[min])) {
                  min = j;
                }
            }
            exch(a, i, min);
        }
    }

    public static void main(String[] args) {
        Integer[] a = {3,4,5,1,2,7,9,8};
        Quick quick = new Quick();
        quick.sort(a);
        assert quick.isSorted(a);
        quick.show(a);
    }
}
```

时间复杂度的话：当i=0时，里层循环了n-1次；n=1时，里层循环n-2次……；当i=n-1时里层循环1次，所以就是1到n-1的求和：(1+(n-1))(n-1)/2=n(n-1)/2，约等于n^2^/2，执行了n次替换。

他有个特点就是不管输入的数组是否有序，都要替换n次。

### 插入排序

插入排序的思路很好理解，比如说打牌抓牌的时候，我们一张一张的抓，然后把抓到的牌放到合适的位置，合适的位置就是前面的牌小于等于这张牌，对应到插入排序里从0索引开始遍历数组就是抓牌的过程，由于抓第0张牌不需要比较，比较还会造成索引异常，所以遍历从索引1开始，假设遍历到第i个索引，那么索引i之前就是抓完的牌，所以需要找到i之前的两个索引x和y，x和y满足条件a[x]<a[i]<a[y]，把a[i]插进去，找到这个位置还需要遍历，只需要从i向前遍历，因为i之前的就是排好序的，所以只要满足a[j],<a[j - 1]，就把这两个元素互换：

```java
public class Insertion extends BaseSort {
    @Override
    public void sort(Comparable[] a) {
        for(int i = 1; i < a.length; i++) {
            for(int j = i; j > 0 && less(a[j], a[j - 1]); j--) {
                exch(a, j, j - 1);
            }
        }
    }

    public static void main(String[] args) {
        Integer[] a = {3,4,5,1,2,7,9,8};
        Insertion insertion = new Insertion();
        insertion.sort(a);
        assert insertion.isSorted(a);
        insertion.show(a);
    }
}
```

实现起来比选择排序的代码少很多，时间复杂度的话，如果输入的数组是有序的，时间复杂度是n-1，最坏的情况如果输入数据的顺序和我们输出的相反，时间复杂度就和选择排序一样约等于n^2^/2，所以平均的时间复杂度是(n^2^/2+n-1)/2约等于n^2^/4，时间复杂度和交换次数是一样的。

插入排序对于部分有序数组来说是非常快的。

部分有序：

*   数组中每个元素距离他最终位置都不远；
*   有序的大数组接一个小数组；
*   数组中只有几个元素的位置不正确；

满足一个就算有序。

### 希尔排序

希尔排序是插入排序的一个演进版，因为插入排序对于部分有序的数组很快，我理解的希尔排序就是把数组变成部分有序数组，主要思路就是把整个数组切分成h段，通过快排的思路先保证以每段数组为单位的小数组有序，然后从头开始进行插入排序：

```java
public class Shell extends BaseSort {
    @Override
    public void sort(Comparable[] a) {
        int n = a.length;
        int h = 1;
        // 分成4段
        while (h < n/3) {
            // 这么写可以保证最后一定是从1开始遍历
            h = 3 * h + 1;
        }
        while (h >= 1) {
            for(int i = h; i < n; i++) {
                for(int j = i; j >= h && less(a[j], a[j - h]); j -= h) {
                    exch(a, j, j - h);
                }
                System.out.println(Arrays.toString(a));
            }
            h = h/3;
        }
    }

    public static void main(String[] args) {
        String[] a = {"L","E","E","A","M","H","L","E","P","S","O","L","T","S","X","R"};
        System.out.println(Arrays.toString(a));
        Shell shell = new Shell();
        shell.sort(a);
        assert shell.isSorted(a);
    }
}
```

没有办法计算希尔排序的性能，因为h的计算、数组的顺序、计算h的因子都会影响他的复杂度，但是他可以排序大型数据，并且不需要额外的空间。

