---
title: jvm-6.类文件结构
tags:
  - JVM
categories: 基础
copyright: true
---

编译的结果是字节码而不是机器码实现了“一次编写，到处运行”，而且语言无关性也越来越被重视，设计java的时候就是这么考虑的，所以把Java的规范拆分成《Java语言规范》和《Java虚拟机规范》，2018年graalVM公开之后基本上实现了语言无关性，目前运行在java虚拟机上的语言有Kotlin、Groovy、JRuby、JPython、Scala等等。

实现平台、语言无关的关键就是虚拟机和编译之后的字节码(就是class文件)，比如javac把java程序编译成class文件、jrubyc把jruby程序编译成class文件。

##### class文件结构

class文件中只有两种数据格式，无符号数和表：

*   无符号数是基本数据类型，u1、u2、u4、u8分别代表1个字节、2个字节、4个字节和8个字节，无符号数用来描述数字、引用或者字符串；
*   表：表就是多个无符号数或者其他表组成的复合数据类型，一般表都以_info结尾，整个class其实就是一张表。

**class中的数据项严格按顺序紧凑的排列，没有任何分隔符**，如果一个变量需要占用1个字节以上的空间时，按照高位在前的方式分割成多个字节，比如u2类型正常的顺序是11100111 00000001，在class文件中就应该是00000001 11100111。不管是表还是符号，在描述同一个类型但是数量不确定的时候都在前面定义一个变量标记这个同类型的若干个变量的数量，class表中各个数据项：

| 名称                     | 类型           | 数量                    |
| ------------------------ | -------------- | ----------------------- |
| magic(魔数)              | u4             | 1                       |
| minor_version(次版本)    | u2             | 1                       |
| major_version(主版本)    | u2             | 1                       |
| constant_pool_count      | u2             | 1                       |
| constant_pool(常量池)    | cp_info        | constant_pool_count - 1 |
| access_flags(访问标志)   | u2             | 1                       |
| this_class(类索引)       | u2             | 1                       |
| super_class(父类索引)    | u2             | 1                       |
| interfaces_count         | u2             | 1                       |
| interfaces(接口索引集合) | u2             | interfaces_count        |
| fields_count             | u2             | 1                       |
| fields(字段表集合)       | field_info     | fields_count            |
| methods_count            | u2             | 1                       |
| methods(方法表集合)      | method_info    | methods_count           |
| attributes_count         | u2             | 1                       |
| attributes(属性表集合)   | attribute_info | attributes_count        |

###### 1.魔数

每个class的头4个字节是魔数，他的作用是确定这个文件能不能被虚拟机接受，class的文件魔数的16进制是0xCAFEBABE(咖啡宝贝)，大部分文件都有魔数，比如图片。

###### 2.版本

魔数后4个字节是版本，第5、6个字节是次版本，次版本号是65535时表示技术预览版功能特性，这样虚拟机在加载类文件的时候能够区分出来。

主版本从45开始，之后每个大版本号递增，比如JDK13的主版本号就是57。《Java虚拟机规范》要求虚拟机必须拒绝执行超过其主版本号的class文件，就是说JDK7不能执行JDK8编译之后的class。

###### 3.常量池

主版本号后面紧跟着常量池，由于常量池中元素个数不确定所以在入口放了一个u2的数据表示常量池容量，**class中只有这个集合类型的索引是从1开始的**，比如constant_pool_count是22，那么常量池的数量就是21，设计的时候考虑到常量池的0有特殊意义。

常量池中的常量分成两类，一类是字面量，类似于Java里的常量，比如字符串、final修饰的变量等，另一类是符号引用，符号引用包括下面几类：

*   import的包；
*   类和接口的全限定名；
*   字段的名称和描述符；
*   方法的名称和描述符；
*   方法句柄和方法类型；
*   动态常量和动态调用点；

常量池中每个常量都是一张表，现在大约有17中常量类型；

###### 4.访问标志

标识类的访问信息，比如是接口还是class，是不是抽象类等等，access_flags一共有16个标识位可以使用，目前只使用了9个。具体如下：

| 标志名称       | 值     | 含义                                                         |
| -------------- | ------ | ------------------------------------------------------------ |
| ACC_PUBLIC     | 0x0001 | 是否是public类型                                             |
| ACC_FINAL      | 0x0010 | 是否是final类型                                              |
| ACC_SUPER      | 0x0020 | 1.0.2之后编译出来的类都有这个标志，表示是否使用invokespecial字节码指令的新语义 |
| ACC_INTERFACE  | 0x0200 | 标识这是一个接口                                             |
| ACC_ABSTRACT   | 0x0400 | 是否是abstract类型，接口和抽象类都有这个标志                 |
| ACC_SYNTHETIC  | 0x1000 | 标识这个类不是用户代码产生的                                 |
| ACC_ANNOTATION | 0x2000 | 标识这是一个注解                                             |
| ACC_ENUM       | 0x4000 | 标识这是一个枚举                                             |
| ACC_MODULE     | 0x8000 | 标识这是一个模块                                             |

###### 5.类索引、父类索引和接口索引集合

这3想数据用来确认继承关系，接口是集合而父索引只是一个无符号类型，因为Java不允许多继承。除了Object类之外的所有类都有父类，所以这些类的父类索引都不是0。类索引和父类索引的值都是一个指向CONSTANT_Class_info的类描述符常量，这个常量中有个索引，通过这个索引可以在常量池中找到对应的全限定名，接口索引集合就是前面比他们多了一个接口数量。

###### 6.字段表集合

字段表里放的是类变量、实例变量信息，没有方法里的局部变量，字段的信息有作用域(public、private)、实例变量还是类变量(static修饰)、可变性(final修饰)、并发可见性(volatile修饰)、能都被序列化(transient修饰)、数据类型、字段名称。其中修饰符都是用标志位来表示的，字段名、字段类型没有办法固定，就引用常量池中的常量，字段表的格式：

| 名称                                                         | 类型           | 数量             |
| ------------------------------------------------------------ | -------------- | ---------------- |
| access_flags：他和类的access_flags非常像，但是他只有public、private、protected、final然后多了个static | u2             | 1                |
| name_index：字段名称，存放的是常量池中的索引                 | u2             | 1                |
| descriptor_index：字段和方法的描述符，存放的也是常量池中的索引 | u2             | 1                |
| attributes_count                                             | u2             | 1                |
| attributes他和类的attribute_info一样，笔记在类的attribute_info | attribute_info | attributes_count |

###### 7.方法表集合

方法表和字段表是一样的东西，但是不包括方法的代码部分，代码部分在属性表的code里，如果子类没有重写父类的方法，就不会出现在方发表里，方发表也会出现编译器自动添加的方法，比如类构造器\<clinit\>()和实例构造器\<init\>()。

###### 8.属性表集合

属性表一共有29项，每个属性表的属性名都是指向常量池的索引，值也是一张表，属性表中Code属性是字节码中最重要的属性，虚拟机定义的部分属性：

| 属性名                 | 使用位置           | 含义                                                         |
| ---------------------- | ------------------ | ------------------------------------------------------------ |
| Code                   | 方法表             | 方法内容编译成的字节码指令                                   |
| ConstantValue          | 字段表             | 由final关键字定义的常量值                                    |
| Deprecated             | 类、方发表、字段表 | 被声明成deprecated的方法和字段                               |
| Exceptions             | 方发表             | 方法抛出的异常表                                             |
| EnclosingMethod        | 类                 | 表示这个类的外围方法，局部类或者内部类才有这个属性           |
| InnerClasses           | 类                 | 内部类表                                                     |
| LineNumberTable        | Code属性           | 源码的行号和字节码指令的对应关系                             |
| LocalVariableTable     | Code属性           | 方法局部变量描述                                             |
| StackMapTable          | Code属性           | 这是个jdk6以后的类型验证器，验证方法的局部变量和操作数栈需要<br />的类型是否匹配 |
| Signatrue              | 类、方发表、字段表 | 用来记录泛型信息，因为Java是使用擦除法实现的伪泛型。<br />编译之后签名中是没有泛型的，需要单独记录 |
| SourceFile             | 类                 | 源文件名                                                     |
| SourceDebugException   | 类                 | 记录非Java语言的程序的调试信息，比如jsp                      |
| Synthetic              | 类、方发表、字段表 | 表示方法或者字段是编译器自动生成的                           |
| LocalVariableTypeTable | 类                 | 使用特征签名代替描述符，为了引入泛型后能描述泛型参数话类型   |
| NestHost               | 类                 | 内部类通过这个属性找到宿主类                                 |
| NestMembers            | 类                 | 宿主类通过这个属性找到内部类                                 |

每个属性都由属性名的索引(attribute_name_index)、属性长度(attribute_length)和属性值(info)组成一张表。

方法体经过编译之后变成字节码指令存储在Code属性中，具体的Code表结构：

| 名称                   | 说明                                                         | 类型 |
| ---------------------- | ------------------------------------------------------------ | ---- |
| attribute_name_index   | 指向常量池的索引，常量池中的值固定是Code                     | u2   |
| attribute_length       | 属性长度，因为属性名索引和属性长度一共6个字节<br />所以属性值长度是属性表长 - 6字节 | u4   |
| max_stack              | 操作数栈深度最大值                                           | u2   |
| max_locals             | 局部变量表需要的存储空间，这个是编译的时候算出来的，变量表的最小单位是变量槽<br />对于byte、int这种占用1个变量槽，变量槽是可以重用的 | u2   |
| code_length            |                                                              | u4   |
| code                   | 方法体的字节码，每个指令就是u1类型的单字节，所以字节码指令一共只能有256个<br />现在大约200个 | u1   |
| exception_table_length |                                                              | u2   |
| exception_table        | 异常表                                                       |      |
| attributes_length      |                                                              | u2   |
| attribute              |                                                              |      |

异常表中有4个属性：

| 名称                                                         | 类型 |
| ------------------------------------------------------------ | ---- |
| start_pc：try左括号所在字节码偏移量                          | u2   |
| end_pc：try右括号所在自己码偏移量                            | u2   |
| handler_pc：发生异常时跳转到的字节码偏移量                   | u2   |
| catch_type：指向CONSTANT_Class_info的索引，为0时任何异常都需要跳转到handler_pc | u2   |

例如：

```java
public int inc() {
    int x;
    try {
        x = 1;
        return x;
    } catch(Exception e) {
        x = 2;
        return x;
    } finally {
        x = 3;
    }
}

public static void main(String[] args) {
    System.out.println(new Test().inc());
}

// 编译后的字节码
public int inc();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=5, args_size=1
         0: iconst_1
         1: istore_1
         2: iload_1
         3: istore_2
         4: iconst_3
         5: istore_1
         6: iload_2
         7: ireturn
         8: astore_2
         9: iconst_2
        10: istore_1
        11: iload_1
        12: istore_3
        13: iconst_3
        14: istore_1
        15: iload_3
        16: ireturn
        17: astore        4
        19: iconst_3
        20: istore_1
        21: aload         4
        23: athrow
      Exception table:
         from    to  target type
             0     4     8   Class java/lang/Exception
             0     4    17   any
             8    13    17   any
            17    19    17   any
      LineNumberTable:
        line 7: 0
        line 8: 2
        line 13: 4
        line 8: 6
        line 9: 8
        line 10: 9
        line 11: 11
        line 13: 13
        line 11: 15
        line 13: 17
        line 14: 21
      StackMapTable: number_of_entries = 2
        frame_type = 72 /* same_locals_1_stack_item */
          stack = [ class java/lang/Exception ]
        frame_type = 72 /* same_locals_1_stack_item */
          stack = [ class java/lang/Throwable ]
```

上面的字节码中args_size是1，**这个参数就是this，把this当参数传到方法中，这样就可以在方法中调用实例的属性了**。

##### 字节码指令

下面的指令中T表示模板，可以替换成i、l、d、f等，i就是int的缩写，d就是double的缩写，reference类型用a表示。**有的指令会不支持一些类型，Tconst不支持byte、short等类型**，编译器会把他们转成int处理，还有boolean，**所有指令都不能处理boolean**，也要转成int。

###### 1.加载和存储指令

用来把数据在栈针中的局部变量表和操作数栈之间传输数据：

*   把局部变量加载到操作数栈：Tload
*   把数据从操作数栈存储到局部变量表：Tstore
*   把常量加载到操作数栈：Tipush、ldc、Tconst
*   扩充局部变量表的访问索引：wide

###### 2.运算指令

*   Tadd：加法指令
*   Tsub：减法指令
*   Tmul：乘法指令
*   Tdiv：除法指令
*   Trem：求余指令
*   Tneg：取反指令
*   Tshl、Tshr、Tushr：位移指令
*   Tor：或指令
*   Tand：与指令
*   Txor：异或指令
*   iinc：自增，只支持int类型
*   dcmpg、dcmpl、fcmpg、fcmpl、lcmp：比较指令

###### 3.类型转换指令

虚拟机支持小范围向大范围不需要指令。大范围向小范围转换包括：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、d2f。转换结果可能导致数据不对、正负不对、精度丢失，比如long转int就是高高位丢弃，这样如果一个负数转换就可能变成正数，NaN转long或者int统一是0，如果double转float太小无法表示，就会变成0，如果太大无法表示就是无穷大。

###### 4.对象创建和访问指令

*   创建类实例：new
*   创建数组：newarray、anewarray、multianewarray
*   访问变量：getfield、putfield、getstatic、putstatic
*   把数组元素加载到操作数栈：Taload
*   把操作数栈的值存到数组中：Tastore
*   获取数组长度：arraylength
*   检查类实例类型：instanceof、checkcast

###### 5.操作数栈管理指令

*   把栈顶的1个或2个元素出栈：pop、pop2
*   复制栈顶元素并重新压入栈顶：dup
*   把栈顶两个值互换：swap

###### 6.控制转移指令

*   条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_icmpeq、if_acmpne
*   复合条件分支：tableswitch、lookupswitch
*   无条件分支：goto、goto_w、jsr、jsr_w、ret

###### 7.方法调用和返回指令

*   调用对象的实例方法：invokevirtual
*   调用接口方法：invokeinterface
*   调用一些需要特殊处理的实例方法，比如初始化、父类方法：invokespecial
*   调用静态方法：invokestatic
*   调用运行时动态根据限定符解析出的方法：invokedynamic
*   返回指令：Treturn

###### 8.异常处理指令

方法中的try catch不是由指令完成的，而是由异常表完成的，很早之前是使用jsr和ret，现在不用了，显示抛出的异常由athrow指令实现。

###### 9.同步指令

同步都是使用管程(monitor)实现，方法级同步是通过方发表中的ACC_AYNCHRONIZED标志实现，如果设置了这个标志，执行线程要先持有管程，方法结束或者抛出异常会在方法边界之外自动释放管程。

同步代码块是通过monitorenter和monitorexit指令实现，编译器需要保证monitorenter和monitorexit的执行必须要成对，所以如果方法没有任何异常处理的情况编译器也会生成一个异常表用来保证monitorenter和monitorexit配对执行，防止代码发生异常管程不释放。