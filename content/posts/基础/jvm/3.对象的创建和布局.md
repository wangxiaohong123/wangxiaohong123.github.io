---
title: jvm-对象的创建和布局
tags:
  - JVM
categories: 基础
copyright: true
---

对象的创建包括new关键字、复制、反序列化等等。

##### new关键字对象的创建

###### 第1步 类加载

这里的new关键字不包括数组和Class对象，当虚拟机遇到一条字节码new指令时，首先会根据关键字的参数去常量池中找这个类的符号引用，然后在检查这个符号引用的类是否已经被加载、解析和初始化过，如果没有就先进行类加载。

###### 第2步 分配内存

类加载完之后需要多大的内存就可以确定了，这个时候就要为对象分配内存，如果堆中的内存是规整的，所有用过的内存放到一边，没用过的在另一边，那么分配内存就是把指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式叫做指针碰撞(Bump The Pointer)；如果堆中的内存是不规整的，就必须要维护一个列表记录那些内存块是可用的，这种方式叫空闲列表(Free List)。

至于堆是否规整由垃圾回收器决定，比如**ParNew使用的就是指针碰撞，因为他在GC的时候有收集整理的能力，而CMS这种基于清除算法的收集器使用的就是空闲列表**。

###### 第3步 设置对象

分配完内存之后把分配到的内存空间都设置成0，如果使用了TLAB的话会在分配TLAB时设置，设置成0是为了保证对象中的变量不需要赋初始值就能直接使用。然后还有一堆设置，比如对象属于哪个类、类的元数据信息、GC的分带年龄等。

###### 第4步 调用构造方法

这个时候一个对象就已经生成了，但是对于java程序来说，对象的创建才刚开始，还需要在调用对象的构造方法，也就是class文件中的init()方法，是否调用构造方法由字节码中的new指令后面是否有invokespecial指令决定，编译器在编译时遇到new关键字会自动生成这个指令，如果通过其他方式产生的对象不一定会有这个指令，调用完构造方法之后对象才算被完整的构造出来。

##### 对象的内存布局

在HotSpot虚拟机里，对象的内存布局可以分成3部分：对象头、实例数据和对齐填充。

###### 对象头

对象头分成两类：一类是存储运行时的数据，另一类是指向类型元数据的指针，运行时的元数据在32位和64位的虚拟机中分别占32和64比特，官方称他为Mark Word：

| 存储内容                             | 标志位 | 状态       |
| ------------------------------------ | ------ | ---------- |
| 对象hash码、对象分代年龄             | 01     | 未锁定     |
| 指向锁记录的指针                     | 00     | 轻量级锁定 |
| 指向重量级锁的指针                   | 10     | 重量级锁定 |
| 空                                   | 11     | GC标记     |
| 偏向线程ID、偏向时间戳、对象分代年龄 | 01     | 可偏向     |

对象运行时的数据有的已经超过了32或者64bit能记录的最大限度，所以Mark Word被设计成了一个动态定义的数据结构，比如32位的HotSpot虚拟机中，如果对象没有被同步锁锁定，32个bit中25个bit存储hash码，4个bit存储分代年龄，2bit存储锁标志位，还有1bit固定是0。

指向类型元数据的指针是为了判断对象是哪个类的实例，单并不是只能通过这个指针查找元数据信息，通过元数据信息还可以计算出对象的大小，因为数组的长度是不确定的，所以数组的对象头中需要记录数组的长度。

###### 实例数据部分

这部分存储的是代码中定义的各种类型的字段内容，包括从父类继承下来的，longs/doubles->ints->shorts/chars->bytes/booleans->oops(Ordinary Object Pointers)，同时父类的long会出现在子类的long之前。可以通过**-XX:FieldsAllocationStyle**调整顺序策略，如果配置了**-XX:CompactFields=true**那么子类比较窄的变量会插到父类变量的空隙中来节约内存。

###### 对齐填充

由于HotSpot要求对象的大小必须是8的整数倍，对象头已经是8的整数倍了，如果实例数据不是8的整数倍就需要通过对齐填充来补全。

##### 对象的定位

对象主要通过栈上的reference数据来操作堆上的具体对象，但是reference指向有两种：

*   句柄池：在堆内存中需要一块单独的区域来当句柄池，句柄中包含的对象的类型数据和实例数据，reference如果存储的是对象的句柄地址，在定位对象的时候会先找到句柄，然后在去查找对象，这个样有个好处就是对象地址改变的时候只需要修改句柄中的实例数据指针，不需要修改所有对象的引用指针，坏处就是不好的地方就是多一次指针定位。
*   直接指针：reference中存储的就是对象地址，减少一次指针定位的开销，HotSpot主要是用的就是这种方式。