---
title: jvm-垃圾回收器和内存分配
tags:
  - JVM
categories: 基础
copyright: true
---

本地方法栈、虚拟机栈和程序计数器会随着线程结束被回收，因为栈针需要多大的内存是确定的，而方法区和堆就有非常多的不确定性，比如一个接口的多个实现类需要的内存是不一样的，同一个方法进入不同分支需要的内存也不一样，所以这两个区域的内存分配和回收时动态的，也是垃圾回收负责的地方。

##### 对象存活判断

很多人说Java虚拟机里使用引用计数算法判断对象是否存活，比如对象中有一个引用计数器，被引用的时候就+1，引用失效的时候就-1，引用计数算法虽然需要花费额外的内存，但是他简单且高效，Python好像用的是这个，不过主流的Java虚拟机没有使用这个算法而是使用可达性分析来确定对象是否存活，因为引用计数看起来很简单，却需要考虑很多情况，必须要做大量的额外处理，比如两个对象的循环引用，其实两个对象都是死去的对象，但是他们的引用计数都不是0，所以不会被回收，一直占着内存。

可达性分析就是先选出一堆GC Root，从这些节点开始根据引用关系向下搜索，搜索过程中走过的路径叫**引用链**，那么如果一个对象和GC Root之间没有引用链，这个对象就是死去的对象，可以被回收。下面是可以当做GC Root的变量：

*   虚拟机栈针中本地变量表的引用对象，可以理解成当前运行方法中的入参、局部变量和临时变量
*   方法区中静态属性引用的对象
*   方法区中常量引用的对象
*   本地方法栈中JNI(就是Native中的方法)引用的对象
*   虚拟机内部引用，比如基本数据类型对应的Class对象、一些常驻异常对象(NullPointException)等
*   被同步锁持有的对象
*   JMXBean、JVMTI、本地代码缓存等
*   根据垃圾收集器和当前回收区域的不同还有其他对象临时加入GC Roots

标记为不可达对象后并不会马上进行回收，如果不可达的对象没有重写finalize方法或者这个对象的finalize方法已经被执行过了，就等着被回收，相反就把他放进一个F-Queue队列中，然后会有一个低优先级的Finalizer线程去遍历F-Queue中的对象并执行里面的finalize方法，想要不被回收可以在finalize方法中引用GC Root对象，注意**每个对象的finalize方法在生命周期中只会被调用1次**。官方已经不推荐重写finalize方法了，因为它运行代价高，而且不能保证对象的调用顺序。

### 经典回收器：

经典说的是JDK7 update4以前出现的回收器，而在这之后的回收器有着高性能低延迟的革命性改进。分代回收器都是遵循分带理论的：

*   绝大多数的对象都是朝生夕灭的
*   熬过越多次数的垃圾收集的对象就越难以消亡

因为这个理论出现了年轻代、老年代的划分，以及发展出了标记-复制算法、标记-清除算法、标记-整理算法。这种分代回收是有问题的，比如说对象之间会存在跨代引用的关系，这就让我们在回收年轻代的时候不得不去遍历老年代的对象，看看是否存在和老年代中的GCRoot有引用链关系的对象，为了解决扫描对象太多的问题在年轻代中维护了一个记忆集的东西，记录老年代中那些内存存在跨代引用，这样是减少了扫描，但是增加了运行时的开销。

##### 1.Serial

serial的单线程不仅是使用1个处理器或者1个线程执行垃圾回收工作，最重要的是强调他在回收的时候需要Stop The Word，他的优点就是简单且高效，大部分的系统已经不用这个收集器了，但是目前他还是HotSpot的默认回收器，他在小内存比如桌面应用上回收效率极高，因为没有线程切换的花销。

##### 2.ParNew

ParNew是Serial的多线程版本，他俩的区别也只有线程数，像控制参数(-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等)、回收策略、算法、对象分配规则都完全一样。单核服务器下他是没有Serial好用的，可以使用-XX:ParallelGCThreads调整垃圾收集的线程数，默认是处理器核心数。**目前只有ParNew和Serial能和CMS配合使用**，因为其他收集器没有分代框架。**在JDK9之后去掉了-XX:+UseParNewGC**参数，可以理解成ParNew合并到了CMS中。

##### 3.Parallel Scavenge（吞吐量优先收集器）

他也是使用标记-复制算法，也是年轻代的垃圾收集器，和ParNew不同的是他可以控制运行业务代码的吞吐量，吞吐量的公式：

$吞吐量=\frac{运行业务代码时间}{运行业务代码时间 + 运行垃圾收集时间}$

**-XX:MaxGCPauseMillis**参数要求是大于0的毫秒数，收集器会尽量保证收集的时间小于这个设定值，这个值直接影响回收频率。

**-XX:GCTimeRatio**参数要求正整数，表示期望虚拟机在GC上消耗的时间不超过程序运行时间的1/(1+n)，默认是99，意思就是垃圾收集器运行的时间不超过总运行时间的1%，也就是程序执行时间是垃圾回收执行之间的99倍以上。

**-XX:+UseAdaptiveSizePolicy**，他是个开关，如果打开就不需要手动设置-Xmn、E区和S区的比例、晋升老年代对象大小等等，虚拟机会根据当前运行情况的性能监控信息动态调整。

##### 4.Serial Old

使用标记-整理算法，JDK5之前和Parallel Scavenge配合使用，目前应该是CMS失败的降级方案。

##### 5.Parallel Old

他是Parallel Scavenge的老年代版本，因为在JDK6之前Parallel Scavenge只能搭配Serial Old，这个非常慢，所以JDK6出了Parallel Old，他也使用的标记-整理算法。

##### 6.CMS

CMS是获取最短回收停顿时间的回收器，他默认基于标记-整理算法，如果指定了CMS收集器(-XX:+UseConcMarkSweepGC)新生代收集器会默认选择ParNew。整个过程分成4步：

*   初始标记：标记被gc root直接关联的对象，这步会有stw，但是很快；
*   并发标记：和系统并行，从上一步标记的对象中开始遍历进行标记所有垃圾对象，因为系统也在运行，所以可能有新对象进来，或者标记过的对象变化了，CMS都会记录，这步是最慢的，而且会占用CPU，使用线程数计算公式：(核数 + 3)/4；
*   重新标记：把第二阶段变化的对象通过可达性分析标记成垃圾对象，会有stw，但是也很快；
*   并发清除：和系统并行，清除垃圾对象；

CMS的缺点非常多，由于并发时使用的线程数是(核数 + 3)/4，所以核数越少，占用的资源就越多，比如4核就要占用25%的资源；而且他没有办法处理浮动垃圾，浮动垃圾就是在回收时产生的垃圾，虽然在并发清除前还要在标记一次，但是并发清除时产生的垃圾没有办法回收，所以使用CMS的堆不能等到内存满了在回收，可以通过**-XX:CMSInitiatingOccupancyFraction=92**参数调整使用内存达到某个百分比时进行GC，这个参数如果设置的越大就越容易导致并发失败。如果在垃圾回收时内存满了会导致并发失败，系统会自动切换成Serial Old回收器，这个时候就要stw了；

最后一个缺点就是他的算法，默认是标记-整理，因为有个参数**-XX:CMSFullGCsBeforeCompaction=5(JDK9之后废弃)**来控制回收几次后进行整理，默认是0，如果设置的参数大于0那就是标记-清除算法了，标记-清除会有大量内存碎片，标记-整理又会增加停顿时间，还有个参数是**-XX:+UseCMSCompactAtFullCollection(JDK9之后废弃)**，这个参数的意思是在FullGC时开启内存碎片的整理，因为需要移动存活对象，所以不能并发，他也会增加停顿时间。

##### 7.G1回收器

G1最早在JDK6update14的时候开始进入实验阶段，JDK7update4的时候进行商用直到JDK8的update40G1完成了并发的类卸载的最后一块功能拼图，在JDK9之后被当做默认的垃圾回收器。

G1虽然也是遵循分代理论，但是没有年轻代和老年代的界限，所有对象都放到一起，还多了一个大对象(Humongous)区域(只要超过了region的一半就算大对象)。region的大小通过**-XX:G1HeapRegionSize**参数决定，范围是1M~32M，且要是2的n次幂。

他只有两个回收情况，年轻代RegionGC和mixedGC，G1的垃圾回收算法都是使用复制清除算法，同样在年轻代中还是有两个survivor区的概念，只不过所有的区域都没有明显的划分。G1将堆内存划分为2048个region，默认初始会给年轻代5%个region，老年代0个，大数据也是0个，当年轻代的region数超过60%（默认）时进行一次regionGC，当老年代的region数超过45%（默认）时进行一次mixedGC，mixedGC包括老年代、年轻代和大数据区，G1的回收时的四个阶段：

*   初始标记：标记直接被gc root关联的对象，并且修改TAMS指针的值，这个也需要停顿，但是他是在MinorGC的时候同步完成的，不会有额外的停顿。
*   并发标记：遍历上一步标记出来的对象，找到满足回收条件的对象，扫描完成后还要处理SATB记录下的在并发时有引用变化的对象。
*   最终标记：std并且标记上一步遗留的SATB(原始快照)记录。
*   筛选回收：更新region的统计数据，对每个region的回收价值进行排序(能够回收多少空间和回收的时间)，根据用户期望的停顿时间制定回收计划，然后把选中要回收的region中存活对象复制到空region中，最后清空region。

G1是收集器技术的里程碑，从G1开始，收集器开始放弃每次回收整个堆，而是每次回收一小部分，只要保证回收的速度大于分配的速度就能让系统稳定运行。但是G1的记忆集、卡表这些指针会花费更多的内存。G1和CMS都是通过写屏障来维护卡表，但是CMS的卡表里只有和新生代有关联的对象，而G1维护的东西就多了，所以G1会更消耗资源。通常在小内存的时候CMS的性能要比G1好，6G或者8G以后使用G1要好。

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h46lvoldekj20ww0fwmy4.jpg)

---

目前没有一个可以在任何场景都适用的完美收集器，否则HotSpot也没必要实现这么多种收集器了。

如何做到基本不fullGC： 进入老年代的条件： 1）对象过大，一般这种情况可能没有或者不多； 2）进入survivor区的对象年龄小于n加在一起内存超过survivor的一半，那么年龄>=n的对象直接进入老年代； 3）躲过15次minorGC； 能躲过15minorGC除了系统很卡的情况一般都是被@Service或者@Component或者@Controller注解或者静态变量的引用对象，这种对象只有一个，加在一起就一百兆左右，所以只要根据具体业务调整es比例、年轻代和老年代的比例就可以。比如系统每秒的QPS，高峰期的QPS，每个请求会创建多少个对象，这些对象大约会使用多少内存计算出多长时间会触发一次minorGC，每次minorGC又有多少进入到survivor区（如果一个请求要处理两秒，就是最后两次请求的会进入s区），估算多长时间会触发条件2进入老年代，推算出老年代多久发生一次fullGC。

### 低延迟垃圾收集器

##### 1.Shenandoah

他不是Sun开发的，他是RedHat开发的，所以Orocle一直在排斥这个回收器。

他和G1非常像，都是使用region划分内存、一样的整理算法、一样的大对象区……，但是他没有年轻代和老年代的划分，同时他使用了全局矩阵维护跨代对象的引用关系。他的回收过程分成9个阶段：

*   初始标记：还是标记GC Roots直接关联的对象，这个阶段仍然需要stw。
*   并发标记：遍历上一步的结果，找到全部可达对象。
*   最终标记：处理剩余的SATB，这步也会有stw。
*   并发清理：这步只清理没有存活对象的region。
*   并发回收：就是把存活对象复制到未使用的region中，但是并不回收，只是把region标记成Immediate Garbage Regions。这步和HotSpot其他虚拟机最大的不同是他支持并发，最大的问题就是用户还可能不断的访问现有对象，移动对象时瞬间修改对象的引用指针非常难，他通过读、写屏障和Brooks Pointers(转发指针来实现)。
*   初始引用更新：这步就是为了确认所有回收线程已经完成对象移动任务，这步会有stw。
*   并发引用更新：把堆中所有指向旧对象的引用改成新对象的地址。
*   最终引用更新：修改GC Roots的引用，这步也会有stw。
*   并发清理：清理Immediate Garbage Regions中的region。

Brooks Pointers很像之前的句柄定位，只不过句柄定位是单独维护一块句柄池，而Brooks Pointers就是在对象头上边搞了个位置，默认就是指向自己，缺点和句柄定位一样在读取对象的时候需要监听读屏障在加一次寻址的开销，而且Shenandoah还需要监听写屏障来维护Brooks Pointers，虽然他可以把回收的停顿时间维持在几十毫秒，但是牺牲了业务的吞吐。

##### 2.ZGC

ZGC的全称就是Z Garbage Collection，他是基于region、目前不设分代的使用了读屏障和染色指针和内存内存多重映射等技术的基于标记-整理算法的低延迟垃圾收集器！！！目前还在实验中。

ZGC的region是动态的创建和销毁的，并且创建的region大部分的容量是固定的，分成3种region：

*   小型region：容量是2M，存放小于256k的对象。
*   中型region：容量是32M，存放256k到4M的对象。
*   大型region：容量不固定，但是要是2M的整数倍，每个大region只存放1个对象，所以大型region可能比中型region要小。同时大型region不会被重分配，因为复制一个大对象的代价非常高。

ZGC过程分为4个阶段：

*   并发标记：这步就是G1的初始标记、并发标记、最终标记，也会有短暂的停顿，但是他标记的是染色指针的标志位而不是对象。
*   并发预备重分配：统计需要清理的region，和G1不同的是他扫描所有region，而且在JDK12之后还要处理类卸载和弱引用。
*   并发重分配：首先要维护一个转发表，记录记录就对象和新对象的转向关系，然后把存活对象复制到新region上，这个时候如果有请求并发访问对象，会通过读屏障拦截，然后根据转发表找到把访问发到新复制的对象上，然后去修改这个引用的值，这样下次这个引用就可以直接找到这个新对象了，这个就是ZGC的**自愈**能力。
*   并发重映射：这里做的工作和G1的是一样的，不过对于ZGC来说这一步并不是很迫切，因为旧引用室友自愈能力的，最多只慢1次，执行这步最主要的原因是回收转向表，所以ZGC把这步放到了下次GC的并发标记阶段里了，这样只需要遍历1遍对象。

染色指针：linux系统说是64位的，但是考虑需求、成本、性能这一块，前18位是没用的，所以linux最多支持64T(2^46^)的内存，ZGC把剩下的46位的高4位用来做标记位，分别是Finalizable、Remapped、Marked1、Marked0。这样会出现一个新问题，就是他把指针改了，就会导致找不到对象了，所以引用了一个多重映射技术，把这几个地址映射到同一个对象，同理染色指针也不支持指针压缩技术(**-XX:+UseCompressOops**)。

### 内存分配

新对象优先分配到Eden区，如果Eden区分配不下会进行一次Minor GC，其他情况下对象会进入老年代，进入老年代的时机：

*   大对象：大对象指的是需要大量连续内存空间的对象，比如大字符串或者数组，链表不是。为了减少复制大对象的高额开销，HotSpot虚拟机提供了**-XX:PretenureSizeThreshold**参数把大于该设置值的对象直接在老年代分配，避免对象在Eden和两个Survivor区来回复制，这个参数只支持Serial和ParNew。
*   长期存活的对象进入老年代：当对象每经历1次Minor GC的时候，年龄加1(**Full GC会不会导致对象年龄加1？**)，有一个参数**-XX:MaxTenuringThreshold**，当年龄大于该设置值的对象会进入到老年代。
*   动态年龄判定：如果S区中年<=n的所有对象大小总和超过了S区的一半，就会把年龄>=n的对象放到老年代。

空间担保机制：在MinorGC之前虚拟机需要检查老年代剩余连续的内存是不是大于年轻代总存活对象内存，如果大于直接Minor GC是没问题的，如果小于就要通过**-XX:HandlePromotionFailure**参数判断是否有风险的Minor GC，如果这个开关是打开的，就要继续判断是老年代剩余连续内存是否大于之前晋升到老年代对象的平均值，如果剩余内存比之前每次回收进入老年代的对象的平均值还要小或者开关是关的，就会直接Full GC。