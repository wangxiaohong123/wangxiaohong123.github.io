---
title: jvm-内存区域
tags:
  - JVM
categories: 基础
copyright: true
---

Java虚拟机规范规定jvm运行时数据区应该包括方法区、堆、虚拟机栈、本地方法栈、程序计数器。其中程序计数器、虚拟机栈和本地方法栈是线程私有的，堆和方法区是所有线程共享的。

### 内存区域

##### 1 程序计数器

他是当前线程执行的字节码行号指示器，占用内存较小，字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令，比如分支、循环、跳转、异常都需要这个计数器来完成。在单核CPU进行多线程切换时，在切换后需要恢复到正确的执行位置也要依赖这个计数器。

如果执行的是java方法，计数器记录的是正在执行的虚拟机字节码指令的地址，如果是本地方法(Native)，计数器的值就是空，所以我猜执行本地方法的时候不能进行线程切换。程序计数器是唯一一个没有OOM情况的区域。

##### 2 虚拟机栈

虚拟机栈是描述java方法执行的线程内存模型，每个方法执行的时候会创建一个栈针，**栈针用来存储局部变量表、操作数栈、动态连接、方法出口等信息**，每个方法从被调用到执行完毕的过程对应着一个栈针的入栈到出栈的过程。**大部分情况下说得jvm中的栈指的是虚拟机栈中的栈针的局部变量表**。

局部变量表里放的是编译期间可知的各种基础数据类型、对象引用(对象引用并不是对象本身，可能是一个指向对象起始地址的指针，也可能是指向一个代表对象句柄或者其他和这个对象相关的位置)和returnAddress类型(指向一条字节码指令的地址)。

这些对象在局部变量表中以局部变量槽(slot)来表示，64位长度的long和double占用两个槽，其他的占用1个槽。所以当进去方法时，需要创建多大的局部变量表是确定的了。

如果线程请求的栈深度超过虚拟机允许的深度会抛出StackOverflowError；当虚拟机栈容量可以扩展时，只会出现扩展到无法申请内存，然后抛出OutOfMemoryError异常，HotSpot虚拟机是不能扩展虚拟机栈的，所以不会因为虚拟机栈无法扩展导致OOM。

##### 3 本地方法栈

本地方法栈和虚拟栈的作用非常相似，虚拟机栈执行的是java方法，也就是字节码服务，本地方法栈执行的是本地Native方法，而且在《java虚拟机规范》中没有强制规定本地方法栈的语言、使用方式、数据结构等，所以每个虚拟机实现的方式都不一样，比如Hot Spot中把虚拟机栈和本地方法栈合二为一了。

##### 4 堆

堆是所有线程共享的空间，堆里面也有一些线程私有的分配缓冲区(Thread Local Allocation Buffer，TLAB)，这个区域是为了对象分配的效率，在高并发的情况下分配堆内存可能会出现两个对象被分配到了同一块内存，解决这个问题有两种方案：一种是CAS不断重试，另外一种就是TLAB，具体那种方案通过**-XX:+/-UseTLAB**参数决定。

堆内存的年轻代、老年代、Eden区……这种分代设计时为了让新生代、老年代收集器搭配工作设计的，但是随着G1的出现之后，这种对于堆的说法仅限分代收集器了。

堆中存放了几乎所有的对象实例，为什么是几乎？不管以后有没有值类型，就现在来说栈上分配、标量替换让对象都在堆中分配变得不是那么绝对了。主流的虚拟机的栈内存都是可扩展的，就是设置-Xmx和-Xms参数，并且堆可以在不连续的内存空间中，但是对于大对象，为了存储高效可能要求连续的内存空间。

##### 5 方法区

方法区也是线程共享的内存区域，它存储的是**被虚拟机加载的类型信息、常量、静态常量、即时编译器编译后的代码缓存**，《Java虚拟机规范》中把方法区描述成堆的一个逻辑部分，但是他又有个别名叫“非堆(Non-Heap)”，目的是和堆区分开。

永久代和方法区并不是等价的，在Java8之前，HotSpot的设计团队把收集器的分代设计扩展到了方法区，从而出现了永久代这个概念，新生代、老年代、永久代听起来是不是很顺耳，可以说在Java8之前，HotSpot虚拟机使用永久代来实现方法区，目的就是方便管理方法区的内存。

因为永久代的内存是有上限(-XX:MaxPermSize)的，这就导致了HotSpot要比JRockit更容易内存溢出，当时Oracle收购BEA之后想把JRockit和HotSpot合二为一但是因为他俩对方法区的实现差太多了，所以合并失败。

在JDK7的时候，HotSpot把原来永久代中的常量池、静态变量等放到了堆中，到了JDK8，HotSpot彻底放弃永久代，采用在本地内存中实现的元数据空间(Meta-space)来代替，把JDK7剩下的类型信息放到元空间中。方法区也会抛出OOM。

##### 6 运行时常量池

他其实是方法区的一部分，因为它存在于class文件中以常量池表的方式，class文件除了常量池表还有版本、字段、方法、接口描述等信息。常量池表存储的是编译时期生成的字面量和符号引用，在类加载后放到方法区的运行时常量池中，运行时常量池中是具有动态性的，就是说运行期间可以加入新的常量，比如String的intern()方法。会抛出OOM。

##### 7 直接内存

直接内存并不是jvm运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，在JDK1.4的时候加入了NIO，他是基于通道(channel)和缓冲区(buffer)的I/O方式，直接调用Native函数分配堆外内存，然后在堆内存中有一个DirectByteBuffer对象引用这个堆外内存，这样可以避免Native内存和Java堆之间来回复制对象。它主要是收到本机总内存(物理内存、SWAP分区等)的影响也会抛出OOM。

### OOM

##### 元数据空间OOM

正常生产环境的元数据空间配置128m或者256m就够用了，如果运行一段时间后元数据空间导致的OOM，原因就是不断的创建类，导致fullGC也无法回收掉动态创建的类，所以使用动态代理模拟元数据空间OOM：

```java
public class OomMat {
    public static void main(String[] args){
        long counter = 0;
        while(true){
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(Car.class);
            enhancer.setUseCache(false);
            enhancer.setCallback(new MethodInterceptor() {
                public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                    if(method.getName().equals("run")){
                        System.out.println("汽车启动前检查");
                        return methodProxy.invokeSuper(o, objects);
                    }else{
                        return methodProxy.invokeSuper(o, objects);
                    }
                }
            });
            Car car = (Car)enhancer.create();
            car.run();
            System.out.println("目前创建了" + (++counter) + "个Car的子类");
        }
    }

    static class Car {
        public void run(){
            System.out.println("汽车启动，开始行使……");
        }
    }

    static class SafeCar extends Car {
        @Override
        public void run(){
            System.out.println("汽车启动，开始行使……");
            super.run();
        }
    }
}
```

代码中使用无线循环创建Car的子类，jvm进程分配10m应该很快就会发生OOM，jvm参数：

```shell
-XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m -XX:+PrintGCDetails -Xloggc:gc.log -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./
```

当创建273个类时元数据空间发生OOM：

<img src="https://tva1.sinaimg.cn/large/006tNbRwly1gatx0qgjflj30jd07ign2.jpg" style="zoom:200%;" />

在看一下GC日志：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gatx0eb3rej318n0fkwv3.jpg)

一共进行了五次Metadata GC，最后停到了9454k，差不多是我设置10m，这时候元数据空间放不下新建的类，抛出OOM异常，使用mat验证一下：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gatx13s59uj30oo0jz74u.jpg)

实例最多的就是AppClassLoader，查看details可以看到大量的使用cglib的enhancer创建的car类。

![](https://tva1.sinaimg.cn/large/006tNbRwly1gatx1gkflhj30n30i1q4r.jpg)

##### 栈内存OOM

每个线程的方法栈给1m就够用了，但是如果写出来没有终止条件或者很深的递归就会触发栈的OOM，但是gc不包括栈内存，内存快照也只针对堆内存和元数据空间，但是，占内存OOM直接可以通过异常发现，简单得很。

##### 堆内存OOM

不管是年轻带还是老年代放不下对象都会触发OOM，只要无限循环创建对象就可以了：

```java
public class DuiOOM {
    public static void main(String[] args){
        List<Object> list = new ArrayList<Object>();
        while(true){
            list.add(new Object());
        }
    }
}
```

把堆内存设置成10m，启动后就会报错：java.lang.OutOfMemoryError: Java heap space，使用mat打开快照只有一个错误，点击details也可以看见都是创建的object，返回到上一级查看调用栈：

<img src="https://tva1.sinaimg.cn/large/006tNbRwly1gatx1vqz7gj30k806mmxf.jpg" style="zoom:150%;" />

可以看到在DuiOOM的11行导致的内存溢出。

