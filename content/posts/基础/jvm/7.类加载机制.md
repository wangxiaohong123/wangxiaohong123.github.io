---
title: jvm-7.类加载机制
tags:
  - JVM
categories: 基础
copyright: true
---

### 生命周期：

*   加载：通过虚拟机内置的类加载器或者自定义的类加载器(重写一个类加载器的findClass或者loadClass方法)把字节流加载到内存中。这个阶段干3件事：
    *   1.通过类的全限定名获取定义这个类的二进制字节流，这个阶段是扩展性最强的阶段，很多技术都建立在这个阶段，比如从jar包或者war包读取二进制、从网络中读取、动态代理的运行时计算生成、其他文件生成，比如jsp、从加密文件中获取，反编译的保护措施；
    *   把字节流转换成方法区需要的存储结构；
    *   在堆中生成一个代表这个类的对象(Class对象)，作为这个类的数据访问入口；

*   验证：java本身是相对C更安全的语言，如果访问数组边界外的数据、类型转换错误这种编译的时候就会报错，但是class文件不一定只能由源码编译而来，比如直接篡改class文件，所以在加载到内存中之后还需要在校验一下，大概就是验证文件格式、元数据、语法、符号引用这些。**文件格式验证和加载是交叉进行的，就是说加载的时候会把一部分已经加载的二进制先拿去验证文件格式**；
*   准备：这个阶段会把类中定义的静态变量分配内存并设置初始值，这写变量在JDK7之后会随着class对象一起放在堆中，因为hotspot没有方法区的物理分区，**这个阶段不会给实例变量分配内存，实例对象会在实例化的时候分配**，基础数据类型除了boolean的初始值都是0，boolean的初始值是false，reference是null。如果静态变量被final修饰，不会赋值初始值，直接赋真实值，因为**final修饰的变量编译的时候属性表会生成ConstantValue属性，而没有final修饰的静态变量编译时把赋值操作放到了编译器生成的构造方法中**；
*   解析：把符号引用替换为直接引用，符号引用就是描述目标的一个字符串，直接引用才是指向内存地址的指针或者句柄，针对的是类或者接口、字段、方法。什么时候解析并没有明确的规定，虚拟机可以在准备之后就解析，也可以在遇见getfield、instanceof这些指令时在解析；
*   初始化：验证、准备、解析都是虚拟机主导的，没有扩展的空间，初始化才会执行类中的程序代码。说白了这步就是执行类的clinit方法，他和构造方法不一样，他不需要显示调用父类clinit方法，虚拟机会保证父类clinit方法先执行，也就是说第一个被执行的clinit方法一定是Object，clinit方法是由编译器根据变量的赋值、静态代码块操作合并生成的；
*   使用；
*   卸载；

验证、准备解析合到一起叫做链接(Linking)，其中加载、验证、准备、初始化的顺序是确定的，也就是初始化完毕，一定是加载、验证、准备好了的，但是不一定会解析，某些情况下解析会出现在初始化阶段之后，这么做是为了**动态绑定**。前5个步骤叫做类加载过程。

《Java虚拟机规范》没有约束什么时候需要加载，但是他规定了有6中情况必须要初始化(那么加载、验证、准备自然需要再次之前开始)：

*   遇到new、getstatic、putstatic、invokestatic四条字节码指令时如果类没有初始化，需要初始化，比如使用new关键字实例化对象、读取或者设置非final修饰的字段、调用静态方法；
*   使用reflect包的方法进行反射调用的时候，如果类没有初始化；
*   初始化类时，如果父类没有初始化，需要先初始化父类。**但是接口不需要，接口是在用到父类的时候才会进行初始化**；
*   虚拟机启动的时候虚拟机会初始化用户指定的主类；
*   使用jdk7新加入的动态语言支持时，如果MethodHandle实例最后的解析结果是RES_getStatic、RES_putstatic、RES_invokestatic、RES_newinvokespecial四种类型的方法句柄、并且这个方法句柄对应的类没有初始化；
*   使用了jdk8新加入的default修饰的接口，如果实现类发生了初始化，那么接口需要在实现类之前被初始化；

只有这6中情况会导致类的初始化，叫做主动引用。其余情况不会类的初始化叫被动引用，被动引用举例：

```java
public class SuperClass {
    static {
        System.out.println("SuperClass init");
    }
    
    public staic int value = 123;
}

public class SubClass extends SuperClass {
    static {
        System.out.println("SubClass init");
    }
    
    public static final String HELLOWORLD = "hello world";
}

public static void main(String[] args) {
    // 被动引用：通过子类引用父类的静态字段
    System.out.println(SubClass.value);
    // 被动引用：通过数组定义引用类
    SuperClass[] sca = new SuperClass[10];
    // 被动引用：通过类引用类的常量，因为常量在类的常量池中，可以直接拿出来
    // 这里有个概念叫常量传播优化，编译的时候会把SubClass.HELLOWORLD的值存储到引用这个变量的常量池中
    System.out.println(SubClass.HELLOWORLD);
}
```

### 类加载器：

根据全限定名获取描述该类的二进制字节流的代码叫做类加载器。对于任何一个类，必须要由加载他的类加载器和类本身才能确定唯一性，也就是说equals、isAssignableFrom、instanceof这些方法比较的结果。

##### 双亲委派模型

从虚拟机的角度来说只有两类类加载器，启动类加载器，这个是虚拟机的一部分，还有一个是独立在虚拟机外部的其他类加载器，这些加载器都继承ClassLoader抽象类。

Java从1.2开始一直保持这三层类加载器架构，就是双亲委派模型，这个模型在模块化之后有一些变动。

*   启动类加载器：加载jdk的lib目录下或者-Xbootclasspath指定的路径下的的类库，并且文件名需要能被虚拟机识别；
*   扩展类加载器：jdk安装目录下的lib\ext下面的类库，由sun.misc.Launcher$ExtClassLoader实现。在JDK9之后被模块化天然的扩展能力取代，JDK9之后叫平台类加载器；
*   应用程序类加载器：加载自己写的类，由sun.misc.Launcher$AppClassLoader实现；
*   自定义类加载器：比如说我们要把class加密，就可以自定义类加载器解密，他是应用程序类加载器的扩展；

双亲委派的意思就是说当一个类加载器收到了类加载的请求时先把请求委派给父类(这里的父类不是继承而是引用关系)，然后从最上层启动类加载器开始加载，如果父类反馈无法加载就自己来。这种模型保证了同名类的唯一性。

双亲委派模型被破坏过几次，最开始是和SPI相关的东西比如JDBC、JNDI这种存在启动类加载器需要调用classPath路径下的某些类，最开始解决这个问题是添加一个线程上下文类加载器，这个就是保存上面的类加载器，如果不指定默认是应用程序类加载器，JDK6之后改成了通过ServiceLoader类加载META/services中的配置。这是一种父类委派子类的情况。

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h4kju4hpxyj20u014oq61.jpg)
