---
title: jvm-8.即时编译器
tags:
  - JVM
categories: 基础
copyright: true
---

Java程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或者代码块运行的特别频繁，就会把这些代码认定为热点代码，为了提高热点代码的执行效率，虚拟机会把热点代码编译为本地机器码，并且尽可能的进行优化，完成这个任务的编译器被称为即时编译器。

HotSpot虚拟机内置了2、3个即时编译器，时间最久的两个是客户端编译器(Client Complier)和服务端编译器(Server Complier)，也被简称为C1、C2，第三个是Java10出现的为了代替C2的Graal编译器，目前还在实验阶段。

##### 分层编译

在分层编译模式出现之前，HotSpot虚拟机采用解释器和即时编译搭配的工作方式，使用哪个即时编译器取决于虚拟机运行的模式，HotSpot会根据宿主机器硬件性能和自身版本选择合适的运行模式，也可以使用**-server**或者**-client**参数强制指定虚拟机运行在客户端模式还是服务端模式。默认情况下虚拟机采用混合模式(Mixed Mode)，可以使用**-Xint**强制虚拟机运行于解释模式，这个时候即时编译器完全不介入，或者使用**-Xcomp**强制虚拟机运行于编译模式，这个时候就优先使用编译器方式运行，编译器无法运行的时候解释器才介入。

因为即时编译编译代码需要占用程序运行时间，尤其是优化部分，优化的成都越高，花的时间就越长，而且解释器还要替编译器收集监控信息，为了平衡运行效率和启动响应速度，JDK7之后出现了分层编译策略，并且作为默认的编译策略：

*   0层：纯解释执行，并且不需要开启监控。
*   1层：使用客户端将字节码编译成本地机器码，不需要开启监控。
*   2层：使用客户端编译器，仅开启方法、回边(从方法边界往回跳转)次数统计等监控。
*   3层：使用客户端编译器，开启全部统计，比如分支跳转。
*   4层：使用服务端编译器。

具体使用多少层也是虚拟机自己决定的。

##### 编译触发条件

热点代码主要分成两类，这两类编译的对象都是整个方法体：

*   被多次调用的方法
*   被多次执行的循环体

###### 1.栈上替换

统计循环体的调用次数时，由于统计的是方法内的代码块，所以要在方法的执行过程中进行统计，如果发现调用次数达到热点的阈值就会进行及时编译，但是编译的对象是整个方法，所以这种情况可能会导致方法的栈针还在栈上就被替换了。

###### 2.热点探测判定方式

热点探测就是判定代码是不是需要触发即时编译，进行热点探测有两种方式：

*   采样热点探测：虚拟机周期性的检查所有线程的调用栈顶，如果发现某个方法经常出现在这个栈顶，那这个方法就是热点方法，这样做就是效率高，但是不准，比如线程阻塞就会影响判断。
*   计数器的热点探测：虚拟机为每个方法甚至是代码块建立计数器，统计代码执行次数，这种方式更准但是实现麻烦。

J9使用的是采样，HotSpot使用的是计数器。使用参数**-XX:CompileThreshold**设置方法计数器的阈值，默认客户端是1500次，服务端10000次，当方法被调用的时候虚拟机先检查这个方法有没有被即时编译过，如果没有，方法的计数器+1，如果方法的调用+回边次数达到阈值就交给即时编译器编译，即时编译是异步的，这个时候还是会解释执行，当即时编译结束后会把方法的入口地址替换。

统计的方法被调用次数并不是绝对的，统计的是某个时间段内的，如果超过了时间限度，调用次数会减半，这个过程成为计数器的热度衰减，这段时间成为半衰周期，**热度衰减的动作是在垃圾回收时顺便进行的**。使用**-XX:UseCounterDecay**关闭热度衰减，还可以使用**-XX:CounterHalfLifeTime**设置半衰周期，单位是s。

回边的热点探测和方法的差不多，他计算阈值的方式更复杂，而且当回边计数器达到阈值时，会把方法计数器的统计数量也改成移出状态，其他的都差不多。