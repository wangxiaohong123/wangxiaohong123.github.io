---
title: 行为型-策略模式
tags:
  - 设计模式
categories: 基础
copyright: true
---

策略模式是为了去掉if else，因为if else中可能包含大量的代码，而且判断条件不是很清晰，很容易出问题，并不是说因为if分支多了才要去掉，策略模式的实现：

![备忘录模式](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/备忘录模式.png)

```java
public class Demo {
    public static void main(String[] args) {
        Context context;
        switch (expression) {
            case "a":
                context = new Context(new DiscountCalculateA());
                break;
            case "b":
                context = new Context(new DiscountCalculateB());
                break;
            case "c":
                context = new Context(new DiscountCalculateC());
                break;
        }
        context.calculate();
    }

    // 抽象算法类
    public abstract class DiscountCalculateStrategy {
        public abstract void calculate();
    }
    
    // 具体算法A
    public static class DiscountCalculateA extend DiscountCalculateStrategy {
        @Override
        public void calculate() {
            System.out.println("算法A实现");
        }
    }
    // 具体算法B
    public static class DiscountCalculateB extend DiscountCalculateStrategy {
        @Override
        public void calculate() {
            System.out.println("算法B实现");
        }
    }
    // 具体算法C
    public static class DiscountCalculateC extend DiscountCalculateStrategy {
        @Override
        public void calculate() {
            System.out.println("算法C时间");
        }
    }
    
    // 上下文
    public static class Context {
        
        DiscountCalculateStrategy discountCalculateStrategy;
        
        public static Context(DiscountCalculateStrategy discountCalculateStrategy) {
            this.discountCalculateStrategy = discountCalculateStrategy;
        }
        
        public static void contextInterface() {
            this.discountCalculateStrategy.calculate();
        }
    }
}
```

每个if分支对应了一个类，通过context实例化对应的算法实现类，这样有个问题就是判断的操作还是在客户端，可以结合工厂去掉客户端的判断分支：

```java
public class Demo {
    public static void main(String[] args) {
        Context context = new Context(expression);
        context.calculate();
    }

    // 抽象算法类
    public abstract class DiscountCalculateStrategy {
        public abstract void calculate();
    }
    
    // 具体算法A
    public static class DiscountCalculateA extend DiscountCalculateStrategy {
        @Override
        public void calculate() {
            System.out.println("算法A实现");
        }
    }
    // 具体算法B
    public static class DiscountCalculateB extend DiscountCalculateStrategy {
        @Override
        public void calculate() {
            System.out.println("算法B实现");
        }
    }
    // 具体算法C
    public static class DiscountCalculateC extend DiscountCalculateStrategy {
        @Override
        public void calculate() {
            System.out.println("算法C时间");
        }
    }
    
    // 上下文
    public static class Context {
        
        DiscountCalculateStrategy discountCalculateStrategy;
        
        public static Context(String expression) {
            switch (expression) {
                case "a":
                    this.discountCalculateStrategy = new DiscountCalculateA();
                    break;
                case "b":
                    this.discountCalculateStrategy = new DiscountCalculateB();
                    break;
                case "c":
                    this.discountCalculateStrategy = new DiscountCalculateC();
                    break;
            }
        }
        
        public static void contextInterface() {
            this.discountCalculateStrategy.calculate();
        }
    }
}
```

让Context实现工厂模式之后，客户端只需要认识Context类并且知道要使用那种算法就可以了，客户端和DiscountCalculateStrategy无接触，耦合度更低。
