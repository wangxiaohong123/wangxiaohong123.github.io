---
title: 行为型-迭代器模式
tags:
  - 设计模式
categories: 基础
copyright: true
---

迭代器模式是提供一种方法顺序访问一个聚合对象中的各个元素，又不暴露该对象的内部展示。就是为不同的聚集结构提供开始、下一个、是否结束、当前哪一项等接口。

场景：比如有一个实体里面的成员有一个数组，使用加强for循环是可以遍历的，但是有一天数组变成了map，那么遍历的代码全部都要改。这个模式基本上没有实用价值，因为java、c#等等已经把这个模式放在语言中了。

```java
/**
 * 定义一个迭代器抽象类
 */
public abstract class Iterator<T> {
    public abstract T first();
    public abstract boolean isDone();
    public abstract T next();
    public abstract T currentItem();
}

/**
 * 集合抽象类
 */
public abstract class Aggregate {
    // 创建迭代器
    public abstract Iterator createIterator();
}

/**
 * 具体迭代器
 */
public class ConcreteIterator extends Iterator {
    // 具体聚合对象
    private ConcreteAggregate aggregate;
    private int current = 0;
    
    public ConcreteIterator(ConcreteAggregate aggregate) {
        this.aggregate = aggregate;
    }
    
    public T first() {
        return aggregate[0];
    }
    
    public boolean isDone() {
        return current >= aggregate.count();
    }

    public T next() {
        T res = null;
        current ++;
        if (current < aggregate.count()) {
            res = aggregate.getI(current);
        }
        return res;
    }

    public T currentItem() {
        aggregate.getI(current)
    }
}

/**
 * 具体集合类
 */
public class ConcreteAggregate extends Aggregate {
    private List<T> items = new List<>();
    
    @Override
    public Iterator createIterator() {
        return new ConcreteIterator(this);
    }
    
    public int count() {
        return this.items.size();
    }
    
    public T getI(int index) {
        return this.items.get(index);
    }
}

public static void main(String[] args) {
    ConcreteAggregate a = new ConcreteAggregate();
    // ……赋值
    Iterator i = a.createIterator();
    while (!i.isDone()) {
        i.next();
    }
}
```

