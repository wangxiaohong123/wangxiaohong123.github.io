---
title: 行为型-观察者模式
tags:
  - 设计模式
categories: 基础
copyright: true
---

观察者模式也叫发布订阅模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，当主题对象状态发生变更的时候通知所有观察者。

类图：
![观察者模式](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/观察者模式.png)

```java
/**
 * 抽象主题类
 */
public abstract class Subject {
    private List<Observer> observers = new ArrayList<>();
    
    /**
     * 增加观察者
     */
    public void attach(Observer observer) {
        observers.add(observer);
    }
    
    /**
     * 移除观察者
     */
    public void detach(Observer observer) {
        observers.remove(observer);
    }
    
    /**
     * 通知
     */
    public void notify() {
        for (Observer observer : observers) {
            observer.update();
        }
    }
}

/**
 * 抽象观察者
 */
public abstract class Observer {
    public abstract void update();
}

/**
 * 具体主题类
 */
public class ConcreteSubject extends Subject {
    /**
     * 具体主题状态
     */
    private String subjectState;
    
    public void setSubjectState(String subjectState) {
        this.subjectState = subjectState;
    }
    
    public String getSubjectState() {
        return this.subjectState;
    }
}

/**
 * 具体观察者
 */
public class ConcreteObserver extends Observer {
    private String name;
    private String observerState;
    private ConcreteSubject subject;
    
    public ConcreteObserver(ConcreteSubject subject, String name) {
        this.subject = subject;
        this.name = name;
    }
    
    @Override
    public void update() {
        this.observerState = this.subject.getSubjectState();
        System.out.println("观察者" + name + "的新状态是" + observerState);
    }
}

public static void main(String[] args) {
    ConcreteSubject s = new ConcreteSubject();
    s.attach(s, "X");
    s.attach(s, "Y");
    s.attach(s, "Z");
    
    s.setSubjectState("ABC");
    s.notify();
}
```

如果一个业务需要一系列类的协作，这样有个不好的地方就是要维护相关对象的一致，维护一致就要产生耦合，而观察者就是不需要知道观察者是谁，当一个对象的改变需要通知其他对象的时候就很适合观察者模式。比如说intellij，点击运行的时候下面的run窗口会弹出，这里run窗口就是程序的观察者，当程序状态变成运行的时候会自动弹出，还有zk的节点监听。

java中自带观察者的实现。

