---
title: 行为型-访问者模式
tags:
  - 设计模式
categories: 基础
copyright: true
---

访问者模式可以使我们在不改变各个元素类的前提下定义作用于这些元素的新操作。

他比组合模式更灵活，将组合模式的操作方法拿出来每个功能定义一个类，然后再把类穿进去，通过组合模式调用，这样就可以灵活的执行各种操作。其实就是以类或者方法为参数传进去执行。这是GoF中最复杂的模式。

![访问者模式](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/访问者模式.png)
访问者类的参数element，访问者中的方法跟element有几个子类相关，就是说只有到element的状态确定才会考虑访问者模式，比如element是人，那他的子类只有男和女，这样访问者里的方法数量是固定的，如果element的子类个数不确定，那么在修改需求的时候需要增加或者删除访问者类中的方法，违反了开放-封闭原则。

```java
public abstract class Visitor {
    public abstract void VisitConcreteElementA(ConcreteElementA element);
    
    public abstract void VisitConcreteElementB(ConcreteElementB element);
}

public class concreteVisitor1 extends Visitor {
    @Override
    public void VisitConcreteElementA(ConcreteElementA element) {
        System.out.println("ConcreteElementA被concreteVisitor1访问");
    }
    
    @Override
    public void VisitConcreteElementB(ConcreteElementB element) {
        System.out.println("ConcreteElement被concreteVisitor1访问");
    }
}

public class concreteVisitor2 extends Visitor {
    @Override
    public void VisitConcreteElementA(ConcreteElementA element) {
        System.out.println("ConcreteElementA被concreteVisitor2访问");
    }
    
    @Override
    public void VisitConcreteElementB(ConcreteElementB element) {
        System.out.println("ConcreteElementB被concreteVisitor2访问");
    }
}

public abstract class Element {
    public abstract void accept(Visitor visitor);
}

public class ConcreteElementA extends Element {
    @Override
    public void accept(Visitor visitor) {
        visitor.VisitConcreteElementA(this);
    }
    
    // 其他相关方法
    public void operationA() {}
}

public class ConcreteElementB extends Element {
    @Override
    public void accept(Visitor visitor) {
        visitor.VisitConcreteElementB(this);
    }
    
    // 其他相关方法
    public void operationB() {}
}

public class ObjectStrustrue {
    private List<Element> elements = new ArrayList<>();
    
    public void attach(Element element) {
        elements.add(element);
    }
    
    public void detach(Element element) {
        elements.remove(element);
    }
    
    public void accept(Visitor visitor) {
        for (Element element : elements) {
            element.accept(visitor);
        }
    }
}

public static void main(String[] args) {
    ObjectStrustrue o = new ObjectStrustrue();
    o.attach(new ConcreteElementA());
    o.attach(new ConcreteElementB());
    
    concreteVisitor1 v1 = new concreteVisitor1();
    concreteVisitor2 v2 = new concreteVisitor2();
    
    o.accept(v1);
    o.accept(v2);
}
```

