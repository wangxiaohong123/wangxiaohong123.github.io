---
title: 行为型-备忘录模式
tags:
  - 设计模式
categories: 基础
copyright: true
---

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后可以将这个对象的状态回复到之前保存的状态。

![备忘录模式](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/备忘录模式.png)

```java
/**
 * 发起人类
 */
public class Originator {
    private String state;
    
    public void setState(String state) {
        this.state = state;
    }
    
    /**
     * 创建备忘录
     */
    public Memento createMemento() {
        return new Memento(this.state);
    }
    
    /**
     * 恢复备忘录
     */
    public void setMemento(Memento memento) {
        state = memento.state;
    }
    
    /**
     * 显示数据
     */
    public void show() {
        System.out.prientln("state=" + state);
    }
}

/**
 * 备忘录类
 */
public class Memento {
    private String state;
    
    public Memento(String state) {
        this.state = state;
    }
    
    public String getState() {
        return this.state;
    }
}

/**
 * 管理备忘录的类
 */
public class Creataker {
    private Memento memento;
    
    public void setMemento(Memento memento) {
        this.memento = memento;
    }
    
    public Memento getMemento() {
        return this.memento;
    }
}

/**
 * 客户端
 */
public static void main(String[] args) {
    Originator o new Originator();
    // Originator的初始状态
    o.setState("on");
    o.show();

    // 保存备忘录
    Creataker c = new Creataker();
    c.setMemento(o.createMemento());

    // Originator状态改变
    o.setState("off");
    o.show();

    // 恢复备忘录
    o.setMemento(c.getMemento());
    o.show();
}
```

当角色状态改变的时候有可能状态无效，这个时候需要把当前状态暂存起来，如果无效的话使用备忘录还原，感觉没啥用。
