---
title: 创建型-原型模式
tags:
  - 设计模式
categories: 基础
copyright: true
---

原型模式就是从一个对象创建另一个可定制的对象，而且不需要知道创建的细节。

*   如果只是申请内存然后再给变量赋值，使用clone的方法提升的性能是可以忽略不计的，但是我觉得如果这种操作很多，比如循环一万次，每次都要创建一个新的实例，这时候可以使用原型模式；
*   当创建对象的操作比较复杂的时候，比如需要操作数据库、文件、计算hash值等等，这时候使用拷贝的对象就比较快了；

实现原型模式的类要继承Cloneable接口，并重写clone方法，因为继承这个接口也不具备复制对象的能力，需要在重写的clone中调用super.clone()：

```java
class Student implements Cloneable {
    private String name;
    private Date birth;
    public String getName(){
        return name;
    }
    public void setName(String name){
        this.name= name;
    }
    public Date getBirth() {
        return birth;
    }
    public void setBirth(Date birth) {
        this.birth = birth;
    }
    /**
     * 重写clone方法
     * @return
     */
    @Override
    public Student clone(){
        Student student = null;
        try{
            // 调用Object的clone方法
            student = (Student) super.clone();
            student.birth = (Date) student.birth.clone();
        }catch(CloneNotSupportedException e){
            e.printStackTrace();
        }
        return student;
    }
}
```

使用时直接调用Student的clone方法：

```java
Student student = new Student();
for(int i=0; i< 10; i++){
    Student student1 = student.clone();
}
```

这样就会得到成员变量的值和student相同的新对象，但是对于其他对象的引用或者List等集合还是使用同一个引用，这就是一种浅拷贝，所以在重写的clone方法中其他对象的引用或者List等集合要单独进行拷贝。在Spring中bean默认都是单例的，我们可以使用@Scope(“prototype”)让bean的创建变成原型模式，每次使用都会复制一个新的bean。

简单的原型模式只是浅克隆，当实体中有引用类型的时候克隆的还是引用类型的地址，所以要在重写的clone()方法中单独设置clone出来的类的引用属性，例如上面的birth属性，需要单独在调用一次clone()方法。这是最简单的深克隆，正常来说深克隆有两种办法，第一种是递归克隆，直到克隆的对象都是基础数据类型；第二种是先序列化在反序列化：

```java
/**
 * 序列化加反序列化实现克隆
 */
public Object deepCopy(Object object) {
    ByteArrayOutputStream bo = new ByteArrayOutputStream();
    ObjectOutputStream oo = new ObjectOutputStream(bo);
    oo.writeObject(object);
    ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
    ObjectInputStream oi = new ObjectInputStream(bi);
    return oi.readObject();
}
```

