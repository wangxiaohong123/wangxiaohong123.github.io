---
title: 创建型-单例模式
tags:
  - 设计模式
categories: 基础
copyright: true
---

什么时候用单例？

比如配置文件这种，存在一份就够了，每次使用都创建实例的话就会浪费资源；

或者一个操作文件的类，每次都创建一个实例去写文件在高并发的场景很可能会相互覆盖；

第二种情况使用分布式锁或者将写操作放到队列中排队消费，但是都很复杂，这些情况都可以使用单例很容易的解决。

我们实现的单例都是类加载器级别的单例，他的作用域介于线程和进程之间，因为java中确定类的唯一是通过类全名+类加载器实例。

#### 饿汉单例

```java
/**
 * 饿汉是第二简单的实现方法，由于Singleton实例在类加载的时候就已经创建好了，所以是线程安全的
 * 缺点就是不支持延迟加载
 * 如果类的初始化耗时长还是应该使用这种方法，在用到的时候再去创建反倒会影响系统性能
 * @author xiaohong
 */
public class Singleton {

    private Singleton() {}

    private static final Singleton instance = new Singleton();

    public static Singleton getInstance() {
        return instance;
    }
}
```

#### 懒汉单例

```java
/**
 * 懒汉单例也比较简单，并且可以支持延迟加载
 * 但是getInstance()方法上有一把锁，这让这个函数的操作都会变成串行，在高并发的时候非常影响性能
 * @author xiaohong
 */
public class Singleton {

    private Singleton(){}

    private static Singleton instance;

    public static synchronized Singleton getInstance() {
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
```

#### 双重检查

```java
/**
 * 双重检查就是更细粒度的锁，提升了一点性能
 * 网上有人说这种写法会发生指令重排，然后在创建完实例还没初始化（调用构造函数）的时候就会被别的线程使用了，需要加上volatile关键字禁止指令重排
 * 其实在高版本java中已经解决了这个问题，在java中把new的操作和初始化的操作设计成立原子操作，不存在编译优化问题
 * @author xiaohong
 */
public class Singleton {

    private Singleton(){}

    private static Singleton instance;

    public static Singleton getInstance() {
        if(instance == null){
            synchronized(Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

#### 静态内部类

```java
/**
 * 主流的单例模式创建方法
 * 由内部类实现，instance的唯一和线程安全都有jvm保证，还支持延迟加载
 * @author xiaohong
 */
public class Singleton {

    private Singleton(){}

    private static class SingletonHolder {
        private static Singleton instance = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }
}
```

#### 枚举类

查看JAD反编译之后的文件感觉枚举的单例和饿汉模式很像

```java
/**
 * 最简单的单例
 * 调用直接用SingletonEnum.INSTANCE.doSomething()
 * @author xiaohong
 */
public enum SingletonEnum {
    INSTANCE;
    public Object doSomething() {}
}
```

### 问题

*   单例模式对面向对象特性支持非常不友好，所以有些人叫他反模式。比如有一个id生成器使用单例实现，如果以后想要根据不同业务使用不同id生成规则，这时候要修改所有调用生成id的方法；
*   扩展性差；
*   不容易测试；
*   不支持有参数的构造函数；