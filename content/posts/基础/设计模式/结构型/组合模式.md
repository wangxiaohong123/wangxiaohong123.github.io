---
title: 结构型-组合模式
tags:
  - 设计模式
categories: 基础
copyright: true
---

组合模式就是将对象组合成属性结构展示，让客户端对单个对象和组合对象的使用具有一致性。

![组合模式](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/组合模式.png)

```java
public abstract class Component {
    protected String name;
    
    public Component(String name) {
        this.name = name;
    }
    
    public abstract void add(Component c);
    public abstract void remove(Component c);
    public abstract void display(int depth);
}

/**
 * 组合中没有子节点的分支
 */
public class Leaf extends Component {
    public Leaf(String name) {
        super(name);
    }
    
    @Override
    public void add(Component c) {
        System.out.println("当前节点不支持添加");
    }
    
    @Override
    public void remove(Component c) {
        System.out.println("当前节点不支持删除");
    }
    
    @Override
    public void display(int depth) {
        // 叶节点的具体方法
        System.out.println(this.name + "-" + depth);
    }
}

/**
 * 组合中有子节点的分支
 */
public class Composite extends Component {
    
    private List<Component> children;
    
    public Leaf(String name) {
        super(name);
        children = new LinkedList<>();
    }
    
    @Override
    public void add(Component c) {
        children.add(c);
    }
    
    @Override
    public void remove(Component c) {
        children.remove(c);
    }
    
    @Override
    public void display(int depth) {
        // 叶节点的具体方法
        System.out.println(this.name + "-" + depth);
        for (Component child : children) {
            child.display(depth + 1);
        }
    }
}

/**
 * 客户端
 */
public static void main(String[] args) {
    Composite root = new Composite("root");
    root.add(new Leaf("leaf a"));
    root.add(new Leaf("leaf b"));
    
    Composite compX = new Composite("compX");
    compX.add(new Leaf("compX a"));
    compX.add(new Leaf("compX b"));
    root.add(compX);
    
    Composite compY = new Composite("compY");
    compY.add(new Leaf("compY a"));
    compY.add(new Leaf("compY b"));
    root.add(compY);
    
    root.display(1);
}
```

数可以有无数分支，只需要反复使用Composite就可以实现，上面的Component把所有管理子节点的方法全部声明成抽象的，让子类必须实现，这样叶节点和枝节点堆外没有区别，具有一致的行为，叫做透明方式，这样有个缺点就是叶节点实现了没有意义的接口。

和他对应的是安全方式，把一些叶节点没有的行为比如说添加和删除子节点变成方法，声明Composite时去判断是否需要重写添加和删除方法，这样就多了一步判断操作。