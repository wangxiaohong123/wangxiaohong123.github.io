---
title: 结构型-装饰器模式
tags:
  - 设计模式
categories: 基础
copyright: true
---

类图：
![装饰器模式](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/装饰器模式.png)

当系统需要新功能的时候如果还像主类中添加代码会增加主类的复杂度并且容易出问题，装饰器模式是说把每个需要装饰的功能放到一个单独的类中，让这个类包装他所装饰的对象，当需要执行这个装饰的功能的时候，调用方可以有选择的、自定义顺序的执行装饰功能。他和代理模式差不多他也可以对已有功能进行增强。java的好多IO类或者spring的aop都是这个模式。

```java
public class Demo {

    public abstract class Component {
        public abstract void operation();
    }

    public class ConcreteComponent extends Component {
        @Override
        public void operation() {
            System.out.println("具体的对象操作");
        }
    }

    public abstract class Decorator extends Component {

        protected Component component;

        public void setComponent(Component component) {
            this.component = component;
        }

        @Override
        public void operation() {
            component.operation();
        }
    }
    
    public class ConcreteDecoratorA extends Decorator {
        
        // 装饰对象A独有的属性
        private String addedState;
        
        @Override
        public void operation() {
            // 先执行Component的operation()，在执行装饰对象A的增强操作
            super.operation();
            this.addedState = "1111";
            System.out.println("具体装饰对象A的操作");
        }
    }

    public class ConcreteDecoratorB extends Decorator {

        @Override
        public void operation() {
            // 先执行Component的operation()，在执行装饰对象B的增强操作
            super.operation();
            this.addBehavior();
            System.out.println("具体装饰对象B的操作");
        }

        // 装饰对象B独有的增强操作
        private void addBehavior() {}
    }
    
    public static void main(string[] args) {
        Component c = new ConcreteComponent();
        ConcreteDecoratorA da = new ConcreteDecoratorA();
        ConcreteDecoratorB db = new ConcreteDecoratorB();
        da.setComponent(c);
        db.setComponent(da);

        db.operation();
    }
}
```

通过具体的装饰类之间的注入决定了装饰类的执行顺序。

