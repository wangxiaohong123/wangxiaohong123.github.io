---
title: ConcurrentLinkedQueue
tags:
  - java源码
  - 并发
categories: 基础
copyright: true
---



concurrentLinkedQueue是线程安全的无界队列，里面有两个指针，head和tail，还有一个单向链表Node。

offer()，看这个代码能看出来链表中只有一个元素的时候，tail指向是null的。

```java
public boolean offer(E e) {
    // 如果是空就抛出异常
    checkNotNull(e);
    final Node<E> newNode = new Node<E>(e);

    for (Node<E> t = tail, p = t;;) {
        Node<E> q = p.next;
        // 如果tail的next是空，就把tail的next指向newNode
        if (q == null) {
            // cas写，如果写失败了还会在进循环
            if (p.casNext(null, newNode)) {
                if (p != t)
                    casTail(t, newNode);
                return true;
            }
            // Lost CAS race to another thread; re-read next
        }
        else if (p == q)
            p = (t != (t = tail)) ? t : head;
        // tail有值的时候会走到这里，移动p的指针，然后继续走循环，就会走到第一个if中
        else
            p = (p != t && t != (t = tail)) ? t : q;
    }
}
```

poll

```java
public E poll() {
    restartFromHead:
    for (;;) {
        // 链表的头结点是null
        for (Node<E> h = head, p = h, q;;) {
            E item = p.item;
			// 所以第一次循环不会走到这
            // 使用cas把第一个节点的item设置成null
            if (item != null && p.casItem(item, null)) {
                // 删除完了移动头结点
                if (p != h) // hop two nodes at a time
                    updateHead(h, ((q = p.next) != null) ? q : p);
                return item;
            }
            else if ((q = p.next) == null) {
                updateHead(h, p);
                return null;
            }
            else if (p == q)
                continue restartFromHead;
            // 到这步完成了p和q的向后移
            else
                p = q;
        }
    }
}
```

