---
title: LinkedBlockingQueue
tags:
  - java源码
  - 并发
categories: 基础
copyright: true
---

一个有界队列，初始化的时候如果传capacity就会设置成参数大小，如果没有就设置成int的最大值。他有两把可重入锁，一个putLock，一个takeLock，这两个lock还对应着两个condition，为什么叫阻塞队列呢？因为当put的时候，如果链表的大小等于capacity，会把线程放到锁的wait队列中去，这样不就是阻塞的了吗。take也是一样的，capacity是0的时候就会阻塞住。

put

```java
public void put(E e) throws InterruptedException {
    if (e == null) throw new NullPointerException();
    // Note: convention in all put/take/etc is to preset local var
    // holding count negative to indicate failure unless set.
    int c = -1;
    Node<E> node = new Node<E>(e);
    final ReentrantLock putLock = this.putLock;
    // count就是链表的节点数量，使用AtomicInteger保证并发安全
    final AtomicInteger count = this.count;
    // 加锁，lockInterruptibly在加锁成功之前是可以被中断的
    putLock.lockInterruptibly();
    try {
        while (count.get() == capacity) {
            notFull.await();
        }
        // 入队，就是修改一下last的指针
        enqueue(node);
        // 节点数量增加
        c = count.getAndIncrement();
        if (c + 1 < capacity)
            // 唤醒等待put的线程
            notFull.signal();
    } finally {
        putLock.unlock();
    }
    // 在这里应该是添加加成功了的，
    // 因为数量自增使用的getAndIncrement，所以当链表中没有元素，然后添加第一个元素走到这里
    // 此时count是1，c是0，也是就是put之前，在这里判断，如果put之前链表没有元素，name可能有线程take被阻塞了
    // 所以唤醒take的wait线程
    if (c == 0)
        signalNotEmpty();
}
```

他的Iterator的next和remove是把putLock和takeLock都锁上。

***

ArrayBlockingQueue

ArrayBlockingQueue只有一把锁，他定义了一个putIndex、takeIndex和一个count，count是数组中元素的数量，putIndex是应该插入的位置，takeIndex是出队元素的位置也就是说，他不会移动元素，而是通过putIndex、takeIndex指针来确定下一个出队的元素和插入元素的索引，如果数组的最后一个index插入了元素，putIndex就会变成0。如果count等于数组大小，会调用notFull.await()，如果count等于0，notEmpty.await()。他和LinkedBlockingQueue的区别是，LinkedBlockingQueue的size()不会加锁，是通过colatile的AtomicInteger实现，所以ArrayBlockingQueue更准确。

