---
title: CopyOnWriteArrayList
tags:
  - java源码
  - 并发
categories: 基础
copyright: true
---



底层还是一个数组，被volatile修饰了，这样可以保证多线程读写的可见性。

add()

```java
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    // 可重入锁进行加锁
    lock.lock();
    try {
        Object[] elements = getArray();
        // 获取长度
        int len = elements.length;
        // 把底层的数组复制到新数组，同时长度增加1
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        // 设置新元素
        newElements[len] = e;
        // 赋值数组
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
```

set和add一样的。

remove

```java
public E remove(int index) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        // 获取要删除的元素
        E oldValue = get(elements, index);
        // 索引之后有多少元素
        int numMoved = len - index - 1;
        // numMoved是0的话就说明删除的是最后一个元素，这时候直接把剩余的元素复制到新数组就好了
        if (numMoved == 0)
            setArray(Arrays.copyOf(elements, len - 1));
        else {
            Object[] newElements = new Object[len - 1];
            // 把删除的索引之前的元素复制到新数组
            System.arraycopy(elements, 0, newElements, 0, index);
            // 把删除的索引之后的元素赋值到新数组
            System.arraycopy(elements, index + 1, newElements, index, numMoved);
            setArray(newElements);
        }
        return oldValue;
    } finally {
        lock.unlock();
    }
}
```

为什么要在复制出来的进行增删改？

为了解决并发问题，在修改数据的时候肯定要加锁，这样的好处是读没有锁，但是可能读到脏数据，写操作在并发时会阻塞，使用弱一致性提高读并发，但是比较耗内存。

在迭代的时候也是使用一个叫snapshot的指针指向就数组，这样就算执行写操作，原来的数组指针会指向新数组，但是迭代器的指针指向的还是旧数组。