---
title: AQS
tags:
  - java源码
  - 并发
categories: 基础
copyright: true
---

### 谈谈对AQS的理解

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gib4srczezj30iu08uaae.jpg" style="zoom:150%;" />

***

### ReentrantLock

全局有一个sync实例，这是一个内部类，继承了AbstractQueuedSynchronizer，加锁和释放锁都是基于sync实现的。AQS中定义了一个node，这是自己实现的双向链表，当做队列使用，还有一个state，记录加锁的次数。Sync有两个实现类，一个NonfairSync，一个FairSync，就是公平锁和非公平锁，他俩就是重写了加锁和释放锁的逻辑。Node中定义挺多东西的

```java
// 一些状态，共享锁、排它锁
static final Node SHARED = new Node();
static final Node EXCLUSIVE = null;

static final int CANCELLED =  1;
static final int SIGNAL    = -1;
static final int CONDITION = -2;
static final int PROPAGATE = -3;
volatile int waitStatus;

// 前一个线程
volatile Node prev;
// 后一个线程
volatile Node next;
// 当前线程
volatile Thread thread;
// 如果是排它锁，nextWaiter就是null，否则就是Node
Node nextWaiter;
```

非公平锁的加锁

```java
final void lock() {
    // 使用CAS判断一下state是不是0，如果是0就赋值成1
    // 调用的是AbstractQueueSynchronizer的方法，compareAndSetState方法中直接调用unSafe类操作stateOffect
    // stateOffect就是state：stateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField("state"));
    if (compareAndSetState(0, 1))
        // 设置加锁的线程是自己
        // 调用的是AbstractOwnableSynchronizer中的方法，这个类是AQS的父类
        // 保存的一个Thread变量，直接赋值
        setExclusiveOwnerThread(Thread.currentThread());
    else
        // 如果state不是0，就尝试reentrantLock
        acquire(1);
}

public final void acquire(int arg) {
    // tryAcquire会走到Sync的nonfairTryAcquire里
    // 这里取了个反，实在加锁失败的时候执行acquireQueued方法
    if (!tryAcquire(arg) &&
        // 线程入队，会使用LockSupport.park(this);把线程挂起
        // addWaiter是吧线程加到队列中
        // acquireQueued挂起线程
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

final boolean nonfairTryAcquire(int acquires) {
    // 获取当前线程
    final Thread current = Thread.currentThread();
    // 获取state
    int c = getState();
    // 0的话就尝试设置线程
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    // 如果线程是一样的
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        // 重入的次数超过整数最大值
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        // 设置新的state
        setState(nextc);
        return true;
    }
    return false;
}
```

公平锁的代码就是acquire(1)。在tryAcquire()中判断队列中有没有线程在等待。

释放锁

```java
public final boolean release(int arg) {
    // 判断state - 1是不是0了，如果不是0，就不是完全释放锁
    if (tryRelease(arg)) {
        Node h = head;
        // 判断队列有没有东西了
        if (h != null && h.waitStatus != 0)
            // 唤醒队头的元素
            // LockSupport.unpark(s.thread);
            unparkSuccessor(h);
        return true;
    }
    return false;
}
// 在unPark成功后会继续运行acquireQueued方法，他里面是一个for(;;)循环，会让下个线程持有锁了
```

这能看出来非公平不会让队列的线程去抢锁，而是无法控制在释放锁的一瞬间会被突然进来的线程抢占锁。

***

### 读写锁

在ReentrantReadWriteLock中持有一个WriteLock和ReadLock和Sync。读写锁中使用state的高16位代表读锁，低16位代表写锁。

写锁

```java
// 写锁也是走acquire()
// tryAcquire会走到ReentrantReadWriteLock中
protected final boolean tryAcquire(int acquires) {
    Thread current = Thread.currentThread();
    int c = getState();
    // 获取低16位
    int w = exclusiveCount(c);
    if (c != 0) {
        // 如果c不是0，w是0，说明有线程加读锁
        // 如果加锁的线程不是这个线程就返回false
        // 最多只能有一个写锁
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;
        if (w + exclusiveCount(acquires) > MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
        // Reentrant acquire
        setState(c + acquires);
        return true;
    }
    // 如果是非公平锁，直接加锁，如果是公平锁，如果队列中有线程排队就不加锁
    if (writerShouldBlock() ||
        !compareAndSetState(c, c + acquires))
        return false;
    setExclusiveOwnerThread(current);
    return true;
}
// 再往后走代码就和可重入锁一样了
```

读锁

```java
protected final int tryAcquireShared(int unused) {
    Thread current = Thread.currentThread();
    int c = getState();
    // exclusiveCount(c)不等于0说明有人加写锁
    // 如果加锁的线程不是自己就不能加锁
    if (exclusiveCount(c) != 0 &&
        getExclusiveOwnerThread() != current)
        return -1;
    // 获取高16位
    int r = sharedCount(c);
    if (!readerShouldBlock() && r < MAX_COUNT
        // 尝试修改高16位的值
        && compareAndSetState(c, c + SHARED_UNIT)) {
        if (r == 0) {
            firstReader = current;
            firstReaderHoldCount = 1;
        } else if (firstReader == current) {
            firstReaderHoldCount++;
        } else {
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != getThreadId(current))
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0)
                readHolds.set(rh);
            rh.count++;
        }
        return 1;
    }
    // 加读锁失败进入死循环CAS
    return fullTryAcquireShared(current);
}
```

释放锁和可重入锁差不多，只不过是state减1的时候读和写分开。

await

```java
public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    // 把node标记成condition
    Node node = addConditionWaiter();
    // 释放锁
    int savedState = fullyRelease(node);
    int interruptMode = 0;
    while (!isOnSyncQueue(node)) {
        // 挂起
        LockSupport.park(this);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}
```

signal

```java
private void doSignal(Node first) {
    do {
        // 判断等待队列有没有
        if ( (firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        first.nextWaiter = null;
        // transferForSignal是把node状态赋值成0
        // 这里会唤醒condition队列头部的线程，放到等待队列中
    } while (!transferForSignal(first) &&
             (first = firstWaiter) != null);
}
```

***

### CountDownLatch

await方法

```java
public final void acquireSharedInterruptibly(int arg)
    throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    // 判断state是不是0
    if (tryAcquireShared(arg) < 0)
        // 不是0就把线程加到等待队列里
        // park线程
        doAcquireSharedInterruptibly(arg);
}
```

countDown操作就是把state-1，然后把await的线程唤醒。

***

### CyclicBarrier

他和AQS没有直接关系，但是内部使用ReentrantLock实现的。

await方法

```java
private int dowait(boolean timed, long nanos)
    throws InterruptedException, BrokenBarrierException, TimeoutException {
    final ReentrantLock lock = this.lock;
    // 可重入锁
    lock.lock();
    try {
        final Generation g = generation;
		// 实例化CyclicBarrier传的线程数量
        int index = --count;
        // 最后一个线程执行完
        if (index == 0) {  // tripped
            boolean ranAction = false;
            try {
                final Runnable command = barrierCommand;
                if (command != null)
                    // 执行runnable的run方法，所以我们传进来的Runnable不是以线程方式执行的
                    command.run();
                ranAction = true;
                // 这里会把count恢复成我们设置的数值，再把所有线程唤醒
                nextGeneration();
                return 0;
            } finally {
                if (!ranAction)
                    breakBarrier();
            }
        }

        for (;;) {
            try {
                if (!timed)
                    // trip是lock的condition，把这个线程放到AQS的wait队列
                    trip.await();
                else if (nanos > 0L)
                    nanos = trip.awaitNanos(nanos);
            } catch (InterruptedException ie) {
                if (g == generation && ! g.broken) {
                    breakBarrier();
                    throw ie;
                } else {
                    Thread.currentThread().interrupt();
                }
            }
            if (g.broken)
                throw new BrokenBarrierException();
            if (g != generation)
                return index;
            if (timed && nanos <= 0L) {
                breakBarrier();
                throw new TimeoutException();
            }
        }
    } finally {
        lock.unlock();
    }
}
```

