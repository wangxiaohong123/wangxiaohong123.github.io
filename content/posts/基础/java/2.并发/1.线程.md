---
title: 线程
tags:
  - java
  - 并发
categories: 基础
copyright: true
---

*   工作线程：main方法就是一个线程，在main线程中在启动一个线程，线程中是一个死循环，比如定时发送心跳，这时候就算main执行完成，jvm也不会退出，因为有一个非后台的工作线程在一直运行。
*   daemon线程：非工作线程就是daemon线程，如果说所有的工作线程都停止了，daemon线程会跟着jvm一起退出了。使用**setDaemon(true)**将工作线程设置成daemon线程，什么时候需要设置成daemon线程呢？比如说有一个后台的监控线程，在工作线程都结束之后，后台的监控也没用了，jvm就可以退出了，不让监控线程影响jvm的退出就要把监控线程设置成daemon线程。
*   ThreadGroup：线程是有父子概念的，比如在main中创建一个线程，那main就是创建线程的父线程，如果没指明线程组，会被分配到父线程所在的线程组中。main线程的名字就是main，平时创建的线程可以使用**setName("ServiceAliveMonitor")**设置线程名。手动创建线程组

```java
// 创建一个线程组
ThreadGroup daemonThreadGroup = new ThreadGroup("daemon");
// daemon是我自己创建的线程，在线程中的构造方法中调用super(ThreadGroup, ThreadName)就可以分配线程组了
this.daemon = new Daemon(daemonThreadGroup, "ServiceAliveMonitor");
```

*   线程优先级:**setPriority(8)**，理论上来说数越大越会CPU更多的执行，默认是5。
*   Thread.yield()：告诉CPU说不执行这个线程了，暂停。
*   join()就是要等待这个线程执行完才能往下走。
*   Interrupt：打断一个线程，就是修改线程里的interrupt标志位，线程中可以通过isInterrupted()来感知到被打断，在决定是否继续运行，还可以打断一个线程的休眠。

```java
Thread thread = new Thread() {
    @Override
    public void run() {
        while (!isInterrupted()) {
            System.out.println("线程1执行在工作");
        }
    }
};
thread.start();
TimeUnit.MILLISECONDS.sleep(200);
// interrupt并不会停止线程，只是修改一下标志位
// 要在线程中判断被打断了以后怎么操作
thread.interrupt();

/**
 * 唤醒睡眠的线程
 */
public static void main(String[] args) throws Exception {
    MyThread thread = new MyThread();
    thread.start();
	// 让线程执行一会
    Thread.sleep(1000);
	// 修改线程的while条件
    thread.setShouldRun(false);
	// 然后在唤醒，这样的话线程被唤醒就退出了
    thread.interrupt();
}

private static class MyThread extends Thread {
    private boolean shouldRun = true;

    @Override
    public void run() {
        while (shouldRun) {
            try {
                System.out.println("线程1执行在工作");
                Thread.sleep(30 * 1000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    public void setShouldRun(boolean shouldRun) {
        this.shouldRun = shouldRun;
    }
}
```

