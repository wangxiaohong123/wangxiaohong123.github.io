---
title: 线程池
tags:
  - java源码
  - 并发
categories: 基础
copyright: true
---

四种线程池：

*   fixed：固定数量
*   cached：数量不固定，有新任务就创建线程，空闲的线程会回收
*   single：只有一个线程池
*   scheduled：在指定时间后执行提交的线程

***

fixed，fixed中并不会触发reject策略，和maximumPoolSize，因为他用的是无界队列。

```java
/**
 * Executors类的newFixedThreadPool方法
 * 虽然LinkedBlockingQueue是有界队列，但是声明线程池的时候没有设置capacity，相当于一个无界队列，容易OOM
 * 核心线程数和最大线程数是相同的，如果nThreads都在处理任务就会把任务压进队列中
 * 如果线程报错挂掉，会在创建一个新的线程来顶替
 * 线程空闲的时候不会被销毁，因为核心线程数就是最大线程数
 */
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}

/**
 * ThreadPoolExecutor类的构造方法
 * 他的父类实现了ExecutorService
 * 所以创建普通线程池一般都用ExecutorService来接收：
 * ExecutorService threadPool = Executors.newFixedThreadPool(10);
 */
public ThreadPoolExecutor(int corePoolSize, // 核心线程数
                          // 最大线程数
                          int maximumPoolSize,
                          // 多余线程的空闲存活时间
                          long keepAliveTime,
                          TimeUnit unit,
                          // 任务队列
                          BlockingQueue<Runnable> workQueue,
                          // 创建线程的工厂
                          ThreadFactory threadFactory,
                          // 线程数达到最大并且队列也满了之后在收到任务的拒绝策略
                          RejectedExecutionHandler handler) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.acc = System.getSecurityManager() == null ?
        null :
    AccessController.getContext();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}

// ThreadPoolExecutor中除了构造函数的参数，还有一些关键的参数

// 通过一个32位的二进制数，来表示线程状态和数量，
// 前3位是线程池的状态，后29为是数量，通过一些二进制计算来查询和修改
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

// 获取状态
private static int runStateOf(int c)     { return c & ~CAPACITY; }
// 获取线程数量
private static int workerCountOf(int c)  { return c & CAPACITY; }
// 设置线程数量和线程池状态
private static int ctlOf(int rs, int wc) { return rs | wc; }

/**
 * 提交线程的方法
 */
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    // 获取上面说得那个32位数字
    int c = ctl.get();
    // 如果线程数小于核心线程数就创建一个线程
    if (workerCountOf(c) < corePoolSize) {
        // addWorker传的true表示是核心线程
        // 使用cas增加核心线程数
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // 任务入队成功，使用的是offer，这个是非阻塞的，如果队列满了就返回false
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        // 下面的操作是双重检查
        // 如果线程池关闭了，删除任务，然后拒绝
        if (! isRunning(recheck) && remove(command))
            reject(command);
        // 如果线程数是0就创建线程
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 任务入队失败，说明核心线程数达到最大并且队列已经满了
    // 尝试创建新线程，直到线程达到最大线程数
    // 如果这个时候创建线程失败就走拒绝策略
    else if (!addWorker(command, false))
        // 拒绝策略
        reject(command);
}
```

关闭，关闭不会马上关闭有任务的线程，而是先关闭线程池，线程池状态是关闭时，不接受新任务，在线程把队列和自己的任务执行完之后while循环中的take（不是阻塞队列的take）就会返回null，线程就结束了。

```java
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        // 使用cas把线程池的状态设置成shutdown
        advanceRunState(SHUTDOWN);
        // 尝试将所有空闲的worker中断
        interruptIdleWorkers();
        // 回调勾子
        onShutdown();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
}

/**
 * 中断所有空闲的worker
 */
private void interruptIdleWorkers(boolean onlyOne) {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w : workers) {
            Thread t = w.thread;
            // 如果线程没被中断，并且解锁成功，因为加锁成功就是线程没执行任务
            if (!t.isInterrupted() && w.tryLock()) {
                try {
                    // 中断
                    t.interrupt();
                } catch (SecurityException ignore) {
                } finally {
                    w.unlock();
                }
            }
            if (onlyOne)
                break;
        }
    } finally {
        mainLock.unlock();
    }
}
```



***

cached，在使用的时候不需要指定线程数，非常适合短时间内大量涌入任务，过一段时间任务量变小或者没有。cached的线程池，不会触发创建核心线程的操作，也没有拒绝策略，因为maximumPoolSize无限大，如果在瞬间收到大量任务，可能会导致CPU负载过高。

```java
// 他的核心线程数是0，最大线程数是无线，有过期时间，队列使用的同步队列
return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());

/**
 * 提交线程的方法
 */
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    int c = ctl.get();
    // cached不会走这个，因为他没有核心线程
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // 在第一次提交任务的时候workQueue.offer会返回false
    // 这时候就会走里面的else if，创建一个非核心线程来执行任务
    // 因为使用的offer，入队成功后没线程take不会阻塞
    // 他就会在创建线程
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        // 拒绝策略
        reject(command);
}

// 非core线程在getTask中会判断超时
// 同时从队列中获取任务使用带超时的poll，等待超时时间还没获取到任务，就自动退出
// 这两个判断会让超时的非core线程超时就结束了
```

***

single就是corePoolSize和maximumPoolSize都是1的fixed 。

schedule用的就是DelayedWorkQueue的fixed。DelayedWorkQueue是ScheduledThreadPoolExecutor自己实现的Queue。

***

拒绝策略

*   CallerRunsPolicy：让提交任务的线程自己去执行
*   AbortPolicy：抛出异常（默认）；
*   DiscardPolicy：什么都不干；
*   DiscardOldestPolicy：把队头的元素出队，然后把这个入队；

RejectedExecutionHandler实现这个接口就可以自己定制。