---
title: ConcurrentHashMap
tags:
  - java源码
  - 并发
categories: 基础
copyright: true
---



1.8中使用了分段加锁，刚开始是CAS，hash冲突在使用synchronized

put

```java
// 计算hash值
int hash = spread(key.hashCode());
for (Node<K,V>[] tab = table;;) {

    // 如果是第一次添加，初始化数组，因为是死循环，这块直接退出了
    if (tab == null || (n = tab.length) == 0)
        tab = initTable();
    // 如果数组这个索引没有元素，使用乐观锁添加，只有一个线程能添加成功
    // 因为是死循环，所以多线程来添加，失败的线程会在进来重新添加
    else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
        if (casTabAt(tab, i, null,
                     new Node<K,V>(hash, key, value, null)))
            break;                   // no lock when adding to empty bin
    }
    else if ((fh = f.hash) == MOVED)
        tab = helpTransfer(tab, f);
    else {
        V oldVal = null;
        // 加锁，只锁数组当前索引的元素
        synchronized (f) {
            if (tabAt(tab, i) == f) {
                if (fh >= 0) {
                    binCount = 1;
                    // binCount是链表的节点数量
                    for (Node<K,V> e = f;; ++binCount) {
                        K ek;
                        // 判断key是否相同，相同就覆盖value
                        if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) {
                            oldVal = e.val;
                            if (!onlyIfAbsent)
                                e.val = value;
                            break;
                        }
                        Node<K,V> pred = e;
                        // 在链表后面追加
                        if ((e = e.next) == null) {
                            pred.next = new Node<K,V>(hash, key,
                                                      value, null);
                            break;
                        }
                    }
                }
                // 红黑树添加元素
                else if (f instanceof TreeBin) {
                    Node<K,V> p;
                    binCount = 2;
                    if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) {
                        oldVal = p.val;
                        if (!onlyIfAbsent)
                            p.val = value;
                    }
                }
            }
        }
        if (binCount != 0) {
            // 如果链表节点数量大于8，就转成红黑树
            if (binCount >= TREEIFY_THRESHOLD)
                treeifyBin(tab, i);
            if (oldVal != null)
                return oldVal;
            break;
        }
    }
}
// 在这里进行扩容
addCount(1L, binCount);
```

get的时候使用的UnSafe类的volatile读，volatile会加上Load内存屏障，这样会保证独到的是最新值。

size()也是被volatile修饰的，只能保证在读到数据的一瞬间是准确的。