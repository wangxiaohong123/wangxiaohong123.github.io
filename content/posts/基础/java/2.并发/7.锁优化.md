---
title: 锁优化
tags:
  - java源码
  - 并发
categories: 基础
copyright: true
---



如果只是修改标志位，一些线程读，尽量使用volatile。

如果大家都要写，就要判断一下，是不是只是数值的累加，如果是，使用Atomic类。

不需要多线程共享的数据，使用ThreadLocal。

读多写少的情况使用读写锁。

尽可能减少线程占用锁的时间，比如使用分段锁，在加锁的代码块里使用磁盘IO、网络IO。

还可以使用多级缓存减少读写锁的冲突。比如eureka的两级缓存readOnlyMap和readWriteMap，两级缓存是因为一级缓存的话和不加这个缓存没有区别，无法降低读写锁的冲突，两级缓存，一个负责读，一个负责写，可以大幅度减少读写锁冲突。

线程饥饿：非公平锁的情况下，高并发时，大量线程抢占锁，导致有的线程一直排队，抢不到锁，改成公平锁就好了。