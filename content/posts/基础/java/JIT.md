---
title: JIT
tags:
  - java源码
categories: 基础
copyright: true
---

一个java文件在被JVM加载之前需要通过JDK自带的javac工具编译成.class文件，但是机器不能运行java的字节文件，需要在运行时再次编译，将字节码转换成机器码，所以在运行时是使用Interpreter将.class文件边解释编执行。不直接编译成机器码是因为Java支持动态加载类，最主要的原因是使用.class文件解释执行可以跨平台。

为了优化执行速度，当虚拟机发现某个方法或者代码块执行的特别频繁，就认为这段代码是热点代码，JIT会对热点代码进行优化编译成机器码存到内存中。

### 即时编译器

在Java8，HotSpot内置两个JIT：

*   C1：客户端编译器，优化局部；
*   C2：服务端编译器，位长期运行的服务端做性能调优；

在java7之前需要指定JIT；在java8之后默认开启分层编译，如果想只开启C2可以使用参数-XX:-TieredCompilation，如果想只开启C1可以使用参数-XX:TieredStopAtLevel=1。

Java9引入了AOT编译器，在程序运行前编译，并且可以将.class文件编译成.so的二进制文件。

Java10，JIT编译器新增一个Graal，Graal可以实现运行时动态即时编译，也可以在执行前静态AOT编译。

#### 分层编译

*   第 0 层：程序解释执行，默认开启性能监控功能（Profiling），如果不开启，可触发第二层编译；
*   第 1 层：可称为 C1 编译，将字节码编译为本地代码，进行简单、可靠的优化，不开启 Profiling；
*   第 2 层：也称为 C1 编译，开启 Profiling，仅执行带方法调用次数和循环回边执行次数 profiling 的 C1 编译；
*   第 3 层：也称为 C1 编译，执行所有带 Profiling 的 C1 编译；
*   第 4 层：可称为 C2 编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。

### 热点探测

HotSpot中使用热点探测来做位JIT优化的条件，虚拟机为每个方法建立两个计数器，统计方法被调用次数，这两个技术区有一个达到阈值就会触发JIT编译：

1.  方法调用计数器：统计方法被调用次数；
2.  回边计数器：统计循环体代码的执行次数，字节码中遇到控制流向后跳转的指令成为回边，就是这次循环执行结束跳到开头执行下次循环；

### JIT优化技术

#### 方法内联

在调用别的方法的时候会记录信息，执行结束后再恢复，这样会浪费一些空间和时间，所以如果热点方法的代码不是很大会直接将热点方法内联到调用方法中，默认情况下方法体大小小于325字节都会内联优化，可以使用-XX:MaxFreqInlineSize=N设置大小值；

#### 逃逸分析

使用逃逸分析分析方法是否被外部方法或线程使用，根据结果进行优化。

*   栈上分配：逃逸分析如果发现对象只在方法中使用就会将对象分配在栈上（现在还没有这个优化）；
*   锁消除：如果不存在线程安全问题JIT编译时会把锁去掉；
*   标量替换：如果逃逸分析发现一个对象不能被外部访问，并且对象可被拆分，那么JIT可能不会创建这个对象，而是创建这个对象被拆分出来的变量，这样就不用在堆中创建对象，创建在栈或寄存器上；

```shell
# 开启逃逸分析（jdk1.8默认开启，其它版本未测试）
-XX:+DoEscapeAnalysis
# 关闭逃逸分析
-XX:-DoEscapeAnalysis
# 开启锁消除（jdk1.8默认开启，其它版本未测试）
-XX:+EliminateLocks
# 关闭锁消除
-XX:-EliminateLocks
# 开启标量替换（jdk1.8默认开启，其它版本未测试）
-XX:+EliminateAllocations
# 关闭标量替换
-XX:-EliminateAllocations
```

