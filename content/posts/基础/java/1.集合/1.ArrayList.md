---
title: ArrayList
tags:
  - java源码
  - 集合
categories: 基础
copyright: true
---

使用默认的构造函数，ArrayList会把数组的长度设置为10（DEFAULT_CAPACITY）。

插入数据很简单，首先判断是否需要扩容**ensureCapacityInternal()**，如果添加完元素的长度大于现在的长度就扩容成1.5倍。然后把数组赋值。

```java
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
```

```java
public void add(int index, E element) {
    // 判断是否数组越界
    rangeCheckForAdd(index);
	// 判断是否扩容
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    // 拷贝数组，向后移1位
    System.arraycopy(elementData, index, elementData, index + 1, size - index);
    // 设置最新值
    elementData[index] = element;
    // 数组大小加1
    size++;
}
```

```java
public E set(int index, E element) {
    // 判断是否数组越界
    rangeCheck(index);
	// 获取index位置的元素的值
    E oldValue = elementData(index);
    // 设置index为新值
    elementData[index] = element;
    return oldValue;
}
```

set不是把元素往后挤，而是替换。

***

get是最简单的

```java
public E get(int index) {
    // 检查数组越界
    rangeCheck(index);
	// 返回元素
    return elementData(index);
}
```

***

```java
public E remove(int index) {
    // 判断数组越界
    rangeCheck(index);

    modCount++;
    // 获取旧元素
    E oldValue = elementData(index);
	// 计算需要移动的元素
    int numMoved = size - index - 1;
    if (numMoved > 0)
        // 拷贝数组
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    // 把最后一位设置成空，因为删除元素了嘛，最后一位是多余的
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}
```

***

扩容，主要是调用两个方法

```java
private void ensureCapacityInternal(int minCapacity) {
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
}

// calculateCapacity主要是判断elementData是不是默认的数组，如果是的话就返回minCapacity和默认大小的最大值
private static int calculateCapacity(Object[] elementData, int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    return minCapacity;
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // 判断是不是需要扩容
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    // 新容量 = 旧容量 + (旧容量 / 2)；
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    // newCapacity = newCapacity和minCapacity的最大值
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    // 超过MAX_ARRAY_SIZE大小直接变成Integer.MAX_VALUE
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // 拷贝数组
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

