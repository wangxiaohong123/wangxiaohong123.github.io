---
title: LinkedList
tags:
  - java源码
  - 集合
categories: 基础
copyright: true
---

核心node，基于前后指针的双向链表：

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

***

添加

add和addLast都是调用的linkLast()

```java
public boolean add(E e) {
    linkLast(e);
    return true;
}
```

```java
void linkLast(E e) {
    final Node<E> l = last;
    // 创建一个新元素，后指针是null
    final Node<E> newNode = new Node<>(l, e, null);
    // 把新创建的node赋值给last
    last = newNode;
    // 如果原来LinkedList是空，就把first设置声新节点
    if (l == null)
        first = newNode;
    // 否则，把原来的尾节点的next指针指向新node
    else
        l.next = newNode;
    size++;
    modCount++;
}
```

在头部添加

```java
private void linkFirst(E e) {
    final Node<E> f = first;
    // 创建一个新元素，前指针是null
    final Node<E> newNode = new Node<>(null, e, f);
    first = newNode;
    // 如果原来LinkedList是空，就把last设置成新节点
    if (f == null)
        last = newNode;
    // 否则，把原来的头结点的next指针指向新node
    else
        f.prev = newNode;
    size++;
    modCount++;
}
```

在指定索引出添加元素

```java
public void add(int index, E element) {
    // 判断index是否有效（0 <=index <= size），无效的话就抛出越界异常
    checkPositionIndex(index);

    // 如果index等于size，执行尾部添加
    if (index == size)
        linkLast(element);
    else
        // 先找到节点【node(index)】，然后插入
        linkBefore(element, node(index));
}

// 找到节点的方法并不是顺序遍历
Node<E> node(int index) {
    // assert isElementIndex(index);
	// 如果目标node在前半段就从头遍历
    if (index < (size >> 1)) {
        Node<E> x = first;
        for (int i = 0; i < index; i++)
            x = x.next;
        return x;
    } else { // 否则从后遍历
        Node<E> x = last;
        for (int i = size - 1; i > index; i--)
            x = x.prev;
        return x;
    }
}
// 插入节点就是正常修改指针指向就完事了
void linkBefore(E e, Node<E> succ) {
    // assert succ != null;
    final Node<E> pred = succ.prev;
    final Node<E> newNode = new Node<>(pred, e, succ);
    succ.prev = newNode;
    if (pred == null)
        first = newNode;
    else
        pred.next = newNode;
    size++;
    modCount++;
}
```



***

获取元素：

getFirst()和getLast还有peek()，都是返回first或者last变量，getFirst如果没有元素会报错，peek如果没有元素会返回null。

get方法

```java
public E get(int index) {
    // 检查索引（0 <=index <= size）
    checkElementIndex(index);
    // 调用node
    return node(index).item;
}
```



***

删除元素

removeLast()

```java
public E removeLast() {
    // 判断是否有最后一个元素
    final Node<E> l = last;
    if (l == null)
        throw new NoSuchElementException();
    // 删除最后一个元素
    return unlinkLast(l);
}

/**
 * 其实就是修改最后一个元素的next指针指向
 * 但是他把原来的最后一个节点中的指针都设置成了null
 * 这样可以在gc的时候回收掉
 */
private E unlinkLast(Node<E> l) {
    // assert l == last && l != null;
    final E element = l.item;
    final Node<E> prev = l.prev;
    l.item = null;
    l.prev = null; // help GC
    last = prev;
    if (prev == null)
        first = null;
    else
        prev.next = null;
    size--;
    modCount++;
    return element;
}
```

removeFirst()

```java
public E removeFirst() {
    final Node<E> f = first;
    if (f == null)
        throw new NoSuchElementException();
    // 和removeLast一样的
    return unlinkFirst(f);
}
```

poll()也是调用的unlinkFirst()；

remove()，还是修改修改指针

```java
public E remove(int index) {
    checkElementIndex(index);
    // 通过node找到节点在调用unlink方法
    return unlink(node(index));
}

E unlink(Node<E> x) {
    // assert x != null;
    final E element = x.item;
    final Node<E> next = x.next;
    final Node<E> prev = x.prev;
	// 删除的是头结点
    if (prev == null) {
        first = next;
    } else {
        prev.next = next;
        x.prev = null;
    }
	// 删除的是为节点
    if (next == null) {
        last = prev;
    } else {
        next.prev = prev;
        x.next = null;
    }

    x.item = null;
    size--;
    modCount++;
    return element;
}
```



