---
title: 2.ApplicationListener没有写范型导致的两个问题
tags:
  - 线上问题
categories: 线上问题
copyright: true
---

最近在优化现有系统时发现一个服务总是启动失败，失败会报两种错：

1. 偶发性的BeanCurrentlyInCreationException；
2. 其他问题导致启动失败(比如缺少apollo配置)必定会跟随无限打印redis客户端关闭异常；

问题2比较好排查，跟随异常栈找到了一个定时任务初始化的类：

```java
public class TaskInitService implements ApplicationListener {
    private static AtomicBoolean isInit = new AtomicBoolean(false);
    private static final AtomicBoolean isSpringStartUp = new AtomicBoolean(false);

    @PostConstruct
    public void init() {
        if (!isInit.get()) {
            log.info("TaskInitService init start");
            lazyStart();
            log.info("TaskInitService init over");
            isInit.set(true);
        }
    }

    private void lazyStart() {
        Thread thread = new Thread(() -> {
            try {
                //  spring启动完成
                while (!isSpringStartUp.get()) {
                    Thread.sleep(3 * 1000);
                }
                // 启动定时任务代码……
            } catch (Exception e) {
                log.error("TaskInitService start error,{}", ExceptionUtils.getStackTrace(e));
            }
        });
        thread.start();
    }

    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        isSpringStartUp.set(true);
    }
}
```

上面的代码监听ApplicationListener事件，但是却没有指定事件，这就会导致isSpringStartUp变量的赋值在@PostConstruct方法之前，所以上面代码中的lazyStart()并没有lazy，定时任务也会在服务启动中就开始执行，由于定时任务是个没有终止条件的`while (true)`循环，当服务启动失败的时候循环不会退出，导致问题二，修改后的代码：

```java
public class TaskInitService implements ApplicationListener<ApplicationReadyEvent> {

    public void init() {
        // 启动定时任务代码……
    }

    @Override
    public void onApplicationEvent(@NotNull ApplicationReadyEvent event) {
        init();
    }
}
```

排查问题1的时候发现也和TaskInitService类有关系，并且BeanCurrentlyInCreationException指向的是一个feign接口，奇怪的是feign接口不会依赖其他bean，也就不可能产生循环依赖问题。

在查找fein接口创建的代码时发现FeignClientsRegistrar类中的下面代码：

```java
private void registerOptionsBeanDefinition(BeanDefinitionRegistry registry, String contextId) {
  if (isClientRefreshEnabled()) {
    String beanName = Request.Options.class.getCanonicalName() + "-" + contextId;
    BeanDefinitionBuilder definitionBuilder = BeanDefinitionBuilder
        .genericBeanDefinition(OptionsFactoryBean.class);
    // 这里
    definitionBuilder.setScope("refresh");
    definitionBuilder.addPropertyValue("contextId", contextId);
    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(definitionBuilder.getBeanDefinition(),
        beanName);
    definitionHolder = ScopedProxyUtils.createScopedProxy(definitionHolder, registry, true);
    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);
  }
}
```

**feign接口的scope是写死的refresh！**，不是单例scope就可以解释通了，再去确认一下创建bean的代码，找到了doGetBean()中的下面一段：

```java
if (mbd.isSingleton()) {
  sharedInstance = getSingleton(beanName, () -> {
    try {
      return createBean(beanName, mbd, args);
    }
    catch (BeansException ex) {
      destroySingleton(beanName);
      throw ex;
    }
  });
  beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
}

else if (mbd.isPrototype()) {
  // It's a prototype -> create a new instance.
  Object prototypeInstance = null;
  try {
    beforePrototypeCreation(beanName);
    prototypeInstance = createBean(beanName, mbd, args);
  }
  finally {
    afterPrototypeCreation(beanName);
  }
  beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
}

else {
  String scopeName = mbd.getScope();
  if (!StringUtils.hasLength(scopeName)) {
    throw new IllegalStateException("No scope name defined for bean ´" + beanName + "'");
  }
  Scope scope = this.scopes.get(scopeName);
  if (scope == null) {
    throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
  }
  try {
    Object scopedInstance = scope.get(beanName, () -> {
      beforePrototypeCreation(beanName);
      try {
        return createBean(beanName, mbd, args);
      }
      finally {
        afterPrototypeCreation(beanName);
      }
    });
    beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
  }
  catch (IllegalStateException ex) {
    throw new ScopeNotActiveException(beanName, scopeName, ex);
  }
}
```

beforePrototypeCreation()方法是向threadlocal中插入当前bean，表示正在被创建，当scope为非单例模式的时候都会有这步操作！

问题2的猜想加结论：

**由于服务启动过程中可能频繁触发配置更改(会导致scope("refresh")的feign接口频繁被标记成无效状态)+定时任务频繁使用scope("refresh")的feign接口，如果接口被标记成无效会重新创建，就可能导致创建时抛出BeanCurrentlyInCreationException异常**