---
title: 2.Redisson封装遇到的问题
tags:
  - 线上问题
categories: 线上问题
copyright: true
---

##### 背景

阿里云redis+各种redis相关依赖，乱的要死。

项目配置：

```yaml
spring:
	redis:
		cluster:
			nodes: 172.x x.xx.xx:6379
			timeout: 60000
			max-redirects: 5
		database: 1
		jedis:
			pool:
				max-active: 100
				max-idle: 10
				max-wait: 200
				min-idle: 1
				time-between-eviction-runs: 60000
```

redis相关依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
</dependency>
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson-spring-boot-starter</artifactId>
    <version>3.17.7</version>
</dependency>
```

其中spring-boot版本为2.5.3，jedis版本为3.6.3。

##### 问题1：wait命令

因为配置中使用了集群模式，所以我最开始redisson也配置了集群模式：

```java
ClusterServersConfig clusterServersConfig = config.useClusterServers()
  .addNodeAddress(this.redisProperties.getCluster().getNodes().stream()
      .map(node -> node.startsWith("redis://") ? node : "redis://" + node).toArray(String[]::new))
  .setMasterConnectionMinimumIdleSize(20);
```

然后在测试的时候发现了第一个坑`unknown command 'WAIT'`，原因有两个，因为阿里云的redis对开放的是代理，相当于是个单例，不支持WAIT命令，第二个原因是redisson高版本处理的WAIT命令的报错，低版本是没处理的。

![wait命令错误](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/wait命令错误.jpg)

所以我第一反应是降低redisson版本。

##### 问题2：版本兼容

我把redisson的版本修改成了3.13.6，此时执行zadd命令会进入死循环直到栈溢出：

![zadd死循环](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/zadd死循环.jpg)

只能先升回17版本，尝试修改redisson配置，因为WAIT命令是在等待从节点复制数据成功，所以我尝试修改从节点的连接池为0，并且只从主节点读取：

```java
ClusterServersConfig clusterServersConfig = config.useClusterServers()
        .addNodeAddress(this.redisProperties.getCluster().getNodes().stream()
                .map(node -> node.startsWith("redis://") ? node : "redis://" + node).toArray(String[]::new))
        .setConnectTimeout(10000)
        .setMasterConnectionMinimumIdleSize(20)
        .setSlaveConnectionMinimumIdleSize(0)
        .setSlaveConnectionPoolSize(0)
        .setReadMode(ReadMode.MASTER);

if (null != redisProperties.getPassword()) {
    clusterServersConfig.setPassword(redisProperties.getPassword());
}
```

到这里redisson的使用没有发现其他问题。

##### 问题3：jedis连接工厂配置

到这里redisson应该是可以正常使用的，但是由于同时引用了redisson和jedis依赖，此时redis的连接工厂使用的是redisson的：

![redissonConnection类型](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/redissonConnection类型.jpg)

因为Jedis和redisson的自定义工厂都继承了RedisConnectionFactory，猜测创建工厂时会有条件判断，在源码中验证猜想：
![jedis自动装配](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/jedis自动装配.jpg)

由于连接工厂中会保存jedis的连接池配置，redisson连接工厂也会持有redisson的相关配置：

![jedis配置](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/jedis配置.jpg)

所以进一步**猜测**项目配置的Jedis连接池信息是没有生效的，可以进一步验证一下，我这里选择直接增加Jedis的配置类，让他和redisson的连接工厂分开，配置类代码：

```java
@Configuration
public class CacheAutoConfiguration {

    @Resource
    private RedisProperties redisProperties;

    /**
     * 防止引入redisson jar后jedis的配置不生效
     * 不配置的的话jedis和redisson会共用RedissonConnectionFactory
     */
    @Bean
    @Primary
    public JedisConnectionFactory jedisConnectionFactory() {
        JedisPoolConfig config = new JedisPoolConfig();
        config.setMinIdle(redisProperties.getJedis().getPool().getMaxIdle());
        config.setMaxIdle(redisProperties.getJedis().getPool().getMinIdle());
        config.setMaxTotal(redisProperties.getJedis().getPool().getMaxActive());
        config.setMaxWaitMillis(redisProperties.getJedis().getPool().getMaxWait().toMillis());
        config.setTimeBetweenEvictionRunsMillis(redisProperties.getJedis().getPool().getTimeBetweenEvictionRuns().toMillis());

        // Configure client
        JedisClientConfiguration clientConfig = JedisClientConfiguration.builder()
                .usePooling()
                .poolConfig(config)
                .and()
//                .readTimeout(Duration.ofMillis(redisProperties.getTimeout().toMillis()))
                .build();

        RedisProperties.Cluster redisCluster = this.redisProperties.getCluster();
        if (null != redisCluster) {
            RedisClusterConfiguration clusterConfiguration = new RedisClusterConfiguration(redisProperties.getCluster().getNodes());
            clusterConfiguration.setMaxRedirects(redisProperties.getCluster().getMaxRedirects());
            if (null != redisProperties.getPassword()) {
                clusterConfiguration.setPassword(redisProperties.getPassword());
            }

            return new JedisConnectionFactory(clusterConfiguration, clientConfig);
        } else {
            RedisStandaloneConfiguration standaloneConfiguration = new RedisStandaloneConfiguration(redisProperties.getHost(), redisProperties.getPort());
            standaloneConfiguration.setPassword(RedisPassword.of(redisProperties.getPassword()));
            standaloneConfiguration.setDatabase(redisProperties.getDatabase());
            if (null != redisProperties.getPassword()) {
                standaloneConfiguration.setPassword(redisProperties.getPassword());
            }

            return new JedisConnectionFactory(standaloneConfiguration, clientConfig);
        }
    }
}
```

##### 问题4：Jedis集群模式

我以为分布式锁可以测试使用了，结果**Jedis的集群并不支持pipeline**。

解决的办法可以把Jedis换成Lettuce，不过Lettuce并不能自动检测宕机节点并重连，3年前我尝试过修改lettuce的这个问题，印象里遇到的其他的坑，所以并不打算把Jedis换成Lettuce；或者直接把redis的配置改成standalone。

总的来说如果使用阿里云的redis配置成standardalone根本不会出现上面的问题，没见过这样的垃圾代码。
