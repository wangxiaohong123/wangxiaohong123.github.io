---
title: 面试-3.网络
tags:
  - 面试专题
categories: 面试专题
copyright: true
---

##### 1.通过浏览器请求百度的时候会发生那些事情

![浏览器访问网站1次握手流程](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/浏览器访问网站1次握手流程.png)

上面的图是1次握手的流程，完成3次握手之后就开始真正的发送请求了，流程是一样的。

##### 2.TCP三次握手过程

![3次握手](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/3次握手.jpg)

上面的数据都是放到TCP包头中的。

*   第一次握手，客户端发送带有SYN(SEQ=x)和ACK=0的连接请求报文，ACK=0说明这是个连接请求，接着客户端处于SYN-SENT状态，等待服务器响应。
*   第二次握手，服务端收到SYN=1的请求报文，需要返回一个SYN + ACK(ack = x + 1，seq = y)的确认报文，自己处于SYN-RECV状态。
*   第三次握手，客户端收到了报文，将ACK(ack = y + 1)返回给服务器，进入ESTABLISHED状态。

**为什么不能是2次或者4次握手？**，如果是2次握手，第一次握手服务端没收到，客户端在等了一会发现服务端没有响应就重试发送握手请求，重试的那次成功了之后正常请求数据，过了一会服务端收到了失败的那次握手请求，然后开辟资源返回响应，等待客户端发送请求，客户端收到后并没有找到对应的一次握手响应，就不会管，此时服务端会等待，浪费资源，如果是3次握手客户端不认识二次握手的请求还是会发送第三次握手给服务端，通知服务端释放资源。3次握手已经够用了，不需要4次了。

##### 3.TCP四次挥手过程

![4次挥手流程](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/4次挥手流程.png)

*   第一次挥手，客户端发送报文，FIN=1(seq=x)，此时进入FIN-WAIT-1状态
*   第二次挥手，服务端收到报文，这时候进入CLOSE_WAIT状态，返回一个报文，ACK(seq=x + 1)。客户端收到这个报文之后，直接进入FIN-WAIT-2状态，此时客户端到服务端的连接就释放了。
*   第三次挥手，服务端关闭和客户端的链接并且发送FIN=1(seq=y)的报文，服务端进入LAST-ACK状态
*   第四次挥手，客户端收到连接释放报文之后，发应答报文，ACK(seq=y + 1)，进入TIME_WAIT状态，服务端收到报文之后就进入CLOSED状态，客户端等待一会发现没有收到服务端的回应确定连接已经关闭进入CLOSED状态。

###### 为什么是4次挥手

服务端或者客户端是全双工通信，可以互相发送消息，在关闭链接的时候必须要确认双发都没有要发送的消息，前两次挥手就是客户端没有要发送的数据，请求关闭链接，如果服务端还有没发送完的数据，会先发送数据，发送完之后会发送第三次挥手。

##### 4.socket网络编程和TCP IP协议的关系(socket网络编程的工作原理)

socket是基于传输层的一个编程规范，然后再说一下封包、建立连接过程。

##### 5.http1.0和1.1、2.0有哪些区别

http1.0默认是短连接，比如打开一个网站，请求一张图片就需要3次握手+请求资源+4次挥手。需要指定keep-alive开启持久连接。

http1.1默认是长连接，就是说打开网站后底层的tcp会保持一段时间的连接，不会马上断开，默认30s。1.1开始支持host头，意思就是支持虚拟主机。

http2.0支持多路复用，解决1.1同一时间对同一域名请求限制问题。支持将数据拆成更小的帧，比1.1更 低延迟。

##### 6.https加密原理

**常用的加密算法：**

非对称加密：RSA；对称加密：AES、RC4；hash算法就是MD5；

原理：

1.  浏览器访问服务器，告诉服务器自己支持哪些加密算法；
2.  服务器选择加密算法，返回证书，证书中包含网站地址，加密公钥，证书颁发机构等；
3.  浏览器收到证书后验证证书的颁发机构和时间是否合法，如果合法，在地址栏会出现一把小锁头；
4.  浏览器生成一串随机密码，并使用公钥加密，生成一段消息（内容就随便了），把消息进行MD5加密（hash值），用随机密码把消息加密，然后把加密后的消息、has值、加密后的随机密码发送到服务器；
5.  服务器收到消息先把公钥加密后的随机密码拿出来使用私钥解密，然后在用得到的随机密码解密消息内容，根据消息内容生成MD5的值，和接收的hash值对比，如果一样就保存这个随机密码。
6.  服务器在用这个随机密码加密一段消息返回给浏览器，如果浏览器能用随机密码解密，就说明可以和服务器进行加密通信，之后的请求响应就都会使用随机密码加密解密；

最开始使用的是非对称机密，也就是公钥、私钥，后来的通信使用的都是对称加密。

##### 7.http实现长连接的底层原理

http的长短连接说的就是底层的TCP的长短链接，就是建立连接之后不马上释放，之后的请求都是用这个连接。http的长连接不常见，一般都是网页加载资源什么的。

##### 8.mmap和零拷贝

###### 8.1普通IO操作的流程

首先操作系统有一块缓冲区叫做OS cache，JVM也有一块缓冲区叫做用户缓冲区，还有两种状态叫做用户态和内核态，用户态就是JVM级别的操作，内核态就是操作系统级别的操作，用户态和内核态切换就是上下文切换。

普通IO时，先从用户态切换到内核态，使用DMA引擎把要读取的文件从磁盘文件拷贝到OS中去，然后在从内核态切换到用户态，使用CPU引擎把OS中的文件拷贝到用户缓冲区，到此为止发生了两次的上下文切换、两次拷贝，如果后面是socket发送数据，他会在发生一次用户态到内核态的切换，使用CPU拷贝把文件从用户缓冲区拷贝到socket缓冲区，然后在用DMA拷贝把文件从socket缓冲区拷贝到网络协议引擎发送出去，然后就切换回用户态了，这就发生了四次切换、四次拷贝。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gizdwey6arj31bt0n8ju3.jpg)

###### 8.2mmap

mmap技术跟普通的IO操作相比会少一次拷贝，他并不是把OS中的文件拷贝到用户缓冲区，而是建立一个映射，之后如果还需要拷贝就会根据映射找到OS中的文件进行操作，不过上下文切换次数没变，RocketMQ中就是使用的mmap提升磁盘读写。

###### 8.3零拷贝原理

零拷贝相比mmap，不会建立映射，在第一次切换和拷贝之后，把数据的offset直接放到socket缓冲区中，然后socket把数据的offset给网络引擎，网络引擎直接去OS中拷贝数据，最后切换回用户态，这样只有两次切换，两次拷贝。

##### 9.java的3个io

*   BIO：一个socket客户端和一个服务端socket建立连接就要创建一个线程去处理客户端的消息，这个线程在链接期间是不能销毁的，这样就很容易把资源打满，服务器就死了，同步阻塞的。
*   NIO：不是线程直接监听socket消息，而是出现了一个多路复用器的概念，叫selector，每接入一个socket客户端的时候selector就会创建一个channel，然后它不断的去轮询channel，发现有消息了就创建一个线程去执行，处理的结果会放在一个缓冲池中，channel会自己去buf pool中读取数据返回给客户端，所以当把数据写到缓冲池中之后这个线程就被销毁了，这时候就可以创建线程池让selector去使用。因为读channel里的数据然后交给工作线程这块是同步的(他会一直轮训，如果channel里没有数据会一直空轮训，占这个线程一直占用资源)，同步非阻塞的。
*   AIO：和NIO非常像，只不过在多路复用器读取channel中的数据的时候是把数据放在工作线程的缓冲区，然后就结束啦，工作线程自己去缓冲区读取，所以AIO是异步非阻塞的。

这个同步阻塞什么的不是完全针对网络通信的，说的是磁盘IO读写，同步阻塞的说得就是比如BIO，FileInputStream去读取文件，在文件读取完成之前就会卡住；而是用NIO的FileChannel去读取的时候就可以干别的了，但是他还是同步的，因为你需要隔一段时间去轮询看看有没有读完，所以NIO是同步非阻塞；AIO是不需要轮询看读没读完，操作系统读完了之后会回调告诉你读完了。

![同步阻塞和同步非阻塞](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/同步阻塞和同步非阻塞.png)

###### 9.1 nio的原理

nio是一种基于channe和lbuffer的方式，当channel接收到数据的时候selector会通知线程把数据读取到buffer中，写入的时候线程会从buffer中读取数据写进channel，他是一种同步非阻塞模型。

###### 9.2 epoll原理

epoll有3个组件，event fd(文件描述符)，event pool(红黑树，存储event fd)，event list(文件描述符对应的时间集合，他是个链表)，当门调用epoll_create()的时候会创建一个新的event fd交给event pool管理，操作系统收到事件后会把事件放到对应的描述符的event list中，此时如果我们调用了epoll_wait()，会传一个event fd的标识，如果这个event fd对应的event list中没有事件，**线程会进入休眠(非阻塞的原因)**，直到超时时间或者event list中出现新的事件会唤醒线程。

epoll的两种模式：

*   et：当有事件进入event_list中时只通知一次，如果线程没有读取完数据，被阻塞住，同时也没有新的事件进来，这个时候epoll会一直等待导致busy loop问题。
*   lt：当event_list中有事件时如果线程没有及时处理完就会一直通知线程，导致busy loop。

这两个模式都会因为没有及时处理完数据导致busy loop。针对et的busy loop，netty没有解决，针对ltnetty自己实现的epoll采用边缘模式只通知一次。

###### 9.3 nio使用的是边缘触发还是水平触发

边缘触发是说一个事件只通知一次，水平出发是只要通道里有数据就会不同的通知程序，nio使用的是边缘触发。

###### 9.4怎么唤醒selector.select()方法？和nio对epoll的实现

调用selector.wakeup()方法或者关闭channel或者向channel中写入数据都可以唤醒。

nio通过EpollSelectorImpl实现对epoll的支持，主要通过JNI对操作系统的epoll相关函数调用。

##### 10.netty的ByteBuf相比nio的ByteBuffer有什么优点

nio的ByteBuffer长度固定，不支持扩容，而且使用起来比较麻烦，需要注意position、limit这些指针，netty的api读写更加简单。

##### 11.netty如何保证高并发高性能高可靠

高并发：他的actor架构模型实现无锁串行，要实现高并发需要自己追加业务处理线程池。

高性能：

*   序列化：netty支持多种序列化协议，比如protobuf
*   避免锁竞争：netty尽量使用atomic类、alocate，减少重量锁的使用
*   网络读写：使用directBuffer，少了一次jvm内存拷贝
*   ByteBuf池化，避免反复创建

高可靠：

*   空闲检测：关闭长时间没有请求的channel，这种情况netty会认为是网络问题导致，所以需要定时发送心跳。
*   NIO bug：NIO有个epoll空轮询bug，可能出现空轮询导致CPU100%。Netty通过rebuildSelector0()方法解决这个bug，他有个计数器，如果空轮训达到512次就会执行这个方法重新创建一个selector，避免一直空轮训。

##### 12.tomcat的阻塞协议和非阻塞协议

tomcat的阻塞协议一般是http1.1，他在收到请求之后会同步阻塞等待结果，非阻塞协议就nio或者apr协议，在这个协议里Tomcat收到请求之后会把请求放进队列，通过selector轮询队列处理请求。

### 安全

###### 1.XSS攻击

跨站点脚本攻击也叫CSS，就是在我们当前访问的网页植入一些恶意性的代码，来获取cookie、或者使用我们的账号发一些东西等等，cookie或者session存放的都是用户信息，一旦获取到了就可以伪装成用户，有两种注入类型

*   反射型：可能是点了某些广告，点击的时候就访问了别的网站然后返回的恶意性的代码，恶意代码就可以在浏览器里执行了。可以将cookie设置成HttpOnly；
*   持久型：可能是一些评论但是评论的内容是一段脚本，评论之后这个脚本是会被持久化的，比如存在数据库里，然后当你用浏览器访问服务器返回了这条评论的时候就会执行恶意脚本。将内容中的标签进行转义消毒；

###### 2.SQL注入

SQL注入就是把访问接口的参数变成SQL语句，比如url/param';drop table ……，这样如果数据库操作这个参数的时候遇见了';就会结束这条语句，后面又是一条SQL，这个就是被注入的恶意SQL，但是要想写恶意SQL就要知道表结构，最基础的就是表名，如果表名都不知道还写个锤子的恶意SQL，所以开发的时候要避免在浏览器能看到SQL异常，比如故意把int类型写成varchar然后让数据库报错，如果后台没处理好，这个错就能在浏览器上看见，这时候不就知道你表结构了吗，但是现在mybatis都是占位符预编译的，传入的参数会被加上双引号和转义字符，恶意SQL一般不会执行。

###### 3.CSRF

跨站点请求伪造，他和XSS比较像，都是被别的站点植入了恶意脚本，但是和XSS的区别是他是自己在脚本中带着获取到的cookie、sessionId之类的东西去访问别的网站，而XSS只是获取到这些信息，然后需要手动去访问，比如使用postman之类的，所以防止CSRF和XSS一样都可以设置cookie是HTTPonly，还可以搞一些随机的加密token，或者重要表单提交需要拼图、验证码之类的，在请求中拼上这些信息，还有就是refere过滤指定站点。

###### 4.文件上传

文件上传可能是一个恶意脚本，这个脚本修改后缀名伪装，到服务器里之后就可以各种操作了，比如连接数据库，把备份发给黑客，然后删库，勒索，要解决这个问题就得有一个文件类型的白名单，但是文件类型不能通过后缀名来判断，需要使用文件的二进制流的前几个字符，也叫做魔数，比如FFD8FF表示jpg文件，还可以使用imagemagic这种工具将图片压缩，破坏原来文件的结构，这样恶意脚本也执行不了了。

###### 5.DDoS攻击

​	先说一下DoS攻击，DoS攻击的中文名叫做服务拒绝攻击，他的意思就是搞一台服务器一直发送大量的请求把你的项目服务器打满，让你的服务器不能正常被用户访问；

​	但是后来出现了分布式、配置更好的服务器，比如原来服务器每秒只能处理500个访问，这样随便搞一个服务器开几十个线程很容易就打满了，但是现在换了一个配置更好的服务器，或者又加了两个服务器，每秒能抗3000并发，这样原来的DoS攻击就没用了，所以出现了DDoS攻击，DDoS攻击也叫分布式服务拒绝攻击，他和DoS的区别是加了很多服务器，不过不是黑客自己的，是黑客的病毒所在的计算机，可以是笔记本或者公司服务器，这些被控制的计算机叫做’肉鸡‘，然后黑客控制着点计算机一起向你的服务器发送请求，这样就又可以把你的服务器打满了。

*   SYN Flood模式的DDoS攻击：SYN是tcp三次握手时发送的消息，SYN Flood模式就是黑客控制肉鸡发送大量的SYN消息去和服务器请求建立链接，但是不给服务器发送第三次握手消息，这样服务器就会等待客户端的第三次握手，如果等待超时了就会把建立失败的客户端信息存放到一个等待列表里，因为服务器认为可能是网络原因到是建立连接失败，所以服务器会发送三到五次第二次握手请求给客户端，并且保留服务器给这次建立tcp链接的资源，这样如果SYN消息很多，并且都是不会给服务器响应的，服务器就会保留很多资源不释放，慢慢服务器的资源就会被打满，就瘫痪了，客户端都不能访问了；
*   DNS Query Flood模式的DDoS攻击：我们在访问网站之前需要根据域名获取服务器的ip地址，这个过程叫DNS解析，就是通过DNS服务器去查找域名和ip的对应关系，DNS Query Flood模式就是发送海量的不存在的域名，让DNS服务器瘫痪，因为最近的DNS服务器如果查不到域名对应的ip就回去上级查找，一直查到世界级，这样DNS服务器的所有资源都用来查找ip，也就没资源去处理正常的请求了；
*   HTTP Flood模式的DDoS攻击：和SYN Flood模式差不多，不同的是发送建立HTTP连接请求的不是被黑客控制的肉鸡，而是HTTP代理服务器；

这些攻击的预防都可以在网关的过滤器里完成，在过滤器中可以获取请求的所有参数，然后就能过滤了，比如查看请求是否带有refere；预防DDoS就是采用计数的方式，比如接到一个请求就在redis中incrBy自增1L，key是这个请求的ip，然后设置1s过期，自增之后就把次数取出来判断1s访问超过多少次就把这个ip给加入黑名单。