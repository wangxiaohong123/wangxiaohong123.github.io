---
title: 消息队列
tags:
  - 面试专题
categories: 面试专题
copyright: true
---

##### 1.用过消息队列吗？

在项目里用的队列，大部分的场景是**解耦**和异步，比如充值完会员会发送一条消息，如果以后增加系统的币种，会员会有对币种的逻辑处理、会员积分这些东西直接消费会员的消息就可以了，不需要改接口。

我们系统里用户是有个收发瓶子次数的限制，很多场景都可以导致这个次数发生改变，比如开通会员、后台手动操作修改用户状态，这些对实时性要求不高的业务可以使用mq进行**异步**处理，减少接口响应时间。

如果有大量写但是对实时性要求不高的需求也可以使用mq来进行**肖峰**。

还有一些一些日志系统、数据同步系统也需要用到消息队列。

###### 缺点

1.  mq出问题这个功能就蹦了。需要多维护一个服务或者框架来处理mq挂掉之后的处理逻辑；
2.  一致性问题，分布式系统的cap理论：高可用，强一致性，分区容错性（在时限内到一致性）只能满足两个，mq就舍弃的强一致性；
3.  重复消费啊、顺序消费导致结果纠错了，丢消息，消费者挂掉会有大量的消息积压等等，解决这些问题还会让系统更复杂。

##### 2.各个消息队列区别（如何选型？）

activeMQ：我没用过，官方好像不维护了，要不就是很不活跃，如果用他的话有bug可能就要靠自己了，印象里吞吐量很低；

rabbitMQ：吞吐量比kafka和rocketmq低，可以在小项目里用，但是源码是erlang的，java程序员看不了，但是社区很活跃，不怕采坑的。集群不好扩展但是管理界面功能非常全；

kafka：吞吐量是最高的，但是功能不多，kafka持久化消息时异步写入，有人说会丢消息，其实配置成同步写入是不会丢消息的，只不过会严重影响性能，一般日志采集，大数据分析服务用的多，因为丢一条两条无所谓，如果kafka要保证消息不丢首先broker要设置acks=-1，然后insync.replicas > 副本数-1，最后关闭自动提交ack；

rocketMQ默认就是集群模式，配置简单，源码是java的，容易扩展，nameserver和broker通信用的是netty。

##### 3.如何保证消息的高可用？

kafka：分布式集群，他会把topic分出多个partition，每个机器存储对应partition上的消息，如果要保证HA的话每个partition需要有多个副本，这些副本有一个leader和多个follower，只有leader进行读写，leader宕机之后会选举出新的leader。用他自己的controller模块加zk实现的选举。

rocketmq：默认就是集群模式，他通过message queue把消息均匀分在每个集群节点上，每个master都有slave，4.5版本之前如果master宕机那么只能手动切换master，4.5版本之后使用Dledger进行主备切换。

如果考虑mq集群可能全部不可用的情况还需要在mq上包装一层自己的代码，当发现集群都不可用的时候需要把消息存到本地或者redis里，然后有一个单独的线程定时轮询发送失败的消息尝试发送搭配mq中。

##### 4.如何保证消息不被重复消费

很多操作都会导致重复消费，比如MQ设置消息最少发一次，有的时候没有提交偏移量就会导致消息重复消费，或者在rocketMQ里以消息组为单位消费，只要有一条消费失败，拉取的所有消息都被标记成失败，过一会会重新发过来，这里面的消息就有消费成功的，或者消费中突然宕机或者重启，一般就是使用redis的setnx或者zk的分布式锁或者数据库唯一索引。kafka是基于zk实现的offset。

##### 5.怎么保证消息可靠性(消息丢失)？

生产者去写消息的过程中，网络传输过程中可能会丢失、mq收到消息后还没持久化到磁盘就挂了、消费者没有处理完但是mq以为处理完了结果消费者挂了或者处理失败(关闭自动提交ack，rocketmq没有这种机制)。

**5.1rocketmq全链路消息不丢失方案：**

首先发送消息使用rocketmq的事务消息或者同步发送加重试检测，超过次数回滚业务逻辑；

然后broker采用同步刷盘(flushDiskType=SYNC_FLUSH)，主从同步复制(brokerRole=SYNC_MASTER)；

最后消费者同步消费业务逻辑，最后返回处理结果，需要注意重复消费问题；

##### 6.顺序消费

##### 7.消息积压

新建几十个消费者，把原来的消费者的消费逻辑改成重新发送到新partiotion中，让几十个消费者去消费，前提是数据库能承受住，消费完了在把消费者换回来。

##### 8.设计一个消息中间件

首先在存储上要分片存储，队列的消息均匀分布在每个节点上，多个消费者平均的绑定n片，分片之间需要考虑主从选举、主从心跳等等。同时要实现两种刷盘方式，使用mmap顺序写磁盘，所以还需要一个队列存储consumer消费的offect，客户端和broker之间使用netty通信，客户端和broker之间也需要心跳。

### rocketmq

#### 发送消息机制

通过message queue把数据分片，均匀存储在broker上。相当于的kafka的partition。producer会定时访问nameserver获取broker信息，发送消息时，会通过负载均衡计算出应该发送到那个message queue上，然后发送请求给对应的broker，如果master宕机，在等待主备切换的时候，是无法往这个broker中发送消息的，结果只能是发送失败或者超时，所以要设置sendLatencyFaultEnable，设置了这个参数后，在发送超时或者失败时会回避访问这个broker一段时间，将消息发送到其他broker。

#### 存储消息

rocketmq的消息存储是在一个commit log中，每个文件最大1g，为什么是1g？因为mmap在生成文件映射的时候限制文件大小为1.5到2G之间。收到消息后会在log文件后追加消息，然后添加到OS cache中，当配置为同步刷盘时，会马上把OS cache的消息刷到consumer queue中，consumer queue中存储的是消息在log文件中的偏移量，每个message queue对应多个consumer queue，和多个commit log。一般会把brokerRole设置成SYNC_MASTER，这样会同步复制master的消息，而flushDiskType根据情况，如果是订单、金额相关的就设置成SYNC_FLUSH，允许丢数据的就设置成ASYNC_FLUSH。

![rocketMQ消息持久化](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/rocketMQ消息持久化.png)

#### 选举和消息同步

选举和消息同步都是通过DLedger + raft协议实现的，在启动或者master宕机时，每个broker都会进行投票，但是每个broker都会给自己投票，然后把结果发送给其他broker，一个master 宕机，还有两个slave，他们刚开始都给自己投票，这时每个slave都会有一票，然后进入随机睡眠，先醒的那个会继续投票，还是给自己，其他broker醒了之后收到选举消息会比对日志，谁的日志新就投给谁，只要有一半 + 1个broker投票给同一个broker就会选出来新的master。

消息同步也是基于raft协议实现的：

![RocketMQ主从数据同步复制](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/RocketMQ主从数据同步复制.png)

#### 消费数据

消费数据有两种模式，pull和push，但是这两种模式都是consumer主动去拉取，push模式下，发送请求给对应的broker，然后broker从consumer queue中拿到上次消费消息的偏移量，去commit log中获取对应的消息，如果没有新消息，请求线程会睡眠15，后台线程一直检查commit log，有新消息后唤醒睡眠的线程，返回消息。拉取数据时是可以从master上拉取，也可以从slave上拉取，其实commitLog和consumer queue都是经过OS cache去刷盘的，commitLog使用OS cache来提高写速度，而consumer queue使用OS cache提高读写速度，因为他很小，所以几乎所有的consumer queue都是在缓存中，这样读写都是缓存级的，很快，而commitLog文件比较大，不可能全部加载到缓存中，缓存中只是刚刚收到的消息还没刷盘的，所以除非消费速度很发消息速度差不多，否则拉取消息只能读取磁盘数据了，这个会比读取磁盘慢很多，而且当master感知到读取的速度落后很多，就会认为是自己负载过高，会让消费者下次去slave broker中拉取数据。

当consumer宕机或者新加机器后会重新分配message queue，这个过程叫rebalance。

#### 事务消息

首先上游服务会发送一条half消息到rocketmq，rocketmq把half消息写入commitLog和RMQ_SYS_TRANS_HALF_TOPIC中，上游业务处理完业务逻辑后会发送commit消息或者rollback消息给rocketmq，rocketmq把对应的操作写入OP_TOPIC中，如果是commit消息，还会把这条消息写入真正的topic对应的message queue下的consumer queue中，这样下游服务就能消费到消息了，broker定时扫描RMQ_SYS_TRANS_HALF_TOPIC，如果OP_TOPIC中没有这条消息的状态就会回调上游服务，最多回调15次，最终失败就把消息状态改成rollback。

##### 自定义延迟消息级别

在发送消息的时候可以指定delay_time_level来设置延迟级别，通过控制台或者直接修改broker配置文件的messageDelayLevel属性可以修改延迟消息级别对应的时间。

