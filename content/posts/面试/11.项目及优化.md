---
title: 面试-项目及优化
tags:
  - 面试专题
categories: 面试专题
copyright: true
---

### 画出自己的项目部署架构图和扩容方案。



### 生产环境开发流程

如果是新服务，在路由信息表中添加服务和路径的映射关系，然后就可以部署了。

如果是修改服务先部署几台机器，在表中开启灰度发布，然后观察修改之后新版本的服务是否正常，如果正常的话就把eureka.instance.metadata-map中的version改成老版本，全部替换新服务。

### redis

使用redis cluster，部署了8台8g机器，每台机器上两个redis实例，整个集群是8个master，8个slave。RDB和AOF都是打开的，使用crontab每天凌晨把最新的RDB文件传到阿里OSS上冷备。100万用户、8万日活、日新增5k用户的情况下内使用稳定在20g左右。

对于时效性不高的缓存采用2级缓存架构，redis分布式缓存+coffine本地堆缓存，coffine以小时为单位过期。

对于时效性较高的缓存采用数据库缓存双写。

#### redis优化-惰性分页

拿用户的动态举例，分页查询用户的动态列表因为没有查询条件、顺序固定并且不会修改，这样放在缓存的list结构里是合适的，但是有些人的动态可能没什么人查看，所以不需要发布完就放到redis中，当分页查询发现list中没有就去数据库中查询然后写到list中，这样只需要在缓存中维护一个user的动态数key和一个用户的list就可以了，需要注意的是比如最后一页没满20个但是在缓存里，这个时候就会导致新发布的没法在缓存中获取，所以在查最后一页的时候需要比较动态数和最后一页list的元素数。
这个方案也有一个问题就是每个用户动态总会被查看，慢慢所有用户的动态就都会变成常驻内存，很浪费内存，redis的过期策略只能针对key，所以可以把动态按照页来存储，每一页都是一个list，size就是固定20，这样还可以避免大key，只有在查到某一页发现redis中没有的时候采取查数据库然后写到redis中同时设置过期时间。
如果涉及到更新就异步更新，但是一有更新，就会出现数据库和缓存不一致的问题。

#### redis优化-绑核

如果一个机器有多个物理核可以考虑把redis绑定到同一个物理核的不同逻辑核上，因为L1、L2和CPU私有的，L3是CPU共享的，如果redis在多个物理核上绑定了socket可能导致数据通过L3传递，绑核之后会减少数据传递。

#### redis优化-多指令

使用lua脚本或者pipeline来打包命令一起发送，减少网络开销。

邦帮盟项目我主要负责订单模块、签到模块、钱包模块、圈子模块，系统的用户量30万，每天高峰的QPS一千六，每天下单量在四千多左右，总订单量是180万，订单明细300多万，圈子的数据量是一千万，使用sharding-jdbc + 16 * 16分库分表，四台服务器，每台机器4个库，存储5g的数据。订单模块部署四台4核8g机器，其他模块是两台4核8g。

IM项目我负责所有模块，用户量四十多万（包括帮帮盟和其他系统），每天新增消息数据七十万（其他系统都是客服使用，IM系统的人数只有几万），目前数据量八千万，使用sharding-jdbc + 32 * 32分库分表，四台服务器，每台服务器11g数据，消息服务三台机器，目前消息数据量

***

Jvm调优实战

比如说订单模块，在压测时估高峰算十万人同时在线，一人每分钟查询一次订单，高峰期每秒钟大约有1700个请求左右，按照每个服务每秒抗400并发算，查询订单列表一条数据1kb，一次请求时10条，在加上折扣、商品其他信息一次请求大约会产生200k的对象，1s会产生80m左右的对象，这样一台4核8g的机器，jvm给4g，虚拟机栈分配1m，这样几百个线程占用几百兆，元数据空间分配256兆，这样也差不多1g了，堆内存分配3g，先按默认的年轻代，老年代每人一半，e区会占用1.1g，s区每个有150兆左右，这样来看，20s左右会触发一次young gc，并且150兆是完全够用的，但是实际压测时，17s左右的时候就会触发young gc，并且s区没增长，反倒是老年代在增长，每次增长90多兆，所以看出来，是young gc回收时存活对象超过了75兆，导致动态年龄判断，存活对象全部进入老年代，然后调整老年代大小为1g，这样s区就有200兆，就够用了。

网关的对外内存溢出：网关的请求是最大的，但是最开始年轻代和s区给的都比较小，而且也关闭了DisableExplicitGC，导师申请对外内存时不能调用System.gc()，这样年轻代回收时，堆外内存没有使用完，恰好s区又装不下，直接进入老年代，但是由于老年代没满，堆外内存满了，所以堆外内存的引用一直在老年代里没法释放，慢慢就内存溢出了。

***

mysql调优实战

看mysql -> 12.优化

##### IM系统

1.   系统的具体流程：系统分为4层，接入层、路由层、业务层和存储层，然后说一下每一层的分工，启动和发消息流程。
2.   使用什么框架开发，断线重连是怎么做的：服务端使用netty的IdelStateHandler来监听关闭长时间没有读写的连接，客户端发送心跳消息失败超过4次会自动重新连接。
3.   发送数据使用什么协议，粘包拆包怎么解决：使用protobuf协议发送数据，使用netty的protocolVarInt32……的两个类，这两个类在发消息的时候会自动添加一个header标记body的长度，接收数据的时候也会根据header中标记的body长度来截取消息。
4.   说一下分发层的作用：分发层主要用来把消息推到mq中，还有一些其他的功能比如校验token、群消息生成sequence、群消息推送判断推送还是主动让客户端拉取。
5.   离线消息怎么存储：离线消息使用redis的zset存储，超过7天用mysql存。
6.   用户上线的时候怎么拉取离线消息：用户连接后采用分批拉取离线消息，每次拉取50条，拉取离线消息的时候会判断用户离线时间是否超过7天来决定是从redis中取还是从数据库中取。
7.   系统的ack是怎么做的：客户端有个队列存放没收到ack的消息，超时提示用户发送失败，服务端先存离线消息，收到ack之后删除离线消息。
8.   系统的并发量、部署机器及配置：这个服务没有做高可用，都是单机4c8g部署，需要调大服务器的最大文件句柄数(etc/security/limit.conf)，压测的时候发现10w左右的客户端连接带宽先到瓶颈，CPU在60%左右，这个完全够用了。

##### 项目里使用到的并发

1.   小星空项目中的读取lua脚本后需要缓存到内存中，使用synchronized双重检查判断脚本是否已经加载过，然后脚本存到HashMap中，没有使用ConcurrentHashMap因为这个map没有修改操作，只有读取和添加。
2.   最终一致性框架中的提交任务使用线程池。

