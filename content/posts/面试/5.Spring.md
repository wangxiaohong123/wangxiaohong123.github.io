---
title: 面试-5.Spring
tags:
  - 面试专题
categories: 面试专题
copyright: true
---

##### 1.IOC

控制反转：把bean的生命周期由程序员自己控制反转给spring控制；

依赖注入：spring启动时创建bean的实例，程序中不需要自己创建依赖的bean的实例，依靠spring注入进来即可；

##### 2.AOP

面向切面编程，在程序运行中会产生一些横切性问题，比如日志记录、事务的创建和提交回滚，如果不把这些问题统一放到切面里就会耦合到代码里。在Spring中默认情况下，如果是接口的实现类，AOP会使用JDK的动态代理，如果是没有实现接口的类，AOP会使用cglib的动态代理。

##### 3.动态代理

就是动态的创建一个代理类的字节码，里面引用被代理的类，在调用被代理的方法之前或者之后加一些增强代码。通过类加载器把字节码加载到jvm里，然后在通过反射创建代理的对象。

##### 4.spring的bean是线程安全的吗？

spring在启动的时候会创建bean的实例，默认是singleton，有五个作用域：

*   singleton：默认，单例；

*   prototype：每个bean的注入会创建一个新的实例；

下面的没用过

*   request：每次请求创建一个实例；

*   session：每次回话创建一个实例；

*   global-session：

*   refresh：应用上下文配置发生改变时标记示例失效，下次使用会创建新的；

所以默认情况吓spring的bean不是线程安全的，但是在bean里没有什么操作共享数据的代码，所以一般不会造成并发问题，没啥影响。

##### 5.@Autowired和@Resource的区别

首先我觉得他俩既不是使用set()方法注入，也不是使用构造方法注入，而是通过反射直接调用Field.set()注入。当@Resource没有设置name属性的时候，这两个注解都是先根据类型获取，如果获取的Bean超过1个在根据属性名筛选；当@Resource设置了name属性或者检测出容器中有属性名对应的Bean就只根据name获取。

##### 6.Bean的生命周期

Bean的生命周期大概分成6个阶段：

1.   容器初始化：启动BeanFactory，创建扫描器，执行容器的后置处理器，扫描Bean放到beanDefinitionMap里，注册BeanPostProcessor；
2.   Bean实例化：推断创建方式(构造方法、Supplier)，实例化Bean(内省)；
3.   属性注入：扫描@Autowired、@Resource进行缓存，创建FactoryBean处理循环依赖，注入属性；
4.   Bean的初始化：执行aware接口回调，比如BeanNameAware。执行后置处理器的回调，执行@PostConstruct注解标记方法；
5.   Bean缓存：清除创建Bean产生的临时变量，把Bean放到单例池中；
6.   Bean销毁：回调@BeforeDestroy方法，从单例池中移除Bean；

##### 7.怎么解决循环依赖

先大概说一下生命周期，然后说一下什么是循环依赖。解决循环依赖主要依靠三级缓存：

*   第一级单例池：Map\<String, Object\> singleObjects;
*   第二级半成品Bean集合：Map\<String, Object\> earlySingleObjects;
*   第三级AbstractFactory集合Map\<String, AbstractFactory\> singleFactories;

然后还要有一个变量标记当前Bean是否正在被创建，当getBean()发现单例池中没有而且这个Bean正在被创建，那就说明发生了循环依赖，这个时候需要把AbstractFactory转成Bean。如果没有这个singleFactories那么转成的Bean是不能被代理的，也就是说如果Bean是AOP的切点，AOP的代码不会生效，转成Bean之后需要放到二级缓存中，执行完剩下的生命周期之后再从2级缓存转移到1级缓存。

如果没有代理其实两级缓存就够用了。

##### 8.@Configuration里的@Bean怎么保证单例性

添加了这个注解的类会被代理，被增强的类执行@Bean标记的方法时会把方法放到threadlocal变量里，如果@Bean方法中调用了第二个@Bean标记的方法，第二个@Bean方法发现当前执行的方法不是自己就不会走本身的逻辑而是去容器中直接获取。

##### 9.事务的传播属性(propagation)

* REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置；

* SUPPORTS：如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行；

* MANDATORY：如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常；
* REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务；
* NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起；
* NEVER：以非事务方式执行，如果当前存在事务，则抛出异常；
* NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行；

当两个方法存在调用关系，如果两个方法使用的都是REQUIRED，那么就算调用时使用try包裹被调用方法，内层方法发生回滚时，外层方法也会回滚，比如下面这段伪代码，一条数据都插不进去：

```java
@Transactional
public void insert1() {
    // 一条插入
    try {
        insert2()
    } catch (Exception e) {
        // 无操作
    }
}
// 另一个类里的方法，同类的话事务注解会失效
@Transactional
public void insert2() {
    // 一条插入
    int i = 1/0;
}
```

嵌套事务：外层事务发生异常内层事务会一起回滚，内层事务发生异常外层事务不会滚。如果上面的代码insert2()上面的注解标记了传播行为是NESTED，结果会插入一条insert1()的数据。

##### 10.SpringMVC核心架构

![mvc工作原理](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/mvc工作原理.png)

##### 11.统一异常处理

使用@ControllerAdvice/@RestControllerAdvice + @ExceptionHandler，@RestControllerAdvice继承了@ControllerAdvice注解，同时他还多了一个@ResponseBody注解。在容器启动的时候会扫描到@ControllerAdvice/@RestControllerAdvice标记的类，把类和对应的@ExceptionHandler标记的方法信息存到缓存里，当DispatcherServlet调用Handler发生异常的时候会在缓存中找到对应的处理方法。

##### 12.Spring中用的设计模式

代理模式，AOP就是使用代理模式创建jdk或者cglib的代理，但是在代理类之前还有一个拦截器，对方法进行增强，比如说TransactionInceptor中对原来逻辑进行生成事务、提交或者回滚。所以还有适配器模式。

执行通知使用的类似责任链的模式。

通过ASM读取文件使用访问者模式。

一些后置处理器的扩展是门面模式，获取高层接口的所有实现，然后排序遍历。

事件处理使用观察者模式。

### SpringBoot

SpringBoot简化了开发流程，比如定义bean也更简单，内嵌tomcat/Jetty等网络容器，直接运行main方法就可以启动项目；自动装配：比如要整合redis，只需要引入一个依赖，就会自动完成一些配置，我们只要做一些简单的配置，比如redis的地址、用户名和密码就可以使用了。

spring boot的启动最关键的两个步骤是扫描和自动装配，扫描使用@ComponentScan注解，spring会解析这个注解然后扫描注解中配置的路径和其他信息，比如ClassPathBeanDefinitonScanner。

自动装配一部分是通过@EnableAutoConfiguration注解实现，还有一部分是通过配置spring.factories文件实现的。

