---
title: 面试-12.面经
tags:
  - 面试专题
categories: 面试专题
copyright: true
---

### 滴滴

介绍一下最近的项目

1.   RocketMQ的事务消息原理：

     上游服务会发送一条half消息，broker将half消息存储到commit log中，此时真正topic中的消息状态为prepared，同时也会将消息id存储到sys_trans_half_topic中。上游服务执行完业务会发送commit或者rollback消息，如果是commit消息就把消息放到真正的topic中，并且在commit log中将消息标记为commit，此时消息就可以被正常消费了。如果是rollback消息就把commir log中的消息标记为rollback。broker会定时轮询sys_trans_half_topic，如果有消息长时间没有没有收到commit或者rollback消息会回调上游服务，根据业务判断应该会滚还是提交。事物消息的状态在LocalTransactionState枚举类中。

2.   MySQL的事务原理以及怎么实现脏读隔离级别。

     事物有4个特性：原子性，隔离性，持久性，一致性

     mysql中使用undo log保证一致性，当有sql失败时通过undo log执行会滚操作；使用mvcc+锁机制实现隔离性，使用redo log+bin log+双写缓冲区实现持久性，原子性+隔离性+持久性保证了一致性。

3.   算法题：力扣第200题，岛屿数量



### 贝壳

1.   mysql B+树的结构:

     B+树的根节点在内存中，子节点存储多个键值对，key是索引值，value是下一级子节点的指针，每个叶子节点就是一个数据页，数据页由file header、page header、行数据、空闲大小、当前页最大行最小行记录、file trailer等组成，file header中有上一页信息，file trailer中有下一页信息。

2.   mysql为什么一个数据页有16k:

     操作系统读取磁盘的最小单位是蔟，为4k，所以如果要按照数据页加载数据到内存必须要为4k的倍数，默认一个数据页是16k可能因为mysql觉得16k的数据可以满足大部分的sql。

3.   dubbo怎么自定义负载均衡策略:

     自定义负载均衡类继承AbstractLoadBalance或者LoadBalance，并重写doSelect方法，之后在resource.dubbo下创建文件org.apache.dubbo.rpc.cluster.LoadBalance，文件中配置name=类的全限定名。之后在配置文件中指定

     ```yml
     dubbo:
       consumer:
         loadbalance: name
     ```

4.   linkedBlockingQueue原理

     linkedBlockingQueue中使用两把可重入锁来实现阻塞，调用take方法时会判断队列的长度是否为0，如果为0就进入wait()，put时判断队列是否已满，满了就进入wait()。

5.   redis查询慢语句

     首先开启slowlog-log-slower-than(超过多少纳秒算慢)和slowlog-max-len(慢日志存储条数)，使用slowlog get命令查询慢日志。

6.   线程之间怎么通信

     *   共享变量
     *   等待通知机制，wait+notify
     *   阻塞队列：一个线程将数据放到队列中，另一个线程从队列中取
     *   使用join函数等待另一个线程之行结束
     *   Semaphore的acquire()+release()获取和释放信号量

7.   如何在dubbo启动provider成功之后发送邮件通知

     自定义一个类实现ExporterListener接口，类上添加注解@Activity(group = "provider")，在exported方法中编写发送邮件逻辑。

8.   手撸带权重的轮询算法

9.   rocketmq如何保证消息的顺序性

     发送消息的方式必须是同步。发送消息时需要重写MessageQueueSelector的select方法，保证需要顺序消费的消息发送到同一个message queue中。消费者MessageListenerOrderly而不是MessageListenerConcurrently。

     当使用MessageListenerOrderly消费消息时rocketmq会自动产生3把锁：

     1.定时向broker申请分布式锁，申请到锁的消费者才会拉取消息消费；2.消费时需要获取本地锁，获取本地锁成功之后才会执行消费逻辑，这是为了防止多线程消费时的乱序；3.还需要一把额外的锁来控制message queue被分配给新的consumer时存在消费者正在消费且没提交偏移量导致的顺序问题。

     发生broker宕机时无法保证顺序性，顺序消费性能较差，存在消息消费失败时只能不断重试消费而不能跳过。

##### 长春合众地产

1.   jvm动态加载类的方式

     通过类加载器：ClassLoader.load()或者UrlClassLoader.load()或者ClassLoader.defineClass();通过反射：Class.forName()；通过unsafe类：Unsafe.defineClass()；其中ClassLoader.defineClass()是protected类型，Unsafe不能直接实例化，需要通过反射调用。

2.   seata默认隔离界别是什么，怎么实现读已提交

     默认隔离级别是读未提交，要实现读已提交可以使用@GlobalTransaction注解或者@GlobalLock注解或者查询时使用select for update语句。其中@GlobalTransaction会在方法执行前注册全局锁，@GlobalLock会在本地事物提交前获取全局锁，select for update会在执行sql前获取全局锁，@GlobalLock和@GlobalTransaction的区别是@GlobalLock不需要开启全局事物。

3.   自研im部署时调整了哪些操作系统参数？

     文件描述符：/etc/security/limits.conf，默认1024，调整为65535；tcp syn队列的长度(net.ipv4.tcp_max_syn_backlog参数)，默认128，改成2048；网络接收和发送缓冲区大小(net.core.rmem_max和net.core.wmem_max参数)；

4.   
