<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 王小红的笔记</title><meta name=keywords content><meta name=description content="Posts - 王小红的笔记"><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><meta property="og:url" content="https://wangxiaohong123.github.io/posts/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wangxiaohong123.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span class=active>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>为什么使用微服务</h2></header><div class=entry-content><p>单块应用的缺点： 代码重复问题，如果十几个人或者更多人一起干一个单块项目，你要别的模块的接口，但是那个人很忙，没时间写，拖了很长时间你可能就自己写了，这样就操作别的表，别人的库，很有可能和那个人的摸个功能有重复代码，可能会出现大量的重复代码，使用cloud的feign可以避免，微服务中每个人都没有修改别人代码的权限；
协作问题：多人修改公共文件夹下的代码就会出现代码冲突，两个人的冲突还好解决，多个人的冲突超级麻烦；
扩容行问题：所有模块都在一个项目里，要扩容就一起扩容，但是根据28法则，只有那么几个模块流量很大，而且有的时候有的模块还有一些状态什么的，如果扩容就会计算出错，这种也很麻烦；
可用性问题，可能一个人负责的模块写了个死循环或者不小心oom，整个系统就瘫痪了，微服务里如果别的服务挂了可以使用histrix降级熔断；
耦合度太高：代码量上来的时候在后期想要修改代码都不敢动手；
spring cloud是一站式微服务架构解决方案。dubbo是RPC框架。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 为什么使用微服务" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>事务-2.XA事务</h2></header><div class=entry-content><p>一般项目刚上线不久，数据量稍微有点大的时候，但是还没到分库分表的数据量，会把不同的表放到不同的数据库中，但是这个时候@transactional注解垮裤不会生效了。这时候就要用到XA规范和2PC、3PC理论。
XA规范 TM和RM通信的规范就是XA，TM就相当于是引入的一个组件。
XA规范流程：connect -> closed，start -> end，prepare -> commit/rollback。
一般的TM用的都是Atomikos
1 2 3 4 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-jta-atomikos&lt;/artifactId> &lt;/dependency> 2PC（Tow Phase Commit） 2PC是一套基于XA的理论，两阶段提交，第一个阶段TM发送prepare消息，让RM先把操作数据库的语句跑完，但是不提交，操作完后给TM结果，如果TM收到的结果全是成功就在告诉RM进行提交，如果有失败的或者超时的就会通知RM回滚。
问题： 在第二阶段提交之前，资源会一直锁定，这样别人在对资源加独占锁的时候会同步阻塞住；
在第一阶段后单点的TM挂了，这时候资源就会被一直占用着；
在TM发送commit消息的时候，一台服务器挂了，TM也挂了，这时候在选举一个TM出来也不知道哪个消息commit成功了；
脑裂问题，所有主从都有脑裂问题；
3PC 第一阶段：TM发送CanCommit消息，各个库确认环境是否OK；
第二阶段：发送PreCommit消息，相当于2PC的第一阶段；
第三阶段：发送DoCommit消息，2PC的第二阶段；
每个库有一个超时机制，如果在PreCommit之后过一段时间没接收到DoCommit的消息，就会回滚，关键还有一个CanCommit阶段，因为能到PreCommit消息说明所有库都在CanCommit阶段返回成功了，那么这么长时间还没有DoCommit或者abort消息，应该就是TM挂了。
MySQL支持的是2PC协议。
JTA事务 J2EE中的概念，单库的的事务是基于jdbc的，多库的事务是JTA事务，也是基于DTP那一套玩的。
全局事务 x/Open组织定义了一套分布式事务的模型和规范，叫做DTP，就是图中的TM、RM等等。全局事务就是DTP模型中的一个概念，图里也写到了。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 事务-2.XA事务" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/%E4%BA%8B%E5%8A%A1/2.%E5%8D%95%E6%A8%A1%E5%9D%97%E5%A4%9A%E5%BA%93/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>事务-3.TCC事务</h2></header><div class=entry-content><p>主业务服务就是调用其他服务的接口，比如说下订单的接口，在这个接口中需要冻结用户钱包金额，主业务服务就是订单服务，从业务服务就是钱包服务，钱包服务需要提供三个接口：try接口、confirm接口、cancel接口。
业务活动管理器就是管理分布式事务状态的，他会去触发从业务服务的confirm和cancel接口。
try阶段：会锁定资源，没有资源锁定的操作，try接口就可以留空。
confirm：执行具体的逻辑；
cancel：对之前的变动回滚；
TCC的两个变种 异步型TCC方案：从业务服务之前加一层消息服务，从业务服务只有一个confirm接口，try操作就是在消息服务中写入一条confirm消息，confirm操作就是把这个消息发送到从业务服务，cancel操作就是把消息删掉，比如从业务服务已经写好了接口，如果现在要改成分布式事务，需要加两个接口，一个try，一个concel，加一个消息服务，从业务服务就不需要加接口了。 补偿性TCC方案：只有两个阶段，一个do接口，一个compensate接口，其实就是把try拿掉了。 国内的热门TCC框架 tcc-transaction：对spring cloud整合不太好，dubbo还行。 himly：他的整合都是用xml格式，现在都是注解了。 ByteTCC：支持TCC和saga事务，注解驱动，和spring cloud整合还行。 byteTCC可以实现tcc事务和saga事务，在tcc事务中，try和cancel是对应起来的，如果confirm失败会一直重试，cancel失败也会一直重试，而在saga事务中，没有confirm，try就是执行业务逻辑，cancel提供对应的反向数据操作。
byteTCC源码 首先使用byteTCC需要在dataSource组件加入注解：@Import(SpringCloudConfiguration.class)，SpringCloudConfiguration.class里面是对cloud的组件比如feign创建了自己的动态代理，实现自己的逻辑。
启动类上添加注解**@ImportResource({ "classpath:bytetcc-supports-springcloud.xml" }) **，这个xml配置了很多bean。
服务之间的事务上下文都是通过request的header传递。
bytejta表中如果只有一条记录，说明try执行完了，confirm或者cancel还没执行成功，正常来说一个事务会对应两条记录。
CompensableWork会定时（60s）重试失败的confirm或者cancel，也是调用CompensableCoordinatorController中的接口，同时在刚启动的时候他也会去恢复没执行的事务。
链式调用也是使用resourceList。
在bytetcc中，confirm和cancel失败会一直重试，直到成功，讲道理来说，confirm失败也应该调用对应的cancel，cancel失败不断重试就完美了。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 事务-3.TCC事务" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/%E4%BA%8B%E5%8A%A1/3.tcc%E5%8F%8A%E5%8F%98%E7%A7%8D%E6%96%B9%E6%A1%88/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>事务-6.seata</h2></header><div class=entry-content><p>seata原理 AT模式原理 首先有一个Seata Server负责控制事务的提交和回滚，每个服务里需要引入seata client负责监听sql，并生成对应的undo_log，undo_log存储在表里，并且操作本地数据和插入undo_log在同一本地事务中，当服务完成本地事务后需要告诉Seata Server分支事务提交成功，所有分支事务都完成后(那个角色提交？)向Seata Server提交事务并释放全局锁，如果存在某个服务发生异常，此时Seata Server会向提交分支事务成功的服务发送执行回滚日志消息，再由seata client执行对应的undo_log。
![seataAT模式](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/seata AT模式.png)
读写隔离原理 seata的隔离级别是读未提交，未提交指的是分布式事务没有提交，并不是本地事务。
首先完整的流程如下图，在提交本地事务前必须要通过Seata Server获取全局锁，其他分布式事务在没有拿到全局锁前不能提交本地事务，如果没有全局锁会导致多个分布式事务同时操作一条数据，发生回滚时数据错乱的问题，但是引入的全局锁会让性能下降的严重，所以AT模式的分布式事务只用在跟钱相关的操作里，其他时候如果需要用到分布式事务可以使用mq的软事务。
![seataAT模式读写隔离原理](https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/seata AT模式读写隔离原理.png)
死锁问题 比如上图两个事务操作同一条数据，事务1中服务A的操作执行完成并且提交了本地事务，此时事务2开始执行服务A的操作，此时全局锁在事务1上，所以事务2的服务A没法提交本地事务，他会等待拿到全局锁，但是这个时候他是持有11001的本地锁的，事务1在执行服务B操作的时候发生异常需要回滚，服务A收到回滚消息需要拿到11001的本地锁，出现了事务1持有事务2需要的全局锁，事务2持有事务1需要的本地锁，循环等待了，seata为了解决这个死锁问题在获取全局锁的时候加了个超时机制，如果超时会回滚数据并释放锁。
使用seata 前提：Seata Server启动好，每个服务对应的库创建好undo_log表。
pom中添加依赖：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 &lt;!-- 引入seata整合分布式事务 --> &lt;dependency> &lt;groupId>com.alibaba.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-alibaba-seata&lt;/artifactId> &lt;exclusions> &lt;exclusion> &lt;groupId>io.seata&lt;/groupId> &lt;artifactId>seata-spring-boot-starter&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;!-- 跟安装的seata-server需要保持版本一致 --> &lt;dependency> &lt;groupId>io.seata&lt;/groupId> &lt;artifactId>seata-spring-boot-starter&lt;/artifactId> &lt;version>1.3.0&lt;/version> &lt;/dependency> 添加配置：
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to 事务-6.seata" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/%E4%BA%8B%E5%8A%A1/6.seata/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>事务-可靠消息最终一致性事务</h2></header><div class=entry-content><p>一些耗时的操作可以使用这个。
步骤5.1失败了：
可靠消息服务更新状态为已发送：一直会有一条状态时待确认的消息； 可靠消息服务删除消息失败：一直会有一条状态是待确认的消息； 不管是那种情况操作失败了，都是比较尴尬的。
步骤7失败：可靠消息服务一直有一条状态是已发送的消息；
可以看出来出现尴尬问题的点都在可靠消息服务上。
解决步骤5.1失败：回调机制，可靠消息服务后台线程定时扫描超时的待确认消息，然后回调上游服务，上游服务返回这条消息对应的业务处理结果是成功还是失败，如果失败就删掉这条消息，如果是成功就执行步骤5.2。
解决步骤6、7失败：可靠消息服务后台线程定时扫描超时的已发送消息，重新投递到消息队列中，不过下游消息要做好幂等性。
一般做这种事务都不要太依赖mq，mq只是作为存储消息的中间件，这样mq的bug不会影响到我们系统，而且以后想换mq或者升级也不会受到影响。
这套方案的缺陷非常明显，可靠消息服务全部基于MySQL，扛不住高并发。数据量也很大，可以用redis或者zk来代替MySQL，定时清理数据。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 事务-可靠消息最终一致性事务" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/%E4%BA%8B%E5%8A%A1/5.%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>全文检索</h2></header><div class=entry-content><p>一般match都是拆词，包含一个词就可以
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 查询title中包含java或者elasticsearch GET /forum/article/_search { "query": { "match": { "title": "java elasticsearch" } } } // 这么写的时候，es把他转换成should语法，像下面这样 GET /forum/article/_search { "query": { "bool": { "should": [ "match": { "title": "java" }, "match": { "title": "elasticsearch" } ] } } } 如果想要必须都包含，也就是并且关系
...</p></div><footer class=entry-footer>3 min</footer><a class=entry-link aria-label="post link to 全文检索" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/es/7.%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>分布式搜索引擎</h2></header><div class=entry-content><p>1.es原理(es是如何实现分布式的) 首先每个节点都有primary shard和replica shard，写数据只能写到primary shard上，读数据可以从primary和replica shard上读。
写数据的时候会随便选择一个协调节点，协调节点通过hash值把请求路由到具体的primary shard所在机器，然后primary shard把数据写到内存的indexing buffer，同时在OS cache中记录trans log，然后同步数据给replica shard，这个时候就可以返回成功了，但是数据还不能被查到。 每秒会有一个refresh操作：再OS cache中新建一个segement file，把indexing buffer刷到segement file中并建立好倒排索引，然后清空indexing buffer，这个时候数据才能被查询到，所以es是准实时的；OS cache中的trans log每5秒会被刷到硬盘中，所以默认情况下es可能会最多丢失5s的数据；当trans log太大或者每半个小时会执行一次flush操作，记录一个commit point然后把trans log清空。 删除的时候会把删除的数据写进del文件，当segement文件太多之后会进行merge操作，把segement文件合成一个大文件，这个时候会把del文件中的数据物理删除。
查询的时候也是根据id计算出数据在那个shard上，然后找对应shard查找，搜索的时候会查找所有shard把符合条件的document的id都返回到协调节点上，然后协调节点在根据doc id去查找对应document再进行筛选，最后返回结果。
2.在大数据量的情况下如何提高查询效率 es的查询优化是没有银弹的！
首先在查询数据的时候，会先去cache中找，如果没有再把磁盘的数据读到filesystem cache中，然后把结果返回，下次再来查找的时候会直接把cache中的数据返回，所以filesystem cache的大小对查询的速度影响是最大的。如果走磁盘的话基本就上秒了。所以要把更多的内存给cache，并且尽可能减少es的document的field大小，就把要用来检索的字段存到es中。检索出来的数据的id再去MySQL或者hbase中查完整的数据。
如果数据量还是很大，可以统计热数据，每隔一段时间主动查询一下热数据，让热数据一直在OS cache中。
在模型设计的时候要避免多次查询，一些join操作把涉及到的数据存到一个document中。
他的分页性能非常差，需要把数据都拿到协调节点上，然后排序，在分页操作，比如查询10000~10010的数据，他会从每个shard中都查询出来10010条数据进行排序然后找到10000~10010的数据，所以翻页越深，性能越差。如果是上拉加载更多那样的可以用scroll api。
3.生产环境的es部署架构？每个索引有多大？每个数据多少个分片？ 我们生产环境部署了3台16g机器，48g的总内存，es进程每个不到8g，OS cache差不多有20多个g。日增数据量差不多八十万条，日增的数据大约120多兆，每个月增量数据大概两千多万，2g左右，两个索引，每个索引6个shard。
4.分词器的二次开发 下载ik分词器源码，然后添加MySQL依赖，然后编写MySQL连接代码，还有查询分词、停用词代码，最后在Dictionary类中添加一个addStopWord()方法，不断查询MySQL调用Dictionary的addStopWord()和addWords()方法就可以了。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 分布式搜索引擎" href=https://wangxiaohong123.github.io/posts/%E9%9D%A2%E8%AF%95/9.%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>创建型-单例模式</h2></header><div class=entry-content><p>什么时候用单例？
比如配置文件这种，存在一份就够了，每次使用都创建实例的话就会浪费资源；
或者一个操作文件的类，每次都创建一个实例去写文件在高并发的场景很可能会相互覆盖；
第二种情况使用分布式锁或者将写操作放到队列中排队消费，但是都很复杂，这些情况都可以使用单例很容易的解决。
我们实现的单例都是类加载器级别的单例，他的作用域介于线程和进程之间，因为java中确定类的唯一是通过类全名+类加载器实例。
饿汉单例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 饿汉是第二简单的实现方法，由于Singleton实例在类加载的时候就已经创建好了，所以是线程安全的 * 缺点就是不支持延迟加载 * 如果类的初始化耗时长还是应该使用这种方法，在用到的时候再去创建反倒会影响系统性能 * @author xiaohong */ public class Singleton { private Singleton() {} private static final Singleton instance = new Singleton(); public static Singleton getInstance() { return instance; } } 懒汉单例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * 懒汉单例也比较简单，并且可以支持延迟加载 * 但是getInstance()方法上有一把锁，这让这个函数的操作都会变成串行，在高并发的时候非常影响性能 * @author xiaohong */ public class Singleton { private Singleton(){} private static Singleton instance; public static synchronized Singleton getInstance() { if(instance == null){ instance = new Singleton(); } return instance; } } 双重检查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * 双重检查就是更细粒度的锁，提升了一点性能 * 网上有人说这种写法会发生指令重排，然后在创建完实例还没初始化（调用构造函数）的时候就会被别的线程使用了，需要加上volatile关键字禁止指令重排 * 其实在高版本java中已经解决了这个问题，在java中把new的操作和初始化的操作设计成立原子操作，不存在编译优化问题 * @author xiaohong */ public class Singleton { private Singleton(){} private static Singleton instance; public static Singleton getInstance() { if(instance == null){ synchronized(Singleton.class){ if(instance == null){ instance = new Singleton(); } } } return instance; } } 静态内部类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 主流的单例模式创建方法 * 由内部类实现，instance的唯一和线程安全都有jvm保证，还支持延迟加载 * @author xiaohong */ public class Singleton { private Singleton(){} private static class SingletonHolder { private static Singleton instance = new Singleton(); } public static Singleton getInstance() { return SingletonHolder.instance; } } 枚举类 查看JAD反编译之后的文件感觉枚举的单例和饿汉模式很像
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 创建型-单例模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>创建型-原型模式</h2></header><div class=entry-content><p>原型模式就是从一个对象创建另一个可定制的对象，而且不需要知道创建的细节。
如果只是申请内存然后再给变量赋值，使用clone的方法提升的性能是可以忽略不计的，但是我觉得如果这种操作很多，比如循环一万次，每次都要创建一个新的实例，这时候可以使用原型模式； 当创建对象的操作比较复杂的时候，比如需要操作数据库、文件、计算hash值等等，这时候使用拷贝的对象就比较快了； 实现原型模式的类要继承Cloneable接口，并重写clone方法，因为继承这个接口也不具备复制对象的能力，需要在重写的clone中调用super.clone()：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Student implements Cloneable { private String name; private Date birth; public String getName(){ return name; } public void setName(String name){ this.name= name; } public Date getBirth() { return birth; } public void setBirth(Date birth) { this.birth = birth; } /** * 重写clone方法 * @return */ @Override public Student clone(){ Student student = null; try{ // 调用Object的clone方法 student = (Student) super.clone(); student.birth = (Date) student.birth.clone(); }catch(CloneNotSupportedException e){ e.printStackTrace(); } return student; } } 使用时直接调用Student的clone方法：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 创建型-原型模式" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>创建型-工厂方法</h2></header><div class=entry-content><p>简单工厂的优点是工厂类中包含了必要的逻辑判断，根据条件动态实例化相关的类，对于客户端来说没有具体类的依赖。工厂方法和简单工厂的区别是工厂方法将类的实例化操作放在子类或者实现类中，而且对于简单工厂来说，说过添加子类需要增加工厂方法中的分支，这也违背了对扩展开放，对修改关闭原则，而且当一个类的创建过程有点复杂，创建这个类会产生大量的重复代码的时候可以提取到工厂方法中创建：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * 工厂方法抽象类 * 当创建类有公用的代码段时可以使用抽象类实现 * * @author xiaohong */ public abstract class FactoryMethod { /** * 创建类实例 * @return */ public abstract MainTestClass getMainTestClass(); } 1 2 3 4 5 6 7 8 9 10 /** * 工厂方法的一个子类 * @author xiaohong */ public class TestClass01FactoryMethod extends FactoryMethod { @Override public MainTestClass getMainTestClass() { return new TestClass01(); } } 测试：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 创建型-工厂方法" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wangxiaohong123.github.io/posts/page/23/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://wangxiaohong123.github.io/posts/page/25/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>