<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 王小红的笔记</title><meta name=keywords content><meta name=description content="Posts - 王小红的笔记"><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><meta property="og:url" content="https://wangxiaohong123.github.io/posts/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wangxiaohong123.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span class=active>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>jvm-内存区域</h2></header><div class=entry-content><p>Java虚拟机规范规定jvm运行时数据区应该包括方法区、堆、虚拟机栈、本地方法栈、程序计数器。其中程序计数器、虚拟机栈和本地方法栈是线程私有的，堆和方法区是所有线程共享的。
内存区域 1 程序计数器 他是当前线程执行的字节码行号指示器，占用内存较小，字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令，比如分支、循环、跳转、异常都需要这个计数器来完成。在单核CPU进行多线程切换时，在切换后需要恢复到正确的执行位置也要依赖这个计数器。
如果执行的是java方法，计数器记录的是正在执行的虚拟机字节码指令的地址，如果是本地方法(Native)，计数器的值就是空，所以我猜执行本地方法的时候不能进行线程切换。程序计数器是唯一一个没有OOM情况的区域。
2 虚拟机栈 虚拟机栈是描述java方法执行的线程内存模型，每个方法执行的时候会创建一个栈针，栈针用来存储局部变量表、操作数栈、动态连接、方法出口等信息，每个方法从被调用到执行完毕的过程对应着一个栈针的入栈到出栈的过程。大部分情况下说得jvm中的栈指的是虚拟机栈中的栈针的局部变量表。
局部变量表里放的是编译期间可知的各种基础数据类型、对象引用(对象引用并不是对象本身，可能是一个指向对象起始地址的指针，也可能是指向一个代表对象句柄或者其他和这个对象相关的位置)和returnAddress类型(指向一条字节码指令的地址)。
这些对象在局部变量表中以局部变量槽(slot)来表示，64位长度的long和double占用两个槽，其他的占用1个槽。所以当进去方法时，需要创建多大的局部变量表是确定的了。
如果线程请求的栈深度超过虚拟机允许的深度会抛出StackOverflowError；当虚拟机栈容量可以扩展时，只会出现扩展到无法申请内存，然后抛出OutOfMemoryError异常，HotSpot虚拟机是不能扩展虚拟机栈的，所以不会因为虚拟机栈无法扩展导致OOM。
3 本地方法栈 本地方法栈和虚拟栈的作用非常相似，虚拟机栈执行的是java方法，也就是字节码服务，本地方法栈执行的是本地Native方法，而且在《java虚拟机规范》中没有强制规定本地方法栈的语言、使用方式、数据结构等，所以每个虚拟机实现的方式都不一样，比如Hot Spot中把虚拟机栈和本地方法栈合二为一了。
4 堆 堆是所有线程共享的空间，堆里面也有一些线程私有的分配缓冲区(Thread Local Allocation Buffer，TLAB)，这个区域是为了对象分配的效率，在高并发的情况下分配堆内存可能会出现两个对象被分配到了同一块内存，解决这个问题有两种方案：一种是CAS不断重试，另外一种就是TLAB，具体那种方案通过**-XX:+/-UseTLAB**参数决定。
堆内存的年轻代、老年代、Eden区……这种分代设计时为了让新生代、老年代收集器搭配工作设计的，但是随着G1的出现之后，这种对于堆的说法仅限分代收集器了。
堆中存放了几乎所有的对象实例，为什么是几乎？不管以后有没有值类型，就现在来说栈上分配、标量替换让对象都在堆中分配变得不是那么绝对了。主流的虚拟机的栈内存都是可扩展的，就是设置-Xmx和-Xms参数，并且堆可以在不连续的内存空间中，但是对于大对象，为了存储高效可能要求连续的内存空间。
5 方法区 方法区也是线程共享的内存区域，它存储的是被虚拟机加载的类型信息、常量、静态常量、即时编译器编译后的代码缓存，《Java虚拟机规范》中把方法区描述成堆的一个逻辑部分，但是他又有个别名叫“非堆(Non-Heap)”，目的是和堆区分开。
永久代和方法区并不是等价的，在Java8之前，HotSpot的设计团队把收集器的分代设计扩展到了方法区，从而出现了永久代这个概念，新生代、老年代、永久代听起来是不是很顺耳，可以说在Java8之前，HotSpot虚拟机使用永久代来实现方法区，目的就是方便管理方法区的内存。
因为永久代的内存是有上限(-XX:MaxPermSize)的，这就导致了HotSpot要比JRockit更容易内存溢出，当时Oracle收购BEA之后想把JRockit和HotSpot合二为一但是因为他俩对方法区的实现差太多了，所以合并失败。
在JDK7的时候，HotSpot把原来永久代中的常量池、静态变量等放到了堆中，到了JDK8，HotSpot彻底放弃永久代，采用在本地内存中实现的元数据空间(Meta-space)来代替，把JDK7剩下的类型信息放到元空间中。方法区也会抛出OOM。
6 运行时常量池 他其实是方法区的一部分，因为它存在于class文件中以常量池表的方式，class文件除了常量池表还有版本、字段、方法、接口描述等信息。常量池表存储的是编译时期生成的字面量和符号引用，在类加载后放到方法区的运行时常量池中，运行时常量池中是具有动态性的，就是说运行期间可以加入新的常量，比如String的intern()方法。会抛出OOM。
7 直接内存 直接内存并不是jvm运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，在JDK1.4的时候加入了NIO，他是基于通道(channel)和缓冲区(buffer)的I/O方式，直接调用Native函数分配堆外内存，然后在堆内存中有一个DirectByteBuffer对象引用这个堆外内存，这样可以避免Native内存和Java堆之间来回复制对象。它主要是收到本机总内存(物理内存、SWAP分区等)的影响也会抛出OOM。
OOM 元数据空间OOM 正常生产环境的元数据空间配置128m或者256m就够用了，如果运行一段时间后元数据空间导致的OOM，原因就是不断的创建类，导致fullGC也无法回收掉动态创建的类，所以使用动态代理模拟元数据空间OOM：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class OomMat { public static void main(String[] args){ long counter = 0; while(true){ Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(Car.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() { public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { if(method.getName().equals("run")){ System.out.println("汽车启动前检查"); return methodProxy.invokeSuper(o, objects); }else{ return methodProxy.invokeSuper(o, objects); } } }); Car car = (Car)enhancer.create(); car.run(); System.out.println("目前创建了" + (++counter) + "个Car的子类"); } } static class Car { public void run(){ System.out.println("汽车启动，开始行使……"); } } static class SafeCar extends Car { @Override public void run(){ System.out.println("汽车启动，开始行使……"); super.run(); } } } 代码中使用无线循环创建Car的子类，jvm进程分配10m应该很快就会发生OOM，jvm参数：
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to jvm-内存区域" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/jvm/2.%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>jvm-垃圾回收器和内存分配</h2></header><div class=entry-content><p>本地方法栈、虚拟机栈和程序计数器会随着线程结束被回收，因为栈针需要多大的内存是确定的，而方法区和堆就有非常多的不确定性，比如一个接口的多个实现类需要的内存是不一样的，同一个方法进入不同分支需要的内存也不一样，所以这两个区域的内存分配和回收时动态的，也是垃圾回收负责的地方。
对象存活判断 很多人说Java虚拟机里使用引用计数算法判断对象是否存活，比如对象中有一个引用计数器，被引用的时候就+1，引用失效的时候就-1，引用计数算法虽然需要花费额外的内存，但是他简单且高效，Python好像用的是这个，不过主流的Java虚拟机没有使用这个算法而是使用可达性分析来确定对象是否存活，因为引用计数看起来很简单，却需要考虑很多情况，必须要做大量的额外处理，比如两个对象的循环引用，其实两个对象都是死去的对象，但是他们的引用计数都不是0，所以不会被回收，一直占着内存。
可达性分析就是先选出一堆GC Root，从这些节点开始根据引用关系向下搜索，搜索过程中走过的路径叫引用链，那么如果一个对象和GC Root之间没有引用链，这个对象就是死去的对象，可以被回收。下面是可以当做GC Root的变量：
虚拟机栈针中本地变量表的引用对象，可以理解成当前运行方法中的入参、局部变量和临时变量 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI(就是Native中的方法)引用的对象 虚拟机内部引用，比如基本数据类型对应的Class对象、一些常驻异常对象(NullPointException)等 被同步锁持有的对象 JMXBean、JVMTI、本地代码缓存等 根据垃圾收集器和当前回收区域的不同还有其他对象临时加入GC Roots 标记为不可达对象后并不会马上进行回收，如果不可达的对象没有重写finalize方法或者这个对象的finalize方法已经被执行过了，就等着被回收，相反就把他放进一个F-Queue队列中，然后会有一个低优先级的Finalizer线程去遍历F-Queue中的对象并执行里面的finalize方法，想要不被回收可以在finalize方法中引用GC Root对象，注意每个对象的finalize方法在生命周期中只会被调用1次。官方已经不推荐重写finalize方法了，因为它运行代价高，而且不能保证对象的调用顺序。
经典回收器： 经典说的是JDK7 update4以前出现的回收器，而在这之后的回收器有着高性能低延迟的革命性改进。分代回收器都是遵循分带理论的：
绝大多数的对象都是朝生夕灭的 熬过越多次数的垃圾收集的对象就越难以消亡 因为这个理论出现了年轻代、老年代的划分，以及发展出了标记-复制算法、标记-清除算法、标记-整理算法。这种分代回收是有问题的，比如说对象之间会存在跨代引用的关系，这就让我们在回收年轻代的时候不得不去遍历老年代的对象，看看是否存在和老年代中的GCRoot有引用链关系的对象，为了解决扫描对象太多的问题在年轻代中维护了一个记忆集的东西，记录老年代中那些内存存在跨代引用，这样是减少了扫描，但是增加了运行时的开销。
1.Serial serial的单线程不仅是使用1个处理器或者1个线程执行垃圾回收工作，最重要的是强调他在回收的时候需要Stop The Word，他的优点就是简单且高效，大部分的系统已经不用这个收集器了，但是目前他还是HotSpot的默认回收器，他在小内存比如桌面应用上回收效率极高，因为没有线程切换的花销。
2.ParNew ParNew是Serial的多线程版本，他俩的区别也只有线程数，像控制参数(-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等)、回收策略、算法、对象分配规则都完全一样。单核服务器下他是没有Serial好用的，可以使用-XX:ParallelGCThreads调整垃圾收集的线程数，默认是处理器核心数。目前只有ParNew和Serial能和CMS配合使用，因为其他收集器没有分代框架。在JDK9之后去掉了-XX:+UseParNewGC参数，可以理解成ParNew合并到了CMS中。
3.Parallel Scavenge（吞吐量优先收集器） 他也是使用标记-复制算法，也是年轻代的垃圾收集器，和ParNew不同的是他可以控制运行业务代码的吞吐量，吞吐量的公式：
$吞吐量=\frac{运行业务代码时间}{运行业务代码时间 + 运行垃圾收集时间}$
-XX:MaxGCPauseMillis参数要求是大于0的毫秒数，收集器会尽量保证收集的时间小于这个设定值，这个值直接影响回收频率。
-XX:GCTimeRatio参数要求正整数，表示期望虚拟机在GC上消耗的时间不超过程序运行时间的1/(1+n)，默认是99，意思就是垃圾收集器运行的时间不超过总运行时间的1%，也就是程序执行时间是垃圾回收执行之间的99倍以上。
-XX:+UseAdaptiveSizePolicy，他是个开关，如果打开就不需要手动设置-Xmn、E区和S区的比例、晋升老年代对象大小等等，虚拟机会根据当前运行情况的性能监控信息动态调整。
4.Serial Old 使用标记-整理算法，JDK5之前和Parallel Scavenge配合使用，目前应该是CMS失败的降级方案。
5.Parallel Old 他是Parallel Scavenge的老年代版本，因为在JDK6之前Parallel Scavenge只能搭配Serial Old，这个非常慢，所以JDK6出了Parallel Old，他也使用的标记-整理算法。
6.CMS CMS是获取最短回收停顿时间的回收器，他默认基于标记-整理算法，如果指定了CMS收集器(-XX:+UseConcMarkSweepGC)新生代收集器会默认选择ParNew。整个过程分成4步：
初始标记：标记被gc root直接关联的对象，这步会有stw，但是很快； 并发标记：和系统并行，从上一步标记的对象中开始遍历进行标记所有垃圾对象，因为系统也在运行，所以可能有新对象进来，或者标记过的对象变化了，CMS都会记录，这步是最慢的，而且会占用CPU，使用线程数计算公式：(核数 + 3)/4； 重新标记：把第二阶段变化的对象通过可达性分析标记成垃圾对象，会有stw，但是也很快； 并发清除：和系统并行，清除垃圾对象； CMS的缺点非常多，由于并发时使用的线程数是(核数 + 3)/4，所以核数越少，占用的资源就越多，比如4核就要占用25%的资源；而且他没有办法处理浮动垃圾，浮动垃圾就是在回收时产生的垃圾，虽然在并发清除前还要在标记一次，但是并发清除时产生的垃圾没有办法回收，所以使用CMS的堆不能等到内存满了在回收，可以通过**-XX:CMSInitiatingOccupancyFraction=92**参数调整使用内存达到某个百分比时进行GC，这个参数如果设置的越大就越容易导致并发失败。如果在垃圾回收时内存满了会导致并发失败，系统会自动切换成Serial Old回收器，这个时候就要stw了；
最后一个缺点就是他的算法，默认是标记-整理，因为有个参数**-XX:CMSFullGCsBeforeCompaction=5(JDK9之后废弃)来控制回收几次后进行整理，默认是0，如果设置的参数大于0那就是标记-清除算法了，标记-清除会有大量内存碎片，标记-整理又会增加停顿时间，还有个参数是-XX:+UseCMSCompactAtFullCollection(JDK9之后废弃)**，这个参数的意思是在FullGC时开启内存碎片的整理，因为需要移动存活对象，所以不能并发，他也会增加停顿时间。
7.G1回收器 G1最早在JDK6update14的时候开始进入实验阶段，JDK7update4的时候进行商用直到JDK8的update40G1完成了并发的类卸载的最后一块功能拼图，在JDK9之后被当做默认的垃圾回收器。
G1虽然也是遵循分代理论，但是没有年轻代和老年代的界限，所有对象都放到一起，还多了一个大对象(Humongous)区域(只要超过了region的一半就算大对象)。region的大小通过**-XX:G1HeapRegionSize**参数决定，范围是1M~32M，且要是2的n次幂。
他只有两个回收情况，年轻代RegionGC和mixedGC，G1的垃圾回收算法都是使用复制清除算法，同样在年轻代中还是有两个survivor区的概念，只不过所有的区域都没有明显的划分。G1将堆内存划分为2048个region，默认初始会给年轻代5%个region，老年代0个，大数据也是0个，当年轻代的region数超过60%（默认）时进行一次regionGC，当老年代的region数超过45%（默认）时进行一次mixedGC，mixedGC包括老年代、年轻代和大数据区，G1的回收时的四个阶段：
初始标记：标记直接被gc root关联的对象，并且修改TAMS指针的值，这个也需要停顿，但是他是在MinorGC的时候同步完成的，不会有额外的停顿。 并发标记：遍历上一步标记出来的对象，找到满足回收条件的对象，扫描完成后还要处理SATB记录下的在并发时有引用变化的对象。 最终标记：std并且标记上一步遗留的SATB(原始快照)记录。 筛选回收：更新region的统计数据，对每个region的回收价值进行排序(能够回收多少空间和回收的时间)，根据用户期望的停顿时间制定回收计划，然后把选中要回收的region中存活对象复制到空region中，最后清空region。 G1是收集器技术的里程碑，从G1开始，收集器开始放弃每次回收整个堆，而是每次回收一小部分，只要保证回收的速度大于分配的速度就能让系统稳定运行。但是G1的记忆集、卡表这些指针会花费更多的内存。G1和CMS都是通过写屏障来维护卡表，但是CMS的卡表里只有和新生代有关联的对象，而G1维护的东西就多了，所以G1会更消耗资源。通常在小内存的时候CMS的性能要比G1好，6G或者8G以后使用G1要好。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to jvm-垃圾回收器和内存分配" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/jvm/4.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>jvm-对象的创建和布局</h2></header><div class=entry-content><p>对象的创建包括new关键字、复制、反序列化等等。
new关键字对象的创建 第1步 类加载 这里的new关键字不包括数组和Class对象，当虚拟机遇到一条字节码new指令时，首先会根据关键字的参数去常量池中找这个类的符号引用，然后在检查这个符号引用的类是否已经被加载、解析和初始化过，如果没有就先进行类加载。
第2步 分配内存 类加载完之后需要多大的内存就可以确定了，这个时候就要为对象分配内存，如果堆中的内存是规整的，所有用过的内存放到一边，没用过的在另一边，那么分配内存就是把指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式叫做指针碰撞(Bump The Pointer)；如果堆中的内存是不规整的，就必须要维护一个列表记录那些内存块是可用的，这种方式叫空闲列表(Free List)。
至于堆是否规整由垃圾回收器决定，比如ParNew使用的就是指针碰撞，因为他在GC的时候有收集整理的能力，而CMS这种基于清除算法的收集器使用的就是空闲列表。
第3步 设置对象 分配完内存之后把分配到的内存空间都设置成0，如果使用了TLAB的话会在分配TLAB时设置，设置成0是为了保证对象中的变量不需要赋初始值就能直接使用。然后还有一堆设置，比如对象属于哪个类、类的元数据信息、GC的分带年龄等。
第4步 调用构造方法 这个时候一个对象就已经生成了，但是对于java程序来说，对象的创建才刚开始，还需要在调用对象的构造方法，也就是class文件中的init()方法，是否调用构造方法由字节码中的new指令后面是否有invokespecial指令决定，编译器在编译时遇到new关键字会自动生成这个指令，如果通过其他方式产生的对象不一定会有这个指令，调用完构造方法之后对象才算被完整的构造出来。
对象的内存布局 在HotSpot虚拟机里，对象的内存布局可以分成3部分：对象头、实例数据和对齐填充。
对象头 对象头分成两类：一类是存储运行时的数据，另一类是指向类型元数据的指针，运行时的元数据在32位和64位的虚拟机中分别占32和64比特，官方称他为Mark Word：
存储内容 标志位 状态 对象hash码、对象分代年龄 01 未锁定 指向锁记录的指针 00 轻量级锁定 指向重量级锁的指针 10 重量级锁定 空 11 GC标记 偏向线程ID、偏向时间戳、对象分代年龄 01 可偏向 对象运行时的数据有的已经超过了32或者64bit能记录的最大限度，所以Mark Word被设计成了一个动态定义的数据结构，比如32位的HotSpot虚拟机中，如果对象没有被同步锁锁定，32个bit中25个bit存储hash码，4个bit存储分代年龄，2bit存储锁标志位，还有1bit固定是0。
指向类型元数据的指针是为了判断对象是哪个类的实例，单并不是只能通过这个指针查找元数据信息，通过元数据信息还可以计算出对象的大小，因为数组的长度是不确定的，所以数组的对象头中需要记录数组的长度。
实例数据部分 这部分存储的是代码中定义的各种类型的字段内容，包括从父类继承下来的，longs/doubles->ints->shorts/chars->bytes/booleans->oops(Ordinary Object Pointers)，同时父类的long会出现在子类的long之前。可以通过**-XX:FieldsAllocationStyle调整顺序策略，如果配置了-XX:CompactFields=true**那么子类比较窄的变量会插到父类变量的空隙中来节约内存。
对齐填充 由于HotSpot要求对象的大小必须是8的整数倍，对象头已经是8的整数倍了，如果实例数据不是8的整数倍就需要通过对齐填充来补全。
对象的定位 对象主要通过栈上的reference数据来操作堆上的具体对象，但是reference指向有两种：
句柄池：在堆内存中需要一块单独的区域来当句柄池，句柄中包含的对象的类型数据和实例数据，reference如果存储的是对象的句柄地址，在定位对象的时候会先找到句柄，然后在去查找对象，这个样有个好处就是对象地址改变的时候只需要修改句柄中的实例数据指针，不需要修改所有对象的引用指针，坏处就是不好的地方就是多一次指针定位。 直接指针：reference中存储的就是对象地址，减少一次指针定位的开销，HotSpot主要是用的就是这种方式。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to jvm-对象的创建和布局" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/jvm/3.%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%B8%83%E5%B1%80/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JVM参数</h2></header><div class=entry-content><p>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 # 初始堆内存 -Xms512M # 最大堆内存 -Xmx512M # 初始年轻代内存 1.8:-XX:NewSize -Xmn256M # 1.8最大年轻代内存 -XX:MaxNewSize=256M # 虚拟机栈内存 -Xss1M # 初始元空间内存 -XX:MetaspaceSize=128M # 最大元空间内存 -XX:MaxMetaspaceSize=128M # 设置Eden区和两个survivor区比例，当前意思是7:1:1默认8:1:1 -XX:SurvivorRatio=7 # 配置年轻代对象躲过多少次minorGC后进入老年代，默认15次 -XX:MaxTenuringThreshold=10 # 超过多少字节的对象直接进入老年代 -XX:PretenureSizeThreshold=1048576 # 当年轻代所有对象大于老年代剩余空间时，判断之前每次进入老年代的对象大小如果都比老年代剩余内存小，就不进行老年代垃圾回收（fullGC），否则进行老年代垃圾回收 JDk1.6之后默认开启 -XX:-HandlePromotionFailure=true # 设置jvm对新生代GC的垃圾回收器为ParNew -XX:+UseParNewGC # 设置jvm对老年代GC的垃圾回收期为CMS -XX:+UseConcMarkSweepGC # cms初始标记阶段开启多线程执行 -XX:+CMSParallelInitialMarkEnabled # 在cms重新标记阶段之前执行一个yongGC -XX:+CMSScavengeBeforeRemark # 调节ParNew回收时使用的线程数（默认与CPU核数相同） -XX:ParallelGCThreads=4 # 当老年代剩余可用空间不足92%时，进行fullGC -XX:CMSInitiatingOccupancyFraction=92 # fullGC之后停止系统所有线程，进行老年代空间整理 -XX:+UseCMSCompactAtFullCollection # 每多少次fullGC之后进行一次空间整理 -XX:CMSFullGCsBeforeCompaction=5 ##################################G1相关################################## # 使用G1回收器 -XX:+UseG1GC # 设置为G1回收器时，新生代默认初始堆内存占比 -XX:G1NewSizePercent # -XX:G1HeapRegionSize # 新生代占比最多为 -XX:G1MaxNewSizePercent # G1回收时最多消耗时间 -XX:MaxGCPauseMills # 默认是45%，当老年代的region数超过总region数的45%，进行年轻代和老年代和大对象的混合垃圾回收 -XX:InitiatingHeapOccupancyPercent # 配置混合回收次数，默认8次 -XX:G1MixedGCCountTarget=8 # -XX:G1HeapWastePercent # region中的存活对象低于多少时才可以回收，默认是85% -XX:G1MixedGCLiveThresholdPercent ######################################################################## # 打印详细的gc日志 -XX:+PrintGCDetils # 打印出来每次GC发生的时间 -XX:+PrintGCTimeStamps # 设置将gc日志写入一个磁盘文件 -Xloggc:gc.log # 禁止显示执行GC System.gc() -XX:+DisableExplicitGC # 在OOM时生成快照文件 -XX:+HeapDumpOnOutOfMemoryError # 生成的OOM快照位置 -XX:HeapDumpPath=/usr/local/app/oom # 关闭锁粗化 -XX:-EliminateLocks # 堆外内存大小 -XX:MaxDirectMemorySize 查看服务启动参数：jps -lv
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to JVM参数" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/jvm/jvm%E5%8F%82%E6%95%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LinkedBlockingQueue</h2></header><div class=entry-content><p>一个有界队列，初始化的时候如果传capacity就会设置成参数大小，如果没有就设置成int的最大值。他有两把可重入锁，一个putLock，一个takeLock，这两个lock还对应着两个condition，为什么叫阻塞队列呢？因为当put的时候，如果链表的大小等于capacity，会把线程放到锁的wait队列中去，这样不就是阻塞的了吗。take也是一样的，capacity是0的时候就会阻塞住。
put
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public void put(E e) throws InterruptedException { if (e == null) throw new NullPointerException(); // Note: convention in all put/take/etc is to preset local var // holding count negative to indicate failure unless set. int c = -1; Node&lt;E> node = new Node&lt;E>(e); final ReentrantLock putLock = this.putLock; // count就是链表的节点数量，使用AtomicInteger保证并发安全 final AtomicInteger count = this.count; // 加锁，lockInterruptibly在加锁成功之前是可以被中断的 putLock.lockInterruptibly(); try { while (count.get() == capacity) { notFull.await(); } // 入队，就是修改一下last的指针 enqueue(node); // 节点数量增加 c = count.getAndIncrement(); if (c + 1 &lt; capacity) // 唤醒等待put的线程 notFull.signal(); } finally { putLock.unlock(); } // 在这里应该是添加加成功了的， // 因为数量自增使用的getAndIncrement，所以当链表中没有元素，然后添加第一个元素走到这里 // 此时count是1，c是0，也是就是put之前，在这里判断，如果put之前链表没有元素，name可能有线程take被阻塞了 // 所以唤醒take的wait线程 if (c == 0) signalNotEmpty(); } 他的Iterator的next和remove是把putLock和takeLock都锁上。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to LinkedBlockingQueue" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/11.linkedblockingqueue/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LinkedHashMap</h2></header><div class=entry-content><p>LinkedHashMap就是有序的。他是HashMap的子类，正常的LinkedHashMap操作都会走到HashMap中去，LinkedHashMap重写了newNode的方法：
1 2 3 4 5 6 7 Node&lt;K,V> newNode(int hash, K key, V value, Node&lt;K,V> e) { LinkedHashMap.Entry&lt;K,V> p = new LinkedHashMap.Entry&lt;K,V>(hash, key, value, e); // 在链表结尾插入 linkNodeLast(p); return p; } TreeMap TreeMap就是一个红黑树，默认按照key排序，可以指定Comparator指定排序。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to LinkedHashMap" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/1.%E9%9B%86%E5%90%88/5.linkedhashmap/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LinkedList</h2></header><div class=entry-content><p>核心node，基于前后指针的双向链表：
1 2 3 4 5 6 7 8 9 10 11 private static class Node&lt;E> { E item; Node&lt;E> next; Node&lt;E> prev; Node(Node&lt;E> prev, E element, Node&lt;E> next) { this.item = element; this.next = next; this.prev = prev; } } 添加
...</p></div><footer class=entry-footer>3 min</footer><a class=entry-link aria-label="post link to LinkedList" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/1.%E9%9B%86%E5%90%88/2.linkedlist/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>linux-1.简介</h2></header><div class=entry-content><p>常见CPU架构 精简指令集(RISC)：这种CPU中的每个指令的运行时间都很短，指令集比较精简，如果要执行复杂的指令需要多个指令组合，常见的有：
甲骨文(Oracle)的SPARC系列，用在学术领域的大型工作站，有的银行的主服务器。 IBM公司的Power Architectrue(包括PowerPC)系列，索尼的PS3系列最早用的就是这个，现在不知道了，06年之前Mac也是用的这个CPU，06年到20年Mac使用的是Intel的x86架构CPU。 ARM的CPU，一些手机、导航、路由器很多使用的都是这个，应该是目前使用最广泛的。 复杂指令集(CICS)：他的指令多而且复杂，每个指令都可以执行一些低级的硬件操作，常见的有AMD、Intel、VIA等x86架构的CPU。因为现在的电脑除了AMD就是Intel，所以也被成为x86架构电脑。
x86架构：Intel最早研发的CPU叫8086，后来又是80286、80386，所以这中架构就被成为x86，最开始也是从8位一直到升到32位，后来AMD在这个架构的基础上改成了64位，64位的电脑CPU改成了x86-64。这里的8、16、32、64是指bit，是CPU一次读取的数据的最大量，32就是每次读取32位，转成内存就是1G，64位就超级大了。
UNIX系统的历史 在1969年之前计算机只有科学、军事这些领域才能用，并且非常慢，操作方式也是读卡机+打印机，程序员把信息在读卡纸上打洞，然后然后计算机把结果输出到打印机。在6几年的时候麻省理工(MIT)开发了兼容分时系统，这个系统就是提供多个终端共同使用一个主机，其实就是CPU在终端之间切换，可以说是近代操作系统的鼻祖了，但是这样有个问题就是终端没有计算能力，而且最多只支持30个终端。
1965年贝尔实验室(Bell)+麻省理工+通用电气公司(GE)发起了Multics计划，目的是让主机支持300个以上的终端联机使用，到了69年资金紧张，Bell也退出了，但是最后Multics计划成功了，不过没被重视。汤普森是Multics计划的一员，最开始他是想把太空旅游的游戏移植到EDC公司推出的PDP-7主机上，因为这个主机没人用，他花了4个星期用汇编语言写了一个内核程序，其实就是把Multics各种简化，所以最开始被叫做Unics，后来因为这个系统太好用了，贝尔实验室都在用，不过他有个缺点，就是安装到不同的机器都需要重写，然后汤普森和李奇用B语言重写，但是性能不好，李奇又用C语言重写了，命名UNIX。
C语言写的版本到现在还在使用，真的牛逼，谁能想到UNIX的诞生是因为一个游戏，如果想做的现实中还没有，自己动手搞一个来玩。
UNIX虽然没有版权问题，没加公司都可以二开自己的UNIX，但是只能支持自己的硬件，后来79年的时候AT&amp;T(Bell实验室的母公司)退出的system v第七版开始支持x86架构，同时也提出不能对学生提供源代码，因为他想把版权收回去，直到现在为止纯种的UNIX也是指System V+BSD(UNIX的一个分支)。86年的时候有一个大学教授自己写了一个Minix，删减版的UNIX，写的时候没有参照UNIX，但是还兼容UNIX上的软件，他当时是为了教学，并且没有时间完善，所以这个系统没有迭代，但是当时确实很好用。
GNU计划 斯托曼在1984年发起GNU计划，当时的黑客是指计算机能力很强的人，不是破坏计算机的骇客。当时黑客都喜欢分享，互相学习代码，当时UNIX已经是专利软件了，但是架构还是开放的。斯托曼最开始就要写个开放的系统，但是太复杂，他自己写不完，所以开始抄UNIX上的付费软件，他写的就是完全免费，后来大家发现功能都差不多，但是GNU的软件全免费，用的人就多了，出名的有c语言编译器GNU C Compiler(gcc)、很多C语言函数库、可以运行操作系统基本接口的eBash Shell。
gcc是斯托曼成立的自由软件基金会(FSF)，请了很多志愿者工程师一起开发的。为了避免GNU的软件被别人变成专利软件，1985年他找律师草拟了通用公共许可证(GPL)，也被成为copyleft，对应专利软件的copyright。GNU其实开发出来一个内核叫hurd。
GNU这个名称的解释非常有意思，就是GNU is not UNIX，那GNU是什么呢？就是GNU is not UNIX，无穷递归。
GPL说得是开放源码，进制修改授权，进制销售，但是室友商业空间的，目前大部分的Linux开发商都是卖售后服务的。GPL只是开源授权的一种，可以参考OSI协会的介绍。
LInux的发展 Linux的诞生也是作者托瓦兹为了玩写的，他在上学的时候抢不到机器，然后就买了一台intel 386机器，装上了Minix系统，当时学校的计算机属于工作站类型了，是可以进行多任务的，个人计算机就不行，就现在来讲，如果在一个CPU上同时打开多个程序也要比先打开一个在打开另一个要慢，因为来回切换任务需要消耗资源。所以托瓦兹参考Minix源码写了一个小内核，实现了286机器上的多任务处理，然后放到一个FTP网站上开源，网站的管理员把目录起名为Linux(Linus UNIX的意思)，第一个版本的Linux就诞生了，第一个内核版本起名0.0.2，不是0.0.1。
为了能兼容UNIX系统，托瓦兹有参照POSIX规范(可移植操作系统规范，由美国电器与电子工程协会IEEE发布)改写，他的思想和Minix完全相反，如果当时Minix和hurb能满足托瓦兹，说不定就不会有Linux了。
最开始Linux的问题托瓦兹还能维护一下，后来问题越来越多，而且他也没钱，比如出现某个硬件不适配，他又没有这个硬件就解决不了，这个时候就会有志愿者跳出来说这个硬件我有，我来改写，然后托瓦兹简单测试一下就合到了内核代码中，思想就是现有且能运行，然后在优化，功能多了之后就开始模块化，大概意思就是分驱动，在后来测试也测不过来了，就有志愿者出来测试，然后把结果发给托瓦兹。Linux的官网：https://kernel.org/
这种开发模式让Linux的发展非常快，1994年正式版1.0就出来了，1996年2.0，2011年3.0,2015年4.0。在2.0版本的时候把企鹅作为Linux的吉祥物，因为托瓦兹小时候被企鹅咬过一口。
Linux的出现让GNU彻底放心了，他们可以不运行在UNIX上了，因为Linux是GNU GPL授权模式，又参考了POSIX规范，斯托曼认为应该叫GNU/Linux。
版本 内核版本 内核版本类似于下面这样：
3.10.0-957.21.3.el7.x86_64 ==> 主版本.次版本.发布版-修改版本，例子里主版本就是3，次版本是10，发布版本0，修改版本957。
在3.0版本之前，主版本和次版本都是偶数叫稳定版，不会改变内核架构，只会在这个基础上修复问题。相反就是开发版，一般会增加内核级代码。在3版本只后没有开发版和稳定版这说了，每一个版本都叫主线版本(mainLine)，一般的主线版本开发结束之后就不在维护了，一般2到3个月推出一个主线版本，有一些版本是在长期维护的，这种版本叫长期维护版本(Longterm)，官网给出的长期维护版本有4.9、4.14、4.19、5.4、5.10、5.15。
使用uname -a查看系统信息
1 2 3 4 5 # 节点名称 iZ2ze7bb75hzl5dpgd13uhZ # 发行版本 3.10.0-957.21.3.el7.x86_64 # 内核版本 1 SMP Tue Jun 18 16:35:19 UTC 2019 # 系统CPU体系结构 x86_64 Linux iZ2ze7bb75hzl5dpgd13uhZ 3.10.0-957.21.3.el7.x86_64 #1 SMP Tue Jun 18 16:35:19 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux 发行版本 为了让用户能够使用Linux，很多非盈利团队或者商业公司把内核和一些软件打包到一起，可以使用网络或者光盘安装的程序叫做发行版(Distribution)，各大开发商的发行版其实差异性不大，因为内核相同，软件也都是当下主流的，而且他们还需要遵守LSB标准和目录结构标准(FHS)。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to linux-1.简介" href=https://wangxiaohong123.github.io/posts/linux/1.%E7%AE%80%E4%BB%8B/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>linux-2.文件和目录管理</h2></header><div class=entry-content><p>用户和用户组 Linux是多人多任务系统，可能同时有多人使用服务器，考虑每个人的隐私权限和每个人喜好的工作环境，这样每个用户都可以把自己的文件权限设置成自己可见，就保证了隐私。用户组主要是为了团队协同工作，这样既能保证每个人的隐私，又能实现多人共同维护服务。
用户组就相当于一个家庭，谁都可以在客厅玩、吃饭、看书，用户相当于每个人自己的卧室，需要得到本人的允许才能进入，others就是陌生人，连进到客厅都需要得要允许。
root用户就是天神，所有文件对于他来说都没有权限。
所有的账号信息都在**/etc/passwd文件里，个人的密码在/etc/shadow文件里，所有的组名在/etc/group**文件里。
文件权限 执行ls -al查看文件权限，他的缩写是ll，执行之后可以得到类似下面的内容：
1 2 -rw-r--r-- 1 root root 1879158 4月28 17:17 test.sql # 权限 连接 用户 用户组 文件大小 修改日期 文件名 ls是list的意思。链接就是有多少文件名链接到了这个节点(inode)。文件大小的默认单位是byte。如果文件名前面多个[.]表示隐藏文件。
ls的更多更多用法使用ls --help或者man ls或者info ls查看。
文件类型 常规文件：[-]表示常规文件，按照文件内容可以分成3类： 纯文本文件，纯文本文件的内容我们可以直接看到，比如数字、字母。 二进制文件，linux中可以执行的文件就是二进制文件，不包括脚本，比如他一些命令，就是一个为进制文件。 数据文件，有些程序在运行的时候会读取某些特定格式的文件，比如在用户登录的时候会记录登录数据在/var/log/wtpm里，如果使用cat查看就是乱码，可以使用last命令查看。 目录：就是文件夹。 链接文件：类似windows的快捷方式， 设备和设备文件：和系统周边及存储相关的文件，一般都在/dev下，通常可以分成两类： 区块设备，提供系统随机读写的接口设备，比如硬盘。 字符设备，一些串行端口的接口设备，鼠标键盘这种，这些设备的特点就是一次性读取，不能断，比如说可以让鼠标移动到一个位置，但是不能让鼠标跳到一个位置。 数据接口文件：一般是网络上的数据交换，在/run或者/tmp目录里。 数据输送文件(FIFO,pipe)：他是为了解决多个程序同时写一个文件的问题，FIFO全称是first-in-first-out，就是管道。 可以使用man fifo和man socket查看数据输送文件和数据接口文件的说明。
权限说明 权限栏一共有10个字符，第一个字符表示这个文件是目录、文件还是链接，如果是[d]就表示目录，如果是[-]就表示文件；如果是[l]就表示链接文件；如果是[b]就表示可以存储的周边设备；如果是[c]就表示串行端口设备；[s]表示数据接口文件；[p]表示数据传送文件。
后面的9个字符每3个一组，均为[rwx]的组合，位置不会变，如果没有权限就是[-]。
文件权限 [r]代表可读，就是读取文件的文字内容。 [w]代表可编辑，新增、修改、删除内容，但是不能删除文件。 代表可执行，跟扩展名无关，只要有x属性就可以执行。 第一组是文件拥有者的权限，第二组是所属用户组的其他账号的权限，第三组是没有加入用户组的其他账号的权限。
目录权限 [r]代表查看目录里的文件。 [w]代表可以创建新的目录和文件、删除文件或者目录、移动目录里的文件或者目录。 代表可执行，跟扩展名无关，只要有x属性就可以执行。 修改文件属性和权限 chgrp [-R] groupName dirname/filename修改文件所属用户组，-R表示递归修改，把子目录下的所有文件、目录都改成这个用户组，同时group name需要在/etc/group文件中存在。
...</p></div><footer class=entry-footer>3 min</footer><a class=entry-link aria-label="post link to linux-2.文件和目录管理" href=https://wangxiaohong123.github.io/posts/linux/2.%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>linux-3.磁盘和文件系统</h2></header><div class=entry-content><p>磁盘的物理组成：
原型碟片：记录数据。 机械手臂：包括手臂和磁头(擦写碟片上的数据)。 主轴马达：可以转动碟片。 扇区：最小的物理存储单元，有512B和4k两种格式。 柱面：扇区组成的一圈。早起分区以柱面为单位，现在使用扇区。 磁盘分区表：一种是限制比较多的MBR(Master boot record)，一种是比较新的GPT，MBR中第一个扇区最重要，里面放的主引导记录(MBR，446B)+分区表(64B)，目前最新的是GPT分区表。 磁盘文件名：
物理磁盘的文件名一般都叫/dev/sd[a-p][1-128] 虚拟磁盘的文件名一般是/dev/vd[a-d][1-128] 如果是磁盘阵列的话一般是/dev/md[0-128] LVM一般是/dev/VGNAME/LVNAME这种 分区之后一般都需要格式化一下，因为每个系统使用的文件系统不一样，比如win98以前用FAT，win2000之后用NTFS，Linux正统文件系统是ext2，一些发行版的Linux使用其他文件系统，比如CentosOS7使用xfs文件系统。
文件系统 文件系统特性 linux的文件系统可以分成6个区块的数据：
超级区块的数据：记录文件系统的整体信息，比如inode和数据区块的总量、使用量、剩余量、文件系统的格式和相关信息。 inode：记录文件信息，比如文件的属性(时间、属组)、权限、文件数据所在区。一个文件占用一个inode。每个inode是128B或者256B。 数据区块：实际记录文件内容，文件太大的时候会占用多个区块，并且一个区块只能写一个文件，如果有剩余空间就浪费了。 文件系统描述：描述每个区块群组的开始、结束区块，以及inode、超级区块等介于那个区块之间。 区块对照表：记录空的区块。 inode对照表：记录使用和未使用的inode号。 上面除了超级区块的5个组成一个区块群组(block group)，一个文件系统只有一个超级区块的数据，如果有多个也是这个的备份。
Linux在读取文件的时候先根据inode把数据所在的区块都读出来，而FAT格式的文件系统，比如U盘是没有inode的，他只是在数据区块中记录下一个数据区块的编号，所以没法一次读取，只能一个一个读，这样就会有个问题，磁盘转一圈可能没读完，需要转好几圈，所以这种系统可以经常清理磁盘碎片，让同一个数据区块挨的进点，方便读取。
可以使用dumpe2fs [-bh] 设备文件名查看超级区块信息，但是xfs是不支持这个命令的：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 # 打印块设备属性，可以看到我的是ext4 blkid # /dev/vda1: UUID="1114fe9e-2309-4580-b183-d778e6d97397" TYPE="ext4" # -b 列出保留为坏道的部分 # -h 只显示超级区块信息，不展示其他区段内容 dumpe2fs /dev/vda1 dumpe2fs 1.42.9 (28-Dec-2013) # 文件系统名称 Filesystem volume name: &lt;none> # 上一次挂载的目录位置 Last mounted on: / Filesystem UUID: 1114fe9e-2309-4580-b183-d778e6d97397 Filesystem magic number: 0xEF53 Filesystem revision #: 1 (dynamic) # 文件系统特性 Filesystem featrues: has_journal ext_attr resize_inode dir_index filetype needs_recovery extent flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize Filesystem flags: signed_directory_hash # 默认挂载参数 Default mount options: user_xattr acl # 文件系统状态，如果是dirty就说明有被修改过的文件但是还在内存，没有刷到粗盘 Filesystem state: clean Errors behavior: Continue Filesystem OS type: Linux # inode总数 Inode count: 2621440 # 区块总数 Block count: 10484164 # 保留区块总数 Reserved block count: 471777 # 可用区块数量 Free blocks: 5941100 # 可用inode数量 Free inodes: 2484489 First block: 0 # 单个区块的大小 Block size: 4096 Fragment size: 4096 Reserved GDT blocks: 1021 Blocks per group: 32768 Fragments per group: 32768 Inodes per group: 8192 Inode blocks per group: 512 Flex block group size: 16 Filesystem created: Thu Jul 11 10:52:00 2019 Last mount time: Thu Mar 10 16:03:03 2022 Last write time: Fri Mar 11 00:03:02 2022 Mount count: 6 Maximum mount count: -1 Last checked: Thu Jul 11 10:52:00 2019 Check interval: 0 (&lt;none>) Lifetime writes: 3907 MB Reserved blocks uid: 0 (user root) Reserved blocks gid: 0 (group root) First inode: 11 # inode容量 Inode size: 256 Required extra isize: 28 Desired extra isize: 28 Journal inode: 8 First orphan inode: 1050033 Default directory hash: half_md4 Directory Hash Seed: 0163c9aa-b271-4625-b08d-5a774c70359e # 日志相关信息 Journal backup: inode blocks Journal featrues: journal_incompat_revoke 日志区块总大小: 128M Journal length: 32768 Journal sequence: 0x0380a708 Journal start: 14867 # 第一区块群组信息 Group 0: (Blocks 0-32767) [ITABLE_ZEROED] Checksum 0x0314, unused inodes 8175 # 主要超级区块位置 主 superblock at 0, Group descriptors at 1-3 保留的GDT块位于 4-1024 Block bitmap at 1025 (+1025), Inode bitmap at 1041 (+1041) Inode表位于 1057-1568 (+1057) 14316 free blocks, 8177 free inodes, 2 directories, 8175个未使用的inodes # 那些区块可用 可用块数: 11727-12287, 12301, 12318, 12336, 12352, 12374, 12390, 12409, 12426, 12440-12719, 13296-13708, 14304-17854, 18201-25833, 27287-28583, 30376-30604, 32424-32767 可用inode数: 12, 14, 18-8192 # 其他区块群组信息 Group 1: (Blocks 32768-65535) [INODE_UNINIT, ITABLE_ZEROED] …… xfs系统相比ext2、ext3、ext4来说多了两个区，他的数据区(data section)可以理解成ext系列的所有区块，但是不包括ext3和ext4的日志，xfs的文件系统活动区(log section)就是用日志用来记录文件的变化，xfs的实时运行区(realtime section)是用来实时分配inode和区块的，这也是他和ext系列系统的最大区别。可以使用xfs_info 挂载点/设备文件名命令查看xfs文件系统信息。
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to linux-3.磁盘和文件系统" href=https://wangxiaohong123.github.io/posts/linux/3.%E7%A3%81%E7%9B%98%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wangxiaohong123.github.io/posts/page/18/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://wangxiaohong123.github.io/posts/page/20/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>