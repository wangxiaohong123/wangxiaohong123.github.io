<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 王小红的笔记</title><meta name=keywords content><meta name=description content="Posts - 王小红的笔记"><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><meta property="og:url" content="https://wangxiaohong123.github.io/posts/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wangxiaohong123.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span class=active>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>服务治理-1.异常治理</h2></header><div class=entry-content><p>治理就是说捕获和上抛异常、处理异常、封装和定义异常(规范化异常)。线上的而系统出现异常一般都是堆外提供的接口处，大概有4个地方：http接口：对应前端的一个功能。rpc接口：给其他系统调用的一个功能。mq消费。调度线程。
错误码规范 code总长度为6位：
前两位是微服务或者通用异常，比如客户端异常异常(缺少参数、请求类型错误)10，探索服务是11，动态服务是12。 中间两位是每个服务对应的模块或者域。 后两位递增表示具体异常。 通常来说每个系统要有自己的异常类，这样看日志就知道出现问题的系统是哪个。
统一异常拦截 异常都会在出口处理，把异常封装成统一的实体返回，mq消费和调度线程可以包在try catch中，但是htto和rpc的接口太多，需要统一处理。
controller层 controller层的同一异常只需要在处理类上添加@RestControllerAdvice注解，然后定义多个方法处理不同异常，每个方法上添加@ExceptionHandler(value=异常类)就可以了：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Slf4j @RestControllerAdvice @Order public class GlobalExceptionHandler { // =========== 系统级别未知异常 ========= @ExceptionHandler(value = Exception.class) public JsonResponse&lt;Object> handle(Exception e) { log.error("[ 系统未知错误 ]", e); return JsonResponse.createByError(SYSTEM_DEFAULT_ERROR); } // =========== 客户端异常 ========= /** * 1001 HTTP请求方法类型错误 */ @ExceptionHandler(value = HttpRequestMethodNotSupportedException.class) public JsonResponse&lt;Object> handle(HttpServletRequest request, HttpRequestMethodNotSupportedException e) { log.error("[客户端HTTP请求方法错误]uri->{}", request.getRequestURI(), e); return JsonResponse.createByError(CLIENT_HTTP_METHOD_ERROR); } ………… /** * 系统自定义业务异常 */ @ExceptionHandler(value = BaseBizException.class) public JsonResponse&lt;Object> handle(BaseBizException e) { log.error("[业务异常:{},{}]", e.getErrorCode(), e.getErrorMsg()); return JsonResponse.createByError(e.getErrorCode(), e.getErrorMsg(), e.getData()); } } rpc层 rpc通过dubbo的SPI扩展机制自定义过滤器实现，创建两个过滤器，第一个过滤器负责处理自定义异常，不让dubbo封装成RuntimeException，第二个过滤器负责把自定义异常封装成JsonRponse。
...</p></div><footer class=entry-footer>3 min</footer><a class=entry-link aria-label="post link to 服务治理-1.异常治理" href=https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/1.%E5%BC%82%E5%B8%B8%E6%B2%BB%E7%90%86/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>服务治理-3.监控系统</h2></header><div class=entry-content><p>监控系统选型 prometheus、zabbis、nagios、open-falcon进行选型
监控系统 语言 成熟度 扩展性 性能 社区活跃 容器支持 企业使用 zabbix c + php 高 高 低 中 低 高 nagios c 高 中 中 低 低 低 open-falcon go 中 高 高 中 中 中 prometheus go 中 高 高 高 高 高 zabbis和nagios的成熟度、企业使用高是因为他俩诞生的造，已经超过20年了。但是zabbix存储使用MySQL是硬伤，他不适合大规模的集群监控，nagios使用的是一个环形数据库，性能会稍微高一点，open-falcon底层是opensTSDB和基于graph分片存储的RRD环形数据库，prometheus是自研的时序数据库，也可以指定其他数据库。prometheus的社区活跃、国内外企业使用都非常高，open-falcon一般是小米(他就是小米开源的)、美团、滴滴这些大厂在用。
prometheus环境搭建 安装prometheus 到官网下载最新版本的prometheus，上传到服务器并解压：
1 tar -zxvf prometheus-2.35.0.linux-amd64.tar.gz 修改包名：
1 mv prometheus-2.35.0.linux-amd64 prometheus 进入prometheus目录验证版本：
1 ./prometheus --version prometheus默认的配置在prometheus.yml中：
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 服务治理-3.监控系统" href=https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/3.%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>服务治理-4.单测</h2></header><div class=entry-content><p>合格的单元测试 一个优秀的单元测试应该满足5个条件：
可验证：当单侧代码运行完就可以验证业务代码是否有问题，而不是通过肉眼去看log，即使用assert来判断结果。 可重复：当单测写好后是可以不分环境不分时间的运行的，比如依赖MySQL，想MySQL中插入数据区测试，如果数据被删或者在测试环境都没有这个数据了，这个单测没法进行，就是说要避免对基础环境(redis、es、MySQL、mq等)和外部接口(rpc接口)的依赖。执行完单测后应该恢复现场， 把之前准备的数据和单测过程中产生的数据全部释放或者删掉。 独立性：单测方法之间独立，单测的方法不能依赖其他单测方法的结果。并且每个单测方法只测试一种情况。 彻底的：核心逻辑的所有分支都要覆盖，整体覆盖率不低于70%。 专业的：测试代码也要有可维护性，因为业务变更频繁，所以单测也会频繁修改和扩展，所以要保证单测的类的职责单一，方法命名清晰，降低方法的复杂度，保证可扩展性。 PowerMock框架使用 常见的框架一般就是Mockito 2.x：官网(https://mockito.org)及(https://github.com/mockito/mockito )和PowerMock 2.x：官网(https://github.com/powermock/powermock)。PowerMock 2.x扩展了了EasyMock和Mockito。Mockito基于Cglib模拟public访问权限类型的方法，PowerMock基于javassist和objenesis来修改类的字节码 + ⾃定义类加载器模拟public、private、static、final等访问权限修饰的⽅法。
使用PowerMock之前需要初始化：
1 2 3 4 @Before public void init() { MockitoAnnotations.initMocks(this); } 然后使用@MockBean标注需要被mock的bean，这个注解会将⼀个spring bean的所有⽅法变成⼀个空⽅法，然后配合**PowerMockito.when().thenReturn()或者PowerMockito.doNothing().when()**来mock数据。
有一个和@MockBean类似的注解是@SpyBean，他的意思是说spring bean保持原样，只有调用了比如PowerMockito.doReturn().when()这种代码后这个方法才会被mock。当我们不想所有方法都mock的时候可以使用这个注解。
@Rule注解是配合JUnit4使用的，他用来断言抛出的异常是否是期望的异常，JUnit5使用过**Assert.assertThrows()**来验证异常。
这么写单测需要花费大量的时间，特别是造数据和清理数据。很有可能单测的代码要比业务逻辑的代码要多。所以一些外部系统，比如redis、es可以使用测试环境，这样会大幅度降低造数据和清理数据消耗的时间。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 服务治理-4.单测" href=https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/5.%E5%8D%95%E6%B5%8B/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>服务治理-4.日志</h2></header><div class=entry-content><p>日志规范 接口的入口和出口需要有日志，包括controller和service，级别是info。 关键步骤也需要有日志。 抛出异常前也需要打印日志，级别视情况而定，可以是info，也可以是error。 catch中也要打印日志，并且要输出异常信息，级别是error。 遇到if else分支时尽量打印日志。 核心功能模块建议打印完整日志。 统一系统、操作日志组件 参考美团文档[如何优雅地记录操作日志？]
系统日志和操作日志是不一样的，系统日志是各个功能运行流转过程中，打印出来的各种日志，能够根据日志还原出来运行的完整过程；操作日志是某个用户执行某些重要操作的时候，把操作日志记录持久化，后续可以随时查询操作。
ELK搭建 es和kibana安装参考之前笔记。
Logstash部署 需要采集的日志服务器都需要安装。
到官网下载安装包，创建目录：
1 mkdir -p /app/logstash 上传到目录下解压，进入解压后的bin目录，安装logstash json插件：
1 ./logstash-plugin install logstash-codec-json_lines 创建用户，修改/app/logstash的属组和属主：
1 2 3 useradd logstash passwd logstash chown -R logstash:logstash /app/logstash 在config目录下创建logstash.conf：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 input { # 输⼊ file { # ⽇志路径 path => "/app/logstash/logs/test.log" # 从头开始 start_position => "beginning" # 设置多⻓时间扫描⽬录发现新⽂件 discover_interval => 600 # 设置多⻓时间检测⽂件是否修改,默认是 1 秒 stat_interval => 1 } } filter{ # 对数据进⾏各种处理，如过滤，切割等 # grok和date是解决Kibana显示时间与应⽤⽇志时间不⼀致问题，还需要在kibana中选择Stack Management-->高级设置-->时区选择UTC grok { # 提取⽇志中的时间并设置为临时变量 match => { "message" => "%{TIMESTAMP_ISO8601:logdate}" } } date { # 设置变量的时间格式 match => [ "logdate", "YYYY-MM-dd HH:mm:ss.SSS" ] # 需要替换的⽬标字段 target => "@timestamp" timezone =>"+00:00" } multiline { # 时间正则表达式，合并多⾏⽇志 pattern => "^\d{4}-\d{1,2}-\d{1,2}\s\d{1,2}:\d{1,2}:\d{1,2}" negate => true # 向前合并 what => "previous" } } output { # 输出 elasticsearch { hosts => ["http://172.19.17.29:9200","http://172.19.17.28:9200","http://172.19.17.2 7:9200"] # 指定索引名称 index => "stars-log-%{+YYYY.MM.dd}" } logstash：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 服务治理-4.日志" href=https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/4.%E6%97%A5%E5%BF%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>服务治理-5.DevOps</h2></header><div class=entry-content><p>持续集成和持续交付 持续集成就是说每天或者说每次有人提交代码到gitlab，gitlab会通知jenkins服务器，然后jenkins把代码拉下来，使用mvn编译，打包，运行所有单元测试，如果单测没问题就说明本次提交到总代码里成功。
持续交付的意思是每隔一段时间比如一周让jenkins拉取最新的代码然后自动化的通过设置的脚本和命令部署到测试，持续性的交付可以运行、测试的完整版本的代码出来，测试完之后就可以让jenkins自动化部署到生产了，持续交付版本。
devOps持续集成和持续交付软件体系： gitlab -> 公司代码私有仓库，jenkins -> 持续集成 + 自动化测试 + 测试代码覆盖率 -> 代码质量检测(SonarQube) + 持续自动化部署，docker + k8s，加上前面的监控。
软件安装 gitlab SonarQube Jenkins</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 服务治理-5.DevOps" href=https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/6.devops/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>权限系统介绍</h2></header><div class=entry-content><p>ACL模型 Access Control List访问控制列表，它是一种最早也是最基本的控制方式，每一项资源都配有一个列表，列表里会记录哪些用户有哪些权限，当用户试图操作这个权限的时候，回先去检查这个列表中是否当前用户的这个权限。
主要包含3个要素，用户、资源、操作。Linux的文件权限就是ACL方式，路由器的设备限速什么的也是用的这种方式。
他有个缺点就是当资源和用户非常多的时候性能不好。
DAC模型 Discretionary Access Control自主访问控制，他是ACL的变种，本质上也是维护了一些资源，但是他规定资源可以被那些用户操作的同时，用户也可以将资源的操作权限授予其他用户，比如windoes的文件权限。他更灵活，但是由于用户的权限太大，可能无意间会泄露信息。
MAC模型 Mandatory Access Control强制访问控制，他是ACL的另一种实现，他更强调安全性，MAC会在系统中对资源和用户划分类别和等级，比如高考试卷的类别就是考试类，级别是绝密级。
MAC一般有两个列表，一个列表标记操作资源的最低级别、类别和主体(类似角色)，另一张表配置用户属于哪个类别，哪个级别，哪个主体。
他非常适合一些机密机构，虽然他和ACL有相同的缺点。
RBAC模型 Role-Based Access Control基于角色的访问控制，大部分的框架比如shiro、spring security都是基于RBAC设计的，他主要有三个著名的安全原则：最小权限原则、责任分离原则和数据抽象原则。
最小权限原则：将角色配置成完成任务所需的最小权限集合；
责任分离原则：可以通过调用互相独立互斥的角色共同完成敏感任务；
数据抽象原则：可以通过权限的抽象来体现，例如财务操作有借款、存款而不是读、写、执行等等。
RBAC可以抽象的概括成who可以对what进行how的访问操作，并对这个逻辑判断结果是否为true的过程。who表示的是用户，而不是角色，用户有不同的权限是因为用户有不同的角色。
RBAC的四种模型 分别是RBAC、RBAC1、RBAC2、RBAC3，RBAC是原始、最简单的版本；
RBAC1是RBAC的优化，增加了角色的分层(即子角色)，子角色可以继承父角色的所有权限；
RBAC2也是RBAC的优化，增加了对角色的一些限制，比如角色互斥、角色容量等。角色互斥的意思就是说当一个用户被赋予默写角色后就不能在赋予另一些角色，又分为静态职责分离和动态职责分离，静态说的就是在分配时校验互斥角色，动态是说可以分配，但是在建立会话时只能生效1个，角色容量的意思是一个角色可被分配的用户数是有限的，一个用户被赋予的角色数也是有限的；
RBAC3是最复杂的模型，他把RBAC1和RBAC2进行了整合。
ABAC Attribute-Based Access Control基于属性的访问控制，也被成为PBAC(Policy-Based Access Control)或者CBAC(Claims-Based Access Control)，他是通过一个或多个属性判断是否满足条件进行授权判断。
阿里云的RAM账号权限管理就是基于ABAC模型实现的。
面试 ACL的关键要素？ ACL的优缺点 举一个ACL的实际例子
DAC/MAC基于ACL做了什么改动 优缺点 举一个的例子
RBAC的四种概念模型 RBAC的3个安全原则
ABAC和RBAC的区别，主要在于授予用户访问权限的方式 ABAC的特点 ABAC的优缺点</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 权限系统介绍" href=https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>消息队列</h2></header><div class=entry-content><p>1.用过消息队列吗？ 在项目里用的队列，大部分的场景是解耦和异步，比如充值完会员会发送一条消息，如果以后增加系统的币种，会员会有对币种的逻辑处理、会员积分这些东西直接消费会员的消息就可以了，不需要改接口。
我们系统里用户是有个收发瓶子次数的限制，很多场景都可以导致这个次数发生改变，比如开通会员、后台手动操作修改用户状态，这些对实时性要求不高的业务可以使用mq进行异步处理，减少接口响应时间。
如果有大量写但是对实时性要求不高的需求也可以使用mq来进行肖峰。
还有一些一些日志系统、数据同步系统也需要用到消息队列。
缺点 mq出问题这个功能就蹦了。需要多维护一个服务或者框架来处理mq挂掉之后的处理逻辑； 一致性问题，分布式系统的cap理论：高可用，强一致性，分区容错性（在时限内到一致性）只能满足两个，mq就舍弃的强一致性； 重复消费啊、顺序消费导致结果纠错了，丢消息，消费者挂掉会有大量的消息积压等等，解决这些问题还会让系统更复杂。 2.各个消息队列区别（如何选型？） activeMQ：我没用过，官方好像不维护了，要不就是很不活跃，如果用他的话有bug可能就要靠自己了，印象里吞吐量很低；
rabbitMQ：吞吐量比kafka和rocketmq低，可以在小项目里用，但是源码是erlang的，java程序员看不了，但是社区很活跃，不怕采坑的。集群不好扩展但是管理界面功能非常全；
kafka：吞吐量是最高的，但是功能不多，kafka持久化消息时异步写入，有人说会丢消息，其实配置成同步写入是不会丢消息的，只不过会严重影响性能，一般日志采集，大数据分析服务用的多，因为丢一条两条无所谓，如果kafka要保证消息不丢首先broker要设置acks=-1，然后insync.replicas > 副本数-1，最后关闭自动提交ack；
rocketMQ默认就是集群模式，配置简单，源码是java的，容易扩展，nameserver和broker通信用的是netty。
3.如何保证消息的高可用？ kafka：分布式集群，他会把topic分出多个partition，每个机器存储对应partition上的消息，如果要保证HA的话每个partition需要有多个副本，这些副本有一个leader和多个follower，只有leader进行读写，leader宕机之后会选举出新的leader。用他自己的controller模块加zk实现的选举。
rocketmq：默认就是集群模式，他通过message queue把消息均匀分在每个集群节点上，每个master都有slave，4.5版本之前如果master宕机那么只能手动切换master，4.5版本之后使用Dledger进行主备切换。
如果考虑mq集群可能全部不可用的情况还需要在mq上包装一层自己的代码，当发现集群都不可用的时候需要把消息存到本地或者redis里，然后有一个单独的线程定时轮询发送失败的消息尝试发送搭配mq中。
4.如何保证消息不被重复消费 很多操作都会导致重复消费，比如MQ设置消息最少发一次，有的时候没有提交偏移量就会导致消息重复消费，或者在rocketMQ里以消息组为单位消费，只要有一条消费失败，拉取的所有消息都被标记成失败，过一会会重新发过来，这里面的消息就有消费成功的，或者消费中突然宕机或者重启，一般就是使用redis的setnx或者zk的分布式锁或者数据库唯一索引。kafka是基于zk实现的offset。
5.怎么保证消息可靠性(消息丢失)？ 生产者去写消息的过程中，网络传输过程中可能会丢失、mq收到消息后还没持久化到磁盘就挂了、消费者没有处理完但是mq以为处理完了结果消费者挂了或者处理失败(关闭自动提交ack，rocketmq没有这种机制)。
5.1rocketmq全链路消息不丢失方案：
首先发送消息使用rocketmq的事务消息或者同步发送加重试检测，超过次数回滚业务逻辑；
然后broker采用同步刷盘(flushDiskType=SYNC_FLUSH)，主从同步复制(brokerRole=SYNC_MASTER)；
最后消费者同步消费业务逻辑，最后返回处理结果，需要注意重复消费问题；
6.顺序消费 7.消息积压 新建几十个消费者，把原来的消费者的消费逻辑改成重新发送到新partiotion中，让几十个消费者去消费，前提是数据库能承受住，消费完了在把消费者换回来。
8.设计一个消息中间件 首先在存储上要分片存储，队列的消息均匀分布在每个节点上，多个消费者平均的绑定n片，分片之间需要考虑主从选举、主从心跳等等。同时要实现两种刷盘方式，使用mmap顺序写磁盘，所以还需要一个队列存储consumer消费的offect，客户端和broker之间使用netty通信，客户端和broker之间也需要心跳。
rocketmq 发送消息机制 通过message queue把数据分片，均匀存储在broker上。相当于的kafka的partition。producer会定时访问nameserver获取broker信息，发送消息时，会通过负载均衡计算出应该发送到那个message queue上，然后发送请求给对应的broker，如果master宕机，在等待主备切换的时候，是无法往这个broker中发送消息的，结果只能是发送失败或者超时，所以要设置sendLatencyFaultEnable，设置了这个参数后，在发送超时或者失败时会回避访问这个broker一段时间，将消息发送到其他broker。
存储消息 rocketmq的消息存储是在一个commit log中，每个文件最大1g，为什么是1g？因为mmap在生成文件映射的时候限制文件大小为1.5到2G之间。收到消息后会在log文件后追加消息，然后添加到OS cache中，当配置为同步刷盘时，会马上把OS cache的消息刷到consumer queue中，consumer queue中存储的是消息在log文件中的偏移量，每个message queue对应多个consumer queue，和多个commit log。一般会把brokerRole设置成SYNC_MASTER，这样会同步复制master的消息，而flushDiskType根据情况，如果是订单、金额相关的就设置成SYNC_FLUSH，允许丢数据的就设置成ASYNC_FLUSH。
选举和消息同步 选举和消息同步都是通过DLedger + raft协议实现的，在启动或者master宕机时，每个broker都会进行投票，但是每个broker都会给自己投票，然后把结果发送给其他broker，一个master 宕机，还有两个slave，他们刚开始都给自己投票，这时每个slave都会有一票，然后进入随机睡眠，先醒的那个会继续投票，还是给自己，其他broker醒了之后收到选举消息会比对日志，谁的日志新就投给谁，只要有一半 + 1个broker投票给同一个broker就会选出来新的master。
消息同步也是基于raft协议实现的：
消费数据 消费数据有两种模式，pull和push，但是这两种模式都是consumer主动去拉取，push模式下，发送请求给对应的broker，然后broker从consumer queue中拿到上次消费消息的偏移量，去commit log中获取对应的消息，如果没有新消息，请求线程会睡眠15，后台线程一直检查commit log，有新消息后唤醒睡眠的线程，返回消息。拉取数据时是可以从master上拉取，也可以从slave上拉取，其实commitLog和consumer queue都是经过OS cache去刷盘的，commitLog使用OS cache来提高写速度，而consumer queue使用OS cache提高读写速度，因为他很小，所以几乎所有的consumer queue都是在缓存中，这样读写都是缓存级的，很快，而commitLog文件比较大，不可能全部加载到缓存中，缓存中只是刚刚收到的消息还没刷盘的，所以除非消费速度很发消息速度差不多，否则拉取消息只能读取磁盘数据了，这个会比读取磁盘慢很多，而且当master感知到读取的速度落后很多，就会认为是自己负载过高，会让消费者下次去slave broker中拉取数据。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 消息队列" href=https://wangxiaohong123.github.io/posts/%E9%9D%A2%E8%AF%95/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>爬虫-1.入门</h2></header><div class=entry-content><p>任何语言都可以进行爬虫，但是python最方便，所以一般人都用python进行爬虫。
爬虫的时候只要不破坏网站、不侵犯用户隐私时不犯法的。
robots协议(君子协议):一般网站的主url后拼接robots.txt输出的内容为不允许爬的，爬的时候需要遵守。
一 爬虫用到的模块 有的时候我们拿到的资源是部分url，需要自己拼域名，不过部分url前面会出现有斜线'/'和没斜线的情况，有斜线的拼主域名就可以，没有斜线的是相对路径，需要把当前路的访问url取然后在拼接，非常麻烦，使用urllib就很简单：
1 2 3 from urllib.parse import urljoin herf = urljoin("当前访问url", "要拼接的url") a.time模块 time模块常用的两个功能：
1 2 3 4 5 6 7 8 9 import time # 获取当前的秒级时间戳 t = time.time() # 毫秒时间戳 t = int(time.time() * 1000) # 让线程休眠5s time.sleep(5) b.os模块 1 2 3 4 5 6 7 import os # 创建目录 os.makedirs("/url/subUrl") # 该url是否是已存在路径 os.path.isDir("url") c.json模块 1 2 3 4 5 6 7 import json # 将json字符串转换成字典 d = json.loads(s) # 把字典转成json字符串 s = json.dumps(dic) d.random模块 1 2 3 4 5 6 7 import random # 生成10到20的随机数 i = random.randint(10, 20) # 生成1到3的随机小数 f = random.uniform(1, 3) e .requests模块(需要安装) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import requests # 请求头伪装，有的网站会根据请求头判断是否是爬虫，我们就是要尽可能装成浏览器 header = { "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36" } # get请求 url = "https://www.sogou.com/web" param = { "query": "周杰伦" } resp = requests.get(url, headers=header, params=param) # post请求 url = "https://fanyi.baidu.com/sug" data = { "kw":"hello" } resp = requests.post(url, data=data) # 文本格式获取响应 print(resp.text) # json格式获取响应 print(resp.json()) # 获取字节内容，可以用这种方式获取媒体然后输出到图片 f.多线程和协程 进程是资源单位，线程是执行单位，爬虫中多线程用处不大，很多网站会限流而且线程过多容易把网站搞挂。
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to 爬虫-1.入门" href=https://wangxiaohong123.github.io/posts/%E5%85%B6%E4%BB%96/%E7%88%AC%E8%99%AB/%E5%85%A5%E9%97%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>私仓相关</h2></header><div class=entry-content><p>仓库有三种：
group（仓库组）：将各种宿主仓库、代理仓库组成虚拟的仓库组，项目只要配置依赖一个仓库自，相当于自动连接仓库组内的各种仓库。
proxy（代理仓库）：代理了公司外部的各种仓库，比如Jboss、中央仓库，可以修改为阿里的。
hosted（宿主仓库）：公司内部的发布包。
平时用的仓库就五个
maven-central：maven中央仓库的代理仓库； maven-public：仓库组，我们平时就连这个； maven-release：公司内部经过完善的测试，可以在生产环境使用的发布包； maven-snapshots：正在开发过程中的其他项目也需要依赖的的发布包； 3rd-party：这个是放中央仓库下载不了，我们自己下载然后传到这个仓库，3.9没有这个仓库，需要我们自己创建； 剩下三个是.net使用的。
账号有三种：
deployment：可以搜索构建，普通的开发账号，3.x之后需要自己创建； admin：管理员，密码是admin123； anonymous：匿名账号，可以下载和查看依赖；</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 私仓相关" href=https://wangxiaohong123.github.io/posts/maven/nexus/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>线上问题排查</h2></header><div class=entry-content><p>服务器 端口号被占用
启动服务发现端口号被占用可以使用netstat或者lsof查看占用端口号进程，没有用就杀掉
1 2 3 netstat -tunlp | grep 80 lsof -i:80 kill -9 [pid] 磁盘
当磁盘不足的时候可能会收到类似java.io.IOException: 磁盘空间不足这种信息，可以先使用以下指令查看磁盘状态
1 df -h 比如显示下面的信息就表示/目录下的磁盘占用很大
就要去/下面查看文件夹大小，一层一层一直找到大文件
1 2 3 4 5 6 du -sh * # 然后可以使用ls查看文件大小 ls -lh # 或者直接找到大文件，max-depth就是查找文件夹的深度 du -h --max-depth=1 | sort -n 或者直接使用find命令把大文件筛选出来
...</p></div><footer class=entry-footer>3 min</footer><a class=entry-link aria-label="post link to 线上问题排查" href=https://wangxiaohong123.github.io/posts/linux/1.%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wangxiaohong123.github.io/posts/page/25/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://wangxiaohong123.github.io/posts/page/27/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>