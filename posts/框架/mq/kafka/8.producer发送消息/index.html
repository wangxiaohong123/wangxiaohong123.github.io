<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>8.kafka源码-producer发送消息 | 王小红的笔记</title><meta name=keywords content="大数据"><meta name=description content='初始化完成后就可以调用producer的send方法了，先看异步发送，传进一个ProducerRecord类型的消息体和一个回调函数，最终调用到KafkaProducer的doSend方法：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85


// 调用doSend之前会使用拦截器在处理一下record
private Futrue<RecordMetadata> doSend(ProducerRecord<K, V> record, Callback callback) {
    TopicPartition tp = null;
    try {
        // 这里要获取topic了，同步阻塞
        ClusterAndWaitTime clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs);
        long remainingWaitMs = Math.max(0, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);
        Cluster cluster = clusterAndWaitTime.cluster;
        // 把key和value都进行序列化
        byte[] serializedKey;
        try {
            serializedKey = keySerializer.serialize(record.topic(), record.headers(), record.key());
        } catch (ClassCastException cce) {
            throw new SerializationException("Can&#39;t convert key of class " + record.key().getClass().getName() +
                                             " to class " + producerConfig.getClass(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG).getName() +
                                             " specified in key.serializer", cce);
        }
        // value就是消息的body
        byte[] serializedValue;
        try {
            serializedValue = valueSerializer.serialize(record.topic(), record.headers(), record.value());
        } catch (ClassCastException cce) {
            throw new SerializationException("Can&#39;t convert value of class " + record.value().getClass().getName() +
                                             " to class " + producerConfig.getClass(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG).getName() +
                                             " specified in value.serializer", cce);
        }
        // 根据topic信息获取对应的分区
        int partition = partition(record, serializedKey, serializedValue, cluster);
        tp = new TopicPartition(record.topic(), partition);

        setReadOnly(record.headers());
        Header[] headers = record.headers().toArray();
		// 统计消息大小
        int serializedSize = AbstractRecords.estimateSizeInBytesUpperBound(apiVersions.maxUsableProduceMagic(),
                                                                           compressionType, serializedKey, serializedValue, headers);
        // 检查消息是否超过了设置的大小上限和是否超过了缓冲区的大小上限
        ensureValidRecordSize(serializedSize);
        long timestamp = record.timestamp() == null ? time.milliseconds() : record.timestamp();
        log.trace("Sending record {} with callback {} to topic {} partition {}", record, callback, record.topic(), partition);
        // producer callback will make sure to call both &#39;callback&#39; and interceptor callback
        // 设置自定义回调和拦截器的回调
        Callback interceptCallback = new InterceptorCallback<>(callback, this.interceptors, tp);

        if (transactionManager != null && transactionManager.isTransactional())
            transactionManager.maybeAddPartitionToTransaction(tp);

        // 把消息放到缓冲里
        RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, serializedKey,
                                                                         serializedValue, headers, interceptCallback, remainingWaitMs);
        // 这里就是判断如果一个batch满了或者创建了一个新的batch，就要唤醒sender线程，发送消息
        if (result.batchIsFull || result.newBatchCreated) {
            log.trace("Waking up the sender since topic {} partition {} is either full or getting a new batch", record.topic(), partition);
            this.sender.wakeup();
        }
        // 返回futrue对象
        return result.futrue;
        // 下面是一大堆异常处理，基本上每一个步骤都会自定义一个自己的异常，在这层捕获进行处理
        // 一般中间件的异常捕获处理之后也会抛出去
        // 如果是业务代码要在业务的最顶层进行捕获处理，根据异常返回给前端对应的提示
    } catch (ApiException e) {
        log.debug("Exception occurred during message send:", e);
        if (callback != null)
            callback.onCompletion(null, e);
        this.errors.record();
        this.interceptors.onSendError(record, tp, e);
        return new FutrueFailure(e);
    } catch (InterruptedException e) {
        this.errors.record();
        this.interceptors.onSendError(record, tp, e);
        throw new InterruptException(e);
    } catch (BufferExhaustedException e) {
        this.errors.record();
        this.metrics.sensor("buffer-exhausted-records").record();
        this.interceptors.onSendError(record, tp, e);
        throw e;
    } catch (KafkaException e) {
        this.errors.record();
        this.interceptors.onSendError(record, tp, e);
        throw e;
    } catch (Exception e) {
        // we notify interceptor about all exceptions, since onSend is called before anything else in this method
        this.interceptors.onSendError(record, tp, e);
        throw e;
    }
}


同步阻塞获取topic
KafkaProducer的waitOnMetadata方法有三个参数，topic、partition、maxWaitMs，topic和partition是在发消息时候设置的，maxWaitMs是初始化producer的时候配置的max.block.ms，最开始是简单配置一下然后判断缓存：'><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/mq/kafka/8.producer%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/mq/kafka/8.producer%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/mq/kafka/8.producer%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="8.kafka源码-producer发送消息"><meta property="og:description" content='初始化完成后就可以调用producer的send方法了，先看异步发送，传进一个ProducerRecord类型的消息体和一个回调函数，最终调用到KafkaProducer的doSend方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // 调用doSend之前会使用拦截器在处理一下record private Futrue<RecordMetadata> doSend(ProducerRecord<K, V> record, Callback callback) { TopicPartition tp = null; try { // 这里要获取topic了，同步阻塞 ClusterAndWaitTime clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs); long remainingWaitMs = Math.max(0, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs); Cluster cluster = clusterAndWaitTime.cluster; // 把key和value都进行序列化 byte[] serializedKey; try { serializedKey = keySerializer.serialize(record.topic(), record.headers(), record.key()); } catch (ClassCastException cce) { throw new SerializationException("Can&#39;t convert key of class " + record.key().getClass().getName() + " to class " + producerConfig.getClass(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG).getName() + " specified in key.serializer", cce); } // value就是消息的body byte[] serializedValue; try { serializedValue = valueSerializer.serialize(record.topic(), record.headers(), record.value()); } catch (ClassCastException cce) { throw new SerializationException("Can&#39;t convert value of class " + record.value().getClass().getName() + " to class " + producerConfig.getClass(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG).getName() + " specified in value.serializer", cce); } // 根据topic信息获取对应的分区 int partition = partition(record, serializedKey, serializedValue, cluster); tp = new TopicPartition(record.topic(), partition); setReadOnly(record.headers()); Header[] headers = record.headers().toArray(); // 统计消息大小 int serializedSize = AbstractRecords.estimateSizeInBytesUpperBound(apiVersions.maxUsableProduceMagic(), compressionType, serializedKey, serializedValue, headers); // 检查消息是否超过了设置的大小上限和是否超过了缓冲区的大小上限 ensureValidRecordSize(serializedSize); long timestamp = record.timestamp() == null ? time.milliseconds() : record.timestamp(); log.trace("Sending record {} with callback {} to topic {} partition {}", record, callback, record.topic(), partition); // producer callback will make sure to call both &#39;callback&#39; and interceptor callback // 设置自定义回调和拦截器的回调 Callback interceptCallback = new InterceptorCallback<>(callback, this.interceptors, tp); if (transactionManager != null && transactionManager.isTransactional()) transactionManager.maybeAddPartitionToTransaction(tp); // 把消息放到缓冲里 RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, serializedKey, serializedValue, headers, interceptCallback, remainingWaitMs); // 这里就是判断如果一个batch满了或者创建了一个新的batch，就要唤醒sender线程，发送消息 if (result.batchIsFull || result.newBatchCreated) { log.trace("Waking up the sender since topic {} partition {} is either full or getting a new batch", record.topic(), partition); this.sender.wakeup(); } // 返回futrue对象 return result.futrue; // 下面是一大堆异常处理，基本上每一个步骤都会自定义一个自己的异常，在这层捕获进行处理 // 一般中间件的异常捕获处理之后也会抛出去 // 如果是业务代码要在业务的最顶层进行捕获处理，根据异常返回给前端对应的提示 } catch (ApiException e) { log.debug("Exception occurred during message send:", e); if (callback != null) callback.onCompletion(null, e); this.errors.record(); this.interceptors.onSendError(record, tp, e); return new FutrueFailure(e); } catch (InterruptedException e) { this.errors.record(); this.interceptors.onSendError(record, tp, e); throw new InterruptException(e); } catch (BufferExhaustedException e) { this.errors.record(); this.metrics.sensor("buffer-exhausted-records").record(); this.interceptors.onSendError(record, tp, e); throw e; } catch (KafkaException e) { this.errors.record(); this.interceptors.onSendError(record, tp, e); throw e; } catch (Exception e) { // we notify interceptor about all exceptions, since onSend is called before anything else in this method this.interceptors.onSendError(record, tp, e); throw e; } } 同步阻塞获取topic KafkaProducer的waitOnMetadata方法有三个参数，topic、partition、maxWaitMs，topic和partition是在发消息时候设置的，maxWaitMs是初始化producer的时候配置的max.block.ms，最开始是简单配置一下然后判断缓存：'><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-06T06:27:35+00:00"><meta property="article:modified_time" content="2021-08-06T06:27:35+00:00"><meta property="article:tag" content="大数据"><meta name=twitter:card content="summary"><meta name=twitter:title content="8.kafka源码-producer发送消息"><meta name=twitter:description content='初始化完成后就可以调用producer的send方法了，先看异步发送，传进一个ProducerRecord类型的消息体和一个回调函数，最终调用到KafkaProducer的doSend方法：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85


// 调用doSend之前会使用拦截器在处理一下record
private Futrue<RecordMetadata> doSend(ProducerRecord<K, V> record, Callback callback) {
    TopicPartition tp = null;
    try {
        // 这里要获取topic了，同步阻塞
        ClusterAndWaitTime clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs);
        long remainingWaitMs = Math.max(0, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);
        Cluster cluster = clusterAndWaitTime.cluster;
        // 把key和value都进行序列化
        byte[] serializedKey;
        try {
            serializedKey = keySerializer.serialize(record.topic(), record.headers(), record.key());
        } catch (ClassCastException cce) {
            throw new SerializationException("Can&#39;t convert key of class " + record.key().getClass().getName() +
                                             " to class " + producerConfig.getClass(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG).getName() +
                                             " specified in key.serializer", cce);
        }
        // value就是消息的body
        byte[] serializedValue;
        try {
            serializedValue = valueSerializer.serialize(record.topic(), record.headers(), record.value());
        } catch (ClassCastException cce) {
            throw new SerializationException("Can&#39;t convert value of class " + record.value().getClass().getName() +
                                             " to class " + producerConfig.getClass(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG).getName() +
                                             " specified in value.serializer", cce);
        }
        // 根据topic信息获取对应的分区
        int partition = partition(record, serializedKey, serializedValue, cluster);
        tp = new TopicPartition(record.topic(), partition);

        setReadOnly(record.headers());
        Header[] headers = record.headers().toArray();
		// 统计消息大小
        int serializedSize = AbstractRecords.estimateSizeInBytesUpperBound(apiVersions.maxUsableProduceMagic(),
                                                                           compressionType, serializedKey, serializedValue, headers);
        // 检查消息是否超过了设置的大小上限和是否超过了缓冲区的大小上限
        ensureValidRecordSize(serializedSize);
        long timestamp = record.timestamp() == null ? time.milliseconds() : record.timestamp();
        log.trace("Sending record {} with callback {} to topic {} partition {}", record, callback, record.topic(), partition);
        // producer callback will make sure to call both &#39;callback&#39; and interceptor callback
        // 设置自定义回调和拦截器的回调
        Callback interceptCallback = new InterceptorCallback<>(callback, this.interceptors, tp);

        if (transactionManager != null && transactionManager.isTransactional())
            transactionManager.maybeAddPartitionToTransaction(tp);

        // 把消息放到缓冲里
        RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, serializedKey,
                                                                         serializedValue, headers, interceptCallback, remainingWaitMs);
        // 这里就是判断如果一个batch满了或者创建了一个新的batch，就要唤醒sender线程，发送消息
        if (result.batchIsFull || result.newBatchCreated) {
            log.trace("Waking up the sender since topic {} partition {} is either full or getting a new batch", record.topic(), partition);
            this.sender.wakeup();
        }
        // 返回futrue对象
        return result.futrue;
        // 下面是一大堆异常处理，基本上每一个步骤都会自定义一个自己的异常，在这层捕获进行处理
        // 一般中间件的异常捕获处理之后也会抛出去
        // 如果是业务代码要在业务的最顶层进行捕获处理，根据异常返回给前端对应的提示
    } catch (ApiException e) {
        log.debug("Exception occurred during message send:", e);
        if (callback != null)
            callback.onCompletion(null, e);
        this.errors.record();
        this.interceptors.onSendError(record, tp, e);
        return new FutrueFailure(e);
    } catch (InterruptedException e) {
        this.errors.record();
        this.interceptors.onSendError(record, tp, e);
        throw new InterruptException(e);
    } catch (BufferExhaustedException e) {
        this.errors.record();
        this.metrics.sensor("buffer-exhausted-records").record();
        this.interceptors.onSendError(record, tp, e);
        throw e;
    } catch (KafkaException e) {
        this.errors.record();
        this.interceptors.onSendError(record, tp, e);
        throw e;
    } catch (Exception e) {
        // we notify interceptor about all exceptions, since onSend is called before anything else in this method
        this.interceptors.onSendError(record, tp, e);
        throw e;
    }
}


同步阻塞获取topic
KafkaProducer的waitOnMetadata方法有三个参数，topic、partition、maxWaitMs，topic和partition是在发消息时候设置的，maxWaitMs是初始化producer的时候配置的max.block.ms，最开始是简单配置一下然后判断缓存：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wangxiaohong123.github.io/posts/"},{"@type":"ListItem","position":2,"name":"8.kafka源码-producer发送消息","item":"https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/mq/kafka/8.producer%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"8.kafka源码-producer发送消息","name":"8.kafka源码-producer发送消息","description":"初始化完成后就可以调用producer的send方法了，先看异步发送，传进一个ProducerRecord类型的消息体和一个回调函数，最终调用到KafkaProducer的doSend方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // 调用doSend之前会使用拦截器在处理一下record private Futrue\u0026lt;RecordMetadata\u0026gt; doSend(ProducerRecord\u0026lt;K, V\u0026gt; record, Callback callback) { TopicPartition tp = null; try { // 这里要获取topic了，同步阻塞 ClusterAndWaitTime clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs); long remainingWaitMs = Math.max(0, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs); Cluster cluster = clusterAndWaitTime.cluster; // 把key和value都进行序列化 byte[] serializedKey; try { serializedKey = keySerializer.serialize(record.topic(), record.headers(), record.key()); } catch (ClassCastException cce) { throw new SerializationException(\u0026#34;Can\u0026#39;t convert key of class \u0026#34; + record.key().getClass().getName() + \u0026#34; to class \u0026#34; + producerConfig.getClass(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG).getName() + \u0026#34; specified in key.serializer\u0026#34;, cce); } // value就是消息的body byte[] serializedValue; try { serializedValue = valueSerializer.serialize(record.topic(), record.headers(), record.value()); } catch (ClassCastException cce) { throw new SerializationException(\u0026#34;Can\u0026#39;t convert value of class \u0026#34; + record.value().getClass().getName() + \u0026#34; to class \u0026#34; + producerConfig.getClass(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG).getName() + \u0026#34; specified in value.serializer\u0026#34;, cce); } // 根据topic信息获取对应的分区 int partition = partition(record, serializedKey, serializedValue, cluster); tp = new TopicPartition(record.topic(), partition); setReadOnly(record.headers()); Header[] headers = record.headers().toArray(); // 统计消息大小 int serializedSize = AbstractRecords.estimateSizeInBytesUpperBound(apiVersions.maxUsableProduceMagic(), compressionType, serializedKey, serializedValue, headers); // 检查消息是否超过了设置的大小上限和是否超过了缓冲区的大小上限 ensureValidRecordSize(serializedSize); long timestamp = record.timestamp() == null ? time.milliseconds() : record.timestamp(); log.trace(\u0026#34;Sending record {} with callback {} to topic {} partition {}\u0026#34;, record, callback, record.topic(), partition); // producer callback will make sure to call both \u0026#39;callback\u0026#39; and interceptor callback // 设置自定义回调和拦截器的回调 Callback interceptCallback = new InterceptorCallback\u0026lt;\u0026gt;(callback, this.interceptors, tp); if (transactionManager != null \u0026amp;\u0026amp; transactionManager.isTransactional()) transactionManager.maybeAddPartitionToTransaction(tp); // 把消息放到缓冲里 RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, serializedKey, serializedValue, headers, interceptCallback, remainingWaitMs); // 这里就是判断如果一个batch满了或者创建了一个新的batch，就要唤醒sender线程，发送消息 if (result.batchIsFull || result.newBatchCreated) { log.trace(\u0026#34;Waking up the sender since topic {} partition {} is either full or getting a new batch\u0026#34;, record.topic(), partition); this.sender.wakeup(); } // 返回futrue对象 return result.futrue; // 下面是一大堆异常处理，基本上每一个步骤都会自定义一个自己的异常，在这层捕获进行处理 // 一般中间件的异常捕获处理之后也会抛出去 // 如果是业务代码要在业务的最顶层进行捕获处理，根据异常返回给前端对应的提示 } catch (ApiException e) { log.debug(\u0026#34;Exception occurred during message send:\u0026#34;, e); if (callback != null) callback.onCompletion(null, e); this.errors.record(); this.interceptors.onSendError(record, tp, e); return new FutrueFailure(e); } catch (InterruptedException e) { this.errors.record(); this.interceptors.onSendError(record, tp, e); throw new InterruptException(e); } catch (BufferExhaustedException e) { this.errors.record(); this.metrics.sensor(\u0026#34;buffer-exhausted-records\u0026#34;).record(); this.interceptors.onSendError(record, tp, e); throw e; } catch (KafkaException e) { this.errors.record(); this.interceptors.onSendError(record, tp, e); throw e; } catch (Exception e) { // we notify interceptor about all exceptions, since onSend is called before anything else in this method this.interceptors.onSendError(record, tp, e); throw e; } } 同步阻塞获取topic KafkaProducer的waitOnMetadata方法有三个参数，topic、partition、maxWaitMs，topic和partition是在发消息时候设置的，maxWaitMs是初始化producer的时候配置的max.block.ms，最开始是简单配置一下然后判断缓存：\n","keywords":["大数据"],"articleBody":"初始化完成后就可以调用producer的send方法了，先看异步发送，传进一个ProducerRecord类型的消息体和一个回调函数，最终调用到KafkaProducer的doSend方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // 调用doSend之前会使用拦截器在处理一下record private Futrue\u003cRecordMetadata\u003e doSend(ProducerRecord\u003cK, V\u003e record, Callback callback) { TopicPartition tp = null; try { // 这里要获取topic了，同步阻塞 ClusterAndWaitTime clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs); long remainingWaitMs = Math.max(0, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs); Cluster cluster = clusterAndWaitTime.cluster; // 把key和value都进行序列化 byte[] serializedKey; try { serializedKey = keySerializer.serialize(record.topic(), record.headers(), record.key()); } catch (ClassCastException cce) { throw new SerializationException(\"Can't convert key of class \" + record.key().getClass().getName() + \" to class \" + producerConfig.getClass(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG).getName() + \" specified in key.serializer\", cce); } // value就是消息的body byte[] serializedValue; try { serializedValue = valueSerializer.serialize(record.topic(), record.headers(), record.value()); } catch (ClassCastException cce) { throw new SerializationException(\"Can't convert value of class \" + record.value().getClass().getName() + \" to class \" + producerConfig.getClass(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG).getName() + \" specified in value.serializer\", cce); } // 根据topic信息获取对应的分区 int partition = partition(record, serializedKey, serializedValue, cluster); tp = new TopicPartition(record.topic(), partition); setReadOnly(record.headers()); Header[] headers = record.headers().toArray(); // 统计消息大小 int serializedSize = AbstractRecords.estimateSizeInBytesUpperBound(apiVersions.maxUsableProduceMagic(), compressionType, serializedKey, serializedValue, headers); // 检查消息是否超过了设置的大小上限和是否超过了缓冲区的大小上限 ensureValidRecordSize(serializedSize); long timestamp = record.timestamp() == null ? time.milliseconds() : record.timestamp(); log.trace(\"Sending record {} with callback {} to topic {} partition {}\", record, callback, record.topic(), partition); // producer callback will make sure to call both 'callback' and interceptor callback // 设置自定义回调和拦截器的回调 Callback interceptCallback = new InterceptorCallback\u003c\u003e(callback, this.interceptors, tp); if (transactionManager != null \u0026\u0026 transactionManager.isTransactional()) transactionManager.maybeAddPartitionToTransaction(tp); // 把消息放到缓冲里 RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, serializedKey, serializedValue, headers, interceptCallback, remainingWaitMs); // 这里就是判断如果一个batch满了或者创建了一个新的batch，就要唤醒sender线程，发送消息 if (result.batchIsFull || result.newBatchCreated) { log.trace(\"Waking up the sender since topic {} partition {} is either full or getting a new batch\", record.topic(), partition); this.sender.wakeup(); } // 返回futrue对象 return result.futrue; // 下面是一大堆异常处理，基本上每一个步骤都会自定义一个自己的异常，在这层捕获进行处理 // 一般中间件的异常捕获处理之后也会抛出去 // 如果是业务代码要在业务的最顶层进行捕获处理，根据异常返回给前端对应的提示 } catch (ApiException e) { log.debug(\"Exception occurred during message send:\", e); if (callback != null) callback.onCompletion(null, e); this.errors.record(); this.interceptors.onSendError(record, tp, e); return new FutrueFailure(e); } catch (InterruptedException e) { this.errors.record(); this.interceptors.onSendError(record, tp, e); throw new InterruptException(e); } catch (BufferExhaustedException e) { this.errors.record(); this.metrics.sensor(\"buffer-exhausted-records\").record(); this.interceptors.onSendError(record, tp, e); throw e; } catch (KafkaException e) { this.errors.record(); this.interceptors.onSendError(record, tp, e); throw e; } catch (Exception e) { // we notify interceptor about all exceptions, since onSend is called before anything else in this method this.interceptors.onSendError(record, tp, e); throw e; } } 同步阻塞获取topic KafkaProducer的waitOnMetadata方法有三个参数，topic、partition、maxWaitMs，topic和partition是在发消息时候设置的，maxWaitMs是初始化producer的时候配置的max.block.ms，最开始是简单配置一下然后判断缓存：\n1 2 3 4 5 6 7 8 9 // 更新要拉取的topic信息 // 更新needUpdate标志位 metadata.add(topic); // 获取现在缓存的cluster Cluster cluster = metadata.fetch(); // 这里就把topic的partition拿出来，判断数量，没有或者分区数比传进来的小就返回当前的cluster Integer partitionsCount = cluster.partitionCountForTopic(topic); if (partitionsCount != null \u0026\u0026 (partition == null || partition \u003c partitionsCount)) return new ClusterAndWaitTime(cluster, 0); 然后有设置了一遍需要拉取的topic信息，在尝试拉取topic元数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 do { // 这里需要重新设置更新的topic信息，我猜因为拉取信息是异步的，有可能走到这，然后version被别的线程拉取之后发生改变了，或者说needUpdate这个标志位被别的线程改成了false，这样就不会拉取元数据了 metadata.add(topic); int version = metadata.requestUpdate(); // 唤醒sender，sender负责拉取元数据 sender.wakeup(); try { // 同步阻塞等待元数据更新 metadata.awaitUpdate(version, remainingWaitMs); } catch (TimeoutException ex) { // Rethrow with original maxWaitMs to prevent logging exception with remainingWaitMs throw new TimeoutException(\"Failed to update metadata after \" + maxWaitMs + \" ms.\"); } // 判断等待是否超时 cluster = metadata.fetch(); elapsed = time.milliseconds() - begin; if (elapsed \u003e= maxWaitMs) throw new TimeoutException(\"Failed to update metadata after \" + maxWaitMs + \" ms.\"); if (cluster.unauthorizedTopics().contains(topic)) throw new TopicAuthorizationException(topic); remainingWaitMs = maxWaitMs - elapsed; partitionsCount = cluster.partitionCountForTopic(topic); } while (partitionsCount == null); 再看awaitUpdate()方法，这个方法里就是不断地wait直到超时或者拉取结束\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public synchronized void awaitUpdate(final int lastVersion, final long maxWaitMs) throws InterruptedException { if (maxWaitMs \u003c 0) { throw new IllegalArgumentException(\"Max time to wait for metadata updates should not be \u003c 0 milliseconds\"); } long begin = System.currentTimeMillis(); long remainingWaitMs = maxWaitMs; // 通过版本号判断是否拉取结束 while (this.version \u003c= lastVersion) { AuthenticationException ex = getAndClearAuthenticationException(); if (ex != null) throw ex; if (remainingWaitMs != 0) wait(remainingWaitMs); // 线程被唤醒之后还要在判断一次时间，如果是在别的地方唤醒，需要把已经等待的时间减去，然后接着等待同步元数据 long elapsed = System.currentTimeMillis() - begin; if (elapsed \u003e= maxWaitMs) throw new TimeoutException(\"Failed to update metadata after \" + maxWaitMs + \" ms.\"); remainingWaitMs = maxWaitMs - elapsed; } } sender同步数据 在sender的run方法最后面调用了一个poll方法，这个poll调用的是KafkaClient的poll方法，这个方法的下面有个handleCompletedReceives()，就是处理收到结果后的处理，这个方法里使用MetadataUpdater.handleCompletedMetadataResponse更新元数据，MetadataUpdater是一个接口，默认的实现类就是DefaultMetadataUpdater，这个是KafkaClient的内部类，这个方法里继续调用metadata.update方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public synchronized void update(Cluster newCluster, Set\u003cString\u003e unavailableTopics, long now) { Objects.requireNonNull(newCluster, \"cluster should not be null\"); // 标志位改成false了 this.needUpdate = false; // 最后更新时间 this.lastRefreshMs = now; this.lastSuccessfulRefreshMs = now; // 版本号加1 this.version += 1; // 处理过期的topic信息 if (topicExpiryEnabled) { …… } // 更新元数据信息 …… // 唤醒线程，之前等待元数据信息的可以继续执行了 notifyAll(); log.debug(\"Updated cluster metadata version {} to {}\", this.version, this.cluster); } 选择分区 KafkaProducer的partition方法会先判断发送的消息是否指定了分区，指定了就直接返回，没有的话会调用DefaultPartitioner的partition方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) { // 拿到这个topic的所有分区 List\u003cPartitionInfo\u003e partitions = cluster.partitionsForTopic(topic); int numPartitions = partitions.size(); // 发消息时没有指定key if (keyBytes == null) { int nextValue = nextValue(topic); List\u003cPartitionInfo\u003e availablePartitions = cluster.availablePartitionsForTopic(topic); // 可用分区数量大于0就用nextValue和可用分区取余 if (availablePartitions.size() \u003e 0) { int part = Utils.toPositive(nextValue) % availablePartitions.size(); return availablePartitions.get(part).partition(); } else { // 和所有分区取模，这时候返回的分区都是不可用的 return Utils.toPositive(nextValue) % numPartitions; } } else { // 如果指定了key，会根据key的byte数组转成32位证书，和总分区数取模，这样就可以保证同一个key会落到同一个分区 // 可以实现发送消息顺序性 return Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions; } } 加入缓冲 加入缓冲的方法在RecordAccumulator.append()方法，首先获取batch所在集合，集合的变量名是batches，类型是CopyOnWriteMap，这个是kafka自己实现的mao，适合度多写少，原理和CopyOnWriteArrayList一样\n1 2 // 从ConcurrentMap","wordCount":"2301","inLanguage":"en","datePublished":"2021-08-06T06:27:35Z","dateModified":"2021-08-06T06:27:35Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/mq/kafka/8.producer%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF/"},"publisher":{"@type":"Organization","name":"王小红的笔记","logo":{"@type":"ImageObject","url":"https://wangxiaohong123.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">8.kafka源码-producer发送消息</h1><div class=post-meta><span title='2021-08-06 06:27:35 +0000 UTC'>August 6, 2021</span>&nbsp;·&nbsp;11 min</div></header><div class=post-content><p>初始化完成后就可以调用producer的send方法了，先看异步发送，传进一个ProducerRecord类型的消息体和一个回调函数，最终调用到KafkaProducer的doSend方法：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">55
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">56
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">59
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">60
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">61
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">62
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">63
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">64
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">65
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">66
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">67
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">68
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">69
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">70
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">71
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">72
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">73
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">74
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">75
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">76
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">77
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">78
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">79
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">80
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">81
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">82
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">83
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">84
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">85
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 调用doSend之前会使用拦截器在处理一下record</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> Futrue<span style=color:#ff79c6>&lt;</span>RecordMetadata<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>doSend</span>(ProducerRecord<span style=color:#ff79c6>&lt;</span>K, V<span style=color:#ff79c6>&gt;</span> record, Callback callback) {
</span></span><span style=display:flex><span>    TopicPartition tp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 这里要获取topic了，同步阻塞</span>
</span></span><span style=display:flex><span>        ClusterAndWaitTime clusterAndWaitTime <span style=color:#ff79c6>=</span> waitOnMetadata(record.<span style=color:#50fa7b>topic</span>(), record.<span style=color:#50fa7b>partition</span>(), maxBlockTimeMs);
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>long</span> remainingWaitMs <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(0, maxBlockTimeMs <span style=color:#ff79c6>-</span> clusterAndWaitTime.<span style=color:#50fa7b>waitedOnMetadataMs</span>);
</span></span><span style=display:flex><span>        Cluster cluster <span style=color:#ff79c6>=</span> clusterAndWaitTime.<span style=color:#50fa7b>cluster</span>;
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 把key和value都进行序列化</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>byte</span><span style=color:#ff79c6>[]</span> serializedKey;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>try</span> {
</span></span><span style=display:flex><span>            serializedKey <span style=color:#ff79c6>=</span> keySerializer.<span style=color:#50fa7b>serialize</span>(record.<span style=color:#50fa7b>topic</span>(), record.<span style=color:#50fa7b>headers</span>(), record.<span style=color:#50fa7b>key</span>());
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>catch</span> (ClassCastException cce) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> SerializationException(<span style=color:#f1fa8c>&#34;Can&#39;t convert key of class &#34;</span> <span style=color:#ff79c6>+</span> record.<span style=color:#50fa7b>key</span>().<span style=color:#50fa7b>getClass</span>().<span style=color:#50fa7b>getName</span>() <span style=color:#ff79c6>+</span>
</span></span><span style=display:flex><span>                                             <span style=color:#f1fa8c>&#34; to class &#34;</span> <span style=color:#ff79c6>+</span> producerConfig.<span style=color:#50fa7b>getClass</span>(ProducerConfig.<span style=color:#50fa7b>KEY_SERIALIZER_CLASS_CONFIG</span>).<span style=color:#50fa7b>getName</span>() <span style=color:#ff79c6>+</span>
</span></span><span style=display:flex><span>                                             <span style=color:#f1fa8c>&#34; specified in key.serializer&#34;</span>, cce);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// value就是消息的body</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>byte</span><span style=color:#ff79c6>[]</span> serializedValue;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>try</span> {
</span></span><span style=display:flex><span>            serializedValue <span style=color:#ff79c6>=</span> valueSerializer.<span style=color:#50fa7b>serialize</span>(record.<span style=color:#50fa7b>topic</span>(), record.<span style=color:#50fa7b>headers</span>(), record.<span style=color:#50fa7b>value</span>());
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>catch</span> (ClassCastException cce) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> SerializationException(<span style=color:#f1fa8c>&#34;Can&#39;t convert value of class &#34;</span> <span style=color:#ff79c6>+</span> record.<span style=color:#50fa7b>value</span>().<span style=color:#50fa7b>getClass</span>().<span style=color:#50fa7b>getName</span>() <span style=color:#ff79c6>+</span>
</span></span><span style=display:flex><span>                                             <span style=color:#f1fa8c>&#34; to class &#34;</span> <span style=color:#ff79c6>+</span> producerConfig.<span style=color:#50fa7b>getClass</span>(ProducerConfig.<span style=color:#50fa7b>VALUE_SERIALIZER_CLASS_CONFIG</span>).<span style=color:#50fa7b>getName</span>() <span style=color:#ff79c6>+</span>
</span></span><span style=display:flex><span>                                             <span style=color:#f1fa8c>&#34; specified in value.serializer&#34;</span>, cce);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 根据topic信息获取对应的分区</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> partition <span style=color:#ff79c6>=</span> partition(record, serializedKey, serializedValue, cluster);
</span></span><span style=display:flex><span>        tp <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> TopicPartition(record.<span style=color:#50fa7b>topic</span>(), partition);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        setReadOnly(record.<span style=color:#50fa7b>headers</span>());
</span></span><span style=display:flex><span>        Header<span style=color:#ff79c6>[]</span> headers <span style=color:#ff79c6>=</span> record.<span style=color:#50fa7b>headers</span>().<span style=color:#50fa7b>toArray</span>();
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 统计消息大小</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> serializedSize <span style=color:#ff79c6>=</span> AbstractRecords.<span style=color:#50fa7b>estimateSizeInBytesUpperBound</span>(apiVersions.<span style=color:#50fa7b>maxUsableProduceMagic</span>(),
</span></span><span style=display:flex><span>                                                                           compressionType, serializedKey, serializedValue, headers);
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 检查消息是否超过了设置的大小上限和是否超过了缓冲区的大小上限</span>
</span></span><span style=display:flex><span>        ensureValidRecordSize(serializedSize);
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>long</span> timestamp <span style=color:#ff79c6>=</span> record.<span style=color:#50fa7b>timestamp</span>() <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>?</span> time.<span style=color:#50fa7b>milliseconds</span>() : record.<span style=color:#50fa7b>timestamp</span>();
</span></span><span style=display:flex><span>        log.<span style=color:#50fa7b>trace</span>(<span style=color:#f1fa8c>&#34;Sending record {} with callback {} to topic {} partition {}&#34;</span>, record, callback, record.<span style=color:#50fa7b>topic</span>(), partition);
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// producer callback will make sure to call both &#39;callback&#39; and interceptor callback</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 设置自定义回调和拦截器的回调</span>
</span></span><span style=display:flex><span>        Callback interceptCallback <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> InterceptorCallback<span style=color:#ff79c6>&lt;&gt;</span>(callback, <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>interceptors</span>, tp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (transactionManager <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> transactionManager.<span style=color:#50fa7b>isTransactional</span>())
</span></span><span style=display:flex><span>            transactionManager.<span style=color:#50fa7b>maybeAddPartitionToTransaction</span>(tp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 把消息放到缓冲里</span>
</span></span><span style=display:flex><span>        RecordAccumulator.<span style=color:#50fa7b>RecordAppendResult</span> result <span style=color:#ff79c6>=</span> accumulator.<span style=color:#50fa7b>append</span>(tp, timestamp, serializedKey,
</span></span><span style=display:flex><span>                                                                         serializedValue, headers, interceptCallback, remainingWaitMs);
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 这里就是判断如果一个batch满了或者创建了一个新的batch，就要唤醒sender线程，发送消息</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (result.<span style=color:#50fa7b>batchIsFull</span> <span style=color:#ff79c6>||</span> result.<span style=color:#50fa7b>newBatchCreated</span>) {
</span></span><span style=display:flex><span>            log.<span style=color:#50fa7b>trace</span>(<span style=color:#f1fa8c>&#34;Waking up the sender since topic {} partition {} is either full or getting a new batch&#34;</span>, record.<span style=color:#50fa7b>topic</span>(), partition);
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>sender</span>.<span style=color:#50fa7b>wakeup</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 返回futrue对象</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> result.<span style=color:#50fa7b>futrue</span>;
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 下面是一大堆异常处理，基本上每一个步骤都会自定义一个自己的异常，在这层捕获进行处理</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 一般中间件的异常捕获处理之后也会抛出去</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 如果是业务代码要在业务的最顶层进行捕获处理，根据异常返回给前端对应的提示</span>
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>catch</span> (ApiException e) {
</span></span><span style=display:flex><span>        log.<span style=color:#50fa7b>debug</span>(<span style=color:#f1fa8c>&#34;Exception occurred during message send:&#34;</span>, e);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (callback <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>)
</span></span><span style=display:flex><span>            callback.<span style=color:#50fa7b>onCompletion</span>(<span style=color:#ff79c6>null</span>, e);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>errors</span>.<span style=color:#50fa7b>record</span>();
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>interceptors</span>.<span style=color:#50fa7b>onSendError</span>(record, tp, e);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> FutrueFailure(e);
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>errors</span>.<span style=color:#50fa7b>record</span>();
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>interceptors</span>.<span style=color:#50fa7b>onSendError</span>(record, tp, e);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> InterruptException(e);
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>catch</span> (BufferExhaustedException e) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>errors</span>.<span style=color:#50fa7b>record</span>();
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>metrics</span>.<span style=color:#50fa7b>sensor</span>(<span style=color:#f1fa8c>&#34;buffer-exhausted-records&#34;</span>).<span style=color:#50fa7b>record</span>();
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>interceptors</span>.<span style=color:#50fa7b>onSendError</span>(record, tp, e);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>throw</span> e;
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>catch</span> (KafkaException e) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>errors</span>.<span style=color:#50fa7b>record</span>();
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>interceptors</span>.<span style=color:#50fa7b>onSendError</span>(record, tp, e);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>throw</span> e;
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>catch</span> (Exception e) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// we notify interceptor about all exceptions, since onSend is called before anything else in this method</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>interceptors</span>.<span style=color:#50fa7b>onSendError</span>(record, tp, e);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>throw</span> e;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h5 id=同步阻塞获取topic>同步阻塞获取topic<a hidden class=anchor aria-hidden=true href=#同步阻塞获取topic>#</a></h5><p>KafkaProducer的waitOnMetadata方法有三个参数，topic、partition、maxWaitMs，topic和partition是在发消息时候设置的，maxWaitMs是初始化producer的时候配置的max.block.ms，最开始是简单配置一下然后判断缓存：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 更新要拉取的topic信息</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 更新needUpdate标志位</span>
</span></span><span style=display:flex><span>metadata.<span style=color:#50fa7b>add</span>(topic);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 获取现在缓存的cluster</span>
</span></span><span style=display:flex><span>Cluster cluster <span style=color:#ff79c6>=</span> metadata.<span style=color:#50fa7b>fetch</span>();
</span></span><span style=display:flex><span><span style=color:#6272a4>// 这里就把topic的partition拿出来，判断数量，没有或者分区数比传进来的小就返回当前的cluster</span>
</span></span><span style=display:flex><span>Integer partitionsCount <span style=color:#ff79c6>=</span> cluster.<span style=color:#50fa7b>partitionCountForTopic</span>(topic);
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> (partitionsCount <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> (partition <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>||</span> partition <span style=color:#ff79c6>&lt;</span> partitionsCount))
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> ClusterAndWaitTime(cluster, 0);
</span></span></code></pre></td></tr></table></div></div><p>然后有设置了一遍需要拉取的topic信息，在尝试拉取topic元数据：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>do</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 这里需要重新设置更新的topic信息，我猜因为拉取信息是异步的，有可能走到这，然后version被别的线程拉取之后发生改变了，或者说needUpdate这个标志位被别的线程改成了false，这样就不会拉取元数据了</span>
</span></span><span style=display:flex><span>    metadata.<span style=color:#50fa7b>add</span>(topic);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> version <span style=color:#ff79c6>=</span> metadata.<span style=color:#50fa7b>requestUpdate</span>();
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 唤醒sender，sender负责拉取元数据</span>
</span></span><span style=display:flex><span>    sender.<span style=color:#50fa7b>wakeup</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 同步阻塞等待元数据更新</span>
</span></span><span style=display:flex><span>        metadata.<span style=color:#50fa7b>awaitUpdate</span>(version, remainingWaitMs);
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>catch</span> (TimeoutException ex) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// Rethrow with original maxWaitMs to prevent logging exception with remainingWaitMs</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> TimeoutException(<span style=color:#f1fa8c>&#34;Failed to update metadata after &#34;</span> <span style=color:#ff79c6>+</span> maxWaitMs <span style=color:#ff79c6>+</span> <span style=color:#f1fa8c>&#34; ms.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 判断等待是否超时</span>
</span></span><span style=display:flex><span>    cluster <span style=color:#ff79c6>=</span> metadata.<span style=color:#50fa7b>fetch</span>();
</span></span><span style=display:flex><span>    elapsed <span style=color:#ff79c6>=</span> time.<span style=color:#50fa7b>milliseconds</span>() <span style=color:#ff79c6>-</span> begin;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (elapsed <span style=color:#ff79c6>&gt;=</span> maxWaitMs)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> TimeoutException(<span style=color:#f1fa8c>&#34;Failed to update metadata after &#34;</span> <span style=color:#ff79c6>+</span> maxWaitMs <span style=color:#ff79c6>+</span> <span style=color:#f1fa8c>&#34; ms.&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (cluster.<span style=color:#50fa7b>unauthorizedTopics</span>().<span style=color:#50fa7b>contains</span>(topic))
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> TopicAuthorizationException(topic);
</span></span><span style=display:flex><span>    remainingWaitMs <span style=color:#ff79c6>=</span> maxWaitMs <span style=color:#ff79c6>-</span> elapsed;
</span></span><span style=display:flex><span>    partitionsCount <span style=color:#ff79c6>=</span> cluster.<span style=color:#50fa7b>partitionCountForTopic</span>(topic);
</span></span><span style=display:flex><span>} <span style=color:#ff79c6>while</span> (partitionsCount <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>);
</span></span></code></pre></td></tr></table></div></div><p>再看awaitUpdate()方法，这个方法里就是不断地wait直到超时或者拉取结束</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>synchronized</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>awaitUpdate</span>(<span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd>int</span> lastVersion, <span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd>long</span> maxWaitMs) <span style=color:#8be9fd;font-style:italic>throws</span> InterruptedException {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (maxWaitMs <span style=color:#ff79c6>&lt;</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> IllegalArgumentException(<span style=color:#f1fa8c>&#34;Max time to wait for metadata updates should not be &lt; 0 milliseconds&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>long</span> begin <span style=color:#ff79c6>=</span> System.<span style=color:#50fa7b>currentTimeMillis</span>();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>long</span> remainingWaitMs <span style=color:#ff79c6>=</span> maxWaitMs;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 通过版本号判断是否拉取结束</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>version</span> <span style=color:#ff79c6>&lt;=</span> lastVersion) {
</span></span><span style=display:flex><span>        AuthenticationException ex <span style=color:#ff79c6>=</span> getAndClearAuthenticationException();
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (ex <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>)
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>throw</span> ex;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (remainingWaitMs <span style=color:#ff79c6>!=</span> 0)
</span></span><span style=display:flex><span>            wait(remainingWaitMs);
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 线程被唤醒之后还要在判断一次时间，如果是在别的地方唤醒，需要把已经等待的时间减去，然后接着等待同步元数据</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>long</span> elapsed <span style=color:#ff79c6>=</span> System.<span style=color:#50fa7b>currentTimeMillis</span>() <span style=color:#ff79c6>-</span> begin;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (elapsed <span style=color:#ff79c6>&gt;=</span> maxWaitMs)
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> TimeoutException(<span style=color:#f1fa8c>&#34;Failed to update metadata after &#34;</span> <span style=color:#ff79c6>+</span> maxWaitMs <span style=color:#ff79c6>+</span> <span style=color:#f1fa8c>&#34; ms.&#34;</span>);
</span></span><span style=display:flex><span>        remainingWaitMs <span style=color:#ff79c6>=</span> maxWaitMs <span style=color:#ff79c6>-</span> elapsed;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h5 id=sender同步数据>sender同步数据<a hidden class=anchor aria-hidden=true href=#sender同步数据>#</a></h5><p>在sender的run方法最后面调用了一个poll方法，这个poll调用的是KafkaClient的poll方法，这个方法的下面有个handleCompletedReceives()，就是处理收到结果后的处理，这个方法里使用MetadataUpdater.handleCompletedMetadataResponse更新元数据，MetadataUpdater是一个接口，默认的实现类就是DefaultMetadataUpdater，这个是KafkaClient的内部类，这个方法里继续调用metadata.update方法：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>synchronized</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>update</span>(Cluster newCluster, Set<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> unavailableTopics, <span style=color:#8be9fd>long</span> now) {
</span></span><span style=display:flex><span>    Objects.<span style=color:#50fa7b>requireNonNull</span>(newCluster, <span style=color:#f1fa8c>&#34;cluster should not be null&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 标志位改成false了</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>needUpdate</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 最后更新时间</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>lastRefreshMs</span> <span style=color:#ff79c6>=</span> now;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>lastSuccessfulRefreshMs</span> <span style=color:#ff79c6>=</span> now;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 版本号加1</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>version</span> <span style=color:#ff79c6>+=</span> 1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 处理过期的topic信息</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (topicExpiryEnabled) {
</span></span><span style=display:flex><span>        ……
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 更新元数据信息</span>
</span></span><span style=display:flex><span>	……
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 唤醒线程，之前等待元数据信息的可以继续执行了</span>
</span></span><span style=display:flex><span>    notifyAll();
</span></span><span style=display:flex><span>    log.<span style=color:#50fa7b>debug</span>(<span style=color:#f1fa8c>&#34;Updated cluster metadata version {} to {}&#34;</span>, <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>version</span>, <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>cluster</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h5 id=选择分区>选择分区<a hidden class=anchor aria-hidden=true href=#选择分区>#</a></h5><p>KafkaProducer的partition方法会先判断发送的消息是否指定了分区，指定了就直接返回，没有的话会调用DefaultPartitioner的partition方法：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>partition</span>(String topic, Object key, <span style=color:#8be9fd>byte</span><span style=color:#ff79c6>[]</span> keyBytes, Object value, <span style=color:#8be9fd>byte</span><span style=color:#ff79c6>[]</span> valueBytes, Cluster cluster) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 拿到这个topic的所有分区</span>
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>PartitionInfo<span style=color:#ff79c6>&gt;</span> partitions <span style=color:#ff79c6>=</span> cluster.<span style=color:#50fa7b>partitionsForTopic</span>(topic);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> numPartitions <span style=color:#ff79c6>=</span> partitions.<span style=color:#50fa7b>size</span>();
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 发消息时没有指定key</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (keyBytes <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> nextValue <span style=color:#ff79c6>=</span> nextValue(topic);
</span></span><span style=display:flex><span>        List<span style=color:#ff79c6>&lt;</span>PartitionInfo<span style=color:#ff79c6>&gt;</span> availablePartitions <span style=color:#ff79c6>=</span> cluster.<span style=color:#50fa7b>availablePartitionsForTopic</span>(topic);
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 可用分区数量大于0就用nextValue和可用分区取余</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (availablePartitions.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>&gt;</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>int</span> part <span style=color:#ff79c6>=</span> Utils.<span style=color:#50fa7b>toPositive</span>(nextValue) <span style=color:#ff79c6>%</span> availablePartitions.<span style=color:#50fa7b>size</span>();
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> availablePartitions.<span style=color:#50fa7b>get</span>(part).<span style=color:#50fa7b>partition</span>();
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 和所有分区取模，这时候返回的分区都是不可用的</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> Utils.<span style=color:#50fa7b>toPositive</span>(nextValue) <span style=color:#ff79c6>%</span> numPartitions;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 如果指定了key，会根据key的byte数组转成32位证书，和总分区数取模，这样就可以保证同一个key会落到同一个分区</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 可以实现发送消息顺序性</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> Utils.<span style=color:#50fa7b>toPositive</span>(Utils.<span style=color:#50fa7b>murmur2</span>(keyBytes)) <span style=color:#ff79c6>%</span> numPartitions;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h5 id=加入缓冲>加入缓冲<a hidden class=anchor aria-hidden=true href=#加入缓冲>#</a></h5><p>加入缓冲的方法在RecordAccumulator.append()方法，首先获取batch所在集合，集合的变量名是batches，类型是CopyOnWriteMap，这个是kafka自己实现的mao，适合度多写少，原理和CopyOnWriteArrayList一样</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 从ConcurrentMap&lt;TopicPartition, Deque&lt;ProducerBatch&gt;&gt; = new CopyOnWriteMap&lt;&gt;()中获取分区对应的batch</span>
</span></span><span style=display:flex><span>Deque<span style=color:#ff79c6>&lt;</span>ProducerBatch<span style=color:#ff79c6>&gt;</span> dq <span style=color:#ff79c6>=</span> getOrCreateDeque(tp);
</span></span></code></pre></td></tr></table></div></div><p>然后尝试append消息：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 加锁</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>synchronized</span> (dq) {
</span></span><span style=display:flex><span>    RecordAppendResult appendResult <span style=color:#ff79c6>=</span> tryAppend(timestamp, key, value, headers, callback, dq);
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 如果dq是空直接返回空</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 如果不是空就是写入成功了，直接返回结果</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (appendResult <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> appendResult;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>如果是空就说明没有正在使用的batch，然后计算出来消息的大小：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span> size <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(<span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>batchSize</span>, AbstractRecords.<span style=color:#50fa7b>estimateSizeInBytesUpperBound</span>(maxUsableMagic, compression, key, value, headers));
</span></span></code></pre></td></tr></table></div></div><p>然后从缓冲池里分配一块内存：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>buffer <span style=color:#ff79c6>=</span> free.<span style=color:#50fa7b>allocate</span>(size, maxTimeToBlock);
</span></span></code></pre></td></tr></table></div></div><p>然后再次尝试写入，这里使用双重检查防止多线程的时候出现并发创建batch，在老版本的时候会多一个把申请的内存放到bytebuffer里，是为了防止多线程获取到多个buffer，然后把多余的还回去。</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>synchronized</span> (dq) {
</span></span><span style=display:flex><span>    RecordAppendResult appendResult <span style=color:#ff79c6>=</span> tryAppend(timestamp, key, value, headers, callback, dq);
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 如果不是空就是写入成功了，直接返回结果</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (appendResult <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>)
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 新版本去掉了，新版本应该是在finally里面实现的这个</span>
</span></span><span style=display:flex><span>        free.<span style=color:#50fa7b>deallocate</span>(buffer);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> appendResult;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>为什么要双重检查呢，因为高并发的时候可能会出现多个线程申请到了ByteBuffer，假设10个线程申请完了之后阻塞在synchronized (dq) 这里，一个线程进去后双重检查是可以通过的，会进行后续的创建batch操作，在放回到dq中，后面的线程再进来就会在双重检查这里尝试插入成功会直接返回，不会执行后面的创建batch操作，双重检查之后会把buffer封装到MemoryRecordsBuilder中，使用刚刚创建的MemoryRecordsBuilder封装成ProducerBatch，然后ProducerBatch.tryAppend()，最后把batch加到dq中，buffer设置成null：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>MemoryRecordsBuilder recordsBuilder <span style=color:#ff79c6>=</span> recordsBuilder(buffer, maxUsableMagic);
</span></span><span style=display:flex><span>ProducerBatch batch <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ProducerBatch(tp, recordsBuilder, time.<span style=color:#50fa7b>milliseconds</span>());
</span></span><span style=display:flex><span>FutrueRecordMetadata futrue <span style=color:#ff79c6>=</span> Utils.<span style=color:#50fa7b>notNull</span>(batch.<span style=color:#50fa7b>tryAppend</span>(timestamp, key, value, headers, callback, time.<span style=color:#50fa7b>milliseconds</span>()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dq.<span style=color:#50fa7b>addLast</span>(batch);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 正在进行中的batch</span>
</span></span><span style=display:flex><span>incomplete.<span style=color:#50fa7b>add</span>(batch);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 这步第一是为了加快gc，减少gc的可达性分析，第二是防止申请出来的buffer被释放</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// finally中判断buffer != null的时候会把申请的ByteBuffer还给bufferPool</span>
</span></span><span style=display:flex><span>buffer <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>;
</span></span></code></pre></td></tr></table></div></div><p>RecordAccumulater的tryAppend很简单就是从dq里取出一个batch，然后调用batch.tryAppend()，所以不管是双重检查通过后穿件新的batch还是双重检查的时候尝试使用已有的batch，最后都是调用batch.tryAppend：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 判断batch剩余内存是否充足</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>recordsBuilder.<span style=color:#50fa7b>hasRoomFor</span>(timestamp, key, value, headers)) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>null</span>;
</span></span><span style=display:flex><span>} <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 写入数据，实现在MemoryRecordsBuilder的appendLegacyRecord()方法</span>
</span></span><span style=display:flex><span>    Long checksum <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>recordsBuilder</span>.<span style=color:#50fa7b>append</span>(timestamp, key, value, headers);
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 记录最大的消息大小</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>maxRecordSize</span> <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(<span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>maxRecordSize</span>, AbstractRecords.<span style=color:#50fa7b>estimateSizeInBytesUpperBound</span>(magic(),
</span></span><span style=display:flex><span>	……
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>点进MemoryRecordsBuilder的appendLegacyRecord()方法：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>long</span> <span style=color:#50fa7b>appendLegacyRecord</span>(<span style=color:#8be9fd>long</span> offset, <span style=color:#8be9fd>long</span> timestamp, ByteBuffer key, ByteBuffer value) <span style=color:#8be9fd;font-style:italic>throws</span> IOException {
</span></span><span style=display:flex><span>	……
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 获取消息大小</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> size <span style=color:#ff79c6>=</span> LegacyRecord.<span style=color:#50fa7b>recordSize</span>(magic, key, value);
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 这里写入了offset和size</span>
</span></span><span style=display:flex><span>    AbstractLegacyRecordBatch.<span style=color:#50fa7b>writeHeader</span>(appendStream, toInnerOffset(offset), size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (timestampType <span style=color:#ff79c6>==</span> TimestampType.<span style=color:#50fa7b>LOG_APPEND_TIME</span>)
</span></span><span style=display:flex><span>        timestamp <span style=color:#ff79c6>=</span> logAppendTime;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 这里会先计算出来crc，然后按照 crc -&gt; magic -&gt; attibutes -&gt; timestamp -&gt; key size -&gt; key -&gt; value size -&gt; value的顺序写入</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 使用appendStream往byteBuffer里写</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>long</span> crc <span style=color:#ff79c6>=</span> LegacyRecord.<span style=color:#50fa7b>write</span>(appendStream, magic, timestamp, key, value, CompressionType.<span style=color:#50fa7b>NONE</span>, timestampType);
</span></span><span style=display:flex><span>    recordWritten(offset, timestamp, size <span style=color:#ff79c6>+</span> Records.<span style=color:#50fa7b>LOG_OVERHEAD</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> crc;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>appendStream是怎么来的呢？这个appendStream是在创建MemoryRecordsBuilder的时候，先用ByteBuffer来实例化一个ByteBufferOutputStream，然后在用ByteBufferOutputStream来通过compressionType.wrapForOutput()获取到对应的压缩流，CompressionType是一个枚举类，里面有none、gzip、snappy、lz4。</p><h3 id=发送消息>发送消息<a hidden class=anchor aria-hidden=true href=#发送消息>#</a></h3><p>加入缓冲之后，sender线程就可以从缓冲中拿到消息发送了，sender中的run方法显示处理了一下transactionManager的东西，这个先不看，然后执行<strong>sendProducerData()</strong>，这个是核心发送的逻辑，方法里首先获取了一下集群的信息，然后通过缓冲区拿到能够发送的broker节点：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Cluster cluster <span style=color:#ff79c6>=</span> metadata.<span style=color:#50fa7b>fetch</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 这里拿到的是ReadyCheckResult，里面有个列表表示要发送数据的节点</span>
</span></span><span style=display:flex><span>RecordAccumulator.<span style=color:#50fa7b>ReadyCheckResult</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>accumulator</span>.<span style=color:#50fa7b>ready</span>(cluster, now);
</span></span></code></pre></td></tr></table></div></div><p>ReadyCheckResult结构：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>ReadyCheckResult</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 节点信息</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>final</span> Set<span style=color:#ff79c6>&lt;</span>Node<span style=color:#ff79c6>&gt;</span> readyNodes;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 下一次尝试发送的时间</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd>long</span> nextReadyCheckDelayMs;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 没有leader的topic信息</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>final</span> Set<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> unknownLeaderTopics;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>再看缓冲池（RecordAccumulator）的ready方法：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> ReadyCheckResult <span style=color:#50fa7b>ready</span>(Cluster cluster, <span style=color:#8be9fd>long</span> nowMs) {
</span></span><span style=display:flex><span>    Set<span style=color:#ff79c6>&lt;</span>Node<span style=color:#ff79c6>&gt;</span> readyNodes <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashSet<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>long</span> nextReadyCheckDelayMs <span style=color:#ff79c6>=</span> Long.<span style=color:#50fa7b>MAX_VALUE</span>;
</span></span><span style=display:flex><span>    Set<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> unknownLeaderTopics <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashSet<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 这个表示buffer池中有没有空闲的ByteBuffer了</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>boolean</span> exhausted <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>free</span>.<span style=color:#50fa7b>queued</span>() <span style=color:#ff79c6>&gt;</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 开始遍历缓存中的batches</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (Map.<span style=color:#50fa7b>Entry</span><span style=color:#ff79c6>&lt;</span>TopicPartition, Deque<span style=color:#ff79c6>&lt;</span>ProducerBatch<span style=color:#ff79c6>&gt;&gt;</span> entry : <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>batches</span>.<span style=color:#50fa7b>entrySet</span>()) {
</span></span><span style=display:flex><span>        TopicPartition part <span style=color:#ff79c6>=</span> entry.<span style=color:#50fa7b>getKey</span>();
</span></span><span style=display:flex><span>        Deque<span style=color:#ff79c6>&lt;</span>ProducerBatch<span style=color:#ff79c6>&gt;</span> deque <span style=color:#ff79c6>=</span> entry.<span style=color:#50fa7b>getValue</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Node leader <span style=color:#ff79c6>=</span> cluster.<span style=color:#50fa7b>leaderFor</span>(part);
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>synchronized</span> (deque) {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 没有leader就在这个变量里添加topic信息</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (leader <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>&amp;&amp;</span> <span style=color:#ff79c6>!</span>deque.<span style=color:#50fa7b>isEmpty</span>()) {
</span></span><span style=display:flex><span>                unknownLeaderTopics.<span style=color:#50fa7b>add</span>(part.<span style=color:#50fa7b>topic</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 只有要发送数据的分区的leader没添加过并且muted不包含这个分区</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 当设置同时发送的请求是1时，发送完消息不管收没收到响应都会在这个集合中插入分区信息</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>readyNodes.<span style=color:#50fa7b>contains</span>(leader) <span style=color:#ff79c6>&amp;&amp;</span> <span style=color:#ff79c6>!</span>muted.<span style=color:#50fa7b>contains</span>(part)) {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 取出第一个batch</span>
</span></span><span style=display:flex><span>                ProducerBatch batch <span style=color:#ff79c6>=</span> deque.<span style=color:#50fa7b>peekFirst</span>();
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (batch <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#6272a4>// 这个是batch创建到现在的时间</span>
</span></span><span style=display:flex><span>                    <span style=color:#8be9fd>long</span> waitedTimeMs <span style=color:#ff79c6>=</span> batch.<span style=color:#50fa7b>waitedTimeMs</span>(nowMs);
</span></span><span style=display:flex><span>                    <span style=color:#6272a4>// 发送失败次数&gt;0并且等待时间小于重试间隔</span>
</span></span><span style=display:flex><span>                    <span style=color:#6272a4>// batch.attempts()是获取发送失败次数</span>
</span></span><span style=display:flex><span>                    <span style=color:#8be9fd>boolean</span> backingOff <span style=color:#ff79c6>=</span> batch.<span style=color:#50fa7b>attempts</span>() <span style=color:#ff79c6>&gt;</span> 0 <span style=color:#ff79c6>&amp;&amp;</span> waitedTimeMs <span style=color:#ff79c6>&lt;</span> retryBackoffMs;
</span></span><span style=display:flex><span>                    <span style=color:#6272a4>// 如果是发送失败，timeToWaitMs就赋值失败等待时间，否则就是正常消息的等待时间</span>
</span></span><span style=display:flex><span>                    <span style=color:#8be9fd>long</span> timeToWaitMs <span style=color:#ff79c6>=</span> backingOff <span style=color:#ff79c6>?</span> retryBackoffMs : lingerMs;
</span></span><span style=display:flex><span>                    <span style=color:#6272a4>// 取出来的batch是否已满，如果dqueue里面的batch超过1个，那取出来的这个肯定是满的</span>
</span></span><span style=display:flex><span>                    <span style=color:#6272a4>// 如果batch只有一个，就判断这个batch的size是不是16k或者我们自己设置的</span>
</span></span><span style=display:flex><span>                    <span style=color:#8be9fd>boolean</span> full <span style=color:#ff79c6>=</span> deque.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>&gt;</span> 1 <span style=color:#ff79c6>||</span> batch.<span style=color:#50fa7b>isFull</span>();
</span></span><span style=display:flex><span>                    <span style=color:#6272a4>// 判断这个batch是否过期</span>
</span></span><span style=display:flex><span>                    <span style=color:#8be9fd>boolean</span> expired <span style=color:#ff79c6>=</span> waitedTimeMs <span style=color:#ff79c6>&gt;=</span> timeToWaitMs;
</span></span><span style=display:flex><span>                    <span style=color:#6272a4>// 当batch满了||已经过期||bufferPool没有内存了||客户端正在关闭||正在flush</span>
</span></span><span style=display:flex><span>                    <span style=color:#8be9fd>boolean</span> sendable <span style=color:#ff79c6>=</span> full <span style=color:#ff79c6>||</span> expired <span style=color:#ff79c6>||</span> exhausted <span style=color:#ff79c6>||</span> closed <span style=color:#ff79c6>||</span> flushInProgress();
</span></span><span style=display:flex><span>                    <span style=color:#6272a4>// 如果达到了上述的条件，并且不是重发，就添加分区的leader信息</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>if</span> (sendable <span style=color:#ff79c6>&amp;&amp;</span> <span style=color:#ff79c6>!</span>backingOff) {
</span></span><span style=display:flex><span>                        readyNodes.<span style=color:#50fa7b>add</span>(leader);
</span></span><span style=display:flex><span>                    } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#6272a4>// 否则就计算下次可以发送的时间</span>
</span></span><span style=display:flex><span>                        <span style=color:#8be9fd>long</span> timeLeftMs <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>max</span>(timeToWaitMs <span style=color:#ff79c6>-</span> waitedTimeMs, 0);
</span></span><span style=display:flex><span>                        nextReadyCheckDelayMs <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>min</span>(timeLeftMs, nextReadyCheckDelayMs);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> ReadyCheckResult(readyNodes, nextReadyCheckDelayMs, unknownLeaderTopics);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>回到Sender的sendProducerData方法，获取完leader信息后不确定leader的机器要重新拉取元数据信息：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>for</span> (String topic : result.<span style=color:#50fa7b>unknownLeaderTopics</span>)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>metadata</span>.<span style=color:#50fa7b>add</span>(topic);
</span></span><span style=display:flex><span><span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>metadata</span>.<span style=color:#50fa7b>requestUpdate</span>();
</span></span></code></pre></td></tr></table></div></div><p>然后遍历可以发送的leader节点，没有连接建立连接</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Iterator<span style=color:#ff79c6>&lt;</span>Node<span style=color:#ff79c6>&gt;</span> iter <span style=color:#ff79c6>=</span> result.<span style=color:#50fa7b>readyNodes</span>.<span style=color:#50fa7b>iterator</span>();
</span></span><span style=display:flex><span><span style=color:#8be9fd>long</span> notReadyTimeout <span style=color:#ff79c6>=</span> Long.<span style=color:#50fa7b>MAX_VALUE</span>;
</span></span><span style=display:flex><span><span style=color:#ff79c6>while</span> (iter.<span style=color:#50fa7b>hasNext</span>()) {
</span></span><span style=display:flex><span>    Node node <span style=color:#ff79c6>=</span> iter.<span style=color:#50fa7b>next</span>();
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 判断broker节点是否可以通信</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span><span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>client</span>.<span style=color:#50fa7b>ready</span>(node, now)) {
</span></span><span style=display:flex><span>        iter.<span style=color:#50fa7b>remove</span>();
</span></span><span style=display:flex><span>        notReadyTimeout <span style=color:#ff79c6>=</span> Math.<span style=color:#50fa7b>min</span>(notReadyTimeout, <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>client</span>.<span style=color:#50fa7b>connectionDelay</span>(node, now));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>判断节点是否可以通信在NetworkClient的ready方法：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>ready</span>(Node node, <span style=color:#8be9fd>long</span> now) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 判断是否可以发送</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (isReady(node, now))
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>    这个里面如果是没连接过，就返回true，否则返回是否是不能连接并且上次连接到现在的时间小于reconnect.<span style=color:#50fa7b>backoff</span>.<span style=color:#50fa7b>ms</span>
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>if</span> (connectionStates.<span style=color:#50fa7b>canConnect</span>(node.<span style=color:#50fa7b>idString</span>(), now))
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 初始化连接</span>
</span></span><span style=display:flex><span>        initiateConnect(node, now);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#6272a4>// isReady调用到了这里</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>isReady</span>(Node node, <span style=color:#8be9fd>long</span> now) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 满足canSendRequest()并且没有正在拉取元数据才可以发送</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>!</span>metadataUpdater.<span style=color:#50fa7b>isUpdateDue</span>(now) <span style=color:#ff79c6>&amp;&amp;</span> canSendRequest(node.<span style=color:#50fa7b>idString</span>());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#6272a4>// canSendRequest在这里</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>canSendRequest</span>(String node) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// broker连接状态的缓存是建立连接的</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// broker已经在selector上注册好了</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 同一时间允许没有响应的请求时没有到上限</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> connectionStates.<span style=color:#50fa7b>isReady</span>(node) <span style=color:#ff79c6>&amp;&amp;</span> selector.<span style=color:#50fa7b>isChannelReady</span>(node) <span style=color:#ff79c6>&amp;&amp;</span> inFlightRequests.<span style=color:#50fa7b>canSendMore</span>(node);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>所以如果判断出来broker不能发送，但是可以连接或者尝试重连，就会初始化连接，初始化连接核心代码是调用了selector的connect方法：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 这是一个状态模式，标记当前broker的状态，不同状态可以做不同操作</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>connectionStates</span>.<span style=color:#50fa7b>connecting</span>(nodeConnectionId, now);
</span></span><span style=display:flex><span>selector.<span style=color:#50fa7b>connect</span>(nodeConnectionId,
</span></span><span style=display:flex><span>                 <span style=color:#ff79c6>new</span> InetSocketAddress(node.<span style=color:#50fa7b>host</span>(), node.<span style=color:#50fa7b>port</span>()),
</span></span><span style=display:flex><span>                 <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>socketSendBuffer</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>socketReceiveBuffer</span>);
</span></span></code></pre></td></tr></table></div></div><p>这个方法里在新版本中被拆成了多个方法，整合到一起大概是这样的：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 初始化一个SocketChannel</span>
</span></span><span style=display:flex><span>SocketChannel socketChannel <span style=color:#ff79c6>=</span> SocketChannel.<span style=color:#50fa7b>open</span>();
</span></span><span style=display:flex><span><span style=color:#6272a4>// 设置为非阻塞</span>
</span></span><span style=display:flex><span>socketChannel.<span style=color:#50fa7b>configureBlocking</span>(<span style=color:#ff79c6>false</span>);
</span></span><span style=display:flex><span>Socket socket <span style=color:#ff79c6>=</span> socketChannel.<span style=color:#50fa7b>socket</span>();
</span></span><span style=display:flex><span><span style=color:#6272a4>// 设置keepAlive，这个意思是如果2个小时内双方没有通信就发送一个探测包，根据结果选择保持连接还是重新连接或者断开连接</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 2个小时是从注释看到的</span>
</span></span><span style=display:flex><span>socket.<span style=color:#50fa7b>setKeepAlive</span>(<span style=color:#ff79c6>true</span>);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 设置发送和接收的缓冲大小</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> (sendBufferSize <span style=color:#ff79c6>!=</span> Selectable.<span style=color:#50fa7b>USE_DEFAULT_BUFFER_SIZE</span>)
</span></span><span style=display:flex><span>    socket.<span style=color:#50fa7b>setSendBufferSize</span>(sendBufferSize);
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> (receiveBufferSize <span style=color:#ff79c6>!=</span> Selectable.<span style=color:#50fa7b>USE_DEFAULT_BUFFER_SIZE</span>)
</span></span><span style=display:flex><span>    socket.<span style=color:#50fa7b>setReceiveBufferSize</span>(receiveBufferSize);
</span></span><span style=display:flex><span><span style=color:#6272a4>// tcp no delay的意思是关闭Nagle，一些小包会被合并成大包一起发送，设置成true的话就会有一些延迟</span>
</span></span><span style=display:flex><span>socket.<span style=color:#50fa7b>setTcpNoDelay</span>(<span style=color:#ff79c6>true</span>);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 发送连接请求，如果配置的是阻塞模式，会阻塞在这里，如果是非阻塞但是发起和接收都在同一台机器上，这里就会马上返回成功</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 否则需要监听OP_CONNECT事件</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>boolean</span> connected <span style=color:#ff79c6>=</span> channel.<span style=color:#50fa7b>connect</span>(address);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 这步可以理解成把SocketChannel和SelectionKey绑定</span>
</span></span><span style=display:flex><span>SelectionKey key <span style=color:#ff79c6>=</span> socketChannel.<span style=color:#50fa7b>register</span>(nioSelector, SelectionKey.<span style=color:#50fa7b>OP_CONNECT</span>);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 这里最核心的就是把selectionKey封装到TransportLayer里</span>
</span></span><span style=display:flex><span>KafkaChannel channel <span style=color:#ff79c6>=</span> channelBuilder.<span style=color:#50fa7b>buildChannel</span>(id, key, maxReceiveSize, memoryPool);
</span></span><span style=display:flex><span><span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>channels</span>.<span style=color:#50fa7b>put</span>(id, channel);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 这个我理解的是把SelectionKey和SocketChannel绑定</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 和上面的正好相反，这样就可以通过SocketChannel找到selectionKey，也可以通过selectionKey找到SocketChannel</span>
</span></span><span style=display:flex><span>key.<span style=color:#50fa7b>attach</span>(channel);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> (connected) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 如果刚才是连接的结果是成功，标记一下马上就成功的SelectionKey，设置关注的事件是0</span>
</span></span><span style=display:flex><span>    immediatelyConnectedKeys.<span style=color:#50fa7b>add</span>(key);
</span></span><span style=display:flex><span>    key.<span style=color:#50fa7b>interestOps</span>(0);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>回到Sender的sendProducerData()方法，检查完连接之后会进行batch的超时处理，以后再说。如果所有节点都没有建立好连接，就会计算出来所有没建立好连接的超时时间中的最小值，和之前在ready方法里计算出来的发送的超时最小值取小返回。返回之后会继续往下走，走到NetworkClient的pool()方法，poll方法里首先获取一下距离下次更新元数据的时间，然后用这个时间和之前获取的时间还有设置的请求超时时间取一个最小值，当成poll的执行最大时间：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>long</span> metadataTimeout <span style=color:#ff79c6>=</span> metadataUpdater.<span style=color:#50fa7b>maybeUpdate</span>(now);
</span></span><span style=display:flex><span><span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>selector</span>.<span style=color:#50fa7b>poll</span>(Utils.<span style=color:#50fa7b>min</span>(timeout, metadataTimeout, requestTimeoutMs));
</span></span><span style=display:flex><span><span style=color:#8be9fd>long</span> updatedNow <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>time</span>.<span style=color:#50fa7b>milliseconds</span>();
</span></span><span style=display:flex><span>List<span style=color:#ff79c6>&lt;</span>ClientResponse<span style=color:#ff79c6>&gt;</span> responses <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#6272a4>// 完成的请求</span>
</span></span><span style=display:flex><span>handleCompletedSends(responses, updatedNow);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 完成的响应</span>
</span></span><span style=display:flex><span>handleCompletedReceives(responses, updatedNow);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 连接失败的请求</span>
</span></span><span style=display:flex><span>handleDisconnections(responses, updatedNow);
</span></span><span style=display:flex><span>handleConnections();
</span></span><span style=display:flex><span>handleInitiateApiVersionRequests(updatedNow);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 判断超时</span>
</span></span><span style=display:flex><span>handleTimedOutRequests(responses, updatedNow);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 这里是处理回调函数的逻辑</span>
</span></span><span style=display:flex><span>completeResponses(responses);
</span></span></code></pre></td></tr></table></div></div><p>Selector的poll方法里没有真正处理请求，主要的代码如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 清掉上次poll标记的东西，包括selectionKey</span>
</span></span><span style=display:flex><span>clear();
</span></span><span style=display:flex><span><span style=color:#6272a4>// 这里获取有多少selectionKey是ready的</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 如果timeout是0会调用nioSelector.selectNow()，selectNow和select(0)差不多，如果超时是0，会一直阻塞</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 否则会调用nioSelector.select(timeoutMs)</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> numReadyKeys <span style=color:#ff79c6>=</span> select(timeout);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 当numReadyKeys大于0，就说明存在ready状态的selectionKey，拿到readyKeys</span>
</span></span><span style=display:flex><span>Set<span style=color:#ff79c6>&lt;</span>SelectionKey<span style=color:#ff79c6>&gt;</span> readyKeys <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>nioSelector</span>.<span style=color:#50fa7b>selectedKeys</span>();
</span></span><span style=display:flex><span><span style=color:#6272a4>// 执行核心的poll方法</span>
</span></span><span style=display:flex><span>pollSelectionKeys(readyKeys, <span style=color:#ff79c6>false</span>, endSelect);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 这个是kafka维护的lru列表，保证一个客户端维护的连接数量</span>
</span></span><span style=display:flex><span>maybeCloseOldestConnection(endSelect);
</span></span></code></pre></td></tr></table></div></div><p>再看pollSelectionKeys中的代码（简化版）：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 这里很奇怪，没有使用selectionKey的迭代器，取出key就删除，居然只是遍历了</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 遍历的时候把selectionKeys顺序打乱，防止内存不够，一个大的请求卡在第一个位置发不出去</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> (SelectionKey key : determineHandlingOrder(selectionKeys)) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 之前使用的selectionKey attach达到channel，现在就可以根据key获取到这个channel了</span>
</span></span><span style=display:flex><span>    KafkaChannel channel <span style=color:#ff79c6>=</span> channel(key);
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 更新lru列表</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (idleExpiryManager <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>)
</span></span><span style=display:flex><span>        idleExpiryManager.<span style=color:#50fa7b>update</span>(channel.<span style=color:#50fa7b>id</span>(), currentTimeNanos);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 如果是可以连接状态，就要完成连接</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (isImmediatelyConnected <span style=color:#ff79c6>||</span> key.<span style=color:#50fa7b>isConnectable</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 这里通过kafkaChannel调用TransportLayer的finishConnect()完成连接的建立</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// boolean connected = socketChannel.finishConnect();</span>
</span></span><span style=display:flex><span>        	<span style=color:#6272a4>// if (connected)</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 这里设置selectionKey取消关注OP_CONNECT增加对OP_READ的关注，因为刚建立连接没必要还在关注OP_CONNECT</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 但是没有设置OP_WRITE事件，因为这个时候还没有开始写数据</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 		key.interestOps(key.interestOps() &amp; ~SelectionKey.OP_CONNECT | SelectionKey.OP_READ);</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (channel.<span style=color:#50fa7b>finishConnect</span>()) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>connected</span>.<span style=color:#50fa7b>add</span>(channel.<span style=color:#50fa7b>id</span>());
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>sensors</span>.<span style=color:#50fa7b>connectionCreated</span>.<span style=color:#50fa7b>record</span>();
</span></span><span style=display:flex><span>            } <span style=color:#ff79c6>else</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 如果channel没有ready，需要三次握手加上权限认证</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (channel.<span style=color:#50fa7b>isConnected</span>() <span style=color:#ff79c6>&amp;&amp;</span> <span style=color:#ff79c6>!</span>channel.<span style=color:#50fa7b>ready</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>try</span> {
</span></span><span style=display:flex><span>                channel.<span style=color:#50fa7b>prepare</span>();
</span></span><span style=display:flex><span>            } <span style=color:#ff79c6>catch</span> (AuthenticationException e) {
</span></span><span style=display:flex><span>                sensors.<span style=color:#50fa7b>failedAuthentication</span>.<span style=color:#50fa7b>record</span>();
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>throw</span> e;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (channel.<span style=color:#50fa7b>ready</span>())
</span></span><span style=display:flex><span>                sensors.<span style=color:#50fa7b>successfulAuthentication</span>.<span style=color:#50fa7b>record</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 读数据直接把数据读取到缓冲中</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (channel.<span style=color:#50fa7b>hasBytesBuffered</span>()) {
</span></span><span style=display:flex><span>            keysWithBufferedRead.<span style=color:#50fa7b>add</span>(key);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 如果是写事件调用channel.write()发送数据</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (channel.<span style=color:#50fa7b>ready</span>() <span style=color:#ff79c6>&amp;&amp;</span> key.<span style=color:#50fa7b>isWritable</span>()) {
</span></span><span style=display:flex><span>            Send send <span style=color:#ff79c6>=</span> channel.<span style=color:#50fa7b>write</span>();
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (send <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>completedSends</span>.<span style=color:#50fa7b>add</span>(send);
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>sensors</span>.<span style=color:#50fa7b>recordBytesSent</span>(channel.<span style=color:#50fa7b>id</span>(), send.<span style=color:#50fa7b>size</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>/* cancel any defunct sockets */</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>key.<span style=color:#50fa7b>isValid</span>())
</span></span><span style=display:flex><span>            close(channel, CloseMode.<span style=color:#50fa7b>GRACEFUL</span>);
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>finally</span> {
</span></span><span style=display:flex><span>        maybeRecordTimePerConnection(channel, channelStartTimeNanos);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>到这里，第一次发送数据的流程就结束了，主要是建立连接，然后接收连接建立成功，准备写数据。</p><p>当第二次进入Sender的run() -> sendProducerData()的时候，此时broker已经建立好连接了，首先要执行的就是封装发送数据：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 调用缓冲区把创建发送的数据，key是node的id，得到的是每个node上可以发送的batch集合</span>
</span></span><span style=display:flex><span>Map<span style=color:#ff79c6>&lt;</span>Integer, List<span style=color:#ff79c6>&lt;</span>ProducerBatch<span style=color:#ff79c6>&gt;&gt;</span> batches <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>accumulator</span>.<span style=color:#50fa7b>drain</span>(cluster, result.<span style=color:#50fa7b>readyNodes</span>,
</span></span><span style=display:flex><span>                                                                   <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>maxRequestSize</span>, now);
</span></span></code></pre></td></tr></table></div></div><p>drain方法没有特殊的处理，只是做一些过滤和判断，核心的代码：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>for</span> (Node node : nodes) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// do while就是把node里的partition遍历一遍</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>do</span> {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 拿到partition中的缓存队列中的第一个batch</span>
</span></span><span style=display:flex><span>        ProducerBatch first <span style=color:#ff79c6>=</span> deque.<span style=color:#50fa7b>peekFirst</span>();
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 大小判断、过滤掉发送中的</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 满足条件就取出第一个</span>
</span></span><span style=display:flex><span>        ProducerBatch batch <span style=color:#ff79c6>=</span> deque.<span style=color:#50fa7b>pollFirst</span>();
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 设置一些状态</span>
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>while</span> (start <span style=color:#ff79c6>!=</span> drainIndex);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>然后会带Map&lt;Integer, List>走到下一个sendProduceRequest()：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 把同一个node上的batch按照partition分组</span>
</span></span><span style=display:flex><span>Map<span style=color:#ff79c6>&lt;</span>TopicPartition, MemoryRecords<span style=color:#ff79c6>&gt;</span> produceRecordsByPartition <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashMap<span style=color:#ff79c6>&lt;&gt;</span>(batches.<span style=color:#50fa7b>size</span>());
</span></span><span style=display:flex><span><span style=color:#6272a4>// 整个请求封装成ProduceRequest.Builder</span>
</span></span><span style=display:flex><span>ProduceRequest.<span style=color:#50fa7b>Builder</span> requestBuilder <span style=color:#ff79c6>=</span> ProduceRequest.<span style=color:#50fa7b>Builder</span>.<span style=color:#50fa7b>forMagic</span>(minUsedMagic, acks, timeout,
</span></span><span style=display:flex><span>                                                                        produceRecordsByPartition,
</span></span><span style=display:flex><span>                                                                        transactionalId);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 在封装成clientRequest</span>
</span></span><span style=display:flex><span>ClientRequest clientRequest <span style=color:#ff79c6>=</span> client.<span style=color:#50fa7b>newClientRequest</span>(nodeId, requestBuilder, now, acks <span style=color:#ff79c6>!=</span> 0, callback);
</span></span><span style=display:flex><span>client.<span style=color:#50fa7b>send</span>(clientRequest, now);
</span></span></code></pre></td></tr></table></div></div><p>NetworkClient的doSend方法:</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 通过builder.build()实例化一个ProduceRequest，这个和老版本不一样，找了半天</span>
</span></span><span style=display:flex><span>doSend(clientRequest, isInternalRequest, now, builder.<span style=color:#50fa7b>build</span>(version));
</span></span></code></pre></td></tr></table></div></div><p>继续看下一个doSend方法：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>doSend</span>(ClientRequest clientRequest, <span style=color:#8be9fd>boolean</span> isInternalRequest, <span style=color:#8be9fd>long</span> now, AbstractRequest request) {
</span></span><span style=display:flex><span>    String nodeId <span style=color:#ff79c6>=</span> clientRequest.<span style=color:#50fa7b>destination</span>();
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 封装一个header</span>
</span></span><span style=display:flex><span>    RequestHeader header <span style=color:#ff79c6>=</span> clientRequest.<span style=color:#50fa7b>makeHeader</span>(request.<span style=color:#50fa7b>version</span>());
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 封装send</span>
</span></span><span style=display:flex><span>    Send send <span style=color:#ff79c6>=</span> request.<span style=color:#50fa7b>toSend</span>(nodeId, header);
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 维护inFlightRequests</span>
</span></span><span style=display:flex><span>    InFlightRequest inFlightRequest <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> InFlightRequest(
</span></span><span style=display:flex><span>        header,
</span></span><span style=display:flex><span>        clientRequest.<span style=color:#50fa7b>createdTimeMs</span>(),
</span></span><span style=display:flex><span>        clientRequest.<span style=color:#50fa7b>destination</span>(),
</span></span><span style=display:flex><span>        clientRequest.<span style=color:#50fa7b>callback</span>(),
</span></span><span style=display:flex><span>        clientRequest.<span style=color:#50fa7b>expectResponse</span>(),
</span></span><span style=display:flex><span>        isInternalRequest,
</span></span><span style=display:flex><span>        request,
</span></span><span style=display:flex><span>        send,
</span></span><span style=display:flex><span>        now);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>inFlightRequests</span>.<span style=color:#50fa7b>add</span>(inFlightRequest);
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 调用kafka的selector的send方法，这里面只调用了kafkaChannel的setSend方法</span>
</span></span><span style=display:flex><span>    selector.<span style=color:#50fa7b>send</span>(inFlightRequest.<span style=color:#50fa7b>send</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>KafkaChannel的setSend核心一行代码：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// 设置selectionKey关注OP_WRITE事件</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 还记得上面建立连接之后并没有关注OP_WRITE事件，在确定要发送消息的时候也就是这里才开始关注</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>transportLayer</span>.<span style=color:#50fa7b>addInterestOps</span>(SelectionKey.<span style=color:#50fa7b>OP_WRITE</span>);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 里面执行的代码是key.interestOps(key.interestOps() | ops);</span>
</span></span></code></pre></td></tr></table></div></div><p>因为sendProducerData(now)之后马上回执行client.poll方法，在这个方法中执行的是selector的pollSelectionKeys方法：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>if</span> (channel.<span style=color:#50fa7b>ready</span>() <span style=color:#ff79c6>&amp;&amp;</span> key.<span style=color:#50fa7b>isWritable</span>()) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 发送数据</span>
</span></span><span style=display:flex><span>    Send send <span style=color:#ff79c6>=</span> channel.<span style=color:#50fa7b>write</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (send <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 维护成功发送的请求</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>completedSends</span>.<span style=color:#50fa7b>add</span>(send);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>sensors</span>.<span style=color:#50fa7b>recordBytesSent</span>(channel.<span style=color:#50fa7b>id</span>(), send.<span style=color:#50fa7b>size</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>kafkChannel里的write有一行代码非常关键：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>send</span>(Send send) <span style=color:#8be9fd;font-style:italic>throws</span> IOException {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 这里就是调用java nio的channel.write()</span>
</span></span><span style=display:flex><span>    send.<span style=color:#50fa7b>writeTo</span>(transportLayer);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (send.<span style=color:#50fa7b>completed</span>())
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 这里会把OP_WRITE事件从selectionKey关注中移除</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// key.interestOps(key.interestOps() &amp; ~ops);</span>
</span></span><span style=display:flex><span>        transportLayer.<span style=color:#50fa7b>removeInterestOps</span>(SelectionKey.<span style=color:#50fa7b>OP_WRITE</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> send.<span style=color:#50fa7b>completed</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h5 id=对关注事件操作的总结>对关注事件操作的总结<a hidden class=anchor aria-hidden=true href=#对关注事件操作的总结>#</a></h5><p>SelectionKey相关的时间一共有4个，OP_READ，OP_WRITE，OP_CONNECT，OP_ACCEPT，上面没有OP_ACCEPT，因为他表示接收连接，在producer中都是发起连接，这4个事件分别是int的第0、2、3、4位，第1位没有值？？？</p><p>发送消息的源码一共出现了3次关注事件：</p><ul><li>socketChannel.register(nioSelector, SelectionKey.OP_CONNECT);这个就是注册的时候设置的关注事件；</li><li>key.interestOps(key.interestOps() & ~SelectionKey.OP_CONNECT | SelectionKey.OP_READ);连接之后开始关注OP_READ事件；</li><li>key.interestOps(key.interestOps() | ops);把消息发送到缓冲里后开始关注OP_WRITE事件；</li></ul><p>可以看到nio的SelectionKey是可以同时关注多个事件的，通过& ~来取消关注，| 新增关注。</p><h5 id=如果一次write不能没有发送所有的bytebuffer数据>如果一次write不能没有发送所有的ByteBuffer数据<a hidden class=anchor aria-hidden=true href=#如果一次write不能没有发送所有的bytebuffer数据>#</a></h5><p>在发送数据的时候Send里会初始化一个remaining，这个数据的大小，然后每次write之后remaining都会减掉发送数据的大小，kafkChannel的send中通过send.completed()来判断是否全部发送，其实就是判断remaining是不是=0，如果remaining>0，不会标记成completed，send也不会标记成null，然后还记得在run方法中调用的ready()方法吗，在这里会调用InFlightRequests的canSendMore()方法：</p><div class=highlight><div style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>boolean</span> <span style=color:#50fa7b>canSendMore</span>(String node) {
</span></span><span style=display:flex><span>    Deque<span style=color:#ff79c6>&lt;</span>NetworkClient.<span style=color:#50fa7b>InFlightRequest</span><span style=color:#ff79c6>&gt;</span> queue <span style=color:#ff79c6>=</span> requests.<span style=color:#50fa7b>get</span>(node);
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// queue.peekFirst().send.completed()就是判断一个请求是否发送完</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> queue <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>||</span> queue.<span style=color:#50fa7b>isEmpty</span>() <span style=color:#ff79c6>||</span>
</span></span><span style=display:flex><span>        (queue.<span style=color:#50fa7b>peekFirst</span>().<span style=color:#50fa7b>send</span>.<span style=color:#50fa7b>completed</span>() <span style=color:#ff79c6>&amp;&amp;</span> queue.<span style=color:#50fa7b>size</span>() <span style=color:#ff79c6>&lt;</span> <span style=color:#ff79c6>this</span>.<span style=color:#50fa7b>maxInFlightRequestsPerConnection</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>如果没有发送完，result会把他删掉，就不会发送心情求了，但是，poll方法还会执行，并且这个SelectionKey还在关注OP_WRITE事件，就会继续发送数据，直到数据全部发送出去。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wangxiaohong123.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/>大数据</a></li></ul><nav class=paginav><a class=prev href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/mq/kafka/7.producer%E5%88%9D%E5%A7%8B%E5%8C%96%E6%BA%90%E7%A0%81/><span class=title>« Prev</span><br><span>7.kafka源码-producer初始化</span>
</a><a class=next href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/mq/kafka/9.%E8%AF%BB%E5%8F%96%E5%93%8D%E5%BA%94/><span class=title>Next »</span><br><span>9.kafka源码-读取响应</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 8.kafka源码-producer发送消息 on x" href="https://x.com/intent/tweet/?text=8.kafka%e6%ba%90%e7%a0%81-producer%e5%8f%91%e9%80%81%e6%b6%88%e6%81%af&amp;url=https%3a%2f%2fwangxiaohong123.github.io%2fposts%2f%25E6%25A1%2586%25E6%259E%25B6%2fmq%2fkafka%2f8.producer%25E5%258F%2591%25E9%2580%2581%25E6%25B6%2588%25E6%2581%25AF%2f&amp;hashtags=%e5%a4%a7%e6%95%b0%e6%8d%ae"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 8.kafka源码-producer发送消息 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwangxiaohong123.github.io%2fposts%2f%25E6%25A1%2586%25E6%259E%25B6%2fmq%2fkafka%2f8.producer%25E5%258F%2591%25E9%2580%2581%25E6%25B6%2588%25E6%2581%25AF%2f&amp;title=8.kafka%e6%ba%90%e7%a0%81-producer%e5%8f%91%e9%80%81%e6%b6%88%e6%81%af&amp;summary=8.kafka%e6%ba%90%e7%a0%81-producer%e5%8f%91%e9%80%81%e6%b6%88%e6%81%af&amp;source=https%3a%2f%2fwangxiaohong123.github.io%2fposts%2f%25E6%25A1%2586%25E6%259E%25B6%2fmq%2fkafka%2f8.producer%25E5%258F%2591%25E9%2580%2581%25E6%25B6%2588%25E6%2581%25AF%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 8.kafka源码-producer发送消息 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwangxiaohong123.github.io%2fposts%2f%25E6%25A1%2586%25E6%259E%25B6%2fmq%2fkafka%2f8.producer%25E5%258F%2591%25E9%2580%2581%25E6%25B6%2588%25E6%2581%25AF%2f&title=8.kafka%e6%ba%90%e7%a0%81-producer%e5%8f%91%e9%80%81%e6%b6%88%e6%81%af"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 8.kafka源码-producer发送消息 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwangxiaohong123.github.io%2fposts%2f%25E6%25A1%2586%25E6%259E%25B6%2fmq%2fkafka%2f8.producer%25E5%258F%2591%25E9%2580%2581%25E6%25B6%2588%25E6%2581%25AF%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 8.kafka源码-producer发送消息 on whatsapp" href="https://api.whatsapp.com/send?text=8.kafka%e6%ba%90%e7%a0%81-producer%e5%8f%91%e9%80%81%e6%b6%88%e6%81%af%20-%20https%3a%2f%2fwangxiaohong123.github.io%2fposts%2f%25E6%25A1%2586%25E6%259E%25B6%2fmq%2fkafka%2f8.producer%25E5%258F%2591%25E9%2580%2581%25E6%25B6%2588%25E6%2581%25AF%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 8.kafka源码-producer发送消息 on telegram" href="https://telegram.me/share/url?text=8.kafka%e6%ba%90%e7%a0%81-producer%e5%8f%91%e9%80%81%e6%b6%88%e6%81%af&amp;url=https%3a%2f%2fwangxiaohong123.github.io%2fposts%2f%25E6%25A1%2586%25E6%259E%25B6%2fmq%2fkafka%2f8.producer%25E5%258F%2591%25E9%2580%2581%25E6%25B6%2588%25E6%2581%25AF%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 8.kafka源码-producer发送消息 on ycombinator" href="https://news.ycombinator.com/submitlink?t=8.kafka%e6%ba%90%e7%a0%81-producer%e5%8f%91%e9%80%81%e6%b6%88%e6%81%af&u=https%3a%2f%2fwangxiaohong123.github.io%2fposts%2f%25E6%25A1%2586%25E6%259E%25B6%2fmq%2fkafka%2f8.producer%25E5%258F%2591%25E9%2580%2581%25E6%25B6%2588%25E6%2581%25AF%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>