<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.150.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>王小红的笔记</title><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wangxiaohong123.github.io/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="王小红的笔记"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="王小红的笔记"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"王小红的笔记","url":"https://wangxiaohong123.github.io/","description":"","logo":"https://wangxiaohong123.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>3.netty-处理消息源码</h2></header><div class=entry-content><p>已经知道了NioEventLoop继承SingleThreadEventLoop，而SingleThreadEventLoop是实现了EventLoop的。
SingleThreadEventLoop其实就是一个线程池，只不过它里面只有1个线程，在SingleThreadEventExecutor中自己定义了一个run()方法，在LocalServerChannel的doRegister方法被调用时，需要时会调用SingleThreadEventExecutor的addShutdownHook()方法，这个方法里调用了自己的execute()方法，在execute方法中调用了run()方法。
在run()方法中是一个死循环，不断地执行processSelectedKeys();方法：
1 2 3 4 5 6 7 8 private void processSelectedKeys() { if (selectedKeys != null) { processSelectedKeysOptimized(); } else { // 拿到selectedKeys processSelectedKeysPlain(selector.selectedKeys()); } } 拿到selectedKeys之后就是要循环了，把SelectionKey交给processSelectedKey()方法处理：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) { final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe(); if (!k.isValid()) { final EventLoop eventLoop; try { eventLoop = ch.eventLoop(); } catch (Throwable ignored) { return; } if (eventLoop == this) { // close the channel if the key is not valid anymore unsafe.close(unsafe.voidPromise()); } return; } try { int readyOps = k.readyOps(); // 处理OP_CONNECT事件 if ((readyOps & SelectionKey.OP_CONNECT) != 0) { // remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking // See https://github.com/netty/netty/issues/924 int ops = k.interestOps(); // 这部设置完了，原来关注什么事件，结果不变 // 除非原来就关注OP_CONNECT事件，经过下面的运算会变成关注OP_ACCEPT事件 ops &= ~SelectionKey.OP_CONNECT; k.interestOps(ops); unsafe.finishConnect(); } // 处理OP_WRITE事件 if ((readyOps & SelectionKey.OP_WRITE) != 0) { ch.unsafe().forceFlush(); } // 处理读和建立连接事件 // 这里通过检查readyOps == 0解决jdk自旋错误 if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) { unsafe.read(); } } catch (CancelledKeyException ignored) { unsafe.close(unsafe.voidPromise()); } } 收消息源码 上面的unsafe.read();会经过NioMessageUnsafe的read()方法->DefaultChannelPipeline的fireChannelRead()方法->AbstractChannelHandlerContext的invokeChannelRead()方法，最后到AbstractChannelHandlerContext的invokeChannelRead()方法：
...</p></div><footer class=entry-footer>5 min</footer><a class=entry-link aria-label="post link to 3.netty-处理消息源码" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/nio/netty/3.%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E6%BA%90%E7%A0%81/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>3.NIO-selector</h2></header><div class=entry-content><p>selector是专门在网络通信中使用的，多路复用思想。基于操作系统底层的select机制，监听所有客户端的连接，收到请求不会处理，一般都是交给一个队列，这样selector就专门干监听，我们只要创建一个线程池，每个线程绑定一个队列，消费这个队列就可以了。
NIO网络demo-服务端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 public class NIOServer { private static final CharsetEncoder encoder = Charset.forName("UTF-8").newEncoder(); private static final CharsetDecoder decoder = Charset.forName("UTF-8").newDecoder(); private static ByteBuffer readBuffer; private static Selector selector; public static void main(String[] args) { init(); listen(); } private static void init(){ // 读取请求数据的缓冲区 readBuffer = ByteBuffer.allocate(1024); // 监听客户端连接的channel ServerSocketChannel servSocketChannel; try { servSocketChannel = ServerSocketChannel.open(); // 设置为非阻塞 // 否则SocketChannel没有事件时，selector会一直阻塞住，不去监听其他channel servSocketChannel.configureBlocking(false); // 9000是服务端监听的端口号 // backlog是请求的队列长度是100，意思就是最多支持100个客户端保持连接 servSocketChannel.socket().bind(new InetSocketAddress(9000), 100); selector = Selector.open(); // 把servSocketChannel注册到selector上，并且配置监听的事件是OP_ACCEPT // OP_ACCEPT的意思是tcp连接请求 servSocketChannel.register(selector, SelectionKey.OP_ACCEPT); } catch (IOException e) { e.printStackTrace(); } } private static void listen() { while(true){ try{ // 这里会阻塞住，等待有事件产生 // 所以nio是同步非阻塞的 selector.select(); // 一个SelectionKey约等于1个请求 Iterator&lt;SelectionKey> keysIterator = selector.selectedKeys().iterator(); while(keysIterator.hasNext()){ SelectionKey key = keysIterator.next(); keysIterator.remove(); // 处理事件 // 正常来说应该把这个事件放到队列中，交给线程池处理 handleKey(key); } } catch(Throwable t){ t.printStackTrace(); } } } private static void handleKey(SelectionKey key) throws IOException { SocketChannel channel = null; try{ // 处理连接请求 if(key.isAcceptable()) { ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel(); // 进行tcp3次握手后会生成一个socketChannel // 通过socketChannel就可以实现和客户端收发数据 channel = serverChannel.accept(); channel.configureBlocking(false); // 把SocketChannel注册到selector上，并设置监听的请求是OP_READ channel.register(selector, SelectionKey.OP_READ); } else if(key.isReadable()) { // 处理客户端发送过来的数据 channel = (SocketChannel) key.channel(); // 缓冲区复位 readBuffer.clear(); // 把数据写入到缓冲区 int count = channel.read(readBuffer); if(count > 0) { // 让position变成0，limit变成接收到的字符长度 // 这样就可以只读取这次收到的数据了 readBuffer.flip(); CharBuffer charBuffer = decoder.decode(readBuffer); System.out.println("收到请求：" + charBuffer.toString()); // 返回响应 channel.write(encoder.encode(CharBuffer.wrap("收到"))); } else { channel.close(); } } } catch(Throwable t) { t.printStackTrace(); if(channel != null){ channel.close(); } } } } NIO网络demo-客户端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 public class NIOClient { private static final CharsetEncoder encoder = Charset.forName("UTF-8").newEncoder(); private static final CharsetDecoder decoder = Charset.forName("UTF-8").newDecoder(); public static void main(String[] args) { for(int i = 0; i &lt; 10; i++) { new Worker().start(); } } static class Worker extends Thread { @Override public void run() { SocketChannel channel = null; Selector selector = null; try { // 创建SocketChannel注册到selector上，并且设置关注的事件是OP_CONNECT channel = SocketChannel.open(); channel.configureBlocking(false); channel.connect(new InetSocketAddress("localhost", 9000)); selector = Selector.open(); channel.register(selector, SelectionKey.OP_CONNECT); while(true) { selector.select(); Iterator&lt;SelectionKey> keysIterator = selector.selectedKeys().iterator(); while(keysIterator.hasNext()) { SelectionKey key = keysIterator.next(); keysIterator.remove(); // 处理建完连接 if(key.isConnectable()) { if(channel.isConnectionPending()) { if(channel.finishConnect()) { key.interestOps(SelectionKey.OP_READ); channel.write(encoder.encode(CharBuffer.wrap("你好"))); } else { key.cancel(); } } } else if(key.isReadable()) { // 处理服务端发送过来的数据 ByteBuffer byteBuffer = ByteBuffer.allocate(128); channel.read(byteBuffer); byteBuffer.flip(); CharBuffer charBuffer = decoder.decode(byteBuffer); System.out.println("收到响应：" + charBuffer.toString()); channel.write(encoder.encode(CharBuffer.wrap("你好"))); } } } } catch (Exception e) { e.printStackTrace(); } finally { if(channel != null) { try { channel.close(); } catch (IOException e) { e.printStackTrace(); } } if(selector != null) { try { selector.close(); } catch (IOException e) { e.printStackTrace(); } } } } } } SelectionKey，就相当于一个SocketChannel，主要有4个方法 key.isAcceptable()：当有客户端连接时触发，这个时候需要获取ServerSocketChannel调用accept方法，然后注册监听事件； key.isConnectable()：表示建立连接成功或者失败或者还没完成，需要在内部继续判断是否完成连接； key.isWritable()：可以写数据； key.isReadable()：读取数据； ...</p></div><footer class=entry-footer>3 min</footer><a class=entry-link aria-label="post link to 3.NIO-selector" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/nio/3.selector/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>3.seata解决圣诞链路数据不一致问题</h2></header><div class=entry-content><p>订单号规则 订单号是一个19位的字符串，由4部分组成例如：
10 20211218 00000001 012
|类型|日期|序列号|用户id后3位|
前两位是订单类型，10表示正向，20标识逆向(比如退款)，中间6位是⽇期，日期后8位是序列号(不够补0)，最后3位是用户id后3位(不够补0)。
生单链路数据不一致问题 创建订单时需要先进行风控检查，然后获取商品信息，计算订单价格，然后锁定优惠券，锁定库存，最后在数据库中插入订单信息，这里最少设计到3个服务对数据库做出了修改，营销服务、库存服务、订单服务，而订单服务在插入订单时可能涉及到拆单问题，并且需要操作的表有订单表、订单条目表、配送信息表、支付信息表、订单费用表、订单费用明细表、订单状态变更日志表、订单快照数据表等，任何一条sql出错都需要整个生单链路的所有对mysql的操作进行回滚，正常的本地事务没法保证订单、营销、库存里任何一个服务发生异常，其他服务回滚数据。
seata原理 AT模式原理 首先有一个Seata Server负责控制事务的提交和回滚，每个服务里需要引入seata client负责监听sql，并声称对应的undo_log，undo_log存储在表里，并且操作本地数据和插入undo_log在同一本地事务中，当服务完成本地事务后需要高速Seata Server分支事务提交成功，所有分支事务都完成后(那个角色提交？)向Seata Server提交事务并释放全局锁，如果存在某个服务发生异常，此时Seata Server会想提交分支事务成功的服务发送执行回滚日志消息，再有seata client执行对应的undo_log。
读写隔离原理 seata的隔离级别是读未提交，未提交指的是分布式事务没有提交，并不是本地事务。
首先完整的流程如下图，在提交本地事务前必须要通过Seata Server获取全局锁，其他分布式事务在没有拿到全局锁前不能提交本地事务，如果没有全局锁会导致多个分布式事务同时操作一条数据，发生回滚时数据错乱的问题，但是引入的全局锁会让性能下降的严重，所以AT模式的分布式事务只用在很钱相关的操作里，其他时候如果需要用到分布式事务可以使用mq的软事务。
死锁问题 比如上图两个事务操作同一条数据，事务1中服务A的操作执行完成并且提交了本地事务，此时事务2开始执行服务A的操作，此时全局锁在事务1上，所以事务2的服务A没法提交本地事务，他会等待拿到全局锁，但是这个时候他是持有11001的本地锁的，事务1在执行服务B操作的时候发生异常需要回滚，服务A收到回滚消息需要拿到11001的本地锁，出现了事务1持有事务2需要的全局锁，事务2持有事务1需要的本地锁，循环等待了，seata为了解决这个死锁问题在获取全局锁的时候加了个超时机制，如果超时会回滚数据并释放锁。
使用seata 前提：Seata Server启动好，每个服务对应的库创建好undo_log表。
pom中添加依赖：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 &lt;!-- 引入seata整合分布式事务 --> &lt;dependency> &lt;groupId>com.alibaba.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-alibaba-seata&lt;/artifactId> &lt;exclusions> &lt;exclusion> &lt;groupId>io.seata&lt;/groupId> &lt;artifactId>seata-spring-boot-starter&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;!-- 跟安装的seata-server需要保持版本一致 --> &lt;dependency> &lt;groupId>io.seata&lt;/groupId> &lt;artifactId>seata-spring-boot-starter&lt;/artifactId> &lt;version>1.3.0&lt;/version> &lt;/dependency> 添加配置：
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to 3.seata解决圣诞链路数据不一致问题" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/cloud-alibaba-demo%E4%B9%8B%E8%AE%A2%E5%8D%95/3.seata%E8%A7%A3%E5%86%B3%E7%94%9F%E5%8D%95%E9%93%BE%E8%B7%AF%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>3.shiro-认证流程</h2></header><div class=entry-content><p>单realm认证 在我们的登录接口中是先使用用户名、密码和账号的类型封装成了token，在使用SecurityUtils.getSubject().login(token)进行登录，断点跟到了DelegatingSubject的login()方法中，这个方法调用了securityManager的login方法并返回SubObject：
1 Subject subject = securityManager.login(this, token); 然后进到DefaultSecurityManager的login()方法里，先调用了authenticate(token)方法，下面就是一些成功和失败的处理，点到authenticate()方法，还是只是调用其他方法:return this.authenticator.authenticate(token);,跟到了AbstractAuthenticator的authenticate方法，调用的是子类的doAuthenticate(token)方法，最后进到ModularRealmAuthenticator类中找到了核心代码：
1 2 3 4 5 6 7 8 9 protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException { assertRealmsConfigured(); Collection&lt;Realm> realms = getRealms(); if (realms.size() == 1) { return doSingleRealmAuthentication(realms.iterator().next(), authenticationToken); } else { return doMultiRealmAuthentication(realms, authenticationToken); } } 首先进到单realm验证的方法：
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to 3.shiro-认证流程" href=https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/shiro/3.%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>3.zk-curator</h2></header><div class=entry-content><p>curator是业内使用最广泛的zk客户端框架。他是网飞的。
crud
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public static void main(String[] args) throws Exception { RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3); // 源码里用的构造器模式 CuratorFramework client = CuratorFrameworkFactory.newClient("localhost:2181", // 心跳超时时间 5000, // 连接超时时间 3000, retryPolicy); client.start(); client.delete().forPath("/my/path"); // creatingParentsIfNeeded是自动创建父节点 // withMode是节点类型，临时节点、永久节点、临时顺序节点…… client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT) .forPath("/my/path", "100".getBytes(StandardCharsets.UTF_8)); System.out.println(new String(client.getData().forPath("/my/path"))); client.setData().forPath("/my/path", "200".getBytes(StandardCharsets.UTF_8)); System.out.println(new String(client.getData().forPath("/my/path"))); client.close(); } znode节点监听
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 3.zk-curator" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/zookeeper/3.curator/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>3.分库分表-经验</h2></header><div class=entry-content><p>shard key 分库分表后首先要考虑的就是分片key的设计，比如单号和用户关联，订单号使用类型(10表示正向下单，20表示退单)+flicker+用户id后3位，这样订单就和用户关联起来，查询用户的订单会路由到同一个库的同一张表中，查询订单明细也会路由到同一个库的同一张表中
主键id 分库分表后的id一般都会使用雪花算法生成，保证不同表的id也没有重复，但是一般shard key不会采用id，这个id其实是没有查询意义的。
默认策略 有的表不需要分库分表(比如seata)，有的表只要分库，有的表需要分库分表，不分库分表的会去走默认策略。有的业务需要一种每个库存储一样的数据，就要配置成广播表。
配合其他数据库 分库分表的原因是数据量过大，一帮分库分表之后只靠MySQL是无法满足业务的，高频率的复杂查询和复杂查询+分页需要es的配合，低频率的大量数据可以使用MongoDB，还有一些更大数据量的低频查询数据可以使用HBase，他和MongoDB的区别是他可以对保存的数据进行列扩展，还可以对MySQL的一些数据做降级，需要注意HBase的查询只有根据rowkey才快，所以在rowkey的设计上需要一些技巧。
数据迁移 分库分表或者多种库异构存储就要涉及到数据迁移，数据迁移方案由两步组成，全量同步和增量同步，两步就有同步执行和串行执行，在执行数据迁移之前要把新版本的服务环境和服务运行起来，此时流量0%打到新系统上，启动数据迁移系统，然后启动canal监听老版本和新版本数据库的binlog，开启数据全量同步。
全量和增量串行，如果是串行在全量同步的时候收到的增量变更只记录，不执行，等到全量同步完成后，遍历增量变更数据，根据变更时间和全量数据的查询时间，选择性刷新数据，在全量同步完成后，收到的增量变更不记录，直接刷新，然后修改分流方案，让流量全部打到新系统上，这个时候就服务就已经没用了，等到增量的topic全部消费完数据迁移服务也没用了。适合小数据量的数据迁移。 全量和增量并行，并行和串行类似，但是比串行快，同时迁移代码也更复杂，需要处理好并发问题。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 3.分库分表-经验" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/3.%E7%BB%8F%E9%AA%8C/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>3.容器初始化</h2></header><div class=entry-content><p>首先想一下如果我们自己实现了一个框架怎么把对象交给spring容器管理，比如类似mybatis使用动态代理生成的对象？
@Service……这种注解：不行，这个注解写到类上，就算我们动态生成的对象可以加上这个注解，Spring也不会扫描。
xml+Bean标签：不行，和上面一样。
@Bean注解：可以，向下面这样：
1 2 3 4 @Bean public MyMapper myMapper() { return (MyMapper) MySqlSession.getMapper(MyMapper.class); } 使用FactoryBean：可以：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Component public class MyFactoryBean implements FactoryBean { Class mapperInterface; public void setMapperInterface(Class mapperInterface) { this.mapperInterface = mapperInterface; } @Override public Object getObject() throws Exception { // 单例池 存放大部分的Bean return MySqlSession.getMapper(mapperInterface); } @Override public Class&lt;?> getObjectType() { return mapperInterface; } } 使用Spring api：可以：
...</p></div><footer class=entry-footer>6 min</footer><a class=entry-link aria-label="post link to 3.容器初始化" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/framework/3.%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>3.归并排序</h2></header><div class=entry-content><p>我觉得归并排序的归并意思是递归、合并，因为这个算法就两步递归和合并。主要的思想就是把数组拆分成两个，两个数组排序完在合并到一起，差分出来的这个数组又可以继续调用这个方法，递归起来了。
归并主要分成自顶向下和自底向上，不管是那种都会有合并的过程，合并方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 把a[lo]~a[mid]he a[mid+1]~a[hi]合并 */ public void merge(Comparable[] a, int lo, int mid, int hi) { int i = lo, j = mid + 1; if (hi + 1 - lo >= 0) { System.arraycopy(a, lo, aux, lo, hi + 1 - lo); } for (int k = lo; k &lt;= hi; k++) { if (i > mid) { a[k] = aux[j++]; } else if (j > hi) { a[k] = aux[i++]; } else if (less(aux[j], aux[i])) { a[k] = aux[j++]; } else { a[k] = aux[i++]; } } } 自顶向下 1 2 3 4 5 6 7 8 9 10 private void sort(Comparable[] a, int lo, int hi) { if (lo >= hi) { return; } int mid = lo + (hi - lo) / 2; sort(a, lo, mid); sort(a, mid + 1, hi); merge(a, lo, mid, hi); } 分析一下时间复杂度，首先可以推出来整个排序的复杂度：C(N) = C(N/2) + C(N/2) + N，第一个C(N/2)表示sort(a, lo, mid);第二个C(N/2)表示sort(a, mid + 1, hi);最后一个N表示merge(a, lo, mid, hi);这个取值最小为N/2，最大才是N，因为merge方法里涉及到计算的是less(aux[j], aux[i])，最好的情况就是比较了N/2次之后就不比较了，最坏情况就是数组的左半部分和有半部分就是一大一小、一大一小，一直比较N次，这里可以就是约等于N。
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 3.归并排序" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/3.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>3.最大子数组和</h2></header><div class=entry-content><p>题目信息 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。
示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
提示：
1 &lt;= nums.length &lt;= 10^5^ -10^4^ &lt;= nums[i] &lt;= 10^4^ 根据题目得到一下结论：
输入一个数组，返回一个整数，返回的这个整数是连续子数组的和； 连续子数组意思是下标是连续的，也就是说不能打乱顺序了； 算法思路 1.暴力解法 使用两个指针，把所有可能的位置求和然后找到最大的，题目要求子数组最少包含一个元素，也就是说指针i&lt;=指针j：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public int maxSubArray(int[] nums) { int maxSum = nums[0], sum; for (int i = 0; i &lt; nums.length; i++) { sum = nums[i]; maxSum = Math.max(maxSum, sum); for (int j = i + 1; j &lt; nums.length; j++) { sum += nums[j]; maxSum = Math.max(sum, maxSum); } } return maxSum; } 这样放到LeetCode提交会不通过，提示时间超出限制，也就是说整个算法过于暴力了，看一下能不能优化或者剪枝，首先两个for循环应该没有什么能优化的，那就看看能不能把数组变短，题目给出的例子[-2,1,-3,4,-1,2,1,-5,4]其实是可以变成这样的[-2,1,-3,4,-1,3,-5,4]，我们把相邻的两个正数2和1合并成了3，如果2参与了最大值，那他后面的1必须也要参与，这样才会更大，那如果数组里有连续的负数，当第一个负数没参与运算的时候，和他相邻的数组也不能参与运算，所以得到的结论就是相邻的正负符号相同的数可以合并，但是有个例外就是数组中全部都是负数，这个时候需要单独处理。优化后的代码：
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to 3.最大子数组和" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/leecode/3.%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>3.机器学习算法</h2></header><div class=entry-content><p>距离度量 一些算法会需要距离度量，比如K近邻、SVM、聚类等，距离有4个特性：
非负性：两点的距离不能小于0； 同一性：两点的距离=0说明时同1个点； 对称性：x到y的距离时0时，y到x的距离也是0； 直递性：dist(i,j)&lt;=dist(i,k) + dist(k,j); 常见的距离公式：
欧式距离：两个点就是勾股定理，n个点就开根号n； 曼哈顿距离：曼哈顿距离是当两个点不能练成直线时的距离，计算公式：$\sum_{k=1}^n\vert X_{k}-X_{k-1} \vert$； 切比雪夫距离：类比于国际象棋中的国王走棋的方式，国王可以在一个步长内向任何方向移动，两点的距离公式为$D(P,Q)=max(\vert x_1−x_2\vert,\vert y_1−y_2\vert,…,\vert x_n−x_{n+1}\vert)$​； 闵氏距离：闵氏距离是将上面3个变成了1个公式，当p=1的时候是曼哈顿距离，p=2的时候是欧式距离，p>=3的时候是切比雪夫距离 1 K近邻算法 根据最近的距离判断类别，最近的样本数据是什么类别，你就是什么类别，这里的样本数量可以取n个。也叫KNN算法。
求两个坐标的距离使用勾股定理，多维也是一样的。
比如现有数据：
电影名 搞笑镜头 拥抱镜头 打斗镜头 电影类型 功夫熊猫 39 0 31 喜剧片 叶问3 3 2 65 动作片 二次曝光 2 3 55 爱情片 代理情人 9 38 2 爱情片 步步惊心 8 34 17 爱情片 谍影重重 5 3 57 动作片 美人鱼 21 17 5 喜剧片 小鬼当家 45 2 9 喜剧片 唐人街探案 23 3 17 唐人街探案时测试数据，上面的事样本数据，需要判断唐人街探案是什么类型的电影时，就要先求出唐人街探案距离每个电影的距离：
...</p></div><footer class=entry-footer>8 min</footer><a class=entry-link aria-label="post link to 3.机器学习算法" href=https://wangxiaohong123.github.io/posts/ai/3.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wangxiaohong123.github.io/page/11/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://wangxiaohong123.github.io/page/13/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>