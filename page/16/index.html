<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.150.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>王小红的笔记</title><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><meta property="og:url" content="https://wangxiaohong123.github.io/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="王小红的笔记"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="王小红的笔记"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"王小红的笔记","url":"https://wangxiaohong123.github.io/","description":"","logo":"https://wangxiaohong123.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>8.model组件源码</h2></header><div class=entry-content><p>Model的相关组件在我们初始化provider之前就已经创建好了，先进到总父类ScopeModel中，看到他继承了ExtensionAccessor接口，看这个名就和SPI有关系，猜测只要实现了ExtensionAccessor接口就具备了使用SPI机制获取指定接口扩展实现的能力。
ScopeModel 看一下类中的变量：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 /** * 这个是他内部的id，用来定位model在model树中的位置 * &lt;ol> * &lt;li>1&lt;/li> * FrameworkModel (index=1) * &lt;li>1.2&lt;/li> * FrameworkModel (index=1) -> ApplicationModel (index=2) * &lt;li>1.2.0&lt;/li> * FrameworkModel (index=1) -> ApplicationModel (index=2) -> ModuleModel (index=0, internal module) * &lt;li>1.2.1&lt;/li> * FrameworkModel (index=1) -> ApplicationModel (index=2) -> ModuleModel (index=1, first user module) * &lt;/ol> */ private String internalId; /** * Public Model Name, can be set from user */ private String modelName; private String desc; /** * 一批要使用的类加载器 */ private Set&lt;ClassLoader> classLoaders; /** * 这个是父类，也就是通过这个属性构成的model树 */ private final ScopeModel parent; /** * 这个是枚举类，用来表示Extension实例对象的范围 * 因为有很多的Model组件，这个属性就决定了当前Model创建出的Extension实例在那个范围可以使用 * 是当前框架都能用还是当前模块都能用 */ private final ExtensionScope scope; /** * 他是一个Extension loader的管理组件 * 如果想针对某个接口加载SPI的实现类，就要用这个变量获取到接口对应的ExtensionLoader组件，再去获取对应的实现类 */ private ExtensionDirector extensionDirector; /** * 这个就和Spring类似的 * dubbo自己实现的，负责管理在dubbo框架内部共享的bean */ private ScopeBeanFactory beanFactory; /** * model组件的生命周期事件监听 */ private List&lt;ScopeModelDestroyListener> destroyListeners; /** * 这个应该放的是当前Model的属性 */ private Map&lt;String, Object> attributes; /** * 当前组件是否被销毁 */ private final AtomicBoolean destroyed = new AtomicBoolean(false); 这个父类的构造方法就是设置parent和ExtensionScope，还有一些属性实在initialize()方法中设置的：
...</p></div><footer class=entry-footer>5 min</footer><a class=entry-link aria-label="post link to 8.model组件源码" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/dubbo/8.model%E7%BB%84%E4%BB%B6/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>8.存在重复元素</h2></header><div class=entry-content><p>题目 给你一个整数数组nums 。如果任一值在数组中出现至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。
示例 1：
输入：nums = [1,2,3,1] 输出：true 提示：
1 &lt;= nums.length &lt;= 10^5^ -10^9^ &lt;= nums[i] &lt;= 10^9^ 解题思路 第一个注意的就是数组不会是空。至少出现2次这是一个剪枝条件。
这个和两数之和很像，随机和暴力都可以，但是力扣上过不了，随机是有失败概率的，暴力会超时。
排序法 如果把数组排序，只需要用一个指针一直遍历，直到找到和后一个元素相同的情况，为了节省时间，我这里采用两个指针前后同时遍历：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ContainsDuplicateSort { public boolean containsDuplicate(int[] nums) { Arrays.sort(nums); for (int i = 1; i &lt;= nums.length / 2; i++) { if ((nums[i] - nums[i - 1] == 0) || (nums[nums.length - i] - nums[nums.length - i - 1] == 0)) { return true; } } return false; } } 线性求解 利用hash、set、bitset存储数组的元素，然后遍历数组的时候检查是否存在重复，hash为例：
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 8.存在重复元素" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/leecode/8.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>8.自然语言处理-nlp</h2></header><div class=entry-content><p>标准数据集GLUE：由纽约大学、华盛顿大学和google联合推出的涵盖11个子任务的NLP数据集。
文本的标签太多，打不完；文本模型不是聚焦某个场景，更重要的是培养模型的学习能力，自监督更合适；有监督容易过拟合，不能做迁移学习，适合做一些针对性的事，自监督适合解决领域通用的问题。
一、文本预处理 1 基本方法 1.1 分词 精确模式：把句子精确的切开，适合文本分析。
1 2 3 4 5 6 7 import jieba content = "工信处女干事每月经过下属科室都要亲口交代24口交换机等技术性器件的安装工作" # cut_all是False表示精确模式 print(jieba.lcut(content, cut_all=False)) # ['工信处', '女干事', '每月', '经过', '下属', '科室', '都', '要', '亲口', '交代', '24', '口', '交换机', '等', '技术性', '器件', '的', '安装', '工作'] 全模式：把句子中所有可以成词的词语都扫出来，不能消除歧义
1 2 3 4 5 6 7 import jieba content = "工信处女干事每月经过下属科室都要亲口交代24口交换机等技术性器件的安装工作" # cut_all是False表示精确模式 print(jieba.lcut(content, cut_all=True)) # ['工信处', '处女', '女干事', '干事', '每月', '月经', '经过', '下属', '科室', '都', '要', '亲口', '口交', '交代', '24', '口交', '交换', '交换机', '换机', '等', '技术', '技术性', '性器', '器件', '的', '安装', '安装工', '装工', '工作'] 搜索引擎模式：在精确模式的基础上对长词再次进行切分，提高召回率。
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to 8.自然语言处理-nlp" href=https://wangxiaohong123.github.io/posts/ai/8.nlp/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>9.dubbo-高阶特性源码</h2></header><div class=entry-content><p>一、triple协议 使用triple协议时DubboProtocol会被替换成TripleProtocol。TripleProtocol的export()方法和DubboProtocol的区别就是调用的是PortUnificationExchanger的bind()方法：
1 2 3 4 5 6 7 8 9 10 11 12 /** * PortUnificationExchanger */ public static void bind(URL url) { servers.computeIfAbsent(url.getAddress(), addr -> { // 构建server final PortUnificationServer server = new PortUnificationServer(url); // 启动server，这里还是使用netty server.bind(); return server; }); } server.bind();方法就是启动netty服务，但是使用的handler和Dubbo协议不一样，triple使用的handler是PortUnificationServerHandler。
...</p></div><footer class=entry-footer>9 min</footer><a class=entry-link aria-label="post link to 9.dubbo-高阶特性源码" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/dubbo/9.%E9%AB%98%E9%98%B6%E7%89%B9%E6%80%A7%E6%BA%90%E7%A0%81/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>9.大模型微调</h2></header><div class=entry-content><p>大语言中的大型主要体现在参数规模和训练数据量，一般参数规模达到1B(10亿)量级才叫大模型，只有达到这个量级才会有机遇Scaling law的涌现现象，涌现现象是大模型的魅力，有点像初中物理学的液态变固态。
模型的参数数量跟显存占比的计算，以OPT-6.7B举例：OPT-6.7B就是6.7Billion个参数，假设参数的类型是Float16，即每个参数占用16位（2字节）的显存。总显存占用=参数总量×每个参数的显存占用。总内存 = 67亿 * 2 = 134亿字节。转换成GB就是134亿 / 1024 / 1024 / 1024 = 12.5GB的显存。
使用大显存的GPU加载整个模型可以加快训练速度，部署时也可以提高响应速度，但是可以只使用CPU+内存的方式训练或者部署，只不过这种方式的训练很慢，因为训练时需要大量的矩阵相乘操作。但是使用部署后的模型只是一个前向传播操作，CPU+内存的方式不会比GPU慢很多，除非是有并发量的批量推理，GPU的优势会很明显。
现在是一个信息过载的时代，搜什么都会出现一堆，大模型工具的使用可以帮助我们筛选出有用的信息
模型分类：自回归(CAUSAL_LM，文本生成任务，比如GPT)、序列分类(SEQ_CLS，情感分析、文本分类)、token级分类(TOKEN_CLS，命名实体识别NER)、问答任务(QUESTION_ANS)
大模型应用4个阶段 1提示词工程 面向的是终端用户，大模型时代的沟通手段，通过提示词从大模型挖掘知识。就是如何通过对话框跟大模型更好交流。大模型都是概率模型，很多能力他都没有，比如数学运算，但是我们可做到通过描述让他理解。这也是为什么基于注意力机制的模型很容易回答错误一个描述很复杂的小学数学应用题。
2AI智能体（AI Agent） 基于ReAct范式，就是大模型自主判断应该使用哪些工具，比如chatGPT+联网搜索。分为3类：
行动代理（Action agents）：自主决定使用工具，比如OpenAI的Function Call； 模拟代理（Simulation agents）：通常设计用于模拟角色扮演，在模拟的环境中运行，比如生成式智能体，CAMEL。以后可能会应用在游戏领域，类似于美剧西部世界； 自主智能体（Autonomous agents）：独立执行实现长期目标，比如Auto-GPT，manus（国产的，好像是Claude套壳）。 基于大模型开发应用的开发人员，比如自动客服，虚拟助手。
3大模型微调（Fine-tuning） 在预训练模型的基础上，使用较小的数据集进一步训练来调整模型参数。当有和目标相关的较小的数据集，并且希望模型在这个任务上表现更好的时候使用。
未来是面向基础模型编程。
4预训练技术（Pre-training） 使用大量的未标记数据（比如维基百科内容）来训练一个初步的模型，为后续的微调提供基础模型。适合有资源的大厂，有大量的数据集，数据清洗做的好，然后大力出奇迹。
能自己预训练模型的都是顶级大厂，因为需要的资源实在是太大了，比如LLaMA-65B就需要780G显存。
RAG 把我们从外部拿到的数据通过处理之后变成向量数据库中的知识。
微调技术路线 20年之前大家都不知道怎么去做微调，OpenAI发表了一篇论文提出调整prompt，让模型能更好的理解输入也能有很好的效果，再加上几年之后的文生图让prompt被大家熟知。
但是prompt有个缺点就是相同的prompt换一个模型或者换一个语言描述效果就会差很多，不管是在LangChain里或者在应用的对话框中都有这个问题。
全量微调（FFT）：所有系数都进行调整，原来的VC相关的模型用的多一点，训练成本高，容易造成灾难性遗忘。 高效微调（PEFT）：分为有监督微调（SFT）、基于人类反馈的强化学习（RLHF）、基于AI反馈的强化学习（RLAIF）。 PEFT 高效微调技术：Adapter Tuning(2019 Google) -> Prefix Tuning(2021 Stanford) -> Prompt Tuning(2021 Google) -> P-Tuning V1(2021 TsingHua, MIT) -> P-Tuning V2(2022 TsingHua, BAAI )
传统的模型微调是很容易的，比如分类的卷积网络中可以直接选择冻结卷积层，训练softmax层直接增加类别，2018年google的bert出来之后模型就已经不是CNN那种神经网络了，都是在叠加transformer的层数，整个模型看起来又宽又高，包括到今天的大语言模型中，哪部分参数干了哪些事也是未知的。
...</p></div><footer class=entry-footer>5 min</footer><a class=entry-link aria-label="post link to 9.大模型微调" href=https://wangxiaohong123.github.io/posts/ai/9.%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>9.整数反转</h2></header><div class=entry-content><p>题目 给你一个32位的有符号整数x ，返回将x中的数字部分反转后的结果。如果反转后整数超过32位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）。
示例 1：
输入：x = -123 输出：-321 示例 2：
输入：x = 120 输出：21 解题思路 题目明确规定不能使用比int更大范围的类型。这个题主要有两点需要解决：反转整数和判断溢出，反转比较简单，关键就是判断溢出(因为判断溢出的时候，这个数本身不能溢出)。
反转有两种方法，一种是边取模边计算新数；第二种是先取模然后把模存到list中，然后在遍历list计算新数。
判断溢出也有两种方法，一种是比较法，如果允许存在64位的数，直接和Integer.MIN_VALUE或者Integer.MAX_VALUE比较就可以，不允许的话可以通过不等式转换： $$ rev * 10 + y > Integer.MAX_VALUE\ 且\ y = x\ %\ 10\ rev * 10 > Integer.MAX_VALUE - y\ rev > (Integer.MAX_VALUE - x\ %\ 10)\ /\ 10 $$ 只要满足这个表达式就说明rev下个数会越界，同理也能得到Integer.MIN_VALUE的公式；
第二种方式就是自检，如果新数 = rev * 10 + y溢出了，那么新数 / 10和原来是不相等的。
数学法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class ReverseMath { public int reverse(int x) { int res = 0; while (x != 0) { // 这里是公式rev > (Integer.MAX_VALUE - x % 10) / 10的简化 // 因为传入的数字是32位，最大值的第一位只能是2 // 只有超过7的时候才会导致简化的公式不正确 if (x > 0) { if (res > Integer.MAX_VALUE / 10) { return 0; } } else { if (res &lt; Integer.MIN_VALUE / 10) { return 0; } } res = res * 10 + x % 10; x /= 10; } return res; } } 时间复杂度的话是log^m^，m是输入的数字大小。
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 9.整数反转" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/leecode/9.%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>AQS</h2></header><div class=entry-content><p>谈谈对AQS的理解 ReentrantLock 全局有一个sync实例，这是一个内部类，继承了AbstractQueuedSynchronizer，加锁和释放锁都是基于sync实现的。AQS中定义了一个node，这是自己实现的双向链表，当做队列使用，还有一个state，记录加锁的次数。Sync有两个实现类，一个NonfairSync，一个FairSync，就是公平锁和非公平锁，他俩就是重写了加锁和释放锁的逻辑。Node中定义挺多东西的
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 一些状态，共享锁、排它锁 static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; volatile int waitStatus; // 前一个线程 volatile Node prev; // 后一个线程 volatile Node next; // 当前线程 volatile Thread thread; // 如果是排它锁，nextWaiter就是null，否则就是Node Node nextWaiter; 非公平锁的加锁
...</p></div><footer class=entry-footer>5 min</footer><a class=entry-link aria-label="post link to AQS" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/5.aqs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ArrayList</h2></header><div class=entry-content><p>使用默认的构造函数，ArrayList会把数组的长度设置为10（DEFAULT_CAPACITY）。
插入数据很简单，首先判断是否需要扩容ensureCapacityInternal()，如果添加完元素的长度大于现在的长度就扩容成1.5倍。然后把数组赋值。
1 2 3 4 5 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } 1 2 3 4 5 6 7 8 9 10 11 12 public void add(int index, E element) { // 判断是否数组越界 rangeCheckForAdd(index); // 判断是否扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 拷贝数组，向后移1位 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 设置最新值 elementData[index] = element; // 数组大小加1 size++; } 1 2 3 4 5 6 7 8 9 public E set(int index, E element) { // 判断是否数组越界 rangeCheck(index); // 获取index位置的元素的值 E oldValue = elementData(index); // 设置index为新值 elementData[index] = element; return oldValue; } set不是把元素往后挤，而是替换。
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to ArrayList" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/1.%E9%9B%86%E5%90%88/1.arraylist/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>atomic</h2></header><div class=entry-content><p>底层基于jdk内部使用UnSafe类，这个类只能在jdk内部用，他把构造函数私有了，并且验证类加载器，如果是应用程序加载器就报错，在类中使用offect记录当前值，自增时调用CompareAndSwap操作，并且是在while循环中。
CPU可以保证在一个线程执行UnSafe的CAS时，其他线程不能执行。
缺点：
ABA问题：可以使用AtomicStampedReference解决，我记着这个类是通过增加时间戳比较来解决的。 无限循环问题：会让CPU负载过高，可以使用jdk1.8的LongAdder来解决 LongAdder在线程很多的时候会使用分段CAS，把多个线程的CAS操作打散到一个cell[]数组上，如果一个线程在一个cell上多次空旋，会去别的cell上操作。获取的时候会把base的值和所有cell的值加到一起。
CAS在修改数据的时候就是把cache entry的flag变成E，然后执行查找在比较在修改操作，修改完了把flag变成M，就结束了。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to atomic" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/4.atomic/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ConcurrentHashMap</h2></header><div class=entry-content><p>1.8中使用了分段加锁，刚开始是CAS，hash冲突在使用synchronized
put
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 // 计算hash值 int hash = spread(key.hashCode()); for (Node&lt;K,V>[] tab = table;;) { // 如果是第一次添加，初始化数组，因为是死循环，这块直接退出了 if (tab == null || (n = tab.length) == 0) tab = initTable(); // 如果数组这个索引没有元素，使用乐观锁添加，只有一个线程能添加成功 // 因为是死循环，所以多线程来添加，失败的线程会在进来重新添加 else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { if (casTabAt(tab, i, null, new Node&lt;K,V>(hash, key, value, null))) break; // no lock when adding to empty bin } else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else { V oldVal = null; // 加锁，只锁数组当前索引的元素 synchronized (f) { if (tabAt(tab, i) == f) { if (fh >= 0) { binCount = 1; // binCount是链表的节点数量 for (Node&lt;K,V> e = f;; ++binCount) { K ek; // 判断key是否相同，相同就覆盖value if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node&lt;K,V> pred = e; // 在链表后面追加 if ((e = e.next) == null) { pred.next = new Node&lt;K,V>(hash, key, value, null); break; } } } // 红黑树添加元素 else if (f instanceof TreeBin) { Node&lt;K,V> p; binCount = 2; if ((p = ((TreeBin&lt;K,V>)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } if (binCount != 0) { // 如果链表节点数量大于8，就转成红黑树 if (binCount >= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } // 在这里进行扩容 addCount(1L, binCount); get的时候使用的UnSafe类的volatile读，volatile会加上Load内存屏障，这样会保证独到的是最新值。
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to ConcurrentHashMap" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/8.concurrenthashmap/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wangxiaohong123.github.io/page/15/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://wangxiaohong123.github.io/page/17/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>