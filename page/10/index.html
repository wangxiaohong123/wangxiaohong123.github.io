<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.150.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>王小红的笔记</title><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wangxiaohong123.github.io/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="王小红的笔记"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="王小红的笔记"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"王小红的笔记","url":"https://wangxiaohong123.github.io/","description":"","logo":"https://wangxiaohong123.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>2.Redisson封装遇到的问题</h2></header><div class=entry-content><p>背景 阿里云redis+各种redis相关依赖，乱的要死。
项目配置：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 spring: redis: cluster: nodes: 172.x x.xx.xx:6379 timeout: 60000 max-redirects: 5 database: 1 jedis: pool: max-active: 100 max-idle: 10 max-wait: 200 min-idle: 1 time-between-eviction-runs: 60000 redis相关依赖：
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 2.Redisson封装遇到的问题" href=https://wangxiaohong123.github.io/posts/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/3.redisson%E5%B0%81%E8%A3%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>2.shiro-realm</h2></header><div class=entry-content><p>1.源码 MyRealm的类关系图： 首先MyRealm继承了CachingRealm和一些接口，CachingRealm也实现了一些接口，先分析最上层的四个接口，⌘+↓跳到源码：
Realm接口： 1 2 3 4 5 6 7 8 9 10 11 12 /** * 注释解释这个类是管理用户、角色、权限的 * 一般和数据源一一对应 */ public interface Realm { // 获取realm名称，同一个用户不同数据源使用不同Realm String getName(); // 判断token是否支持，比如去ATM取钱，要先判断银行卡类型是否支持 boolean supports(AuthenticationToken var1); // 根据token获取认证信息 AuthenticationInfo getAuthenticationInfo(AuthenticationToken var1) throws AuthenticationException; } 1.上面两个方法都用到了AuthenticationToken类： 1 2 3 4 5 6 7 8 9 /** * 在身份验证阶段尝的账户名和密码集合 */ public interface AuthenticationToken extends Serializable { // 返回用户提交的账户名(能严格区分账号) Object getPrincipal(); // 返回用户提交的密码 Object getCredentials(); } 使用control+h查看子类关系： 可以看到他有两个子接口，但是这两个接口有一个共同的实现类UsernamePasswordToken，HostAuthenticationToken有一个自己的实现类BearerToken里面只有一个token和一个host属性，直接看UsernamePasswordToken的getPrincipal()和getCredentials()的方法实现：
...</p></div><footer class=entry-footer>5 min</footer><a class=entry-link aria-label="post link to 2.shiro-realm" href=https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/shiro/2.realm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>2.zk安装</h2></header><div class=entry-content><p>集群搭建 下载压缩包，用的最多的应该就是3.4.5，解压然后配置zoo.cfg：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # zk里的最小时间单位，2000毫秒，2s，其他参数会以这个来设置 # 比如tickTime * 3 tickTime=2000 # 主要是放zk里的数据快照，停机重启之后可以恢复数据 dataDir=/Users/xiaohong/data/zookeeper/data # 放一些日志数据，比如proposal，这个最好挂SSD，这样会提高写性能 dataLogDir=/Users/xiaohong/data/zookeeper/log clientPort=2181 # leader启动后会等待follower跟自己建立连接，同步数据，这个就是等待时间 # 10的意思就是10 * tickTime就是20s # 如果zk里存的数据比较大，follower同步数据需要的时间比较长，可以调大这个参数 initLimit=10 # leader跟follower的心跳超时 # 5 * tickTime就是10s # 超过10s没收到心跳就认为follower死掉了 syncLimit=5 # 每执行多少个事务就把内存的数据创建一份磁盘快照，用默认的就可以 snapCount=100000 # 一台机器最多有多少个客户端连接，默认60 # 一台机器上不能无限制搞很多客户端，搞了也连不上 maxClientCnxns=60 # 一个znode最大存储的字节数，默认1兆 jute.maxbuffer=1048575 # 每1个小时执行一次数据清理 # 0就是不自动清理 autopurge.purgeInterval=1 # 每次清理保留3个日志文件和数据快照文件 autopurge.snapRetainCount=3 # 在2PC的第一个阶段是没有把proposal写到磁盘的，而是写到了os cache中，然后在commit的时候在去执行刷盘操作 # 如果设置成false就是不执行刷盘操作 forceSync=yes # leader是否接收客户端的连接 leaderServers=yes # leader选举的时候和3888端口建立连接的超时时间 cnxTimeout=5000 一般集群都是3台或者5台机器，集群比单机的多了一个参数：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 2.zk安装" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/zookeeper/2.%E5%AE%89%E8%A3%85/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>2.代码规范</h2></header><div class=entry-content><p>整体的规范是基于阿⾥巴巴的《Java开发⼿册》，额外补充：
方法命名规范 总的原则是⽤动词做前缀，名词在后⾯。 获取单个对象的时候使⽤get做前缀。 获取多个对象的时候使⽤list做前缀，复数形式结尾如:listOrders。 获取统计值的时候使⽤count做前缀。 插⼊数据的时候使⽤save/insert做前缀。 删除数据的时候使⽤remove/delete做前缀。 修改数据的时候使⽤update做前缀。 POJO类命名规范 数据对象用xxxDO，使用DDD时用xxxPO。 Controller层返回结果，展示对象⽤xxxVO，请求⼊参的命名格式⽤xxxRequest，查询条件封装对象⽤xxxQuery。 API层返回结果，返回对象⽤xxxDTO，请求的命名格式为xxxRequest，查询条件封装对象⽤xxxQuery。 业务层内部的数据传输对象⼀般⽤xxxDTO，不做强制规定，怎么⽅便怎么来。 每个POJO继承承AbstractObject.java，可以实现不同POJO属性之间的克隆，AbstractObject.java类中包含浅克隆、深克隆、对象集合克隆。 统一异常处理 common模块的exception包下定义了GlobalExceptionHandler组件，该组件通过添加@RestControllerAdvice注解，作为默认的Controller全局异常处理增强组件，在这个组件中分别对系统级别未知系统、客户端异常、服务端异常 都分别做了统⼀处理。 其次是BaseBizException⾃定义基础业务异常类，在业务代码的开发中，可以直接抛出这个异常类，也可以在具体的业务代码⼯程新建⼀个异常类继承BaseBizException，然后抛出⾃定义的异常类。
common模块中还有⼀个CommonErrorCodeEnum枚举类，他继承了BaseErrorCodeEnum，BaseErrorCodeEnum是一个错误信息枚举接⼝，也是供各个业务服务⾃定义错误枚举信息时继承⽤的，通过在抛业务的时候统⼀使⽤枚举定义错误信息，CommonErrorCodeEnum中定义了⼤量框架级别通⽤的常⻅错误信息枚举值。
对于Service层，程序需要中断的逻辑，统⼀抛BaseBizException或其⼦类业务异常。 DAO层不要显示的抛任何业务异常，统⼀由Service来抛异常。 Controller层不需要显示的try..catch..Service层的业务异常，因为会由GlobalExceptionHandler组件来统⼀处理异常。 抛业务异常时，建议对异常信息定义⼀个枚举值，这个枚举类要继承com.ruyuan.eshop.common.exception.BaseErrorCodeEnum。 统一返回结果处理 接口返回结果统一使用JsonResponse组件作为返回值，当接口返回值不为JsonResponse时由GlobalResponseBodyAdvice统一拦截处理，如果不想使用JsonResponse作为返回值，可以返回JsonMap组件。
GlobalResponseBodyAdvice，通过实现ResponseBodyAdvice接⼝并添加@RestControllerAdvice注解，来实现了全局默认的Controller⽅法返回结果统⼀格式处理，处理逻辑都在beforeBodyWrite()⽅法中。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 2.代码规范" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/cloud-alibaba/cloud-alibaba-demo%E4%B9%8B%E8%AE%A2%E5%8D%95/2.%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>2.删除数组中重复的项</h2></header><div class=entry-content><p>题目： 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:
1 2 3 4 5 6 7 8 // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 根据题目可以得到一下结论：
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 2.删除数组中重复的项" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/leecode/2.%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>2.基础排序</h2></header><div class=entry-content><p>基础算法模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class Example { /** * 排序方法 */ public static void sort(Comparable[] a) {} /** * 判断数组是否有序 * 从小到大排序 */ public static boolean isSorted(Comparable[] a) { for(int i = 1; i &lt; a.length; i++) { if (less(a[i], a[i - 1])) { return false; } } return true; } /** * 比较方法 */ private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) &lt; 0; } /** * 交换两个元素 */ private static void exch(Comparable[] a, int i, int j) { Comparable t = a[i]; a[i] = a[j]; a[j] = t; } /** * 打印数组 */ private static void show(Comparable[] a) { for (Comparable comparable : a) { System.out.println(comparable); } } } 这套模板可以用在任何实现了Comparable接口的数据类型。我把这个模板里除了排序的方法都放在抽象类中，以后的排序只继承这个抽象类重写sort()方法。BaseSort如下：
...</p></div><footer class=entry-footer>3 min</footer><a class=entry-link aria-label="post link to 2.基础排序" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/2.%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>2.安装es</h2></header><div class=entry-content><p>1准备工作 首先准备3台虚拟机，三台机器上进行相同的操作
1.1修改系统参数 修改资源配置文件：vim /etc/security/limits.conf：
1 2 3 4 5 6 7 # *表示任何用户 # soft表示警告值，hard是真正限制的阈值 # nofile是文件描述符数量，nproc是开启进程数 * soft nofile 65535 * hard nofile 65535 * soft nproc 4096 * hard nproc 4096 修改这个配置要退出当前用户重新登录生效。
修改sysctl配置文件：vim /etc/sysctl.conf修改每个进程可以拥有的虚拟内存区域的数量
1 vm.max_map_count=262144 执行sysctl -p刷新配置
1.2创建es用户 执行命令useradd es添加名为es的用户，执行命令passwd es 然后根据提示输入要设置密码比如qiyuan1502，再次输入确认密码完成设置。
1.3创建目录 1 2 3 mkdir -p /app/elasticsearch mkdir -p /app/elasticsearch/data mkdir -p /app/elasticsearch/log 2安装es 到官网[https://www.elastic.co/cn/downloads/past-releases#elasticsearch ]下载es安装包，上传到服务器下的/app/elasticsearch文件夹中解压：
...</p></div><footer class=entry-footer>6 min</footer><a class=entry-link aria-label="post link to 2.安装es" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/es/2.%E5%AE%89%E8%A3%85/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>2.机器学习基础</h2></header><div class=entry-content><p>机器学习就是模仿人类处理问题，人类是先从经验归纳，机器学习也是自动从数据中获取模型，用模型对位置数据进行预测。白话讲就是从历史数据里找规律，有了规律之后根据输入的数据输出结果，这个规律就是模型。比如说某个样子的物体是猫，那下次看见类似的也可以把他当成猫。
机器学习不能解决的问题，跨域：机器学习学习的是历史数据的特征，新的数据不可能和历史数据有一样的特征分布
1. 计算机视觉 用摄像机、电脑或者其他设备模拟生物视觉，让计算机理解图片或者视频中的内容。可以分为三类：
图像分类：将图像结构化成类别信息，用实现确定好的类别来描述图片。 目标检测：关注特定的物体目标，要求获取这一目标的类别和位置信息，他和分类的区别是，分类将图片当做整体，目标检测可以在一张图片中获取多种目标及位置。 图像分割：分割是在检测的基础上还需要获取像素信息。 应用领域：人脸识别、视频监控、智能驾驶、图片识别（以图搜图，图片鉴黄），比如抖音送礼的眼镜特效属于人脸识别里的人脸关键点定位。
2. 自然语言处理 语言模型是用来计算下一个句子概率的模型。
3 时间序列 时间序列是一种 有序的、依赖时间的结构化数据，其核心任务是研究和预测数据随时间变化的规律。深度学习为时间序列任务提供了更强大的建模工具，尤其是在处理复杂非线性关系或长时间依赖时。他是一个跨领域的问题，还会涉及到统计学等。
3. 机器学习的工作流程： 获取数据->对数据进行基本处理->特征工程->机器学习(模型训练，也是算法应用的过程)->模型评估，如果模型评估没有达到要求需要从对数据进行基本处理重新进行一遍。
3.1 获取数据 拿到的数据类似于表格，一行就是一个样本，一列就是一个特征，涉及到判断的列不叫特征，叫目标值，不是所有数据都有目标值。数据分为训练数据和测试数据，一般比例为3/7或者2/8。
3.2 数据基本处理 修改数据的空值、异常值、类型转换等。
3.3 特征工程 对数据的进一步处理。包括特征提取(比如将文本或者图片转换成可以用于机器学习的数字)，特征预处理(通过一些函数将数据转换成适合算法模型的特征数据)和特征降维(降低特征个数)。
3.3.1 特征预处理 将数据转换成机器更好识别，更好处理的数据。当特征数据的单位或者大小相差较大，或者某个特征的方差相比其他的方差大出好几个数量级，这种情况可能这个特征对结果的影响比较大，使得算法无法学习到其他特征。
3.3.1.1 归一化 把原始数据映射到某个区间内，默认0~1。计算公式为： $$ X’ = \frac {x - min}{max - min}\
X’’ = X’ * (mx - mi) + mi $$ 上面的公式中，X’‘就是归一化处理后的特征值，max和min表示初始特征值的最大值和最小值，mx和mi表示想要将特征值映射到区间的最大值和最小值。
归一化的时候如果出现一条特征统计不正确，比如有1条数据比其他的大了很多倍或者小了很多倍，这种情况对其他数据的影响很大，所以这种方法鲁棒性较差，只适合精确小数据场景。
1 2 3 4 5 6 7 8 9 import pandas as pd from sklearn.preprocessing import MinMaxScaler data = pd.read_csv('./data/dating.txt') # 实例化转化器 transfer = MinMaxScaler(featrue_range=(3, 5)) # 将目标列转换到指定区间，这里是3~5 ret_data = transfer.fit_transform(data[["列1名称", "列2名称"]]) print("转化后的数据:\n", ret_data) 3.3.1.2 标准化 1 2 3 4 5 6 7 8 9 10 11 import pandas as pd from sklearn.preprocessing import StandardScaler data = pd.read_csv('./data/dating.txt') # 实例化转化器 transfer = StandardScaler() # 将目标列转标准化 ret_data = transfer.fit_transform(data[["列1名称", "列2名称"]]) print("转化后的数据:\n", ret_data) print("每一列的方差为:\n", transfer.var_) print("每一列的平均值为:\n", transfer.mean_) 第一步就是去均值，将平均值变成0，然后在比上标准差，这样能让所有维度的数相差不大：$X’ = \frac{x - avg}{\sigma}$。
...</p></div><footer class=entry-footer>5 min</footer><a class=entry-link aria-label="post link to 2.机器学习基础" href=https://wangxiaohong123.github.io/posts/ai/2.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>2.注入相关</h2></header><div class=entry-content><p>1.自动注入和手动注入 手动注入就是通过xml方式，要么是&lt;property/>标签通过set方法注入，要么提供&lt;constructor-arg/>标签通过构造方法注入。
自动注入就是设置bean得注入方式并提供对应得set方法或者构造方法，spring就会自己分析方法完成注入。
在AbstractBeanDefinition中有一个属性叫autowireModel，他有4个值可选：
AUTOWIRE_NO(默认)：手动注入。 AUTOWIRE_BY_NAME：按属性名称自动注入。Spring 寻找与需要自动装配的属性同名的bean。例如，如果一个 bean定义的注入模式被设置为AUTOWIRE_BY_NAME，并且它包含一个master属性（即它有一个 setMaster(..)方法），那么 Spring 会查找一个命名为master的bean，并使用它来设置该属性。 AUTOWIRE_BY_TYPE：和AUTOWIRE_BY_NAME类似，只不过他是按照类型，如果容器中出现多个相同type会抛出异常。 AUTOWIRE_CONSTRUCTOR：通过构造函数+byType注入，如果容器中没有构造函数中指定的bean会抛出异常。 AUTOWIRE_AUTODETECT(被弃用)： 总结：官网上写的注入方式有两种，setter方法和构造方法，不管是手动注入还是自动注入都是通过这两种方式实现。注入模型有四种，默认是手动注入，byType和byName都是通过setter方法注入。byName是根据setter方法去掉set后把第一个字母改成小写的那么去找。通过@Autowired或者@Resource注解实现的注入既不属于setter注入也不是构造方法注入。
2.@Autowired源码 @Autowired注入对象的源码在AutowiredAnnotationBeanPostProcessor类中，这个类里有两个内部类，一个是AutowiredMethodElement用来处理方法上的@Autowired，另一个是AutowiredFieldElement用来处理成员变量上的@Autowired注解。
AutowiredAnnotationBeanPostProcessor类实现了InstantiationAwareBeanPostProcessorAdapter，在程序启动的时候一定会触发postProcessProperties()方法：
1 2 3 4 5 6 7 8 9 public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) { // 根据当前bean找到所有加了@Autowired和@Value注解的变量或者方法 // 然后用找到的变量或者方法创建对应的注入器 InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs); try { metadata.inject(bean, beanName, pvs); } return pvs; } InjectionMetadata就是注入器，AutowiredFieldElement类继承了InjectionMetadata.InjectedElement，在metadata.inject(bean, beanName, pvs);代码中就是遍历刚才拿到的InjectedElement集合，然后调用他的inject()方法：
...</p></div><footer class=entry-footer>8 min</footer><a class=entry-link aria-label="post link to 2.注入相关" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/framework/2.%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>21.翻转链表</h2></header><div class=entry-content><p>题目 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
示例:
输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL 限制：
0 &lt;= 节点个数 &lt;= 5000
题解 这个题的原链表是可以修改的。
1.三指针法 在遍历的时候修改指针的指向
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class ReverseListThreePoints { public ListNode reverseList(ListNode head) { if (null == head || null == head.next) { return head; } // cur指向没翻转的头，pre指向已经翻转的头，next保护现场 ListNode pre = null; ListNode next; ListNode cur = head; while (null != cur) { // 指针翻转 next = cur.next; cur.next = pre; // 指针移动 pre = cur; cur = next; } return pre; } static class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } } 2.双指针 上面的解法中，入参head是没用到的，可以用它存储三指针中的某一个指针，其实随便替换一个就行，因为cur指针在每一步都用到了，所以我选择替换cur：
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 21.翻转链表" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/leecode/21.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wangxiaohong123.github.io/page/9/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://wangxiaohong123.github.io/page/11/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>