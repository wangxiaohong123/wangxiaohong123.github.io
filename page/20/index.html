<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.150.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>王小红的笔记</title><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wangxiaohong123.github.io/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="王小红的笔记"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="王小红的笔记"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"王小红的笔记","url":"https://wangxiaohong123.github.io/","description":"","logo":"https://wangxiaohong123.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>linux-3.磁盘和文件系统</h2></header><div class=entry-content><p>磁盘的物理组成：
原型碟片：记录数据。 机械手臂：包括手臂和磁头(擦写碟片上的数据)。 主轴马达：可以转动碟片。 扇区：最小的物理存储单元，有512B和4k两种格式。 柱面：扇区组成的一圈。早起分区以柱面为单位，现在使用扇区。 磁盘分区表：一种是限制比较多的MBR(Master boot record)，一种是比较新的GPT，MBR中第一个扇区最重要，里面放的主引导记录(MBR，446B)+分区表(64B)，目前最新的是GPT分区表。 磁盘文件名：
物理磁盘的文件名一般都叫/dev/sd[a-p][1-128] 虚拟磁盘的文件名一般是/dev/vd[a-d][1-128] 如果是磁盘阵列的话一般是/dev/md[0-128] LVM一般是/dev/VGNAME/LVNAME这种 分区之后一般都需要格式化一下，因为每个系统使用的文件系统不一样，比如win98以前用FAT，win2000之后用NTFS，Linux正统文件系统是ext2，一些发行版的Linux使用其他文件系统，比如CentosOS7使用xfs文件系统。
文件系统 文件系统特性 linux的文件系统可以分成6个区块的数据：
超级区块的数据：记录文件系统的整体信息，比如inode和数据区块的总量、使用量、剩余量、文件系统的格式和相关信息。 inode：记录文件信息，比如文件的属性(时间、属组)、权限、文件数据所在区。一个文件占用一个inode。每个inode是128B或者256B。 数据区块：实际记录文件内容，文件太大的时候会占用多个区块，并且一个区块只能写一个文件，如果有剩余空间就浪费了。 文件系统描述：描述每个区块群组的开始、结束区块，以及inode、超级区块等介于那个区块之间。 区块对照表：记录空的区块。 inode对照表：记录使用和未使用的inode号。 上面除了超级区块的5个组成一个区块群组(block group)，一个文件系统只有一个超级区块的数据，如果有多个也是这个的备份。
Linux在读取文件的时候先根据inode把数据所在的区块都读出来，而FAT格式的文件系统，比如U盘是没有inode的，他只是在数据区块中记录下一个数据区块的编号，所以没法一次读取，只能一个一个读，这样就会有个问题，磁盘转一圈可能没读完，需要转好几圈，所以这种系统可以经常清理磁盘碎片，让同一个数据区块挨的进点，方便读取。
可以使用dumpe2fs [-bh] 设备文件名查看超级区块信息，但是xfs是不支持这个命令的：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 # 打印块设备属性，可以看到我的是ext4 blkid # /dev/vda1: UUID="1114fe9e-2309-4580-b183-d778e6d97397" TYPE="ext4" # -b 列出保留为坏道的部分 # -h 只显示超级区块信息，不展示其他区段内容 dumpe2fs /dev/vda1 dumpe2fs 1.42.9 (28-Dec-2013) # 文件系统名称 Filesystem volume name: &lt;none> # 上一次挂载的目录位置 Last mounted on: / Filesystem UUID: 1114fe9e-2309-4580-b183-d778e6d97397 Filesystem magic number: 0xEF53 Filesystem revision #: 1 (dynamic) # 文件系统特性 Filesystem featrues: has_journal ext_attr resize_inode dir_index filetype needs_recovery extent flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize Filesystem flags: signed_directory_hash # 默认挂载参数 Default mount options: user_xattr acl # 文件系统状态，如果是dirty就说明有被修改过的文件但是还在内存，没有刷到粗盘 Filesystem state: clean Errors behavior: Continue Filesystem OS type: Linux # inode总数 Inode count: 2621440 # 区块总数 Block count: 10484164 # 保留区块总数 Reserved block count: 471777 # 可用区块数量 Free blocks: 5941100 # 可用inode数量 Free inodes: 2484489 First block: 0 # 单个区块的大小 Block size: 4096 Fragment size: 4096 Reserved GDT blocks: 1021 Blocks per group: 32768 Fragments per group: 32768 Inodes per group: 8192 Inode blocks per group: 512 Flex block group size: 16 Filesystem created: Thu Jul 11 10:52:00 2019 Last mount time: Thu Mar 10 16:03:03 2022 Last write time: Fri Mar 11 00:03:02 2022 Mount count: 6 Maximum mount count: -1 Last checked: Thu Jul 11 10:52:00 2019 Check interval: 0 (&lt;none>) Lifetime writes: 3907 MB Reserved blocks uid: 0 (user root) Reserved blocks gid: 0 (group root) First inode: 11 # inode容量 Inode size: 256 Required extra isize: 28 Desired extra isize: 28 Journal inode: 8 First orphan inode: 1050033 Default directory hash: half_md4 Directory Hash Seed: 0163c9aa-b271-4625-b08d-5a774c70359e # 日志相关信息 Journal backup: inode blocks Journal featrues: journal_incompat_revoke 日志区块总大小: 128M Journal length: 32768 Journal sequence: 0x0380a708 Journal start: 14867 # 第一区块群组信息 Group 0: (Blocks 0-32767) [ITABLE_ZEROED] Checksum 0x0314, unused inodes 8175 # 主要超级区块位置 主 superblock at 0, Group descriptors at 1-3 保留的GDT块位于 4-1024 Block bitmap at 1025 (+1025), Inode bitmap at 1041 (+1041) Inode表位于 1057-1568 (+1057) 14316 free blocks, 8177 free inodes, 2 directories, 8175个未使用的inodes # 那些区块可用 可用块数: 11727-12287, 12301, 12318, 12336, 12352, 12374, 12390, 12409, 12426, 12440-12719, 13296-13708, 14304-17854, 18201-25833, 27287-28583, 30376-30604, 32424-32767 可用inode数: 12, 14, 18-8192 # 其他区块群组信息 Group 1: (Blocks 32768-65535) [INODE_UNINIT, ITABLE_ZEROED] …… xfs系统相比ext2、ext3、ext4来说多了两个区，他的数据区(data section)可以理解成ext系列的所有区块，但是不包括ext3和ext4的日志，xfs的文件系统活动区(log section)就是用日志用来记录文件的变化，xfs的实时运行区(realtime section)是用来实时分配inode和区块的，这也是他和ext系列系统的最大区别。可以使用xfs_info 挂载点/设备文件名命令查看xfs文件系统信息。
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to linux-3.磁盘和文件系统" href=https://wangxiaohong123.github.io/posts/linux/3.%E7%A3%81%E7%9B%98%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>linux-4.vi</h2></header><div class=entry-content><p>比vi好用的编辑器有很多，比如nano，但是不是所有发行版都内置除vi意外的编辑器。最重要的是很多软件的编辑接口都会主动调用vi，比如crontab、visudo，所以vi是最重要的。vim是vi的升级版，他会根据文件的扩展名和文件内的开头信息显示对应的语法样式，其实感觉就是多个颜色、下划线等样式，缩进啥的还是很痛苦。
大部分的发行版都用vim替换vi了，如果输入alias时出现**alias vi=‘vim’**表示执行vi就是在执行vim，否则还是要手动执行vim。
vi分为3中模式：
一般命令模式：vi 文件名 就进入一般命令模式了，简称一般模式，在这个模式里可以使用上下左右移动光标，删除字符或者删除整行，也可以使用复制粘贴； 编辑模式：一般模式不能编辑，直到按下【i、l、o、O、a、A、r、R】任意一个字母才会进入编辑模式，一般编辑模式屏幕左下方会出现insert、replace等字样，按【esc】退出编辑模式； 命令模式：在一般模式下输入【:、/、?】任意一个进入命令模式，在这个模式里可以查找数据、保存、批量替换、退出vi、显示行号等操作； 一般命令模式的按键： 移动光标方法 可以使用数字加命令，比如30↓就是向下移动30个字符 h或者← 光标向左移动一个字符 j或者↓ 光标向下移动一个字符 k或者↑ 光标向上移动一个字符 l或者→ 光标向右移动一个字符 ctrl+f 屏幕向下翻页 ctrl+b 屏幕向上翻页 ctrl+d 屏幕向下翻半页 ctrl+u 屏幕向上翻半页 + 光标移动到非空格的下一行 - 光标移动到非空格的上一行 N + 空格 n是数字，光标向右移动n个字符 0或者home键 移动到这一行的第一个字符位置，这个是数字0 $或者end键 移动到这一行的最后一个字符位置 H 移动到屏幕最上方第一行第一个字符 M 移动到屏幕中央那行的第一个字符 L 移动到屏幕最下方最后一行的第一个字符 G 移动到文件的最后一行 nG n是数字，移动到文件的第n行 gg 移动到文件的第一行，相当于1G n + 回车 n是数字，光标向下移动n行 查找和替换 /word 向光标之下查找第一个名为word的字符串 ?word 向光标之上查找第一个名为word的字符串 n n是按键，代表重复前一个查找的操作，比如/word之后在按n就是继续查找 N N是按键，和n相反，反向前一个查找的操作，/word会变成?word :n1,n2/word1/word2/g n1和n2是数字，在第n1和n2行之间查找word1，并把word1替换成word2 :1,$s/word1/word2/g 从第1行到最后一行之间查找word1，并把word1替换成word2 :1,$s/word1/word2/gc 从第1行到最后一行之间查找word1，并把word1替换成word2，且在替换前给用户显示确认提示字符 删除，复制和粘贴 x、X x表示向后删除一个字符，X表示向前删除一个字符 nx n是数字，向后删除n个字符 dd 删除光标所在一整行 ndd n是数字，向下删除光标所在的下n行 d1G 删除光标到第一行的所有数据 dG 删除光标到最后一行的所有数据 d$ 删除光标所在位置到这行最后一个字符 d0 删除光标所在位置到这行第一个字符 yy 复制光标所在行 nyy n是数字，复制光标所在行的下n行 y1G 复制光标所在行到第一行的所有数据 yG 复制光标所在行到最后一行的所有数据 y0 复制光标所在字符到行首的所有数据 y$ 复制光标所在字符到行尾的所有数据 p、P p是把复制的数据在光标下一行粘贴，P是在上一行粘贴 J 把光标所在行和下一行合成同一行 c 删除重复多个数据 u 恢复前一个操作 ctrl + r 重做上一个操作 一般命令模式切换到编辑模式的按键： i和I 插入，i是从光标处开始插入，I是从光标所在行的第一个非空格开始插入 a和A 插入，a是从光标所在的下一个字符开始插入，A是光标所在行的最后一个字符开始插入 o和O o是在光标所在行的下一行插入一个新空行，O是在上一行插入一个空行 r和R r会替换光标所在的字符，R会一直替换光标所在的字符，直到按下esc键 esc 退出编辑模式 一般命令模式切换到命令模式的按键 :w 将编辑的数据写入到硬盘 :w! 如果文件的权限是只读，强制写入，能不能强制跟你对该文件的权限有关 :q 退出 :q! 强制退出，不保存 :wq 保存后退出，如果是:wq!就是强制保存退出 ZZ 和:wq的效果一样 :w [filename] 另存为 :r [filename] 把文件内容加载到光标所在行后面 :n1,n2 w [filename] 把n1到n2的内容另存为新文件 :! command 暂时退出vi到命令模式下执行command的显示结果例如【:! ls /home】就是在vi中查看/home下面以ls输出文件信息 :set nu(针对vim) 显示行号 :set nonu(针对vim) 取消行号 vim的缓存 vim防止某些原因导致的程序异常退出的情况会在编辑文件时创建一个.filename.swp的文件，这个文件里缓存了对filename的操作，如果打开文件之前出现了.swp文件就会报错，说什么found a swap file之类的，出现这个错误可能有两种情况：第一个就是多人维护同一个文件，第二个就是异常退出了。
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to linux-4.vi" href=https://wangxiaohong123.github.io/posts/linux/4.vi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>linux-5.bash</h2></header><div class=entry-content><p>bash是shell的一种 操作系统就是一组软件，通过这组软件来管理硬件和监控，如果这组软件能被用户随意使用，那么操作系统就很容易崩溃，但是又不能不让用户使用操作系统，所以就有了操作系统之上的一层程序，通过这层程序指挥内核，然后内核再去操作硬件。现在关系变成了应用程序–>内核–>硬件，这样一层一层的关系，我理解的就是硬件像蛋黄，内核是蛋清，应用程序是蛋壳，所以叫shell(壳程序)。壳程序的功能是提供用户操作系统的一个界面。
也就是说只要能操作内核程序的软件都叫壳程序，比如图形界面的软件(视频播放器这种)，比如bash，我们可以在bash中运行操作内核的命令，比如man、chmod等等。
shell有很多个 最开始的时候UNIX有很多的发展者，就会对应多个shell的版本，比如Bourne shell(sh)，Sun里的C shell，商用的K shell，TCSH(增强版C shell)。Linux使用的是Bouren Again Shell(bash)，是Bourne shell的增强版本，在/etc/shells里可以看到能够使用的shell：
1 2 3 4 /bin/sh # 等于/usr/bin/sh /bin/bash # 等于/usr/bin/bash /usr/bin/sh /usr/bin/bash 我的虚拟机里有两种shell，sh和bash，而在/etc/passwd文件中记录的账号信息外，最后就有一个字段标记这个账号登录后使用的shell类型，差不多长这样：
1 2 3 root:x:0:0:root:/root:/bin/bash # /sbin/nologin是一个奇怪的shell，他的目的是不想让用户以其他服务登录主机 bin:x:1:1:bin:/bin:/sbin/nologin 查询是否是bash shell的内置命令 使用type [-tpa] name来查询name是否是bash内置的命令，没有参数时只会显示是外部命令还是内部命令，参数说明：
-t：把name以以下字眼显示意义：file(外部命令)，alias(别名设置的命令)，builtin(bash内置命令)。 -p：如果name是外部命令，显示完整文件名。 -a：把PATH变量定义的路径中，所有包含name的命令都列出来，包括alias。 1.变量的使用和设置 查看变量使用echo，但是变量前要加$。$更多的用法使用man echo查看，赋值变量直接使用等号，例如：
1 2 3 4 5 6 7 # echo ${myname}也是输出变量 # 如果没有这个变量在bash中会输出一个空 echo $myname # 给变量赋值后在打印变量就可以看到变量的值了 myname=xiaohong echo ${myname} 不同的shell处理不存的变量也不同，bash中返回空，但是有的shell中会抛出异常，同时变量的设置也要遵循规则：
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to linux-5.bash" href=https://wangxiaohong123.github.io/posts/linux/5.bash/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>linux-6.shell脚本</h2></header><div class=entry-content><p>shell脚本不光是一些命令的集合，他还可以做一些简单的数据处理，比如自动化的服务器管理、日志的处理等等。
执行脚本的方法：
直接执行xx.sh，前提是脚本必须要有可读和可执行的权限； 路径执行：/home/xx.sh或者./xx.sh； 设置变量，在PATH中增加脚本的路径，或者把脚本放到PATH配置的路径中，然后就可以直接执行脚本了； 以bash程序来执行：bash xx.sh或者sh xx.sh，因为/bin/sh是/bin/bash的链接文件，只要脚本有可读属性就可以使用bash的方式执行脚本，还可以加上-n或者-x这种参数检查语法啥的； 上面的执行方式都是创建一个新的子进程来执行脚本，就是说在脚本中修改的变量不会对主进程中的变量有影响，还有一种执行脚本的方式：source xx.sh，这个是之前修改变量后刷新的命令，他会在主进程中执行，所以变量才会刷新，换句话说刷新配置时使用sh ~/.bbash.sh是不生效的。
搞一个hello world：
1 2 3 4 5 6 7 8 9 #! /bin/bash # program: # This program shows "Hello World!" in your screen. # History: # 2022/01/01 xiaohong First release PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin export PATH echo -e "Hello World! \a \n" exit 0 #!/bin/bash表示声明这个脚本使用哪个shell的语法，#和!中间是没有空格的，这种叫做shebang行，脚本被执行的时候会根据这行来加载需要的配置文件，bash的话就是~/.bashrc。没有这一行系统就不知道下面是什么shell，可能就无法执行。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to linux-6.shell脚本" href=https://wangxiaohong123.github.io/posts/linux/6.shell%E8%84%9A%E6%9C%AC/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>maven基础</h2></header><div class=entry-content><p>gradle：google发布的，安卓用的比较多，一些开源的项目比如Spring也使用的这个构建的，使用DSL语言构建管理，非常难搞。
配置 maven配置了基本的环境变量之后还要再配一下opts，因为maven也是用java写的，有的时候构建的项目很大也会导致OOM，新建一个用户变量MAVEN_OPTS值是-Xms128m -Xmx512m就够了应该.
一般配置完settings.xml之后不要把这个文件放在maven的目录下，因为以后maven可能升级，这样还要去搞一下这个文件，所以要把这个配置文件放在用户目录下，用户目录下有一个.m2文件夹，如果没有就运行mvn help:system命令，然后就有了，这样的话以后不管怎么弄maven他都会去.m2文件夹下找配置文件。
大概的体系结构 首先会去看.m2文件夹下的配置文件 解析工程的pom.xml文件 然后去本地仓库找依赖 没找到的就去远程仓库下载到本地仓库 查看中央仓库地址：在maven的安装文件夹的lib目录下有个maven-model-builder的jar包，jar包里有一个超级pom文件，里面写了默认的中央仓库地址：https://repo.maven.apache.org/maven2/。
简单的打包：
mvn clean package：先清理上次编译的文件，然后编译项目在打包。
包名：一般都是公司域名倒过来，如果公司没有官网，就用com.公司名称缩写
坐标 maven有五个维度来定位唯一的jar包：groupId + artifactId + version + packaging + classifier，正常情况下用前三个就可以定位到了，企业级的坐标命名：
groupId：公司或者组织的官网域名倒叙然后再加上项目名，比如com.net5008.oa； artifactId：项目名-模块名，比如权限模块：oa-auth； version：版本号； packaging：打包的方式，war或者jar或者pom； classifier：定义工程的附属项目， dependency ：引入的类型，一般不用写，如果依赖的工程的打包方式写上pom，这块也应该写pom；
：maven有三种classpath，编译、测试和打包，scope标注了引用的jar包在那个classpath下可用，有四个选项：
compile：默认的，三个classpath都可以用； test：测试范围有效，一般就是测试的框架使用； runtime：测试和打包有效，写代码（编译）的时候没有； provided：测试和编译有效，但是打包的时候是没有的； 比如说我们引入的junit，写上test之后，不能在正常的代码中使用@Test注解，只能在test包下使用。
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to maven基础" href=https://wangxiaohong123.github.io/posts/maven/maven%E5%9F%BA%E7%A1%80/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>maven统一版本号修改</h2></header><div class=entry-content><p>引入 versions-maven-plugin 插件
1 2 3 4 5 6 7 8 &lt;plugin> &lt;groupId>org.codehaus.mojo&lt;/groupId> &lt;artifactId>versions-maven-plugin&lt;/artifactId> &lt;version>2.7&lt;/version> &lt;configuration> &lt;generateBackupPoms>false&lt;/generateBackupPoms> &lt;/configuration> &lt;/plugin> 设置父模块的版本号
1 mvn versions:set -DnewVersion=1.0.1 子模块同步父模块的版本号
1 mvn -N versions:update-child-modules 提交更新
1 mvn versions:commit</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to maven统一版本号修改" href=https://wangxiaohong123.github.io/posts/maven/maven%E7%BB%9F%E4%B8%80%E7%89%88%E6%9C%AC%E5%8F%B7%E4%BF%AE%E6%94%B9/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL-0.主从搭建</h2></header><div class=entry-content><p>安装mysql5.7：https://www.cnblogs.com/hsbt2333/p/9915616.html
首先在主库上创建一个用于主从复制的账号：
1 2 3 create user 'backup_user'@'%' identified by 'qiyuan1502'; grant replication slave on *.* to 'backup_user'@'%'; flush privileges; 如果是新增从库需要让系统停机，对外不可用，然后全量备份一下主库：
1 2 3 4 5 # 先把主从库的的binlog打开，修改my.cnf，在mysqld下添加，一定要在这个下面，两个库的server-id=1不能一样 log-bin=mysql-bin server-id=1 # --master-data=2是记录binlog和position，主从需要 /usr/local/mysql/bin/mysqldump --single-transaction -uroot -proot --master-data=2 -A > /usr/local/mysql/backup.sql 然后在新的从库上执行sql文件。
从库上执行命令绑定主库
1 2 3 4 5 6 7 # MASTER_LOG_FILE和MASTER_LOG_POS在backup.sql中获取 CHANGE MASTER TO MASTER_HOST='59.110.156.68',MASTER_USER='backup_user',MASTER_PASSWORD='qiyuan1502',MASTER_LOG_FILE='mysql-bin.000001',MASTER_LOG_POS=154; # 开始主从 start slave; # 查看主从状态，看到slave io running和slave copy tunning就可以了 show slave status; 5.7默认是半同步方式。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to MySQL-0.主从搭建" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/0.%E4%B8%BB%E4%BB%8E%E6%90%AD%E5%BB%BA/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL-1.基础</h2></header><div class=entry-content><p>DDL：数据库定义语句，用来操作数据库中的表、索引、试图、存储过程等；
DML：增删改查；
DCL：控制语句，授权什么的；
TCL：事务控制语句；
常见的连接池 DBCP、C3P0、Druid
MySQL自己也有一个连接池；
日志 undo log：存储更新前的值，为了事务回滚和MVCC（版本并发控制）；
redo log：搜索引擎中存储的操作日志，防止数据库宕机，是InnoDB特有的，偏物理性质的重做日志，记录的是对那个数据页中的那条记录做了什么修改；redo log是固定文件数循环写。
binlog：MySQL server自己的日志文件，对表中那一条数据做了什么操作，结果是什么；binlog会不断产生新文件。
一条sql语句的执行步骤 当MySQL内部线程从网络连接解析出来一条sql语句的时候会提交SQL接口（MySQL提供的一个组件）去执行，SQL接口把sql语句交给SQl解析器，解析器将SQL按照SQL语法进行拆解，在到查询优化器找到最优查询路径最后通过执行器把优化后的最优路径方案一步一步提交给存储引擎执行。操作数据成功后，redo log中已经有了记录，这时候会添加binlog记录，binlog记录成功后会在redo log中写入这次更新数据的binlog文件名和文件中的位置，然后在redo log中写入commit标记，然后提交事务，到此，一条sql语句才算执行成功了。
innodb内存模型 io thread：处理读写操作，使用show engine innodb status可以查看io 现成信息，一般分成4类：
read thread：负责把数据页加载到内存； write thread：把脏页刷新到磁盘； log thread：把内存中的日志刷到磁盘； insert buffer thread：将change buffer内容刷到磁盘； purge thread：事务提交之后回收不需要的undo log，通过innodb_purge_threads配置数量；
page cleaner thread：通过innodb_page_cleaners配置数量，默认是1个，他是负责调用write thread的。
master thread：主线程，负责调用其他线程，他有每秒的操作，也有每10秒的操作。 每秒的操作：
脏页达到75%的时候刷新脏页到磁盘，每次刷新200个； 当1s的io次数小于5时合并写缓冲区数据； 刷新日志缓冲区，没有提交的事务涉及到的redo log也会刷新； 每10秒的操作：
刷新脏页到磁盘，每次刷200(innodb_io_capacity)个； 合并写缓冲区的数据，合并innodb_io_capacity * 5%个； 刷新日志缓冲区； 删掉没用的undo log；</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to MySQL-1.基础" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/1.%E5%9F%BA%E7%A1%80/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL-2.压测</h2></header><div class=entry-content><p>sysbench 执行以下命令安装sysbench：
1 2 3 4 curl -s https://packagecloud.io/install/repositories/akopytov/sysbench/script.rpm.sh | sudo bash sudo yum install -y sysbench # 查看版本 sysbench --version 可以创建测试用户和测试库，我只创建个测试库，5.6创建用户烦得很。
构建测试表和测试数据
1 2 3 4 5 6 7 8 9 10 11 12 13 14 sysbench --db-driver=mysql --time=300 --threads=10 --report-interval=1 --mysql-host=192.168.0.6 --mysql-port=3306 --mysql-user=root --mysql-password=root --mysql-db=test_db --tables=20 --table_size=100000 oltp_read_write --db-ps-mode=disable prepare ####################参数说明#################### --db-driver=mysql 基于mysql驱动链接mysql --time=300 连续访问300秒 --threads=10 10个线程 --report-interval=1 每隔1秒输出一下压测情况 --mysql-host=192.168.0.6 --mysql-port=3306 --mysql-user=root --mysql-password=root 数据库连接参数 --mysql-db=test_db --tables=20 --table_size=100000 在test_db中创建20张表，每个表10万条数据 oltp_read_write 执行oltp数据库的读写测试，除了读写还有很多，比如删除、只读、只写、索引等等 --db-ps-mode=disable 禁止ps模式 prepare 准备，还有run运行、cleanup清除测试数据 在run之前先prepare，run之后cleanup 分析结果
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to MySQL-2.压测" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/2.%E5%8E%8B%E6%B5%8B/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL-3.InnoDB的内存结构</h2></header><div class=entry-content><p>一 buffer pool(缓冲池) 用来缓存表数据和索引数据。MySQL的增删改查都是在buffer pool中进行的，如果buffer pool中没有目标数据会从磁盘中加载到buffer pool中。默认是128M。
1）缓存页 直接操作磁盘会让MySQL的效率极低而且扛不住并发，通过在缓存中操作数据可以解决这个问题，从磁盘加载数据到缓存和从缓存写入磁盘都是以数据页的形式，被加载到内存里数据页就叫缓存页，磁盘中每个数据页都是16k，所以一个缓存页也是16k。不管是数据还是索引都是使用数据页方式存储，所以缓存页中可能存在数据页也可能存在索引页。
在缓存中除了缓存页还有缓存页描述信息(也叫控制块)，描述信息包括缓存页的所属表空间、缓存页的编号、缓存页在缓存中的地址以及各个控制块组成的链表信息等等。描述信息在缓存前面，大概相当于数据页的5%大小，缓存页在缓存后面，每个缓存页都有对应的描述信息。
2）数据时如何被加载到缓存中的？ 2.1）buffer pool的内存结构 Buffer pool中的缓存页使用链表来管理，缓存页有3种状态，每种状态对应一个链表，他的3种状态及对应链表：
free page：缓存页是空的，没有被使用，把所有没有使用的缓存页对应的控制块组成一个双向链表，叫做free链表。free链表的头结点叫做基础节点，这个节点不是一个控制块，他用来存储的是链表长度、首尾节点等描述信息； dirty page：脏页，缓存页被使用并且页中的数据被修改但是还没有刷新到磁盘，所有脏页的控制块会组成一个双向链表，叫flush链表。flush链表的头节点也不是控制块，和free链表一样，主要是记录脏页用来刷盘操作； clean page：缓存页被使用，但是数据没有被修改； 除了上面的两种链表，还有一个链表叫lru链表，用来管理被使用的缓存页，就是说dirty page和clean page的控制块会共同组成这个链表。他的基节点和其他节点一样，这个链表使用lru算法(最近最少使用)实现，当使用了缓存页之后，缓存页会被加载到链表的头部。他的优点是可以保证与最近经常使用的数据有关的SQL能够快速响应。
除了上面的3个链表，想要在内存中管理page页还需要一个hash表，内存中被使用的缓存页会在hash表中存在一条记录，表空间 + 数据页号作为key，缓存页的地址是value，通过hash表可以判断出来数据页是否在缓存中。
2.2）lru链表的改进 传统的lru链表如果应用到MySQL上有两个问题：
发生全表扫描的时候会把表里的数据页都加载到内存中，这个时候就刚加载进来的数据会在lru链表的前面，如果缓存页满了lru链表尾部的数据会被刷盘，就是说可能真正经常被使用的数据被刷到了磁盘。 MySQL存在预读机制，预读有两种情况，线性预读(当发现读取的数据页都在同一个区并且页数超过了56个就会把整个区都加载到buffer pool中)和随机预读(当buffer pool中出现同一个区的数据页数超过13，就会异步把这个区的所有数据页加载到内存中)，和上面一样可能会有很多预读页出现在lru链表的头部，其实他们可能没啥用，也可能导致真正热点数据被刷到磁盘上。 正对这两个可能覆盖真正的热数据问题MySQL对lru链表进行了优化：MySQL将lru链表分成冷热数据区，数据页刚被加载到内存中时会放到冷数据区，当冷数据区的缓存页存在超过1s并且被访问了，就会移动到热数据区的1/4的位置，再次被访问后移动到热数据区的头部。
2.3）加载数据的过程 数据库启动的时候会按照设置的buffer pool大小在加一点（因为有描述信息+链表基节点信息），然后去申请一块内存，申请下来了之后就会按照16k和800字节的描述信息划分出来一块一块的空间（800b就是描述信息），当我们执行crud时会先通过hash表判断buffer pool中是否有目标数据页，如果没有的话会将磁盘中的数据加载到缓存中来。然后修改对应的free链表和lru链表的指针。
3）数据是如何刷盘的 当缓存页满了的时候会使用LRU淘汰算法，当一个缓存页被使用时，就会在描述信息中添加两个节点信息，组成了LRU链表，每次缓存页被使用就会将描述信息放到LRU链表的头部，这样当缓存页满了的时候就会从链表的尾部取出一个描述信息，先将缓存页的数据刷入磁盘，然后在清掉对应的缓存页和描述信息加载新的数据页。
但是这样会有很大的问题，因为MySQL存在预读机制：
预读机制：当在同一区读取了很多（参数可配）连续的数据页的时候就会产生预读，一次读取很多数据页。 如果这些数据页并没有用到，但是新读出来的却放在了LRU链表的头部，这样发生淘汰时会将链表最后的缓存页刷盘，但是很有可能最后的缓存页是被频繁访问的，而预读出来的数据页是没用的，所以LRU链表有两部分，一部分是热数据，一部分是冷数据，预读出来的数据页都放在冷数据里，淘汰时也优先淘汰冷数据，当冷数据在1s（参数可配）后被使用时，就会把这个缓存页放到热数据里。
二 change buffer(写缓冲区) change buffer是针对二级索引的更新优化措施。change buffe是buffer pool划分出来的一块区域，占buffer pool的25%，对二级索引的增删改操作会被记录到change buffer中。
当执行增删改数据的时候，不会用到change buffer，正常加载数据修改就行，如果被修改的数据是非聚簇索引(因为聚簇索引的修改需要校验唯一性，这个没办法缓存，也会同步执行)会先判断数据对应的二级索引数据页是否在buffer pool中，如果在的话就直接修改然后添加redo log那一套，如果不在的话会在change buffer记录这个更新操作就结束了，等到非聚簇数据页被加载到内存中时，会去change buffer中查找对应的修改操作，如果有修改操作会merge到缓存页中。
1）change buffer的merge时机 当二级索引数据页被加载到内存时 后台线程定时merge 正常关闭数据库的时候 三 log buffer(日志缓冲区) log buffer分成两块，一块叫undo log buffer，另一块是redo log buffer，redo log buffer是用来优化每次更新都需要写入redo log的磁盘io问题。默认16M。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to MySQL-3.InnoDB的内存结构" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/3.innodb%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wangxiaohong123.github.io/page/19/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://wangxiaohong123.github.io/page/21/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>