<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.150.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>王小红的笔记</title><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><meta property="og:url" content="https://wangxiaohong123.github.io/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="王小红的笔记"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="王小红的笔记"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"王小红的笔记","url":"https://wangxiaohong123.github.io/","description":"","logo":"https://wangxiaohong123.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>linux-4.vi</h2></header><div class=entry-content><p>比vi好用的编辑器有很多，比如nano，但是不是所有发行版都内置除vi意外的编辑器。最重要的是很多软件的编辑接口都会主动调用vi，比如crontab、visudo，所以vi是最重要的。vim是vi的升级版，他会根据文件的扩展名和文件内的开头信息显示对应的语法样式，其实感觉就是多个颜色、下划线等样式，缩进啥的还是很痛苦。
大部分的发行版都用vim替换vi了，如果输入alias时出现**alias vi='vim'**表示执行vi就是在执行vim，否则还是要手动执行vim。
vi分为3中模式：
一般命令模式：vi 文件名 就进入一般命令模式了，简称一般模式，在这个模式里可以使用上下左右移动光标，删除字符或者删除整行，也可以使用复制粘贴； 编辑模式：一般模式不能编辑，直到按下【i、l、o、O、a、A、r、R】任意一个字母才会进入编辑模式，一般编辑模式屏幕左下方会出现insert、replace等字样，按【esc】退出编辑模式； 命令模式：在一般模式下输入【:、/、?】任意一个进入命令模式，在这个模式里可以查找数据、保存、批量替换、退出vi、显示行号等操作； 一般命令模式的按键： 移动光标方法 可以使用数字加命令，比如30↓就是向下移动30个字符 h或者← 光标向左移动一个字符 j或者↓ 光标向下移动一个字符 k或者↑ 光标向上移动一个字符 l或者→ 光标向右移动一个字符 ctrl+f 屏幕向下翻页 ctrl+b 屏幕向上翻页 ctrl+d 屏幕向下翻半页 ctrl+u 屏幕向上翻半页 + 光标移动到非空格的下一行 - 光标移动到非空格的上一行 N + 空格 n是数字，光标向右移动n个字符 0或者home键 移动到这一行的第一个字符位置，这个是数字0 $或者end键 移动到这一行的最后一个字符位置 H 移动到屏幕最上方第一行第一个字符 M 移动到屏幕中央那行的第一个字符 L 移动到屏幕最下方最后一行的第一个字符 G 移动到文件的最后一行 nG n是数字，移动到文件的第n行 gg 移动到文件的第一行，相当于1G n + 回车 n是数字，光标向下移动n行 查找和替换 /word 向光标之下查找第一个名为word的字符串 ?word 向光标之上查找第一个名为word的字符串 n n是按键，代表重复前一个查找的操作，比如/word之后在按n就是继续查找 N N是按键，和n相反，反向前一个查找的操作，/word会变成?word :n1,n2/word1/word2/g n1和n2是数字，在第n1和n2行之间查找word1，并把word1替换成word2 :1,$s/word1/word2/g 从第1行到最后一行之间查找word1，并把word1替换成word2 :1,$s/word1/word2/gc 从第1行到最后一行之间查找word1，并把word1替换成word2，且在替换前给用户显示确认提示字符 删除，复制和粘贴 x、X x表示向后删除一个字符，X表示向前删除一个字符 nx n是数字，向后删除n个字符 dd 删除光标所在一整行 ndd n是数字，向下删除光标所在的下n行 d1G 删除光标到第一行的所有数据 dG 删除光标到最后一行的所有数据 d$ 删除光标所在位置到这行最后一个字符 d0 删除光标所在位置到这行第一个字符 yy 复制光标所在行 nyy n是数字，复制光标所在行的下n行 y1G 复制光标所在行到第一行的所有数据 yG 复制光标所在行到最后一行的所有数据 y0 复制光标所在字符到行首的所有数据 y$ 复制光标所在字符到行尾的所有数据 p、P p是把复制的数据在光标下一行粘贴，P是在上一行粘贴 J 把光标所在行和下一行合成同一行 c 删除重复多个数据 u 恢复前一个操作 ctrl + r 重做上一个操作 一般命令模式切换到编辑模式的按键： i和I 插入，i是从光标处开始插入，I是从光标所在行的第一个非空格开始插入 a和A 插入，a是从光标所在的下一个字符开始插入，A是光标所在行的最后一个字符开始插入 o和O o是在光标所在行的下一行插入一个新空行，O是在上一行插入一个空行 r和R r会替换光标所在的字符，R会一直替换光标所在的字符，直到按下esc键 esc 退出编辑模式 一般命令模式切换到命令模式的按键 :w 将编辑的数据写入到硬盘 :w! 如果文件的权限是只读，强制写入，能不能强制跟你对该文件的权限有关 :q 退出 :q! 强制退出，不保存 :wq 保存后退出，如果是:wq!就是强制保存退出 ZZ 和:wq的效果一样 :w [filename] 另存为 :r [filename] 把文件内容加载到光标所在行后面 :n1,n2 w [filename] 把n1到n2的内容另存为新文件 :! command 暂时退出vi到命令模式下执行command的显示结果
例如【:! ls /home】就是在vi中查看/home下面以ls输出文件信息 :set nu(针对vim) 显示行号 :set nonu(针对vim) 取消行号 vim的缓存 vim防止某些原因导致的程序异常退出的情况会在编辑文件时创建一个.filename.swp的文件，这个文件里缓存了对filename的操作，如果打开文件之前出现了.swp文件就会报错，说什么found a swap file之类的，出现这个错误可能有两种情况：第一个就是多人维护同一个文件，第二个就是异常退出了。
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to linux-4.vi" href=https://wangxiaohong123.github.io/posts/linux/4.vi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>linux-5.bash</h2></header><div class=entry-content><p>bash是shell的一种 操作系统就是一组软件，通过这组软件来管理硬件和监控，如果这组软件能被用户随意使用，那么操作系统就很容易崩溃，但是又不能不让用户使用操作系统，所以就有了操作系统之上的一层程序，通过这层程序指挥内核，然后内核再去操作硬件。现在关系变成了应用程序-->内核-->硬件，这样一层一层的关系，我理解的就是硬件像蛋黄，内核是蛋清，应用程序是蛋壳，所以叫shell(壳程序)。壳程序的功能是提供用户操作系统的一个界面。
也就是说只要能操作内核程序的软件都叫壳程序，比如图形界面的软件(视频播放器这种)，比如bash，我们可以在bash中运行操作内核的命令，比如man、chmod等等。
shell有很多个 最开始的时候UNIX有很多的发展者，就会对应多个shell的版本，比如Bourne shell(sh)，Sun里的C shell，商用的K shell，TCSH(增强版C shell)。Linux使用的是Bouren Again Shell(bash)，是Bourne shell的增强版本，在/etc/shells里可以看到能够使用的shell：
1 2 3 4 /bin/sh # 等于/usr/bin/sh /bin/bash # 等于/usr/bin/bash /usr/bin/sh /usr/bin/bash 我的虚拟机里有两种shell，sh和bash，而在/etc/passwd文件中记录的账号信息外，最后就有一个字段标记这个账号登录后使用的shell类型，差不多长这样：
1 2 3 root:x:0:0:root:/root:/bin/bash # /sbin/nologin是一个奇怪的shell，他的目的是不想让用户以其他服务登录主机 bin:x:1:1:bin:/bin:/sbin/nologin 查询是否是bash shell的内置命令 使用type [-tpa] name来查询name是否是bash内置的命令，没有参数时只会显示是外部命令还是内部命令，参数说明：
-t：把name以以下字眼显示意义：file(外部命令)，alias(别名设置的命令)，builtin(bash内置命令)。 -p：如果name是外部命令，显示完整文件名。 -a：把PATH变量定义的路径中，所有包含name的命令都列出来，包括alias。 1.变量的使用和设置 查看变量使用echo，但是变量前要加$。$更多的用法使用man echo查看，赋值变量直接使用等号，例如：
1 2 3 4 5 6 7 # echo ${myname}也是输出变量 # 如果没有这个变量在bash中会输出一个空 echo $myname # 给变量赋值后在打印变量就可以看到变量的值了 myname=xiaohong echo ${myname} 不同的shell处理不存的变量也不同，bash中返回空，但是有的shell中会抛出异常，同时变量的设置也要遵循规则：
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to linux-5.bash" href=https://wangxiaohong123.github.io/posts/linux/5.bash/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>linux-6.shell脚本</h2></header><div class=entry-content><p>shell脚本不光是一些命令的集合，他还可以做一些简单的数据处理，比如自动化的服务器管理、日志的处理等等。
执行脚本的方法：
直接执行xx.sh，前提是脚本必须要有可读和可执行的权限； 路径执行：/home/xx.sh或者./xx.sh； 设置变量，在PATH中增加脚本的路径，或者把脚本放到PATH配置的路径中，然后就可以直接执行脚本了； 以bash程序来执行：bash xx.sh或者sh xx.sh，因为/bin/sh是/bin/bash的链接文件，只要脚本有可读属性就可以使用bash的方式执行脚本，还可以加上-n或者-x这种参数检查语法啥的； 上面的执行方式都是创建一个新的子进程来执行脚本，就是说在脚本中修改的变量不会对主进程中的变量有影响，还有一种执行脚本的方式：source xx.sh，这个是之前修改变量后刷新的命令，他会在主进程中执行，所以变量才会刷新，换句话说刷新配置时使用sh ~/.bbash.sh是不生效的。
搞一个hello world：
1 2 3 4 5 6 7 8 9 #! /bin/bash # program: # This program shows "Hello World!" in your screen. # History: # 2022/01/01 xiaohong First release PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin export PATH echo -e "Hello World! \a \n" exit 0 #!/bin/bash表示声明这个脚本使用哪个shell的语法，#和!中间是没有空格的，这种叫做shebang行，脚本被执行的时候会根据这行来加载需要的配置文件，bash的话就是~/.bashrc。没有这一行系统就不知道下面是什么shell，可能就无法执行。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to linux-6.shell脚本" href=https://wangxiaohong123.github.io/posts/linux/6.shell%E8%84%9A%E6%9C%AC/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>maven基础</h2></header><div class=entry-content><p>gradle：google发布的，安卓用的比较多，一些开源的项目比如Spring也使用的这个构建的，使用DSL语言构建管理，非常难搞。
配置 maven配置了基本的环境变量之后还要再配一下opts，因为maven也是用java写的，有的时候构建的项目很大也会导致OOM，新建一个用户变量MAVEN_OPTS值是-Xms128m -Xmx512m就够了应该.
一般配置完settings.xml之后不要把这个文件放在maven的目录下，因为以后maven可能升级，这样还要去搞一下这个文件，所以要把这个配置文件放在用户目录下，用户目录下有一个.m2文件夹，如果没有就运行mvn help:system命令，然后就有了，这样的话以后不管怎么弄maven他都会去.m2文件夹下找配置文件。
大概的体系结构 首先会去看.m2文件夹下的配置文件 解析工程的pom.xml文件 然后去本地仓库找依赖 没找到的就去远程仓库下载到本地仓库 查看中央仓库地址：在maven的安装文件夹的lib目录下有个maven-model-builder的jar包，jar包里有一个超级pom文件，里面写了默认的中央仓库地址：https://repo.maven.apache.org/maven2/。
简单的打包：
mvn clean package：先清理上次编译的文件，然后编译项目在打包。
包名：一般都是公司域名倒过来，如果公司没有官网，就用com.公司名称缩写
坐标 maven有五个维度来定位唯一的jar包：groupId + artifactId + version + packaging + classifier，正常情况下用前三个就可以定位到了，企业级的坐标命名：
groupId：公司或者组织的官网域名倒叙然后再加上项目名，比如com.net5008.oa； artifactId：项目名-模块名，比如权限模块：oa-auth； version：版本号； packaging：打包的方式，war或者jar或者pom； classifier：定义工程的附属项目， dependency ：引入的类型，一般不用写，如果依赖的工程的打包方式写上pom，这块也应该写pom；
：maven有三种classpath，编译、测试和打包，scope标注了引用的jar包在那个classpath下可用，有四个选项：
compile：默认的，三个classpath都可以用； test：测试范围有效，一般就是测试的框架使用； runtime：测试和打包有效，写代码（编译）的时候没有； provided：测试和编译有效，但是打包的时候是没有的； 比如说我们引入的junit，写上test之后，不能在正常的代码中使用@Test注解，只能在test包下使用。
：可选依赖，会让依赖传递失效，比如A依赖B，B依赖C，但是B中对C声明了optional，那么A就不会依赖C
传递性依赖 maven会下载你依赖中依赖的其他jar包，会把所有的依赖链下完，自动下载。传递性依赖就是我们依赖了A，A自己依赖了B，如果我们对A的scope是compile，A对B是runtime，那么我们对B也是runtime。
依赖调解 依赖链条可能会很长，当简介引用了相同的项目，但是版本不一样，就会选用最近的依赖版本，如果长度相等，就使用先声明的。
既然有依赖调解为什么还会有依赖冲突？ 这是因为maven选择了错误的版本，如果发生了冲突一般就选择最新的版本，因为正常的开源项目高版本都会兼容低版本，如果不兼容赶紧换插件，太垃圾了。
运行mvn dependency:tree，然后他会分析版本，找到最新的是哪个依赖引用的，然后把其他引用冲突的依赖给排除。
1 2 3 4 5 6 &lt;exclusions> &lt;exclusion> &lt;groupId>&lt;/groupId> &lt;artifactId>&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> 仓库 本地仓库：本地的仓库 私服：有的公司由于安全性不会让你使用外网，或者自己开发的中间件需要在别的项目使用，就要用到私服，只有私服连外网或者私服上有自己开发的中间件； 其他仓库：比如Jboss仓库、Google仓库，私服上和中央仓库上都没有就可以去其他仓库找找； 镜像仓库：由于中央仓库在国外，所以下载非常慢，阿里云的镜像仓库差不多和中央仓库一样，由于在国内，下载jar包非常快，镜像仓库没有再去中央仓库上找； 中央仓库：maven的超父pom中定义的仓库地址； 私仓 使用nexus就可以搭建自己的私仓，挺简单的，用的时候百度一下，主要有三种仓库。
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to maven基础" href=https://wangxiaohong123.github.io/posts/maven/maven%E5%9F%BA%E7%A1%80/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>maven统一版本号修改</h2></header><div class=entry-content><p>引入 versions-maven-plugin 插件
1 2 3 4 5 6 7 8 &lt;plugin> &lt;groupId>org.codehaus.mojo&lt;/groupId> &lt;artifactId>versions-maven-plugin&lt;/artifactId> &lt;version>2.7&lt;/version> &lt;configuration> &lt;generateBackupPoms>false&lt;/generateBackupPoms> &lt;/configuration> &lt;/plugin> 设置父模块的版本号
1 mvn versions:set -DnewVersion=1.0.1 子模块同步父模块的版本号
1 mvn -N versions:update-child-modules 提交更新
1 mvn versions:commit</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to maven统一版本号修改" href=https://wangxiaohong123.github.io/posts/maven/maven%E7%BB%9F%E4%B8%80%E7%89%88%E6%9C%AC%E5%8F%B7%E4%BF%AE%E6%94%B9/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL-0.主从搭建</h2></header><div class=entry-content><p>安装mysql5.7：https://www.cnblogs.com/hsbt2333/p/9915616.html
首先在主库上创建一个用于主从复制的账号：
1 2 3 create user 'backup_user'@'%' identified by 'qiyuan1502'; grant replication slave on *.* to 'backup_user'@'%'; flush privileges; 如果是新增从库需要让系统停机，对外不可用，然后全量备份一下主库：
1 2 3 4 5 # 先把主从库的的binlog打开，修改my.cnf，在mysqld下添加，一定要在这个下面，两个库的server-id=1不能一样 log-bin=mysql-bin server-id=1 # --master-data=2是记录binlog和position，主从需要 /usr/local/mysql/bin/mysqldump --single-transaction -uroot -proot --master-data=2 -A > /usr/local/mysql/backup.sql 然后在新的从库上执行sql文件。
从库上执行命令绑定主库
1 2 3 4 5 6 7 # MASTER_LOG_FILE和MASTER_LOG_POS在backup.sql中获取 CHANGE MASTER TO MASTER_HOST='59.110.156.68',MASTER_USER='backup_user',MASTER_PASSWORD='qiyuan1502',MASTER_LOG_FILE='mysql-bin.000001',MASTER_LOG_POS=154; # 开始主从 start slave; # 查看主从状态，看到slave io running和slave copy tunning就可以了 show slave status; 5.7默认是半同步方式。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to MySQL-0.主从搭建" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/0.%E4%B8%BB%E4%BB%8E%E6%90%AD%E5%BB%BA/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL-1.基础</h2></header><div class=entry-content><p>DDL：数据库定义语句，用来操作数据库中的表、索引、试图、存储过程等；
DML：增删改查；
DCL：控制语句，授权什么的；
TCL：事务控制语句；
常见的连接池 DBCP、C3P0、Druid
MySQL自己也有一个连接池；
日志 undo log：存储更新前的值，为了事务回滚和MVCC（版本并发控制）；
redo log：搜索引擎中存储的操作日志，防止数据库宕机，是InnoDB特有的，偏物理性质的重做日志，记录的是对那个数据页中的那条记录做了什么修改；redo log是固定文件数循环写。
binlog：MySQL server自己的日志文件，对表中那一条数据做了什么操作，结果是什么；binlog会不断产生新文件。
一条sql语句的执行步骤 当MySQL内部线程从网络连接解析出来一条sql语句的时候会提交SQL接口（MySQL提供的一个组件）去执行，SQL接口把sql语句交给SQl解析器，解析器将SQL按照SQL语法进行拆解，在到查询优化器找到最优查询路径最后通过执行器把优化后的最优路径方案一步一步提交给存储引擎执行。操作数据成功后，redo log中已经有了记录，这时候会添加binlog记录，binlog记录成功后会在redo log中写入这次更新数据的binlog文件名和文件中的位置，然后在redo log中写入commit标记，然后提交事务，到此，一条sql语句才算执行成功了。
innodb内存模型 io thread：处理读写操作，使用show engine innodb status可以查看io 现成信息，一般分成4类：
read thread：负责把数据页加载到内存； write thread：把脏页刷新到磁盘； log thread：把内存中的日志刷到磁盘； insert buffer thread：将change buffer内容刷到磁盘； purge thread：事务提交之后回收不需要的undo log，通过innodb_purge_threads配置数量；
page cleaner thread：通过innodb_page_cleaners配置数量，默认是1个，他是负责调用write thread的。
master thread：主线程，负责调用其他线程，他有每秒的操作，也有每10秒的操作。 每秒的操作：
脏页达到75%的时候刷新脏页到磁盘，每次刷新200个； 当1s的io次数小于5时合并写缓冲区数据； 刷新日志缓冲区，没有提交的事务涉及到的redo log也会刷新； 每10秒的操作：
刷新脏页到磁盘，每次刷200(innodb_io_capacity)个； 合并写缓冲区的数据，合并innodb_io_capacity * 5%个； 刷新日志缓冲区； 删掉没用的undo log；</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to MySQL-1.基础" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/1.%E5%9F%BA%E7%A1%80/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL-2.压测</h2></header><div class=entry-content><p>sysbench 执行以下命令安装sysbench：
1 2 3 4 curl -s https://packagecloud.io/install/repositories/akopytov/sysbench/script.rpm.sh | sudo bash sudo yum install -y sysbench # 查看版本 sysbench --version 可以创建测试用户和测试库，我只创建个测试库，5.6创建用户烦得很。
构建测试表和测试数据
1 2 3 4 5 6 7 8 9 10 11 12 13 14 sysbench --db-driver=mysql --time=300 --threads=10 --report-interval=1 --mysql-host=192.168.0.6 --mysql-port=3306 --mysql-user=root --mysql-password=root --mysql-db=test_db --tables=20 --table_size=100000 oltp_read_write --db-ps-mode=disable prepare ####################参数说明#################### --db-driver=mysql 基于mysql驱动链接mysql --time=300 连续访问300秒 --threads=10 10个线程 --report-interval=1 每隔1秒输出一下压测情况 --mysql-host=192.168.0.6 --mysql-port=3306 --mysql-user=root --mysql-password=root 数据库连接参数 --mysql-db=test_db --tables=20 --table_size=100000 在test_db中创建20张表，每个表10万条数据 oltp_read_write 执行oltp数据库的读写测试，除了读写还有很多，比如删除、只读、只写、索引等等 --db-ps-mode=disable 禁止ps模式 prepare 准备，还有run运行、cleanup清除测试数据 在run之前先prepare，run之后cleanup 分析结果
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to MySQL-2.压测" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/2.%E5%8E%8B%E6%B5%8B/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL-3.InnoDB的内存结构</h2></header><div class=entry-content><p>一 buffer pool(缓冲池) 用来缓存表数据和索引数据。MySQL的增删改查都是在buffer pool中进行的，如果buffer pool中没有目标数据会从磁盘中加载到buffer pool中。默认是128M。
1）缓存页 直接操作磁盘会让MySQL的效率极低而且扛不住并发，通过在缓存中操作数据可以解决这个问题，从磁盘加载数据到缓存和从缓存写入磁盘都是以数据页的形式，被加载到内存里数据页就叫缓存页，磁盘中每个数据页都是16k，所以一个缓存页也是16k。不管是数据还是索引都是使用数据页方式存储，所以缓存页中可能存在数据页也可能存在索引页。
在缓存中除了缓存页还有缓存页描述信息(也叫控制块)，描述信息包括缓存页的所属表空间、缓存页的编号、缓存页在缓存中的地址以及各个控制块组成的链表信息等等。描述信息在缓存前面，大概相当于数据页的5%大小，缓存页在缓存后面，每个缓存页都有对应的描述信息。
2）数据时如何被加载到缓存中的？ 2.1）buffer pool的内存结构 Buffer pool中的缓存页使用链表来管理，缓存页有3种状态，每种状态对应一个链表，他的3种状态及对应链表：
free page：缓存页是空的，没有被使用，把所有没有使用的缓存页对应的控制块组成一个双向链表，叫做free链表。free链表的头结点叫做基础节点，这个节点不是一个控制块，他用来存储的是链表长度、首尾节点等描述信息； dirty page：脏页，缓存页被使用并且页中的数据被修改但是还没有刷新到磁盘，所有脏页的控制块会组成一个双向链表，叫flush链表。flush链表的头节点也不是控制块，和free链表一样，主要是记录脏页用来刷盘操作； clean page：缓存页被使用，但是数据没有被修改； 除了上面的两种链表，还有一个链表叫lru链表，用来管理被使用的缓存页，就是说dirty page和clean page的控制块会共同组成这个链表。他的基节点和其他节点一样，这个链表使用lru算法(最近最少使用)实现，当使用了缓存页之后，缓存页会被加载到链表的头部。他的优点是可以保证与最近经常使用的数据有关的SQL能够快速响应。
除了上面的3个链表，想要在内存中管理page页还需要一个hash表，内存中被使用的缓存页会在hash表中存在一条记录，表空间 + 数据页号作为key，缓存页的地址是value，通过hash表可以判断出来数据页是否在缓存中。
2.2）lru链表的改进 传统的lru链表如果应用到MySQL上有两个问题：
发生全表扫描的时候会把表里的数据页都加载到内存中，这个时候就刚加载进来的数据会在lru链表的前面，如果缓存页满了lru链表尾部的数据会被刷盘，就是说可能真正经常被使用的数据被刷到了磁盘。 MySQL存在预读机制，预读有两种情况，线性预读(当发现读取的数据页都在同一个区并且页数超过了56个就会把整个区都加载到buffer pool中)和随机预读(当buffer pool中出现同一个区的数据页数超过13，就会异步把这个区的所有数据页加载到内存中)，和上面一样可能会有很多预读页出现在lru链表的头部，其实他们可能没啥用，也可能导致真正热点数据被刷到磁盘上。 正对这两个可能覆盖真正的热数据问题MySQL对lru链表进行了优化：MySQL将lru链表分成冷热数据区，数据页刚被加载到内存中时会放到冷数据区，当冷数据区的缓存页存在超过1s并且被访问了，就会移动到热数据区的1/4的位置，再次被访问后移动到热数据区的头部。
2.3）加载数据的过程 数据库启动的时候会按照设置的buffer pool大小在加一点（因为有描述信息+链表基节点信息），然后去申请一块内存，申请下来了之后就会按照16k和800字节的描述信息划分出来一块一块的空间（800b就是描述信息），当我们执行crud时会先通过hash表判断buffer pool中是否有目标数据页，如果没有的话会将磁盘中的数据加载到缓存中来。然后修改对应的free链表和lru链表的指针。
3）数据是如何刷盘的 当缓存页满了的时候会使用LRU淘汰算法，当一个缓存页被使用时，就会在描述信息中添加两个节点信息，组成了LRU链表，每次缓存页被使用就会将描述信息放到LRU链表的头部，这样当缓存页满了的时候就会从链表的尾部取出一个描述信息，先将缓存页的数据刷入磁盘，然后在清掉对应的缓存页和描述信息加载新的数据页。
但是这样会有很大的问题，因为MySQL存在预读机制：
预读机制：当在同一区读取了很多（参数可配）连续的数据页的时候就会产生预读，一次读取很多数据页。 如果这些数据页并没有用到，但是新读出来的却放在了LRU链表的头部，这样发生淘汰时会将链表最后的缓存页刷盘，但是很有可能最后的缓存页是被频繁访问的，而预读出来的数据页是没用的，所以LRU链表有两部分，一部分是热数据，一部分是冷数据，预读出来的数据页都放在冷数据里，淘汰时也优先淘汰冷数据，当冷数据在1s（参数可配）后被使用时，就会把这个缓存页放到热数据里。
二 change buffer(写缓冲区) change buffer是针对二级索引的更新优化措施。change buffe是buffer pool划分出来的一块区域，占buffer pool的25%，对二级索引的增删改操作会被记录到change buffer中。
当执行增删改数据的时候，不会用到change buffer，正常加载数据修改就行，如果被修改的数据是非聚簇索引(因为聚簇索引的修改需要校验唯一性，这个没办法缓存，也会同步执行)会先判断数据对应的二级索引数据页是否在buffer pool中，如果在的话就直接修改然后添加redo log那一套，如果不在的话会在change buffer记录这个更新操作就结束了，等到非聚簇数据页被加载到内存中时，会去change buffer中查找对应的修改操作，如果有修改操作会merge到缓存页中。
1）change buffer的merge时机 当二级索引数据页被加载到内存时 后台线程定时merge 正常关闭数据库的时候 三 log buffer(日志缓冲区) log buffer分成两块，一块叫undo log buffer，另一块是redo log buffer，redo log buffer是用来优化每次更新都需要写入redo log的磁盘io问题。默认16M。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to MySQL-3.InnoDB的内存结构" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/3.innodb%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL-4.数据的物理模型</h2></header><div class=entry-content><p>一 表空间 表空间是用来存储表的结构和数据的，InnoDB中表空间分为以下几种：
系统表空间：system tablespace，也叫共享表空间，对应的物理文件是var/lib/mysql/ibdata，这个表空间存了很多东西会越来越大。
系统表空间内容：
数据字典：表结构、数据库名、表名、试图、索引等等元数据 change buffer doubleWrite buffer files：双写缓冲区，为了解决写失效问题，因为操作系统的os cache每页只有4k，默认情况下一个缓存页有16k，所以要把一个缓存页刷新到os cache后再刷到磁盘，需要再os cache中刷4次，如果刷到一半服务器挂了，这个时候这个数据页就是不完整的，这就是写丢失问题。为了解决这种极端情况，在把刷剧刷到磁盘之前innodb会把数据复制到一个2M的内存中，通过这个2M的内存向共享表空间的doubleWrite buffer顺序写，如果doubleWrite buffer顺序写成功，在进行正常的数据页刷新，如果写双写缓冲区的时候失败，其实就算刷盘失败了，但是不会产生坏掉的数据页，如果刷数据页失败在重启之后会使用双写缓冲区的数据页来恢复。 undo logs 独立表空间：file-per-table tablespaces，默认情况下表的数据文件存在独立表空间中，每个库都有自己对应的文件夹，独立表空间是在var/lib/mysql/库名/表名.idb文件，这个文件不能拆分，所以数据越大文件越大，表结构的信息除了存储到系统表空间之外也会在表空间统计的.frm文件中，8.0之后所有的表结构信息都在系统表空间中。
通用表空间：MySQL5.7之后支持，类似系统表空间，可以创建表的时候把表空间指定到通用表空间。
撤销表空间：undo tablespaces，用来保存undo log的，undo log默认存在系统表空间里，也就是存在ibdata文件中，5.7之后可以通过undo_log_truncate+innodb_undo_tablespaces参数设置让undo log保存到对应的撤销表空间。这样可以解决系统表空间越来越大的问题。8.0之后默认会把undo log放到撤销表空间里。
临时表空间：temporary tabespaces，5.7之后独立出来的，之前也在系统表空间里，存储的是临时表数据，对应的文件是MySQL数据文件夹里的ibtmpl文件，初始16M，也是自动扩容的，会越来越大，当内存里的临时表空间满了的时候会刷新到磁盘里，可以设置临时表空间的大小，重启时ibtmpl里的内容会被释放。
1）表空间的逻辑结构 一个表空间包括多个段(segement)，每个段包括多个区(extent)，每个区有多个页(page)，每个也有多条数据(row)。 表空间：相当于innodb存储引擎存储的最高层，用来存储多个idb文件，每个idb文件都是独立的表空间。 段：他是一个逻辑概念，用来申请空间和回收，一个段有256个区，常见的段有数据段、索引段、回滚段等等。 区：由连续的页组成的空间，一个区有64个页，默认情况下一个页16k，所以一个区就是1M。 页：存储多个连续row，常见的页类型有数据页、undo页、索引页等等。
2）page结构 innoDB的数据都是以页为单位存储的，每个数据页都有一个38字节的file header(描述信息) + 56字节的page header(存储页状态) + infimum + supermum records(26字节的最大最小行记录) + user records(存储的数据行记录) + free space(空闲空间大小) + page directory(页目录，存储数据记录的偏移量) + file trailer(8字节文件尾，用来校验页的完整性)。
file header中有上一页信息，file trailer有下一页的信息，这样数据页之间就组成了一个双向链表。
3）行数据结构 行格式有4种，可以在建表的时候指定row_format或者alter table修改，5.7之后默认使用dynamic。
数据库中有些类型的数据是不固定长度的，比如varchar(20)，但是你可能只存1个‘a’，所以需要一个标记来记录不定长的字段中的数据长度，标记使用的是16进制，还要有记录列名、类型的信息，然后你还有可以为null的列，需要记录可以为空的列到底有没有数据，compact格式的行数据大概是这个样子的：
1 2 3 4 5 # 前两个16进制存储的是地址1的长度、姓名1的长度（逆序存储） # 中间的8位bit数就是null值列表，存储的是可以为null的列 # 只要某一列可以为空就要在null值列表中有一个占位，当列为空时存0，不为空时存1 # null值列表一定是8的整数倍，不足时在头部补0，也是逆序存储 0x03 0x03 00000101 头字段 姓名1 地址1 40位的头字段详细信息：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to MySQL-4.数据的物理模型" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/4.innodb%E7%9A%84%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wangxiaohong123.github.io/page/19/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://wangxiaohong123.github.io/page/21/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>