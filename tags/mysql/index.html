<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL | 王小红的笔记</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/tags/mysql/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/tags/mysql/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/tags/mysql/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wangxiaohong123.github.io/tags/mysql/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="MySQL"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="MySQL"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>MySQL</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MySQL-0.主从搭建</h2></header><div class=entry-content><p>安装mysql5.7：https://www.cnblogs.com/hsbt2333/p/9915616.html
首先在主库上创建一个用于主从复制的账号：
1 2 3 create user 'backup_user'@'%' identified by 'qiyuan1502'; grant replication slave on *.* to 'backup_user'@'%'; flush privileges; 如果是新增从库需要让系统停机，对外不可用，然后全量备份一下主库：
1 2 3 4 5 # 先把主从库的的binlog打开，修改my.cnf，在mysqld下添加，一定要在这个下面，两个库的server-id=1不能一样 log-bin=mysql-bin server-id=1 # --master-data=2是记录binlog和position，主从需要 /usr/local/mysql/bin/mysqldump --single-transaction -uroot -proot --master-data=2 -A > /usr/local/mysql/backup.sql 然后在新的从库上执行sql文件。
从库上执行命令绑定主库
1 2 3 4 5 6 7 # MASTER_LOG_FILE和MASTER_LOG_POS在backup.sql中获取 CHANGE MASTER TO MASTER_HOST='59.110.156.68',MASTER_USER='backup_user',MASTER_PASSWORD='qiyuan1502',MASTER_LOG_FILE='mysql-bin.000001',MASTER_LOG_POS=154; # 开始主从 start slave; # 查看主从状态，看到slave io running和slave copy tunning就可以了 show slave status; 5.7默认是半同步方式。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to MySQL-0.主从搭建" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/0.%E4%B8%BB%E4%BB%8E%E6%90%AD%E5%BB%BA/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MySQL-1.基础</h2></header><div class=entry-content><p>DDL：数据库定义语句，用来操作数据库中的表、索引、试图、存储过程等；
DML：增删改查；
DCL：控制语句，授权什么的；
TCL：事务控制语句；
常见的连接池 DBCP、C3P0、Druid
MySQL自己也有一个连接池；
日志 undo log：存储更新前的值，为了事务回滚和MVCC（版本并发控制）；
redo log：搜索引擎中存储的操作日志，防止数据库宕机，是InnoDB特有的，偏物理性质的重做日志，记录的是对那个数据页中的那条记录做了什么修改；redo log是固定文件数循环写。
binlog：MySQL server自己的日志文件，对表中那一条数据做了什么操作，结果是什么；binlog会不断产生新文件。
一条sql语句的执行步骤 当MySQL内部线程从网络连接解析出来一条sql语句的时候会提交SQL接口（MySQL提供的一个组件）去执行，SQL接口把sql语句交给SQl解析器，解析器将SQL按照SQL语法进行拆解，在到查询优化器找到最优查询路径最后通过执行器把优化后的最优路径方案一步一步提交给存储引擎执行。操作数据成功后，redo log中已经有了记录，这时候会添加binlog记录，binlog记录成功后会在redo log中写入这次更新数据的binlog文件名和文件中的位置，然后在redo log中写入commit标记，然后提交事务，到此，一条sql语句才算执行成功了。
innodb内存模型 io thread：处理读写操作，使用show engine innodb status可以查看io 现成信息，一般分成4类：
read thread：负责把数据页加载到内存； write thread：把脏页刷新到磁盘； log thread：把内存中的日志刷到磁盘； insert buffer thread：将change buffer内容刷到磁盘； purge thread：事务提交之后回收不需要的undo log，通过innodb_purge_threads配置数量；
page cleaner thread：通过innodb_page_cleaners配置数量，默认是1个，他是负责调用write thread的。
master thread：主线程，负责调用其他线程，他有每秒的操作，也有每10秒的操作。 每秒的操作：
脏页达到75%的时候刷新脏页到磁盘，每次刷新200个； 当1s的io次数小于5时合并写缓冲区数据； 刷新日志缓冲区，没有提交的事务涉及到的redo log也会刷新； 每10秒的操作：
刷新脏页到磁盘，每次刷200(innodb_io_capacity)个； 合并写缓冲区的数据，合并innodb_io_capacity * 5%个； 刷新日志缓冲区； 删掉没用的undo log；</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to MySQL-1.基础" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/1.%E5%9F%BA%E7%A1%80/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MySQL-2.压测</h2></header><div class=entry-content><p>sysbench 执行以下命令安装sysbench：
1 2 3 4 curl -s https://packagecloud.io/install/repositories/akopytov/sysbench/script.rpm.sh | sudo bash sudo yum install -y sysbench # 查看版本 sysbench --version 可以创建测试用户和测试库，我只创建个测试库，5.6创建用户烦得很。
构建测试表和测试数据
1 2 3 4 5 6 7 8 9 10 11 12 13 14 sysbench --db-driver=mysql --time=300 --threads=10 --report-interval=1 --mysql-host=192.168.0.6 --mysql-port=3306 --mysql-user=root --mysql-password=root --mysql-db=test_db --tables=20 --table_size=100000 oltp_read_write --db-ps-mode=disable prepare ####################参数说明#################### --db-driver=mysql 基于mysql驱动链接mysql --time=300 连续访问300秒 --threads=10 10个线程 --report-interval=1 每隔1秒输出一下压测情况 --mysql-host=192.168.0.6 --mysql-port=3306 --mysql-user=root --mysql-password=root 数据库连接参数 --mysql-db=test_db --tables=20 --table_size=100000 在test_db中创建20张表，每个表10万条数据 oltp_read_write 执行oltp数据库的读写测试，除了读写还有很多，比如删除、只读、只写、索引等等 --db-ps-mode=disable 禁止ps模式 prepare 准备，还有run运行、cleanup清除测试数据 在run之前先prepare，run之后cleanup 分析结果
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to MySQL-2.压测" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/2.%E5%8E%8B%E6%B5%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MySQL-3.InnoDB的内存结构</h2></header><div class=entry-content><p>一 buffer pool(缓冲池) 用来缓存表数据和索引数据。MySQL的增删改查都是在buffer pool中进行的，如果buffer pool中没有目标数据会从磁盘中加载到buffer pool中。默认是128M。
1）缓存页 直接操作磁盘会让MySQL的效率极低而且扛不住并发，通过在缓存中操作数据可以解决这个问题，从磁盘加载数据到缓存和从缓存写入磁盘都是以数据页的形式，被加载到内存里数据页就叫缓存页，磁盘中每个数据页都是16k，所以一个缓存页也是16k。不管是数据还是索引都是使用数据页方式存储，所以缓存页中可能存在数据页也可能存在索引页。
在缓存中除了缓存页还有缓存页描述信息(也叫控制块)，描述信息包括缓存页的所属表空间、缓存页的编号、缓存页在缓存中的地址以及各个控制块组成的链表信息等等。描述信息在缓存前面，大概相当于数据页的5%大小，缓存页在缓存后面，每个缓存页都有对应的描述信息。
2）数据时如何被加载到缓存中的？ 2.1）buffer pool的内存结构 Buffer pool中的缓存页使用链表来管理，缓存页有3种状态，每种状态对应一个链表，他的3种状态及对应链表：
free page：缓存页是空的，没有被使用，把所有没有使用的缓存页对应的控制块组成一个双向链表，叫做free链表。free链表的头结点叫做基础节点，这个节点不是一个控制块，他用来存储的是链表长度、首尾节点等描述信息； dirty page：脏页，缓存页被使用并且页中的数据被修改但是还没有刷新到磁盘，所有脏页的控制块会组成一个双向链表，叫flush链表。flush链表的头节点也不是控制块，和free链表一样，主要是记录脏页用来刷盘操作； clean page：缓存页被使用，但是数据没有被修改； 除了上面的两种链表，还有一个链表叫lru链表，用来管理被使用的缓存页，就是说dirty page和clean page的控制块会共同组成这个链表。他的基节点和其他节点一样，这个链表使用lru算法(最近最少使用)实现，当使用了缓存页之后，缓存页会被加载到链表的头部。他的优点是可以保证与最近经常使用的数据有关的SQL能够快速响应。
除了上面的3个链表，想要在内存中管理page页还需要一个hash表，内存中被使用的缓存页会在hash表中存在一条记录，表空间 + 数据页号作为key，缓存页的地址是value，通过hash表可以判断出来数据页是否在缓存中。
2.2）lru链表的改进 传统的lru链表如果应用到MySQL上有两个问题：
发生全表扫描的时候会把表里的数据页都加载到内存中，这个时候就刚加载进来的数据会在lru链表的前面，如果缓存页满了lru链表尾部的数据会被刷盘，就是说可能真正经常被使用的数据被刷到了磁盘。 MySQL存在预读机制，预读有两种情况，线性预读(当发现读取的数据页都在同一个区并且页数超过了56个就会把整个区都加载到buffer pool中)和随机预读(当buffer pool中出现同一个区的数据页数超过13，就会异步把这个区的所有数据页加载到内存中)，和上面一样可能会有很多预读页出现在lru链表的头部，其实他们可能没啥用，也可能导致真正热点数据被刷到磁盘上。 正对这两个可能覆盖真正的热数据问题MySQL对lru链表进行了优化：MySQL将lru链表分成冷热数据区，数据页刚被加载到内存中时会放到冷数据区，当冷数据区的缓存页存在超过1s并且被访问了，就会移动到热数据区的1/4的位置，再次被访问后移动到热数据区的头部。
2.3）加载数据的过程 数据库启动的时候会按照设置的buffer pool大小在加一点（因为有描述信息+链表基节点信息），然后去申请一块内存，申请下来了之后就会按照16k和800字节的描述信息划分出来一块一块的空间（800b就是描述信息），当我们执行crud时会先通过hash表判断buffer pool中是否有目标数据页，如果没有的话会将磁盘中的数据加载到缓存中来。然后修改对应的free链表和lru链表的指针。
3）数据是如何刷盘的 当缓存页满了的时候会使用LRU淘汰算法，当一个缓存页被使用时，就会在描述信息中添加两个节点信息，组成了LRU链表，每次缓存页被使用就会将描述信息放到LRU链表的头部，这样当缓存页满了的时候就会从链表的尾部取出一个描述信息，先将缓存页的数据刷入磁盘，然后在清掉对应的缓存页和描述信息加载新的数据页。
但是这样会有很大的问题，因为MySQL存在预读机制：
预读机制：当在同一区读取了很多（参数可配）连续的数据页的时候就会产生预读，一次读取很多数据页。 如果这些数据页并没有用到，但是新读出来的却放在了LRU链表的头部，这样发生淘汰时会将链表最后的缓存页刷盘，但是很有可能最后的缓存页是被频繁访问的，而预读出来的数据页是没用的，所以LRU链表有两部分，一部分是热数据，一部分是冷数据，预读出来的数据页都放在冷数据里，淘汰时也优先淘汰冷数据，当冷数据在1s（参数可配）后被使用时，就会把这个缓存页放到热数据里。
二 change buffer(写缓冲区) change buffer是针对二级索引的更新优化措施。change buffe是buffer pool划分出来的一块区域，占buffer pool的25%，对二级索引的增删改操作会被记录到change buffer中。
当执行增删改数据的时候，不会用到change buffer，正常加载数据修改就行，如果被修改的数据是非聚簇索引(因为聚簇索引的修改需要校验唯一性，这个没办法缓存，也会同步执行)会先判断数据对应的二级索引数据页是否在buffer pool中，如果在的话就直接修改然后添加redo log那一套，如果不在的话会在change buffer记录这个更新操作就结束了，等到非聚簇数据页被加载到内存中时，会去change buffer中查找对应的修改操作，如果有修改操作会merge到缓存页中。
1）change buffer的merge时机 当二级索引数据页被加载到内存时 后台线程定时merge 正常关闭数据库的时候 三 log buffer(日志缓冲区) log buffer分成两块，一块叫undo log buffer，另一块是redo log buffer，redo log buffer是用来优化每次更新都需要写入redo log的磁盘io问题。默认16M。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to MySQL-3.InnoDB的内存结构" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/3.innodb%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MySQL-4.数据的物理模型</h2></header><div class=entry-content><p>一 表空间 表空间是用来存储表的结构和数据的，InnoDB中表空间分为以下几种：
系统表空间：system tablespace，也叫共享表空间，对应的物理文件是var/lib/mysql/ibdata，这个表空间存了很多东西会越来越大。
系统表空间内容：
数据字典：表结构、数据库名、表名、试图、索引等等元数据 change buffer doubleWrite buffer files：双写缓冲区，为了解决写失效问题，因为操作系统的os cache每页只有4k，默认情况下一个缓存页有16k，所以要把一个缓存页刷新到os cache后再刷到磁盘，需要再os cache中刷4次，如果刷到一半服务器挂了，这个时候这个数据页就是不完整的，这就是写丢失问题。为了解决这种极端情况，在把刷剧刷到磁盘之前innodb会把数据复制到一个2M的内存中，通过这个2M的内存向共享表空间的doubleWrite buffer顺序写，如果doubleWrite buffer顺序写成功，在进行正常的数据页刷新，如果写双写缓冲区的时候失败，其实就算刷盘失败了，但是不会产生坏掉的数据页，如果刷数据页失败在重启之后会使用双写缓冲区的数据页来恢复。 undo logs 独立表空间：file-per-table tablespaces，默认情况下表的数据文件存在独立表空间中，每个库都有自己对应的文件夹，独立表空间是在var/lib/mysql/库名/表名.idb文件，这个文件不能拆分，所以数据越大文件越大，表结构的信息除了存储到系统表空间之外也会在表空间统计的.frm文件中，8.0之后所有的表结构信息都在系统表空间中。
通用表空间：MySQL5.7之后支持，类似系统表空间，可以创建表的时候把表空间指定到通用表空间。
撤销表空间：undo tablespaces，用来保存undo log的，undo log默认存在系统表空间里，也就是存在ibdata文件中，5.7之后可以通过undo_log_truncate+innodb_undo_tablespaces参数设置让undo log保存到对应的撤销表空间。这样可以解决系统表空间越来越大的问题。8.0之后默认会把undo log放到撤销表空间里。
临时表空间：temporary tabespaces，5.7之后独立出来的，之前也在系统表空间里，存储的是临时表数据，对应的文件是MySQL数据文件夹里的ibtmpl文件，初始16M，也是自动扩容的，会越来越大，当内存里的临时表空间满了的时候会刷新到磁盘里，可以设置临时表空间的大小，重启时ibtmpl里的内容会被释放。
1）表空间的逻辑结构 一个表空间包括多个段(segement)，每个段包括多个区(extent)，每个区有多个页(page)，每个也有多条数据(row)。 表空间：相当于innodb存储引擎存储的最高层，用来存储多个idb文件，每个idb文件都是独立的表空间。 段：他是一个逻辑概念，用来申请空间和回收，一个段有256个区，常见的段有数据段、索引段、回滚段等等。 区：由连续的页组成的空间，一个区有64个页，默认情况下一个页16k，所以一个区就是1M。 页：存储多个连续row，常见的页类型有数据页、undo页、索引页等等。
2）page结构 innoDB的数据都是以页为单位存储的，每个数据页都有一个38字节的file header(描述信息) + 56字节的page header(存储页状态) + infimum + supermum records(26字节的最大最小行记录) + user records(存储的数据行记录) + free space(空闲空间大小) + page directory(页目录，存储数据记录的偏移量) + file trailer(8字节文件尾，用来校验页的完整性)。
file header中有上一页信息，file trailer有下一页的信息，这样数据页之间就组成了一个双向链表。
3）行数据结构 行格式有4种，可以在建表的时候指定row_format或者alter table修改，5.7之后默认使用dynamic。
数据库中有些类型的数据是不固定长度的，比如varchar(20)，但是你可能只存1个‘a’，所以需要一个标记来记录不定长的字段中的数据长度，标记使用的是16进制，还要有记录列名、类型的信息，然后你还有可以为null的列，需要记录可以为空的列到底有没有数据，compact格式的行数据大概是这个样子的：
1 2 3 4 5 # 前两个16进制存储的是地址1的长度、姓名1的长度（逆序存储） # 中间的8位bit数就是null值列表，存储的是可以为null的列 # 只要某一列可以为空就要在null值列表中有一个占位，当列为空时存0，不为空时存1 # null值列表一定是8的整数倍，不足时在头部补0，也是逆序存储 0x03 0x03 00000101 头字段 姓名1 地址1 40位的头字段详细信息：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to MySQL-4.数据的物理模型" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/4.innodb%E7%9A%84%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MySQL-5.三个log</h2></header><div class=entry-content><p>redo log WAL机制：预写日志机制，这是一种日志先行机制，意思是刷新数据的时候，先把数据对应的log刷新到磁盘上的对应的log file中，然后再根据log file刷新数据。针对redo log的WAL机制就是先将内存中的redo log buffer刷新到磁盘上的redo log file里，然后再根据redo log file刷新磁盘上的数据。这样有个好处是如果直接修改磁盘数据是随机写，但是WAL的话会顺序写日志，然后异步随机写。
1）基本概念 redo log叫重做日志，它包括两部分，一部分是内存中的redo log buffer，另一部分是磁盘上的redo log file。通过redo log可以实现数据的持久型。
2）数据刷盘 脏页落盘的chack point：
强制落盘：关闭数据库的时候把所有脏页落盘； 主线程定时将脏页写入磁盘； 当redo log快写满的时候：redo log在75%到90%之间会异步落盘，超过90%会同步落盘； lru链表中有脏页被淘汰的脏页会落盘； buffer pool中的脏页超过75%会落盘； 3）redo log刷盘策略 redo log持久化策略通过innodb_flush_log_at_trx_commit来配置，这个属性有3个选项，分别是0、1、2：
为0时：redo log buffer每秒会写入到os cache，并调用fsync操作进行刷盘，设置成0的话当系统崩溃的时候可能会丢失1s的数据。 为1时：事务提交时会直接写入os cache并调用fsync操作刷到磁盘，这种不会丢失数据，但是磁盘io会很频繁。 为2时：事务提交时会写入os cache，由后台线程每秒执行fsync操作，这种只要不是服务器宕机就不会丢失数据。 4）日志格式 redo log记录的是哪个数据页的哪个位置上的数据被修改，修改为多少。
type space id page number offset len data 日志类型 表空间的id 数据页号 数据页中的偏移量 修改的内容不确定长度时占用的字节数 redo log的具体内容 日志类型有很多种，在5.7里有五十多种，比如type=1的时候是MLOG_1BYTE，意思是某个偏移量处写入了1字节的数据，type=30的时候是MYLOG_WRITE_STRING，表示修改了字符串的值，这种不确定长度的值的修改会使用len进行标记。
5）刷盘时机 首先在MySQL关闭的时候是必须要刷盘的； 其次MySQL在后台有一个线程会每秒刷一次； 然后如果1s内产生的redo log超过了redo log buf的一半大小会马上进行刷盘； 最后事务提交的时候会进行刷盘； 默认情况下磁盘中的redo log只有两个文件，ib_logfile0和ib_logfile1，写满了就会覆盖。这两个文件组成了一个日志组。组里的日志文件组成立一个环，比如ib_logfile0写满了会去写ib_logfile1，ib_logfile1写满了之后又会去写ib_logfile0。其中write pos表示当前日志记录到的位置，check point表示将日志记录写进磁盘，然后会将日志擦除，write pos和check point是追逐关系，当write pos追上check point的时候不能写继续写redo log。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to MySQL-5.三个log" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/5.%E4%B8%89%E4%B8%AAlog/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MySQL-6.事务</h2></header><div class=entry-content><p>一）事务的4个特性 原子性：同一个事物内的SQL要么都成功要么都失败，innodb中使用undo log保证数据的回滚，在事务执行过程中如果宕机的话没有提交的事务不会被恢复，因为redo log中的日志是uncommit的。 一致性：原子性+隔离性+持久性是为一致性服务的，一致性说的是事务开始之前到结束不会破坏数据库的完整性，可以理解为其他3个特性加在一起就是一致性。一致性分为约束一致性和数据一致性： 约束一致性：针对表结构的外键、唯一索引等约束； 数据一致性：由原子性+隔离性+持久性共同保证的结果； 隔离性：一个事务执行过程中不能被其他事物干扰，针对隔离性SQL定义了4个隔离级别，分别通过锁和mvcc实现。 持久性：事务提交之后对数据的改变是永久性的，innodb通过bin log + redo log(两阶段提交) + 双写缓冲区实现持久性。 控制多个事务对数据的操作其实就是隔离性，通过锁+mvcc实现。
查看系统中事物的语句是：
1 2 # 查看持续时间超过60s的事物 select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60 二）数据库并发的问题 针对于隔离性SQL定义了四种隔离级别来解决4种并发问题：
脏写：比如两个事务，一个A，一个B，A先将一个null值修改为a，但是还没有提交事务，可能还有别的数据要处理，这时候B过来把a改成了b，然后提交数据，然后A处理别的数据失败执行回滚，此时数据又变成了null，这就是脏写。 脏读：比如两个事务，一个事务A，一个事务B，事务A读取数据为a，然后就去处理别的数据了，没有提交事务，这时候事务B过来把a改成null但是也没有提交事务，然后事务A处理完回来再去读取数据变成了null，一下就蒙了，这就是脏读。脏读和脏写都是因为一个事务去读了另一个事务还没有提交事务的更新操作。 不可重复读：不可重复读和脏读的区别是不可重复读不能读取没提交事务的数据，脏读是读到了其他事物没提交的数据，属于脏数据。出现不可重复读的原因是在一次事务中对同一条数据的读取可能被别的事务改值并且提交，这么一看不可重复读算不算并发问题都可以，要根据业务去定义。 幻读：幻读和不可重复读的区别是不可重读是修改，幻读是增加或者删除，导致一次事务中多次读取的数据条数不一样。 三）SQL标准事务隔离 这是SQL不是MySQL，SQL数据库都有隔离级别，事务的隔离级别就是锁+MVCC的封装。
read uncommitted：读未提交，不会发生脏写，但是会有其他三个并发读问题，不适用MVCC并且不加锁实现这个隔离级别。 read committed：读已提交，就是说不能读取没有提交事务的值，这种隔离级别不会发生脏写和脏读，但是会有可重复读和幻读，一般都说RC。 repeatable read：可重复读，在一次事务中不管别人有没有提交过修改这个值的事务，读出来的值都是一样的，这种隔离级别只可能产生幻读问题，一般叫他RR。 serializable：串行化了，没人用，都串行了肯定不会有并发问题，性能太低，所有操作都加锁。 在spring中使用@Transactional(isolation=Isolation.DEFAULT)来设置隔离级别，DEFAULT就是默认，由数据库决定。
查看当前数据库的隔离级别的语句是：
1 show variables like 'transaction_isolation'; 四）MVCC 这个是数据库为了实现高并发的数据访问，通过事务的可见性来保证事务能够看见应该看见的版本，他的优点是读可以不加锁，并且读写不冲突。通过undo log版本链 + read view机制实现。
1）undo log版本链 每条数据都有两个隐藏的字段，trx_id和roll_pointer，trx_id是最新修改数据的事务id，而roll_pointer指向的是最后一次更新之前的undo log，undo log是链表结构，每个undo log元素都有修改前的值、trx_id和roll_pointer，trx_id就是那次修改的id，roll_pointer指向前一次的undo log元素，也就是说具体的数据行和undo log之间通过roll_pointer组成单向链表。
通过undo log版本链可以实现事务没提交的时候其他事务可以去读版本链中的已经提交的最新版本的undo log上的最新数据。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to MySQL-6.事务" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/6.%E4%BA%8B%E5%8A%A1/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MySQL-7.锁</h2></header><div class=entry-content><p>从操作粒度上可以分成全局锁(主要做全库的逻辑备份)、表锁(每个引擎都支持)、页锁(BDB引擎)、行锁(InnoDB)。
从操作类型分为读锁和写锁，读锁也叫共享锁，写锁也叫排它锁，共享锁和共享锁不互斥，排他锁和排他锁、排他锁和共享锁互斥。除了读写锁还有意向共享锁和意向排它锁，这两个都是表级的锁。
从性能上可以分成乐观锁和悲观锁，乐观锁的实现是通过版本对比来决定是否可以更新，但是更新的时候仍然需要加悲观锁。
全局锁 通过命令flush tables with read lock;开启全局锁，MySQL异常时会自动断开。开启全局锁后DDL、DML和TCL都会阻塞住，让整个库处于一个只读的状态，使用unlock tables释放锁。通常用于整库备份，不常用，一般备份的话可以用MySQL自带的备份工具，自带的备份工具会开启事务，基于快照的方式备份。
表级锁 使用show open tables查看表状态，结果中的inUse列大于0表示有表锁。使用lock table 表名 read/write添加表级读写锁，还是使用unlock tables释放锁。我使用innodb添加表级锁时，不管读锁还是写锁show open tables结果中的inUse都是1。
行锁 InnoDB引擎独有的，只有rr隔离级别并且在索引上才能生效。当修改或者删除没有使用索引或者索引失效的时候或者条件再索引中重复率超过30%，InnoDB会把行锁升级成表锁。
行锁有3种模式：
记录锁(Records lock)：为某行数据加锁，加锁的列必须是唯一索引或者聚簇索引；查询语句必须是精准匹配，否则会变成间隙锁； 间隙锁(Gap lock)：锁定一个范围内的索引，查询的结果是个范围的时候会添加间隙锁，如果是根据聚簇索引或者唯一索引范围查询，范围的下一条数据也会被加锁；如果是根据聚簇索引或者唯一索引不是范围查询的情况(也就是说操作指定一条数据)，当这条数据不存在的时候会产生间隙锁； 临键锁(next-key lock)：它相当于一种特殊的间隙锁，当操作的条件是聚簇或者唯一索引的等值条件时使用记录锁，聚簇或者唯一索引的条件会退化成间隙锁，对于非唯一索引使用临键锁。 lock in share mode会对二级索引加锁而for update会对二级索引和聚簇索引都加锁。
1）临键锁解决幻读问题 MySQL的RR级别如果使用的是快照读，不会出现幻读问题，当使用当前读或者RC级别、RU级别时才会出现幻读。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to MySQL-7.锁" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/7.%E9%94%81/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MySQL-8.索引</h2></header><div class=entry-content><p>索引类型 索引是存储引擎用例快速查找数据的数据结构。innodb只支持B+树索引，但是内部有个自适应的hash索引用来提高查询速度。
1）hash索引 根据索引列计算出hash码，使用hash码+行指针组成hash结构来存储索引，当发生指hash冲突的时候会追加链表。
hash索引做等值查询的时候非常快，但是他不会有索引覆盖的情况，而且他不能范围查询也不能排序。
2）B+树索引 b+树的根节点在内存中，子节点和叶子节点在磁盘
B+树的优点：增加阶数减少树的高度，减少树的高度就是减少磁盘io次数，查询的io次数更稳定。
索引匹配规则 全值匹配：查询条件和索引的字段完全相同，如果是组合索引，顺序不同优化器也会优化成组合和索引相同的顺序。 最左侧列匹配：在组合索引中，正常排序只是按照左侧第一个，如果相同，就用左侧第二个排序，以此类推，最左侧列匹配就是查询条件中有索引包含的列的时候，查询条件必须包含这个列所在的索引的左面所有的列，查询才会走索引。 最左前缀匹配：就是左侧第一个列使用like%，一定只能是在右侧放%，比如class_name like ‘3’%。 范围查找：也是左侧第一个列的范围，比如 ‘3’ &lt; class_name and class_name &lt; ‘5’。 等值匹配加范围匹配：范围匹配最多只能有一个，因为等值匹配可以确定下一列是有序的，按照范围查找很容易，但是第一个范围查找结束后，数据对于下一索引列是无序得了，所以只能有一个范围匹配。 order by的索引使用 order by中有ASC也有DESC的时候是没办法走索引的；
order by后不是列，而是计算出来的字段也是不走索引的；
group by的索引 group by和order by一样，满足索引使用规则时会走索引，不满足就不会走；
回表问题 因为聚簇索引里存储的都是部分列，当使用查询的字段需要回表并且回表次数太多时，MySQL会觉得还不如全表扫描快，全表扫描只需要遍历一遍索引树，所以当我们需要的字段在索引中包含了的时候，就不应该写select *了，这样都不用回表，不得不回表时，最好限制一下条数，否则很可能全表扫描。
创建索引 一般在业务开发完成后，需要把所有的sql检查一遍，查询的条件顺序尽量一致，然后根据条件创建组合索引；
但是对于基数很小，比如说是有0或者1，这种体现不出来二分查找的效率，还不如不建索引；
如果字段的值很大，那么可以只是用前几个字符当做索引，不过这种索引在order by或者group by中就不生效了；
避免聚簇索引频繁页分裂，应该使用自增主键；
避免二级索引过多，因为在增删改查的时候是要维护索引的B+树的，索引太多会让增删改变慢，两三个组合索引能覆盖大部分查询就可以；
当where和order by和limit一起使用但是不能同时满足索引时，优先满足where的索引； 当我们使用复核索引查询时，可能有些字段没用上，这样的话还是不会走索引的，如果没用上的列时字典类型，那么可以用加一个in（字典的所有状态），比如一个复合索引，城市+性别+最近七天登录+年龄，当查询语句是where city=‘哈尔滨’ and 21 &lt; age &lt; 25时是不会走索引的，可以改成where city=‘哈尔滨’ and sex in(0, 1) and does_login_in_7_days in(0, 1) and 21 &lt; age &lt; 25，这样就可以正常走索引了；
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to MySQL-8.索引" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/8.%E7%B4%A2%E5%BC%95/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MySQL优化</h2></header><div class=entry-content><p>参数优化： 1）buffer pool参数优化 查看缓冲池大小，一般可以调成服务器内存的70%。
1 2 3 4 5 6 7 8 9 10 11 12 13 mysql> show variables like '%innodb_buffer_pool_size%'; +-------------------------+-----------+ | Variable_name | Value | +-------------------------+-----------+ | innodb_buffer_pool_size | 134217728 | +-------------------------+-----------+ mysql> select 134217728 / 1024 / 1024; +-------------------------+ | 134217728 / 1024 / 1024 | +-------------------------+ | 128.00000000 | +-------------------------+ 在线调整InnoDB缓冲池大小
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to MySQL优化" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/10.%E4%BC%98%E5%8C%96/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://wangxiaohong123.github.io/tags/mysql/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>