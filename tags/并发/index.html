<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>并发 | 王小红的笔记</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/tags/%E5%B9%B6%E5%8F%91/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/tags/%E5%B9%B6%E5%8F%91/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/tags/%E5%B9%B6%E5%8F%91/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><meta property="og:url" content="https://wangxiaohong123.github.io/tags/%E5%B9%B6%E5%8F%91/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="并发"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="并发"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>并发</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>AQS</h2></header><div class=entry-content><p>谈谈对AQS的理解 ReentrantLock 全局有一个sync实例，这是一个内部类，继承了AbstractQueuedSynchronizer，加锁和释放锁都是基于sync实现的。AQS中定义了一个node，这是自己实现的双向链表，当做队列使用，还有一个state，记录加锁的次数。Sync有两个实现类，一个NonfairSync，一个FairSync，就是公平锁和非公平锁，他俩就是重写了加锁和释放锁的逻辑。Node中定义挺多东西的
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 一些状态，共享锁、排它锁 static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; volatile int waitStatus; // 前一个线程 volatile Node prev; // 后一个线程 volatile Node next; // 当前线程 volatile Thread thread; // 如果是排它锁，nextWaiter就是null，否则就是Node Node nextWaiter; 非公平锁的加锁
...</p></div><footer class=entry-footer>5 min</footer><a class=entry-link aria-label="post link to AQS" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/5.aqs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>atomic</h2></header><div class=entry-content><p>底层基于jdk内部使用UnSafe类，这个类只能在jdk内部用，他把构造函数私有了，并且验证类加载器，如果是应用程序加载器就报错，在类中使用offect记录当前值，自增时调用CompareAndSwap操作，并且是在while循环中。
CPU可以保证在一个线程执行UnSafe的CAS时，其他线程不能执行。
缺点：
ABA问题：可以使用AtomicStampedReference解决，我记着这个类是通过增加时间戳比较来解决的。 无限循环问题：会让CPU负载过高，可以使用jdk1.8的LongAdder来解决 LongAdder在线程很多的时候会使用分段CAS，把多个线程的CAS操作打散到一个cell[]数组上，如果一个线程在一个cell上多次空旋，会去别的cell上操作。获取的时候会把base的值和所有cell的值加到一起。
CAS在修改数据的时候就是把cache entry的flag变成E，然后执行查找在比较在修改操作，修改完了把flag变成M，就结束了。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to atomic" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/4.atomic/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ConcurrentHashMap</h2></header><div class=entry-content><p>1.8中使用了分段加锁，刚开始是CAS，hash冲突在使用synchronized
put
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 // 计算hash值 int hash = spread(key.hashCode()); for (Node&lt;K,V>[] tab = table;;) { // 如果是第一次添加，初始化数组，因为是死循环，这块直接退出了 if (tab == null || (n = tab.length) == 0) tab = initTable(); // 如果数组这个索引没有元素，使用乐观锁添加，只有一个线程能添加成功 // 因为是死循环，所以多线程来添加，失败的线程会在进来重新添加 else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { if (casTabAt(tab, i, null, new Node&lt;K,V>(hash, key, value, null))) break; // no lock when adding to empty bin } else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else { V oldVal = null; // 加锁，只锁数组当前索引的元素 synchronized (f) { if (tabAt(tab, i) == f) { if (fh >= 0) { binCount = 1; // binCount是链表的节点数量 for (Node&lt;K,V> e = f;; ++binCount) { K ek; // 判断key是否相同，相同就覆盖value if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node&lt;K,V> pred = e; // 在链表后面追加 if ((e = e.next) == null) { pred.next = new Node&lt;K,V>(hash, key, value, null); break; } } } // 红黑树添加元素 else if (f instanceof TreeBin) { Node&lt;K,V> p; binCount = 2; if ((p = ((TreeBin&lt;K,V>)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } if (binCount != 0) { // 如果链表节点数量大于8，就转成红黑树 if (binCount >= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } // 在这里进行扩容 addCount(1L, binCount); get的时候使用的UnSafe类的volatile读，volatile会加上Load内存屏障，这样会保证独到的是最新值。
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to ConcurrentHashMap" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/8.concurrenthashmap/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ConcurrentLinkedQueue</h2></header><div class=entry-content><p>concurrentLinkedQueue是线程安全的无界队列，里面有两个指针，head和tail，还有一个单向链表Node。
offer()，看这个代码能看出来链表中只有一个元素的时候，tail指向是null的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public boolean offer(E e) { // 如果是空就抛出异常 checkNotNull(e); final Node&lt;E> newNode = new Node&lt;E>(e); for (Node&lt;E> t = tail, p = t;;) { Node&lt;E> q = p.next; // 如果tail的next是空，就把tail的next指向newNode if (q == null) { // cas写，如果写失败了还会在进循环 if (p.casNext(null, newNode)) { if (p != t) casTail(t, newNode); return true; } // Lost CAS race to another thread; re-read next } else if (p == q) p = (t != (t = tail)) ? t : head; // tail有值的时候会走到这里，移动p的指针，然后继续走循环，就会走到第一个if中 else p = (p != t && t != (t = tail)) ? t : q; } } poll
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to ConcurrentLinkedQueue" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/10.concurrentlinkedqueue/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CopyOnWriteArrayList</h2></header><div class=entry-content><p>底层还是一个数组，被volatile修饰了，这样可以保证多线程读写的可见性。
add()
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public boolean add(E e) { final ReentrantLock lock = this.lock; // 可重入锁进行加锁 lock.lock(); try { Object[] elements = getArray(); // 获取长度 int len = elements.length; // 把底层的数组复制到新数组，同时长度增加1 Object[] newElements = Arrays.copyOf(elements, len + 1); // 设置新元素 newElements[len] = e; // 赋值数组 setArray(newElements); return true; } finally { lock.unlock(); } } set和add一样的。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to CopyOnWriteArrayList" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/9.copyonwritearraylist/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>LinkedBlockingQueue</h2></header><div class=entry-content><p>一个有界队列，初始化的时候如果传capacity就会设置成参数大小，如果没有就设置成int的最大值。他有两把可重入锁，一个putLock，一个takeLock，这两个lock还对应着两个condition，为什么叫阻塞队列呢？因为当put的时候，如果链表的大小等于capacity，会把线程放到锁的wait队列中去，这样不就是阻塞的了吗。take也是一样的，capacity是0的时候就会阻塞住。
put
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public void put(E e) throws InterruptedException { if (e == null) throw new NullPointerException(); // Note: convention in all put/take/etc is to preset local var // holding count negative to indicate failure unless set. int c = -1; Node&lt;E> node = new Node&lt;E>(e); final ReentrantLock putLock = this.putLock; // count就是链表的节点数量，使用AtomicInteger保证并发安全 final AtomicInteger count = this.count; // 加锁，lockInterruptibly在加锁成功之前是可以被中断的 putLock.lockInterruptibly(); try { while (count.get() == capacity) { notFull.await(); } // 入队，就是修改一下last的指针 enqueue(node); // 节点数量增加 c = count.getAndIncrement(); if (c + 1 &lt; capacity) // 唤醒等待put的线程 notFull.signal(); } finally { putLock.unlock(); } // 在这里应该是添加加成功了的， // 因为数量自增使用的getAndIncrement，所以当链表中没有元素，然后添加第一个元素走到这里 // 此时count是1，c是0，也是就是put之前，在这里判断，如果put之前链表没有元素，name可能有线程take被阻塞了 // 所以唤醒take的wait线程 if (c == 0) signalNotEmpty(); } 他的Iterator的next和remove是把putLock和takeLock都锁上。
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to LinkedBlockingQueue" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/11.linkedblockingqueue/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Threadlocal</h2></header><div class=entry-content><p>线程变量的副本。每个Thread内部有一个ThreadLocalMap，这个map是一个Entry数组，只能是线程自己内部使用，因为他就是内部的变量嘛，Entry中有两个变量，一个是k（ThreadLocal类型），一个是value（自己定义类型）
set
1 2 3 4 5 6 7 8 9 10 11 public void set(T value) { Thread t = Thread.currentThread(); // 获取线程内部的ThreadLocalMap ThreadLocalMap map = getMap(t); // 如果map已经创建了就添加元素 if (map != null) map.set(this, value); // 不存在就创建 else createMap(t, value); } get
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to Threadlocal" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/6.threadlocal/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>volatile</h2></header><div class=entry-content><p>volatile是为了解决修改数据后，其他线程可以立即感知到数据的变化。
因为CPU读写主内存的速度比较低，所以数据的处理都是在CPU缓存中。CPU会读写的自己缓存，缓存在刷新到主内存或者别的地方，提高性能。但是这样的话就会导致别的线程修改了数据，不会马上写回主内存，就算写回主内存，有些线程可能也不会去主内存读，还是读取自己的缓存中的数据。
被volatile修饰后就符合MESI协议，当数据被修改之后也就是assign步骤结束后，会强制执行store和write操作，同时所有CPU会嗅探到数据过期，在重新读取数据。
java内存模型 可以看出来和CPU的缓存模型很像，也存在同样的问题，线程1在修改数据后，线程2感知不到。
并发三大问题 可见性：上面说得都是可见性。
原子性：多个线程读，一个线程写，会发生可见性，如果多个线程写就会发生原子性了，可能两个线程都执行+1操作，结果执行完了结果还是1。jvm规定变量的简单赋值都是原子性的，包括引用类型的赋值。复杂的赋值比如i = j + 2;这种待计算的就不保证原子性。但是在32位虚拟机中，赋值long和double是不保证原子性的，加上volatile就可以了，但是仅仅在这种情况使用volatile可以保证原子性。
有序性：编译器和指令器会进行指令重排。在静态编译（javac）和动态编译（JIT）过程中，都可能会发生指令重排，尤其是JIT。处理器在收到JIT编译好之后的机器码指令后，可能对指令进行重排序，处理器执行完到写缓冲器、无效队列、高速缓存中执行指令可能又发生下指令重排。
处理器在执行的时候哪个指令先就绪，就执行哪个指令，执行完了以后把结果放到重排序处理器，重排序处理器根据CPU收到的指令顺序把结果写到高度缓存或者写缓冲器中。
volatile是无法保证保证原子性的，因为就算数据被强制加载到工作内存，但是线程可能正在修改或者正在执行write操作，这时候就算工作内存中的数据变化了，也没用。
MESI协议 tag是保存主内存中数据的地址，flag是数据的状态，cache line里可以包含多个变量，就是具体的值。
处理器根据index、tag、offect来定位到数据，index定位到缓存中的bucket，tag定位到tag entry，offect定位到cache line中的数据。
flag的状态：
invalid：无效的
shared：共享的
exclusive：独占的
modified：修改过的
读取数据的时候，CPU1向总线发送read消息，主内存把数据返回，这时，数据的flag是S（共享的），修改数据的时候向总线发送invalidate消息，其他CPU嗅探到这条消息会把数据的flag变成I，然后返回ack给总线，CPU收到所有CPU的ack消息之后把flag变成E，修改完了把flag改成M，有的处理器还会把主内存的数据刷新。其他CPU在读取数据的时候发现flag是I，就要在发送read消息。这样会有一个问题，操作数据变成串行了，效率非常低。
在发invalidate消息之前把数据写到写缓冲器里，就可以去干别的了，收到invalidate消息之后把消息写到无效队列中，就返回ack，CPU1收到所有处理器的ack之后从写缓冲器中取出写入的数据，把flag变成E，然后在修改数据，在变成M，其他处理器从无效队列中消费完消息就把flag变成I，然后返回ack。这种异步的就会导致消息不会马上更新到高速缓存或者主内存，产生了可见性问题。还可能发生StoreLoad、StoreStore。
从图中可以看出，可见性是因为处理器更新数据副本可能写到寄存器、高速缓存或者写缓冲器，写到这几个地方其他处理器都不能马上感知到数据的变化。
flush操作：在刷新数据到写缓冲器的同时，也要把数据刷新到高速缓存中，有的硬件还需要把数据刷到主内存中，刷新完了会发送消息到消息总线。
refresh操作：处理器接收到总线的消息后会把变量副本过期，然后从发消息的处理器的高速缓存或者主内存中加载数据（根据硬件决定）。
happens-before 只要是符合这个原则，就不能重排序。
内存屏障 Load屏障：执行refresh操作，收到invalidate消息之后马上修改flag为I；
Store屏障：执行flush操作，把数据写到写缓冲器中后必须等到所有ack之后写到高速缓存或者主内存中；
Acquire屏障（LoadLoad + LoadStore）：禁止读操作和读写操作发生指令重排；
Release屏障（StoreLoad + StoreStore）：禁止写操作和读写操作发生指令重排；
1 2 3 4 5 6 7 8 9 10 11 boolean volatile isRunning; // Release屏障 isRunning = false; // Store屏障 // Load屏障 while(isRunning) { // Acquire屏障 …… }</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to volatile" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/2.volatile/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>线程</h2></header><div class=entry-content><p>工作线程：main方法就是一个线程，在main线程中在启动一个线程，线程中是一个死循环，比如定时发送心跳，这时候就算main执行完成，jvm也不会退出，因为有一个非后台的工作线程在一直运行。 daemon线程：非工作线程就是daemon线程，如果说所有的工作线程都停止了，daemon线程会跟着jvm一起退出了。使用**setDaemon(true)**将工作线程设置成daemon线程，什么时候需要设置成daemon线程呢？比如说有一个后台的监控线程，在工作线程都结束之后，后台的监控也没用了，jvm就可以退出了，不让监控线程影响jvm的退出就要把监控线程设置成daemon线程。 ThreadGroup：线程是有父子概念的，比如在main中创建一个线程，那main就是创建线程的父线程，如果没指明线程组，会被分配到父线程所在的线程组中。main线程的名字就是main，平时创建的线程可以使用**setName("ServiceAliveMonitor")**设置线程名。手动创建线程组 1 2 3 4 // 创建一个线程组 ThreadGroup daemonThreadGroup = new ThreadGroup("daemon"); // daemon是我自己创建的线程，在线程中的构造方法中调用super(ThreadGroup, ThreadName)就可以分配线程组了 this.daemon = new Daemon(daemonThreadGroup, "ServiceAliveMonitor"); 线程优先级:setPriority(8)，理论上来说数越大越会CPU更多的执行，默认是5。 Thread.yield()：告诉CPU说不执行这个线程了，暂停。 join()就是要等待这个线程执行完才能往下走。 Interrupt：打断一个线程，就是修改线程里的interrupt标志位，线程中可以通过isInterrupted()来感知到被打断，在决定是否继续运行，还可以打断一个线程的休眠。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 Thread thread = new Thread() { @Override public void run() { while (!isInterrupted()) { System.out.println("线程1执行在工作"); } } }; thread.start(); TimeUnit.MILLISECONDS.sleep(200); // interrupt并不会停止线程，只是修改一下标志位 // 要在线程中判断被打断了以后怎么操作 thread.interrupt(); /** * 唤醒睡眠的线程 */ public static void main(String[] args) throws Exception { MyThread thread = new MyThread(); thread.start(); // 让线程执行一会 Thread.sleep(1000); // 修改线程的while条件 thread.setShouldRun(false); // 然后在唤醒，这样的话线程被唤醒就退出了 thread.interrupt(); } private static class MyThread extends Thread { private boolean shouldRun = true; @Override public void run() { while (shouldRun) { try { System.out.println("线程1执行在工作"); Thread.sleep(30 * 1000L); } catch (InterruptedException e) { e.printStackTrace(); } } } public void setShouldRun(boolean shouldRun) { this.shouldRun = shouldRun; } }</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 线程" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/1.%E7%BA%BF%E7%A8%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>线程池</h2></header><div class=entry-content><p>四种线程池：
fixed：固定数量 cached：数量不固定，有新任务就创建线程，空闲的线程会回收 single：只有一个线程池 scheduled：在指定时间后执行提交的线程 fixed，fixed中并不会触发reject策略，和maximumPoolSize，因为他用的是无界队列。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 /** * Executors类的newFixedThreadPool方法 * 虽然LinkedBlockingQueue是有界队列，但是声明线程池的时候没有设置capacity，相当于一个无界队列，容易OOM * 核心线程数和最大线程数是相同的，如果nThreads都在处理任务就会把任务压进队列中 * 如果线程报错挂掉，会在创建一个新的线程来顶替 * 线程空闲的时候不会被销毁，因为核心线程数就是最大线程数 */ public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable>()); } /** * ThreadPoolExecutor类的构造方法 * 他的父类实现了ExecutorService * 所以创建普通线程池一般都用ExecutorService来接收： * ExecutorService threadPool = Executors.newFixedThreadPool(10); */ public ThreadPoolExecutor(int corePoolSize, // 核心线程数 // 最大线程数 int maximumPoolSize, // 多余线程的空闲存活时间 long keepAliveTime, TimeUnit unit, // 任务队列 BlockingQueue&lt;Runnable> workQueue, // 创建线程的工厂 ThreadFactory threadFactory, // 线程数达到最大并且队列也满了之后在收到任务的拒绝策略 RejectedExecutionHandler handler) { if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } // ThreadPoolExecutor中除了构造函数的参数，还有一些关键的参数 // 通过一个32位的二进制数，来表示线程状态和数量， // 前3位是线程池的状态，后29为是数量，通过一些二进制计算来查询和修改 private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); // 获取状态 private static int runStateOf(int c) { return c & ~CAPACITY; } // 获取线程数量 private static int workerCountOf(int c) { return c & CAPACITY; } // 设置线程数量和线程池状态 private static int ctlOf(int rs, int wc) { return rs | wc; } /** * 提交线程的方法 */ public void execute(Runnable command) { if (command == null) throw new NullPointerException(); // 获取上面说得那个32位数字 int c = ctl.get(); // 如果线程数小于核心线程数就创建一个线程 if (workerCountOf(c) &lt; corePoolSize) { // addWorker传的true表示是核心线程 // 使用cas增加核心线程数 if (addWorker(command, true)) return; c = ctl.get(); } // 任务入队成功，使用的是offer，这个是非阻塞的，如果队列满了就返回false if (isRunning(c) && workQueue.offer(command)) { int recheck = ctl.get(); // 下面的操作是双重检查 // 如果线程池关闭了，删除任务，然后拒绝 if (! isRunning(recheck) && remove(command)) reject(command); // 如果线程数是0就创建线程 else if (workerCountOf(recheck) == 0) addWorker(null, false); } // 任务入队失败，说明核心线程数达到最大并且队列已经满了 // 尝试创建新线程，直到线程达到最大线程数 // 如果这个时候创建线程失败就走拒绝策略 else if (!addWorker(command, false)) // 拒绝策略 reject(command); } 关闭，关闭不会马上关闭有任务的线程，而是先关闭线程池，线程池状态是关闭时，不接受新任务，在线程把队列和自己的任务执行完之后while循环中的take（不是阻塞队列的take）就会返回null，线程就结束了。
...</p></div><footer class=entry-footer>4 min</footer><a class=entry-link aria-label="post link to 线程池" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/12.%E7%BA%BF%E7%A8%8B%E6%B1%A0/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://wangxiaohong123.github.io/tags/%E5%B9%B6%E5%8F%91/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>