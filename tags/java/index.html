<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java | 王小红的笔记</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/tags/java/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/tags/java/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/tags/java/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wangxiaohong123.github.io/tags/java/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="Java"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Java</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>atomic</h2></header><div class=entry-content><p>底层基于jdk内部使用UnSafe类，这个类只能在jdk内部用，他把构造函数私有了，并且验证类加载器，如果是应用程序加载器就报错，在类中使用offect记录当前值，自增时调用CompareAndSwap操作，并且是在while循环中。
CPU可以保证在一个线程执行UnSafe的CAS时，其他线程不能执行。
缺点：
ABA问题：可以使用AtomicStampedReference解决，我记着这个类是通过增加时间戳比较来解决的。 无限循环问题：会让CPU负载过高，可以使用jdk1.8的LongAdder来解决 LongAdder在线程很多的时候会使用分段CAS，把多个线程的CAS操作打散到一个cell[]数组上，如果一个线程在一个cell上多次空旋，会去别的cell上操作。获取的时候会把base的值和所有cell的值加到一起。
CAS在修改数据的时候就是把cache entry的flag变成E，然后执行查找在比较在修改操作，修改完了把flag变成M，就结束了。</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to atomic" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/4.atomic/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>volatile</h2></header><div class=entry-content><p>volatile是为了解决修改数据后，其他线程可以立即感知到数据的变化。
因为CPU读写主内存的速度比较低，所以数据的处理都是在CPU缓存中。CPU会读写的自己缓存，缓存在刷新到主内存或者别的地方，提高性能。但是这样的话就会导致别的线程修改了数据，不会马上写回主内存，就算写回主内存，有些线程可能也不会去主内存读，还是读取自己的缓存中的数据。
被volatile修饰后就符合MESI协议，当数据被修改之后也就是assign步骤结束后，会强制执行store和write操作，同时所有CPU会嗅探到数据过期，在重新读取数据。
java内存模型 可以看出来和CPU的缓存模型很像，也存在同样的问题，线程1在修改数据后，线程2感知不到。
并发三大问题 可见性：上面说得都是可见性。
原子性：多个线程读，一个线程写，会发生可见性，如果多个线程写就会发生原子性了，可能两个线程都执行+1操作，结果执行完了结果还是1。jvm规定变量的简单赋值都是原子性的，包括引用类型的赋值。复杂的赋值比如i = j + 2;这种待计算的就不保证原子性。但是在32位虚拟机中，赋值long和double是不保证原子性的，加上volatile就可以了，但是仅仅在这种情况使用volatile可以保证原子性。
有序性：编译器和指令器会进行指令重排。在静态编译（javac）和动态编译（JIT）过程中，都可能会发生指令重排，尤其是JIT。处理器在收到JIT编译好之后的机器码指令后，可能对指令进行重排序，处理器执行完到写缓冲器、无效队列、高速缓存中执行指令可能又发生下指令重排。
处理器在执行的时候哪个指令先就绪，就执行哪个指令，执行完了以后把结果放到重排序处理器，重排序处理器根据CPU收到的指令顺序把结果写到高度缓存或者写缓冲器中。
volatile是无法保证保证原子性的，因为就算数据被强制加载到工作内存，但是线程可能正在修改或者正在执行write操作，这时候就算工作内存中的数据变化了，也没用。
MESI协议 tag是保存主内存中数据的地址，flag是数据的状态，cache line里可以包含多个变量，就是具体的值。
处理器根据index、tag、offect来定位到数据，index定位到缓存中的bucket，tag定位到tag entry，offect定位到cache line中的数据。
flag的状态：
invalid：无效的
shared：共享的
exclusive：独占的
modified：修改过的
读取数据的时候，CPU1向总线发送read消息，主内存把数据返回，这时，数据的flag是S（共享的），修改数据的时候向总线发送invalidate消息，其他CPU嗅探到这条消息会把数据的flag变成I，然后返回ack给总线，CPU收到所有CPU的ack消息之后把flag变成E，修改完了把flag改成M，有的处理器还会把主内存的数据刷新。其他CPU在读取数据的时候发现flag是I，就要在发送read消息。这样会有一个问题，操作数据变成串行了，效率非常低。
在发invalidate消息之前把数据写到写缓冲器里，就可以去干别的了，收到invalidate消息之后把消息写到无效队列中，就返回ack，CPU1收到所有处理器的ack之后从写缓冲器中取出写入的数据，把flag变成E，然后在修改数据，在变成M，其他处理器从无效队列中消费完消息就把flag变成I，然后返回ack。这种异步的就会导致消息不会马上更新到高速缓存或者主内存，产生了可见性问题。还可能发生StoreLoad、StoreStore。
从图中可以看出，可见性是因为处理器更新数据副本可能写到寄存器、高速缓存或者写缓冲器，写到这几个地方其他处理器都不能马上感知到数据的变化。
flush操作：在刷新数据到写缓冲器的同时，也要把数据刷新到高速缓存中，有的硬件还需要把数据刷到主内存中，刷新完了会发送消息到消息总线。
refresh操作：处理器接收到总线的消息后会把变量副本过期，然后从发消息的处理器的高速缓存或者主内存中加载数据（根据硬件决定）。
happens-before 只要是符合这个原则，就不能重排序。
内存屏障 Load屏障：执行refresh操作，收到invalidate消息之后马上修改flag为I；
Store屏障：执行flush操作，把数据写到写缓冲器中后必须等到所有ack之后写到高速缓存或者主内存中；
Acquire屏障（LoadLoad + LoadStore）：禁止读操作和读写操作发生指令重排；
Release屏障（StoreLoad + StoreStore）：禁止写操作和读写操作发生指令重排；
1 2 3 4 5 6 7 8 9 10 11 boolean volatile isRunning; // Release屏障 isRunning = false; // Store屏障 // Load屏障 while(isRunning) { // Acquire屏障 …… }</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to volatile" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/2.volatile/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>线程</h2></header><div class=entry-content><p>工作线程：main方法就是一个线程，在main线程中在启动一个线程，线程中是一个死循环，比如定时发送心跳，这时候就算main执行完成，jvm也不会退出，因为有一个非后台的工作线程在一直运行。 daemon线程：非工作线程就是daemon线程，如果说所有的工作线程都停止了，daemon线程会跟着jvm一起退出了。使用**setDaemon(true)**将工作线程设置成daemon线程，什么时候需要设置成daemon线程呢？比如说有一个后台的监控线程，在工作线程都结束之后，后台的监控也没用了，jvm就可以退出了，不让监控线程影响jvm的退出就要把监控线程设置成daemon线程。 ThreadGroup：线程是有父子概念的，比如在main中创建一个线程，那main就是创建线程的父线程，如果没指明线程组，会被分配到父线程所在的线程组中。main线程的名字就是main，平时创建的线程可以使用**setName(“ServiceAliveMonitor”)**设置线程名。手动创建线程组 1 2 3 4 // 创建一个线程组 ThreadGroup daemonThreadGroup = new ThreadGroup("daemon"); // daemon是我自己创建的线程，在线程中的构造方法中调用super(ThreadGroup, ThreadName)就可以分配线程组了 this.daemon = new Daemon(daemonThreadGroup, "ServiceAliveMonitor"); 线程优先级:setPriority(8)，理论上来说数越大越会CPU更多的执行，默认是5。 Thread.yield()：告诉CPU说不执行这个线程了，暂停。 join()就是要等待这个线程执行完才能往下走。 Interrupt：打断一个线程，就是修改线程里的interrupt标志位，线程中可以通过isInterrupted()来感知到被打断，在决定是否继续运行，还可以打断一个线程的休眠。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 Thread thread = new Thread() { @Override public void run() { while (!isInterrupted()) { System.out.println("线程1执行在工作"); } } }; thread.start(); TimeUnit.MILLISECONDS.sleep(200); // interrupt并不会停止线程，只是修改一下标志位 // 要在线程中判断被打断了以后怎么操作 thread.interrupt(); /** * 唤醒睡眠的线程 */ public static void main(String[] args) throws Exception { MyThread thread = new MyThread(); thread.start(); // 让线程执行一会 Thread.sleep(1000); // 修改线程的while条件 thread.setShouldRun(false); // 然后在唤醒，这样的话线程被唤醒就退出了 thread.interrupt(); } private static class MyThread extends Thread { private boolean shouldRun = true; @Override public void run() { while (shouldRun) { try { System.out.println("线程1执行在工作"); Thread.sleep(30 * 1000L); } catch (InterruptedException e) { e.printStackTrace(); } } } public void setShouldRun(boolean shouldRun) { this.shouldRun = shouldRun; } }</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 线程" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/1.%E7%BA%BF%E7%A8%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>线程</h2></header><div class=entry-content><p>Synchronized原理
Mark Word结构
Synchronized修饰普通方法，锁的是实例对象，修饰的是静态方法的时候锁的是类，class对象。
每个对象都有monitor对象，monitor中有一个计数器，编译的时候碰到了Synchronized时候会生成MonitorEnter和对应的MonitorExit，线程执行到Synchronized修饰的代码块或者方法的时候，先看看monitor对象中的计数器是不是0，如果不是0就根据owner判断持有锁的对象是不是自己，如果不是就等待，如果是就把计数器在加1，调用wait方法的时候会把计数器清0，owner变成null，然后waitset中添加当前线程，调用notify的时候就唤醒waitset中的线程。
双重检查的单例需要使用volatile并不是因为volatile的可见性，因为Synchronized本身就可以保证可见性，而是因为双重检查的写法可能会导致指令重排，打乱了创建对象实例的时候的顺序，比如单例的构造函数中实例化了其他的对象，可能会重排成对象没实例化，但是指针有了，这时候线程2走if判断，发现是true直接返回实例，但是实例的对象还没全部初始化，只是有了一个指针，用这个实例就会有问题。加上volatile根据happens-before原则不会进行重排序。
synchornized使用锁来保证原子性，通过在释放锁的时候执行flush操作，在进入代码块的时候执行refresh操作，通过内存屏障来解决有序性，和可见性。
在执行完monitorenter之后会执行Load内存屏障，执行monitorexit之后会执行Store内存屏障。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // synchronized通过Acquire和Release屏障可以保证代码块内部和外部不发生指令重排 // 代码块里面还是可能会发生指令重排 int b = 0; int c = 0; synchronized(this) { // -> monitorenter // Load内存屏障 // Acquire内存屏障 int a = b; c = 1; // Release内存屏障 } // -> monitorexit // Store内存屏障 锁升级 偏向锁 偏向锁就是在Mark Word中存储线程ID，为了提升同一个线程多次加锁释放锁的性能，比如循环调用Synchronized代码块，如果高并发而且并不存在同一个线程多次调用同一个Synchronized代码块时，会频繁的发生stop the world和CAS，影响性能，这时候应该关闭偏向锁：
...</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 线程" href=https://wangxiaohong123.github.io/posts/%E5%9F%BA%E7%A1%80/java/2.%E5%B9%B6%E5%8F%91/3.synchronized/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>