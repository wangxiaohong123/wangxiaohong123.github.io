<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>研发效能 on 王小红的笔记</title><link>https://wangxiaohong123.github.io/tags/%E7%A0%94%E5%8F%91%E6%95%88%E8%83%BD/</link><description>Recent content in 研发效能 on 王小红的笔记</description><generator>Hugo -- 0.150.0</generator><language>zh-CN</language><lastBuildDate>Thu, 24 Jun 2021 06:27:35 +0000</lastBuildDate><atom:link href="https://wangxiaohong123.github.io/tags/%E7%A0%94%E5%8F%91%E6%95%88%E8%83%BD/index.xml" rel="self" type="application/rss+xml"/><item><title>1.敏捷开发</title><link>https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/ddd/1.%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/</link><pubDate>Thu, 24 Jun 2021 06:27:35 +0000</pubDate><guid>https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/ddd/1.%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/</guid><description>&lt;p&gt;传统的瀑布流就是产品经理定义了一个功能非常多，非常完善的产品，然后一堆后端、前端、UI等等进行排期开发，如果这些人包括产品对项目非常了解，每个人都有10年这种类似的产品的开发经验，闭关开发半年或者一年，产出一个成型的完善的产品其实是可能的，一旦对这个产品没有相关经验，开发周期变得很长就会出现一个问题，开发时发现产品的不完善，需要delay，测试时每天会出现几百个bug，需要delay，各种delay原来半年的项目可能变成了1年，还是有一堆bug。&lt;/p&gt;
&lt;p&gt;敏捷开发就是解决传统瀑布流的问题，出现这种问题的原因是工期很长，不可控的因素太多，如果把目标该小并就可以稳定产出，说白了就是拆版本。敏捷开发定义了一套流程和规范，他是一种方法论。主流的框架就是scrum，这个是一种理论框架/方法框架。&lt;/p&gt;
&lt;p&gt;不管是瀑布流还是敏捷开发都需要product backlog（产品功能列表），在国外是项目负责人维护，国内一般没有负责人这种说法，因为国内开发一个软件，一般都是从各个组里抽出几个人组成一个团队，没有真正的leader一说，一般是项目经理维护。&lt;/p&gt;
&lt;h4 id="敏捷教练"&gt;敏捷教练&lt;/h4&gt;
&lt;p&gt;如果想发挥出来敏捷开发的优势，可能需要配合TDD（测试驱动）、持续集成、持续交付、XP（极限编程）、结对编程等等。一般没玩过敏捷开发的公司可能最开始是玩不转的，有可能会玩崩，所以可以从外部的咨询公司，反正要找一个有经验的人过来指导，这个人就叫敏捷教练。&lt;/p&gt;
&lt;h4 id="sprint"&gt;sprint&lt;/h4&gt;
&lt;p&gt;冲刺！一般在敏捷开发里，每个月或者几周会有一个大版本，比如每个月要更新一个新功能，前三周可能都是开发这个功能+修复一些bug，每周更新修复的bug，第四周上一个新功能，第四周就叫每个月的冲刺，每个月都叫一个版本冲刺。&lt;/p&gt;
&lt;p&gt;sprint计划会议，就是在最开始产品拿出来需求文档和product backlog之后开评审会议，把backlog拆分成一个一个小版本，这个就叫sprint计划会议，每个冲刺任务还有自己的backlog，然后针对每次冲刺的backlog，预估工期（包括框架搭建、库表设计、coding耗时、单元测试耗时），QA并行的写测试用例，一般会把工期放到燃尽图中，并且时间要精确到小时。&lt;/p&gt;
&lt;h4 id="站立会和测试驱动"&gt;站立会和测试驱动&lt;/h4&gt;
&lt;p&gt;站立会就是随便找个地方，然后每个人汇报一下昨天都干了什么，今天计划干什么，是否遇到了什么问题，有什么风险，应该如何处理，是否会导致预计之外的变化，是否有新的需求或者缺陷插入，对目前的计划是否有变动。&lt;/p&gt;
&lt;p&gt;测试驱动要求每个发开都需要对开发的每个类的每个方法都需要有最少一个单元测试，有的方法可能需要不能的参数测试不同的边界需要很多个测试用例，还要有一个人专门写集成测试，就是用代码访问之前定义好的接口，查看流程是否可以走通。一般上了测试驱动开发任务最少会多一倍。&lt;/p&gt;
&lt;h3 id="持续集成和持续交付"&gt;持续集成和持续交付&lt;/h3&gt;
&lt;p&gt;敏捷开发要求一天最少提交一次代码，提交代码之后会有一个类似jenkins的持续集成系统拉取代码，然后通过maven运行里面的单元测试，还有代码的覆盖率，一般要求覆盖率要达到95%以上，所有人都提交了代码之后就会跑一个集成测试的脚本看看controller的返回值是否都符合期望，然后通过持续交付把项目自动化打包、部署到测试环境里去。&lt;/p&gt;
&lt;p&gt;第二天QA会运行写好的测试脚本进行测试，然后把bug提到jira这种缺陷管理系统里去，然后第三天站立会的时候要说明昨天提的bug今天能否修复，是否需要延期。&lt;/p&gt;
&lt;h3 id="sprint验收"&gt;sprint验收&lt;/h3&gt;
&lt;p&gt;开发+测试+修复bug并行进行可以减少长期项目的不确定性，最终交付一个sprint版本到测试环境，由产品经理验收，如果发现需要改进的地方可以提到下一个sprint中去，然后会开一个会议，包括客户、产品、所有开发进行sprint交付，然后再开一个回顾会议，讨论这次sprint有没有需要改进的地方。&lt;/p&gt;
&lt;h3 id="三大角色"&gt;三大角色&lt;/h3&gt;
&lt;p&gt;产品负责人：就是产品经理，上跟领导对接，中跟用户对接，下跟开发对接，负责定义产品的sprint和backlog，编写原型图、需求文档（PRD）。&lt;/p&gt;
&lt;p&gt;项目负责人：或者是敏捷教练，scrumMaster，一般就是高P，这个可以选出来，也可以直接由高层指定，hold场子的。&lt;/p&gt;
&lt;p&gt;团队成员：前端，web，后端，UI什么的。&lt;/p&gt;
&lt;h3 id="user-story"&gt;user story&lt;/h3&gt;
&lt;p&gt;用户故事就是面向用户或者其他系统或者后台的一个功能，可以理解成一个完整的系统功能。每个冲刺包含一些user story，每个user story可以包含一些backlog。&lt;/p&gt;
&lt;h3 id="开发流程"&gt;开发流程&lt;/h3&gt;
&lt;p&gt;开始之前需要确定一批技术专家，针对项目里用到的技术，防止开发或者线上突然出现源码或者原理级的bug，比如消息丢失，需要有一些这样的人到时候能够指导或者解决，可以是本团队，或者其他团队，或者中间件团队或者别的公司的朋友，或者花钱。&lt;/p&gt;
&lt;p&gt;还需要确定项目负责人需不需要写代码？&lt;/p&gt;
&lt;p&gt;项目负责人每天需要通过站立会盯进度、检查和验收代码，覆盖率是否达标、bug是否达标、预发布环境里的压测、可用性、监控等是否达标，做完了这些基本上没啥时间写代码了，基本上项目负责人80%的时间都是做这个，20%的时间可以写代码，或者做架构设计、方案设计、流程规范设计。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开发之前所有人会进行需求评审，进行sprint拆分，一般可以拆成1周到一个月，如果产品只确定的大功能，很多细节模糊不清，这个时候最好是1周一个冲刺，方便调整和改动。&lt;/li&gt;
&lt;li&gt;确定本次冲刺的需求之后项目负责人需要制定技术层面的sprint和backlog，比如，开发功能、开发测试用例、code review、继承测试、完善文档、完善监控项、stating环境压测等等。&lt;/li&gt;
&lt;li&gt;测试驱动开发，&lt;/li&gt;
&lt;li&gt;自动化集成测试，&lt;/li&gt;
&lt;li&gt;QA环境进行功能测试、性能测试、可用性测试。&lt;/li&gt;
&lt;li&gt;自动交付到staging环境，进行压测。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;没有结对编程，人走了代码就没人接手了，通过结对编程+code review提高代码质量，不怕有人走代码没人接手。&lt;/p&gt;
&lt;p&gt;概念的关系：&lt;/p&gt;
&lt;p&gt;一般一个发布计划就是一个版本，一个发布计划对应多个sprint，一个sprint包含多个用户故事，一个用户故事包含多个backlog。&lt;/p&gt;
&lt;p&gt;每个print结束之后都要有一个总结会，每个人都可以提意见，比如说单侧不标准之类的，这个东西是越来越完善的。&lt;/p&gt;</description></item><item><title>3.DDD框架之cola</title><link>https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/ddd/4.cola/</link><pubDate>Thu, 24 Jun 2021 06:27:35 +0000</pubDate><guid>https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/ddd/4.cola/</guid><description>&lt;p&gt;COLA是一个应用架构，作者对应用架构的解释是处理模块（Module）、组件（Component）、包（Package）和类（Class）之间的关系，让系统有章法，有结构。提倡以业务为核心，解耦外部依赖，分离业务复杂度和技术复杂度。&lt;/p&gt;
&lt;h5 id="cola架构"&gt;COLA架构&lt;/h5&gt;
&lt;p&gt;&lt;img alt="68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f36353439323330633637323334343866623361623531636137343832396538302e706e67" loading="lazy" src="https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f36353439323330633637323334343866623361623531636137343832396538302e706e67.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适配层（Adapter Layer）：负责对前端展示（web，wireless，wap）的路由和适配，相当于MVC中的controller，主要用来解释用户指令；&lt;/li&gt;
&lt;li&gt;应用层（Application Layer）：主要负责获取输入，组装上下文，参数校验，调用领域层做业务处理，如果需要的话，发送消息通知等，其实就是&lt;strong&gt;对业务编排&lt;/strong&gt;。层次是开放的，应用层也可以绕过领域层，直接访问基础实施层；&lt;/li&gt;
&lt;li&gt;领域层（Domain Layer）：主要是封装了核心业务逻辑，并通过领域服务（Domain Service）和领域对象（Domain Entity）的方法对App层提供业务实体和业务逻辑计算。领域是应用的核心，&lt;strong&gt;不依赖任何其他层次&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;基础实施层（Infrastructrue Layer）：主要负责技术细节问题的处理，比如数据库的CRUD、搜索引擎、文件系统、分布式服务的RPC等。此外，领域防腐的重任也落在这里，外部依赖需要通过gateway的转义处理，才能被上面的App层和Domain层使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出来COLA和DDD的分层是一模一样的，只不过对于一些组件比如防腐层什么的所在的层级做了一些改动，这三种架构的普适性都是针对前端需求的变和领域模型的不变。&lt;/p&gt;
&lt;h4 id="cola的包结构"&gt;COLA的包结构&lt;/h4&gt;
&lt;h5 id="adapter层"&gt;Adapter层&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;mobile：文档上写的是wireless，但是生成的代码里叫mobile，就是app端对应的controller接口；&lt;/li&gt;
&lt;li&gt;web：电脑端页面对应的controller；&lt;/li&gt;
&lt;li&gt;wap：移动端页面对应的controller；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="app层"&gt;App层&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;executor：处理request，包括command和query；&lt;/li&gt;
&lt;li&gt;consumer：处理外部message，就是对应的事件消费者；&lt;/li&gt;
&lt;li&gt;scheduler：处理定时任务；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="domain层"&gt;Domain层&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;model：领域模型，就是实体、聚合这些东西；&lt;/li&gt;
&lt;li&gt;ability：领域能力，就是领域服务；&lt;/li&gt;
&lt;li&gt;gateway：领域网关，&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="infra层"&gt;Infra层&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;gatewayimpl：网关实现；&lt;/li&gt;
&lt;li&gt;mapper：ibatis数据库映射；&lt;/li&gt;
&lt;li&gt;config：配置信息；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="client层"&gt;Client层&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;api：服务对外暴露的api接口；&lt;/li&gt;
&lt;li&gt;dto：服务对外的DTO；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="start层"&gt;Start层&lt;/h5&gt;
&lt;p&gt;里面只有服务的配置和启动类；&lt;/p&gt;
&lt;p&gt;其实不管我们用不用DDD的模型设计都可以用这一套包架构，只不过就是model里有没有东西的事儿。&lt;/p&gt;
&lt;h5 id="对于领域层和基础层的gateway包说明"&gt;对于领域层和基础层的gateway包说明：&lt;/h5&gt;
&lt;p&gt;这里的gateway并不是微服务的网关，而是代表DDD中的防腐层或者仓储，操作数据库时，通过仓储+po和实体的转换实现解耦，rpc调用其他服务或者三方的时候通过防腐层进行实体转换，给我的感觉都是一样的，只要有依赖就有耦合，这几个做法都是为了降低耦合的可接受成都，主要的思想也都是一样的。cola中的gatewayImpl就是他的防腐层，他把数据库、es这些也定义成了外部依赖，这样做不管是应用层还是领域层都可以调用三方服务了。&lt;/p&gt;
&lt;h3 id="基于dddcola改造开发"&gt;基于DDD+cola改造开发&lt;/h3&gt;
&lt;h5 id="分析方法"&gt;分析方法&lt;/h5&gt;
&lt;p&gt;DDD的分析方法有三种，事件风暴、领域故事陈述和4色建模：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件风暴：类似于大家在一起的头脑风暴，每个人针对业务都想说什么说什么，然后有一个人专门根据大家的发言提炼出业务流、事件和命令，然后在根据事件的语义划分出实体、聚合、子域以及限界上下文。&lt;/li&gt;
&lt;li&gt;领域故事陈述：梳理出每个业务的流程图&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="cola相关修改"&gt;COLA相关修改&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;COLA中每一层就是一个模块，每一个子域对应一个工程，这样对人少的团队会增加维护成本，我们还是一个项目对应一个工程对应多个子域，每个子域只有两个服务，业务服务和api服务，api专门堆外暴露接口，其他层使用包的方式存在业务服务中。&lt;/li&gt;
&lt;li&gt;在COLA中client层除了对外的接口和dto还有命令和事件，我们把client层去掉后，把命令放到了app层，事件放到了领域层，事件的处理(publisher、subscriber)也在app层，还有一种方式是对于事件的publisher组件放到了gateway中，这么做是考虑下层不应该调用上层，publisher组件放到了gateway中方便在domain层调用。&lt;/li&gt;
&lt;li&gt;COLA的应用服务接口也放到了Client层，我觉得没必要，也没必要设计成依赖倒置的，所以我们直接在app层创建一个应用服务用来编排命令，app的executor包下有cmd和qry的包对应查询和命令的处理逻辑。&lt;/li&gt;
&lt;li&gt;COLA中并没有出现工厂的概念，我们需要，也放在app层，同时infra层需要convertor实现实体和其他dto或者do转换。&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>DDD-2.入门</title><link>https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/ddd/2.ddd/</link><pubDate>Thu, 24 Jun 2021 06:27:35 +0000</pubDate><guid>https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/ddd/2.ddd/</guid><description>&lt;p&gt;DDD是一套软件/系统的设计思想，目前没有一套完整的方法论。他建议用现实的场景映射我们的代码设计，传统的MVC主要是快，但是代码会全部堆积在service层，在拿到需求后，开始建库表，然后所有的代码都是面向数据库的，这样service的代码会越来越多，并且在面对复杂业务会很无力，DDD就是为了解决复杂场景下的代码设计。但是目前使用DDD做代码设计的非常少，因为资料少，实践困难，如果是一个微型团队，每个人负责几个子系统，每个人都需要定义自己子系统的通用语言，这样沟通很容易产生误会，最好是一个二三十人的团队，负责十几个系统，每个小团队负责一个系统（一个系统里可能包含很多服务），这样小团队之间用自己的自定语言，项目leader先划分好领域，然后建模，每个团队的leader在把自己的系统建模，这样才可以。&lt;/p&gt;
&lt;h5 id="为什么要用ddd"&gt;为什么要用DDD？&lt;/h5&gt;
&lt;p&gt;首先DDD的思想是面向对象的，更接近真实场景，其次在复杂系统的设计上DDD更优于传统三层架构，但如果三层架构把服务拆的足够微，我不觉得他比DDD弱，其实现在的DDD和十几年前的三层架构一样，当时三层架构刚刚开始流行，大部分公司没有接触过，就感觉很厉害，很难，几年之后，三层架构变成标配，在这种分层的思想已经固化的时候，出来了一个DDD，思想和三层架构有些差别，使用的少或者没使用就会感觉DDD很深奥，可能再过几年DDD普及之后就和现在的MVC一样了。DDD的价值是让开发和产品对业务有相同的理解，DDD的流程差不多是这样：&lt;/p&gt;
&lt;p&gt;需求评审-&amp;gt;和产品、运营、用户定义通用语言-&amp;gt;业务建模-&amp;gt;架构设计(业务架构+技术架构)-&amp;gt;团队成员开始建模(实体、值对象、互动的流程)-&amp;gt;搭建工程、定义接口、代码落地(根据通用语言)&lt;/p&gt;
&lt;p&gt;可以看到和产品的沟通变多了，和产品一起定义的名词和业务挂钩，沟通无障碍，新人在看完需求文档，在看代码也很轻松。&lt;/p&gt;
&lt;p&gt;其实传统的service+controller+dao+domain除了开发快，还有一个优点，就是门槛低，随便一个培训出来的人都能开发。但是DDD更适合大型的复杂的业务系统，而且他更贴合显示，业务模型和业务代码特别清晰，代码非常好看，如果一直维护面向数据库的代码肯定会越来乱。&lt;/p&gt;
&lt;p&gt;如果一个大团队没搞DDD，小团队自己能不能搞？能，只要把只要把团队负责的几个系统定义一套通用语言就可以，小团队不搞，自己负责的几个服务能不能搞？能，自己负责的每个服务都是一个子域，使用一个通用语言也可以。&lt;/p&gt;
&lt;h5 id="基础概念"&gt;基础概念&lt;/h5&gt;
&lt;h6 id="1限界上下文"&gt;1.限界上下文&lt;/h6&gt;
&lt;p&gt;他是一个独立的业务领域，可以是一个或多个子域，一般就是一个子域，也建议这么划分，建议每个限界上下文最好是一个独立的子系统，拥有独立的git仓库，独立的数据仓库，独立的测试环境，独立的团队。&lt;/p&gt;
&lt;h6 id="2通用语言"&gt;2.通用语言&lt;/h6&gt;
&lt;p&gt;针对同一限界上下文需要定义一套自己的名词，比如同样的orderNumber，在订单域里是充值、消费的订单号，在匹配域里，是发起一次群聊请求的订单号/房间号。&lt;/p&gt;
&lt;h6 id="3子域domain"&gt;3.子域（domain）&lt;/h6&gt;
&lt;p&gt;其实说的就是限界上下文，主要有3种子域，一般一个子域最好对应唯一一个限界上下文。&lt;/p&gt;
&lt;p&gt;核心域：核心业务系统，比如订单、钱包、动态。&lt;/p&gt;
&lt;p&gt;支撑子域：非核心系统，但是有了锦上添花或者是辅助性的系统，比如BI系统、爬虫系统、社会化治理系统。&lt;/p&gt;
&lt;p&gt;通用子域：一般具有普适性，全公司都可以用的类似OA系统、权限系统这种。&lt;/p&gt;
&lt;p&gt;一个子域可以拆分成多个module，一般一个子域也是一个独立运行的大系统。&lt;/p&gt;
&lt;h6 id="4module"&gt;4.module&lt;/h6&gt;
&lt;p&gt;一般一个module就是一个服务。&lt;/p&gt;
&lt;h6 id="5上下文映射"&gt;5.上下文映射&lt;/h6&gt;
&lt;p&gt;就是子域进行集成，就是不同系统之间的接口调用，因为不同的系统可能会有通用语言的冲突，就需要在接口调用的时候把冲突的单词映射成另一个。&lt;/p&gt;
&lt;p&gt;上下文映射的种类，U-D就是调用链的上下游，下游调用，上游提供，箭头是由上游指向下游，表示数据的流向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合作关系（Partnership）：两个上下文强耦合在一起，多个服务完成一整个业务，一般都是一起需求评审，一起开发，一起上线。这种关系需求变更对应的服务也要改动。&lt;/li&gt;
&lt;li&gt;共享内核（Shared Kernel）：两个系统共同维护一些模型，比如A系统的API里的一些类是B系统认可的，或者一个单独的公共的模块，他们共用并且共同维护这些实体，很少见。&lt;/li&gt;
&lt;li&gt;客户方-供应方（Customer-Supplier Development）：就是系统B根据系统A的需求定制接口，返回值还是系统A（客户方说的算），一般都是和合作关系配合用，你需要接口，人家没有就一起商量一下。&lt;/li&gt;
&lt;li&gt;发布订阅（Publish-Subscribe）：比如那种发mq消息的。&lt;/li&gt;
&lt;li&gt;尊奉着/没商量（Conformist）：系统A调用系统B，但是A说得不算，B只暴露一些接口，你要是用就调一下，你想要修改人家也不配合你，一般就是中间件部门写的接口，或者其他独立的系统。&lt;/li&gt;
&lt;li&gt;开放主机服务OHS（Open Host Service）和发布语言PL（Published Language）：相当于是开放的API了，一般指三方或者公司自己的平台，比如云片短信，定义一种协议，一般都是http。基于消息机制也是发布语言的实现方式。&lt;/li&gt;
&lt;li&gt;防腐层ACL（Anticorruption Layer）：为了防止系统B接口改动频繁，把调用系统B的代码抽离出来，以后系统B再次改动，这需要改防腐层的代码即可，一般和尊奉着/开放主机服务一起使用。&lt;/li&gt;
&lt;li&gt;大泥球（Big Ball of Mud）：上下文没有关系，各行其道，混乱的组织在一起，一般说得就是本该拆成几个子域，结果混在了一个服务里。&lt;/li&gt;
&lt;li&gt;独立路线/隔离模式（SeparateWay）：没关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id="6实体和值对象"&gt;6.实体和值对象&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;实体：先理解成传统MVC的domain下的实体，但其实远不止，实体是有状态和行为的，也就是说实体的变量是可变的。&lt;/li&gt;
&lt;li&gt;值对象：就是实体中包含的数据，比如订单中的值对象可以有订单详情，代表的是封装了一份数据，最经典的例子，前端返回的实体一般起名都以VO结尾，VO就是value object的缩写，翻译过来就是值对象，比如返回给前端的订单信息中有OrderInfo、OrderItem、Product、PurchaseCart。其实实体和值对象的区别可以理解成实体有id，值对象没有id。标准的DDD中规定值对象只能替换，不能修改。&lt;/li&gt;
&lt;li&gt;聚合（Aggregate）：多个实体或者值对象的组合关系，一个订单实体中有多个订单明细实体，他们就是聚合关系，他可以看成是特殊的实体。&lt;/li&gt;
&lt;li&gt;根实体：每个聚合关系里都有一个根实体，在订单里，大订单就是跟实体，也叫聚合根。&lt;/li&gt;
&lt;li&gt;事务：说的是聚合实体的事务关系，比如说一起更新，要保证事务更新了这个聚合实体的整体或者部分的时候，实体内的数据是一致的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;聚合关系应尽量通过实体id引用，不要通过面向对象的引用，尽可能保证小型，主要就是通过事务规则，符合事务原则的实体，可以设计成聚合关系。&lt;/p&gt;
&lt;h6 id="7资源库repository"&gt;7.资源库(repository)&lt;/h6&gt;
&lt;p&gt;负责对实体对象进行持久化。&lt;/p&gt;
&lt;h6 id="8应用服务"&gt;8.应用服务&lt;/h6&gt;
&lt;p&gt;负责对业务流程的编排，对应service接口。&lt;/p&gt;
&lt;h6 id="9领域服务"&gt;9.领域服务&lt;/h6&gt;
&lt;p&gt;实体/值对象/资源库/工厂/聚合不适合放在里面的复杂性为的补充。里面的行为就是指挥多个实体/值对象完成业务逻辑。&lt;/p&gt;
&lt;h6 id="10领域事件"&gt;10.领域事件&lt;/h6&gt;
&lt;p&gt;系统交互的核心事件，比如支付订单事件，一般用过去式命名。&lt;/p&gt;
&lt;h6 id="11业务组件"&gt;11.业务组件&lt;/h6&gt;
&lt;p&gt;对领域事件的发布和处理。&lt;/p&gt;
&lt;h6 id="12用户界面"&gt;12.用户界面&lt;/h6&gt;
&lt;p&gt;对应controller接口。&lt;/p&gt;
&lt;h6 id="13基础设施"&gt;13.基础设施&lt;/h6&gt;
&lt;p&gt;MySQL、es、redis什么的，业务组件、领域服务、实体、资源库都可以用，根据业务决定。&lt;/p&gt;
&lt;h6 id="14命令-command和查询query"&gt;14.命令 command和查询query&lt;/h6&gt;
&lt;p&gt;用来驱动领域服务的业务逻辑核方法的执行，一般就是人通过web或者app这种UI界面发起的指令，是从CQRS架构里延伸出来的，牵扯到了下面的类DDD和泛DDD。&lt;/p&gt;
&lt;h6 id="15战略设计战略建模领域对象建模"&gt;15.战略设计/战略建模/领域对象建模&lt;/h6&gt;
&lt;p&gt;对子域划分、上下文映射、子域集成、实体、值对象和领域服务建模，完全没必要说得这么高大上，其实就是业务建模。一般一块业务就对应一个领域，一个领域又可以拆成多个子域，拆分域还是很容易的。&lt;/p&gt;
&lt;p&gt;业务领域 -&amp;gt; 各个子域（module） -&amp;gt; 自己子域的通用语言（你应该跟子域里的其他人一起合作） -&amp;gt; 上下文映射（上下游关系）&lt;/p&gt;</description></item><item><title>DDD-3.DDD的分层架构</title><link>https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/ddd/3.ddd%E7%9A%84%E5%88%86%E5%B1%82/</link><pubDate>Thu, 24 Jun 2021 06:27:35 +0000</pubDate><guid>https://wangxiaohong123.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/ddd/3.ddd%E7%9A%84%E5%88%86%E5%B1%82/</guid><description>&lt;p&gt;目前没有一套完整的DDD方法论，他仅仅提供了一些思想，所以每个公司可能都有自己的DDD目录结构，一般都是用到他的概念和分层，有的简单业务甚至只用到他的分层。&lt;/p&gt;
&lt;p&gt;推进DDD是很难的，第1花时间还没有产出，第2就是没有完整的方法论，包结构数据怎么流转等等都没有统一的规定。而且完全按照DDD的规范来开发不适合互联网，DDD讲究的是把聚合、值对象这些东西分的很细还有对以后扩展的预留，完全用这个会把开发周期拖长，对业务不熟或者赶工的时候非常容易走样。&lt;/p&gt;
&lt;h3 id="一些普适性架构"&gt;一些普适性架构&lt;/h3&gt;
&lt;h5 id="清洁架构"&gt;清洁架构&lt;/h5&gt;
&lt;p&gt;也叫洋葱架构，因为分层的图画出来很像洋葱：&lt;/p&gt;
&lt;p&gt;&lt;img alt="fc8208d9f4cfadb7949d6e98a8c18442" loading="lazy" src="https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/fc8208d9f4cfadb7949d6e98a8c18442.webp"&gt;&lt;/p&gt;
&lt;p&gt;越里层，越是核心能力，并且外圆只能依赖内圆，基础资源除外，或者说最外层除外。在DDD中4层架构的功能边界如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="006_图解四层架构功能边界" loading="lazy" src="https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/006_%E5%9B%BE%E8%A7%A3%E5%9B%9B%E5%B1%82%E6%9E%B6%E6%9E%84%E5%8A%9F%E8%83%BD%E8%BE%B9%E7%95%8C.jpg"&gt;&lt;/p&gt;
&lt;p&gt;传统4层架构的调用方式看起来像下面这样：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;就很怪，为什么接口可以直接调用基础层，数据库什么的都在这里？？？&lt;/p&gt;
&lt;h5 id="六边形架构"&gt;六边形架构&lt;/h5&gt;
&lt;p&gt;也叫端口适配器架构，红框内是核心逻辑，核心逻辑不变采用适配器适配不同端，同理和基础架构的交互也是使用了依赖倒置，置于为什么叫6边型，是为了形容一套逻辑可以适配多个端口。&lt;/p&gt;
&lt;p&gt;&lt;img alt="6" loading="lazy" src="https://raw.githubusercontent.com/wangxiaohong123/p-bed/main/uPic/6.webp"&gt;&lt;/p&gt;
&lt;p&gt;四层架构里的接口层虽然有web界面这些东西，但是他定义的不是传统3层架构的controller，6变形架构就是为了解决这个问题，并且他把基础设施也定义成了api的方式提供其他层调用。&lt;/p&gt;</description></item></channel></rss>