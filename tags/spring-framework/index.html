<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Spring-Framework | 王小红的笔记</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://wangxiaohong123.github.io/tags/spring-framework/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://wangxiaohong123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wangxiaohong123.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangxiaohong123.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wangxiaohong123.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wangxiaohong123.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wangxiaohong123.github.io/tags/spring-framework/index.xml><link rel=alternate hreflang=en href=https://wangxiaohong123.github.io/tags/spring-framework/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><meta property="og:url" content="https://wangxiaohong123.github.io/tags/spring-framework/"><meta property="og:site_name" content="王小红的笔记"><meta property="og:title" content="Spring-Framework"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Spring-Framework"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangxiaohong123.github.io/ accesskey=h title="王小红的笔记 (Alt + H)">王小红的笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangxiaohong123.github.io/posts/ title=笔记><span>笔记</span></a></li><li><a href=https://wangxiaohong123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://wangxiaohong123.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Spring-Framework</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>1.基础</h2></header><div class=entry-content><p>1.源码编译 源码的README.md有编译源码的步骤，但是由于操作系统、硬件环境可能会出现一些问题，而且文档里说的是没有开发工具的情况，这里我们自己把源码下载直接导入到idea里。
首先确保idea里配置好了git，然后下载gradle5.6安装。
1）修改配置文件 然后进入下载的spring源码的根目录，这里下载的是5.2.x，找到build.gradle文件，修改repositories属性为阿里云镜像：
1 2 3 4 5 6 7 8 9 repositories { // mavenCentral() // maven { url "https://repo.spring.io/libs-spring-framework-build" } maven { url "https://maven.aliyun.com/nexus/content/groups/public/"} maven { url "https://maven.aliyun.com/nexus/content/repositories/jcenter"} maven { url "https://repo.spring.io/libs-spring-framework-build" } maven { url "https://repo.spring.io/snapshot" } // Reactor maven { url "https://oss.jfrog.org/artifactory/oss-snapshot-local" } // RSocket } 在spring源码的根目录的gradle.properties文件中可以查看当前源码的小版本，我的是5.2.23：
...</p></div><footer class=entry-footer>2 min</footer><a class=entry-link aria-label="post link to 1.基础" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/framework/1.%E5%9F%BA%E7%A1%80/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>2.注入相关</h2></header><div class=entry-content><p>1.自动注入和手动注入 手动注入就是通过xml方式，要么是&lt;property/>标签通过set方法注入，要么提供&lt;constructor-arg/>标签通过构造方法注入。
自动注入就是设置bean得注入方式并提供对应得set方法或者构造方法，spring就会自己分析方法完成注入。
在AbstractBeanDefinition中有一个属性叫autowireModel，他有4个值可选：
AUTOWIRE_NO(默认)：手动注入。 AUTOWIRE_BY_NAME：按属性名称自动注入。Spring 寻找与需要自动装配的属性同名的bean。例如，如果一个 bean定义的注入模式被设置为AUTOWIRE_BY_NAME，并且它包含一个master属性（即它有一个 setMaster(..)方法），那么 Spring 会查找一个命名为master的bean，并使用它来设置该属性。 AUTOWIRE_BY_TYPE：和AUTOWIRE_BY_NAME类似，只不过他是按照类型，如果容器中出现多个相同type会抛出异常。 AUTOWIRE_CONSTRUCTOR：通过构造函数+byType注入，如果容器中没有构造函数中指定的bean会抛出异常。 AUTOWIRE_AUTODETECT(被弃用)： 总结：官网上写的注入方式有两种，setter方法和构造方法，不管是手动注入还是自动注入都是通过这两种方式实现。注入模型有四种，默认是手动注入，byType和byName都是通过setter方法注入。byName是根据setter方法去掉set后把第一个字母改成小写的那么去找。通过@Autowired或者@Resource注解实现的注入既不属于setter注入也不是构造方法注入。
2.@Autowired源码 @Autowired注入对象的源码在AutowiredAnnotationBeanPostProcessor类中，这个类里有两个内部类，一个是AutowiredMethodElement用来处理方法上的@Autowired，另一个是AutowiredFieldElement用来处理成员变量上的@Autowired注解。
AutowiredAnnotationBeanPostProcessor类实现了InstantiationAwareBeanPostProcessorAdapter，在程序启动的时候一定会触发postProcessProperties()方法：
1 2 3 4 5 6 7 8 9 public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) { // 根据当前bean找到所有加了@Autowired和@Value注解的变量或者方法 // 然后用找到的变量或者方法创建对应的注入器 InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs); try { metadata.inject(bean, beanName, pvs); } return pvs; } InjectionMetadata就是注入器，AutowiredFieldElement类继承了InjectionMetadata.InjectedElement，在metadata.inject(bean, beanName, pvs);代码中就是遍历刚才拿到的InjectedElement集合，然后调用他的inject()方法：
...</p></div><footer class=entry-footer>8 min</footer><a class=entry-link aria-label="post link to 2.注入相关" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/framework/2.%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>3.容器初始化</h2></header><div class=entry-content><p>首先想一下如果我们自己实现了一个框架怎么把对象交给spring容器管理，比如类似mybatis使用动态代理生成的对象？
@Service……这种注解：不行，这个注解写到类上，就算我们动态生成的对象可以加上这个注解，Spring也不会扫描。
xml+Bean标签：不行，和上面一样。
@Bean注解：可以，向下面这样：
1 2 3 4 @Bean public MyMapper myMapper() { return (MyMapper) MySqlSession.getMapper(MyMapper.class); } 使用FactoryBean：可以：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Component public class MyFactoryBean implements FactoryBean { Class mapperInterface; public void setMapperInterface(Class mapperInterface) { this.mapperInterface = mapperInterface; } @Override public Object getObject() throws Exception { // 单例池 存放大部分的Bean return MySqlSession.getMapper(mapperInterface); } @Override public Class&lt;?> getObjectType() { return mapperInterface; } } 使用Spring api：可以：
...</p></div><footer class=entry-footer>6 min</footer><a class=entry-link aria-label="post link to 3.容器初始化" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/framework/3.%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>4.扫描</h2></header><div class=entry-content><p>启动容器时会执行一堆BeanFactoryPostProcessor接口和子接口的方法，ConfigurationClassPostProcessor实现了BeanDefinitionRegistryPostProcessor，所以这个类有父接口和子接口的方法，扫描的代码入口就在子接口的方法实现里。
@inherited注解标记的类上的注解会被子类继承，接口无效。
半配置和全配置 全配置会被代理，为了确保@Bean对应的Bean的作用域的正确，在全被配置类里可以保证@Bean配置的Bean的作用域是单例的，而半配置类没法保证。
除了@Bean注解产生的类或者ImportBeanDefinitionRegistrar的实现类，其他的Bean都是配置类！
1.Spring中存在多个扫描器 容器启动的时候会创建一个ClassPathBeanDefinitionScanner，当ConfigurationClassPostProcessor扫描类的时候又会在方法里创建一个局部的ClassPathBeanDefinitionScanner，这两个有什么区别？
第一个scanner是负责处理我们手动设置的扫描路径context.scan("包名")，这里要注意如果我们手动设置扫描路径实例化容器的时候是不能传配置类的，因为传进去一个配置类，容器会自动调用refresh()方法，这个时候我们在调用context.scan("包名")就不生效，因为容器已经启动了，设置完之后需要手动调用refresh()方法。
第二个scanner是负责处理@ComponentScan注解的。
修改第一个名字生成器需要再调用applicationContext.setBeanNameGenerator()，修改第二个生成器需要再@ComponentScan注解里设置nameGenerator属性。注意修改scanner1的时候他会把生成器放到单例池中，这个时候scanner2也会被修改，也就是说通过applicationContext.setBeanNameGenerator()设置的名字生成器是全局的，所有名字生成器都会使用设置的这个。
2.为什么Spring在加载类的时候不是通过反射，而是使用了ASM技术？ 因为通过反射加载的类会进到元数据空间，如果累里面有静态代码块，此时也会执行，但是很有可能这个类不是一个Bean，我们也不需要提前把这个类加载到元数据空间里，ASM就会实现这个效果，最小限度的干扰我们。
3.@Configuration+@Bean怎么保证单例 添加了@Configuration注解，这个类就会被标记成全配置类，全配置类在BeanFactoryPostProcessor的回调里会被CGLib代理，代理的类里加了3个callbackFilter，分别是处理@Bean标记的方法，和setBeanFactory()方法。处理@Bean方法的callback在执行方法前会把方法信息存到threadlocal里判断是否是当前执行的方法避免单例Bean被重复创建：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 判断当前这个@Bean方法是不是正在执行 // 通过这个增强可以避免下面这种重复创建Bean的写法： // @Bean // public X createX() {return new X();} // // @Bean // public Y createY() { // createX(); // return new Y(); // } // 当调用createY()的时候，createX()不会通过下面的判断 if (isCurrentlyInvokedFactoryMethod(beanMethod)) { // 调用父类方法 return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs); } // 如果没通过上面的判断，会直接从容器中获取 return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName); }</p></div><footer class=entry-footer>1 min</footer><a class=entry-link aria-label="post link to 4.扫描" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/framework/4.%E6%89%AB%E6%8F%8F/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>5.Bean的实例化</h2></header><div class=entry-content><p>1.单例池 在BeanFactory中beanDefinitionMap存放的是bean的名字作为key，类对应的BeanDefinition作为value，还有一个singletonObjects用来存放已经实例化好的Bean，Spring中叫单例池。
2.实例化源码 在启动容器结束后就已经完成了Bean的扫描，ApplicationContext的refresh()方法中会调用下面的方法，就是Bean实例化的入口：
1 2 // 完成不是懒加载的单例Bean的实例化 finishBeanFactoryInitialization(beanFactory); 真正的入口在finishBeanFactoryInitialization(beanFactory);方法里的最后一行：
1 beanFactory.preInstantiateSingletons(); 这个类里先校验，然后把name前面拼上"&"去调用getBean()方法，这个方法中会判断如果单例池中没有这个Bean回去创建：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public void preInstantiateSingletons() throws BeansException { if (logger.isTraceEnabled()) { logger.trace("Pre-instantiating singletons in " + this); } // 这个beanDefinitionNames存的是beanDefinitionMap的key List&lt;String> beanNames = new ArrayList&lt;>(this.beanDefinitionNames); for (String beanName : beanNames) { // 先从mergedBeanDefinitions(map)中根据name拿到BeanDefinition // todo mergedBeanDefinitions和beanDefinitionMap有什么区别 // todo 为什么获取BeanDefinition要搞得真么复杂，直接遍历beanDefinitionMap不可以吗 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); // 抽象类或者非单例类或者懒加载的类不会实例化 if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) { // 验证是否是FactoryBean if (isFactoryBean(beanName)) { // 把name前面拼上"&"，然后获取Bean Object bean = getBean(FACTORY_BEAN_PREFIX + beanName); if (bean instanceof FactoryBean) { FactoryBean&lt;?> factory = (FactoryBean&lt;?>) bean; boolean isEagerInit; if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) { isEagerInit = AccessController.doPrivileged( (PrivilegedAction&lt;Boolean>) ((SmartFactoryBean&lt;?>) factory)::isEagerInit, getAccessControlContext()); } else { isEagerInit = (factory instanceof SmartFactoryBean && ((SmartFactoryBean&lt;?>) factory).isEagerInit()); } if (isEagerInit) { getBean(beanName); } } } else { // 非FactoryBean得话走这里 getBean(beanName); } } } // Trigger post-initialization callback for all applicable beans... for (String beanName : beanNames) { Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) { SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedAction&lt;Object>) () -> { smartSingleton.afterSingletonsInstantiated(); return null; }, getAccessControlContext()); } else { smartSingleton.afterSingletonsInstantiated(); } } } } getBean()方法里直接调用了doGetBean()方法：
...</p></div><footer class=entry-footer>13 min</footer><a class=entry-link aria-label="post link to 5.Bean的实例化" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/framework/5.bean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>6.AOP</h2></header><div class=entry-content><p>AOP和OOP是对应的，OOP是面象对象，AOP是面象切面，在程序运行的过程中可能会产生一些横切性的问题，这些问题一般不会对业务产生影响，比如日志记录，如果不把这些横切性的问题集中到切面里就会散落到整个代码，比如日志，如果不使用AOP那么每个controller的每个方法都需要手动编写日志打印。
Spring通过CGLib和JDK的动态代理实现的AOP。
Join point：连接点，程序运行的一个点，由于Spring中使用的CGLib或者JDK动态代理是以方法为单位的，所以join point也就是一个被增强了的方法。 Point cut：切点，表示一组连接点。 Advice：通知，包括通知内容(增强一个方法的具体业务逻辑);通知的时机(before、after、around、after);通知的目标(通知要作用到那些连接点上)。 Introduction：导入，这个可以实现导入某个接口的某个实现类中的某个方法到别的类里。 Target object：目标对象，要被增强的对象。 AOP proxy：代理对象，增强之后的对象。 Aspect：切面，上面的加到一起叫切面，对应了一个包括上面内容的类。 Spring借助了AspectJ的注解，但是处理的逻辑是自己实现的。
最简单的demo：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Aspect @Component public class MyAspect { /** * 切点：某个包下的所有类 */ @Pointcut("execution(* com.spring.aop.service.impl..*.*(..))") public void pointCutPackage() {} /** * 通知 * Before：通知的时机 * pointCutPackage()：通知的切点 */ @Before("pointCutPackage()") public void adviceBefore() { System.out.println("before aop"); } } 切点表达式含义 execution：用来匹配连接点，最小粒度是方法。
...</p></div><footer class=entry-footer>3 min</footer><a class=entry-link aria-label="post link to 6.AOP" href=https://wangxiaohong123.github.io/posts/%E6%A1%86%E6%9E%B6/spring/framework/6.aop/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://wangxiaohong123.github.io/>王小红的笔记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>